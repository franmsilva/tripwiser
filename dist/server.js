/******/ (function(modules) { // webpackBootstrap
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotDownloadUpdateChunk(chunkId) {
/******/ 		var chunk = require("./" + "" + chunkId + "." + hotCurrentHash + ".hot-update.js");
/******/ 		hotAddUpdateChunk(chunk.id, chunk.modules);
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotDownloadManifest() {
/******/ 		try {
/******/ 			var update = require("./" + "" + hotCurrentHash + ".hot-update.json");
/******/ 		} catch (e) {
/******/ 			return Promise.resolve();
/******/ 		}
/******/ 		return Promise.resolve(update);
/******/ 	}
/******/
/******/ 	//eslint-disable-next-line no-unused-vars
/******/ 	function hotDisposeChunk(chunkId) {
/******/ 		delete installedChunks[chunkId];
/******/ 	}
/******/
/******/ 	var hotApplyOnUpdate = true;
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentHash = "fc1e685d27ca2f3ec0fe";
/******/ 	var hotRequestTimeout = 10000;
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentChildModule;
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentParents = [];
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentParentsTemp = [];
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotCreateRequire(moduleId) {
/******/ 		var me = installedModules[moduleId];
/******/ 		if (!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if (me.hot.active) {
/******/ 				if (installedModules[request]) {
/******/ 					if (installedModules[request].parents.indexOf(moduleId) === -1) {
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 					}
/******/ 				} else {
/******/ 					hotCurrentParents = [moduleId];
/******/ 					hotCurrentChildModule = request;
/******/ 				}
/******/ 				if (me.children.indexOf(request) === -1) {
/******/ 					me.children.push(request);
/******/ 				}
/******/ 			} else {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" +
/******/ 						request +
/******/ 						") from disposed module " +
/******/ 						moduleId
/******/ 				);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		var ObjectFactory = function ObjectFactory(name) {
/******/ 			return {
/******/ 				configurable: true,
/******/ 				enumerable: true,
/******/ 				get: function() {
/******/ 					return __webpack_require__[name];
/******/ 				},
/******/ 				set: function(value) {
/******/ 					__webpack_require__[name] = value;
/******/ 				}
/******/ 			};
/******/ 		};
/******/ 		for (var name in __webpack_require__) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(__webpack_require__, name) &&
/******/ 				name !== "e" &&
/******/ 				name !== "t"
/******/ 			) {
/******/ 				Object.defineProperty(fn, name, ObjectFactory(name));
/******/ 			}
/******/ 		}
/******/ 		fn.e = function(chunkId) {
/******/ 			if (hotStatus === "ready") hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			return __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {
/******/ 				finishChunkLoading();
/******/ 				throw err;
/******/ 			});
/******/
/******/ 			function finishChunkLoading() {
/******/ 				hotChunksLoading--;
/******/ 				if (hotStatus === "prepare") {
/******/ 					if (!hotWaitingFilesMap[chunkId]) {
/******/ 						hotEnsureUpdateChunk(chunkId);
/******/ 					}
/******/ 					if (hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 						hotUpdateDownloaded();
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		fn.t = function(value, mode) {
/******/ 			if (mode & 1) value = fn(value);
/******/ 			return __webpack_require__.t(value, mode & ~1);
/******/ 		};
/******/ 		return fn;
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotCreateModule(moduleId) {
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_selfInvalidated: false,
/******/ 			_disposeHandlers: [],
/******/ 			_main: hotCurrentChildModule !== moduleId,
/******/
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if (dep === undefined) hot._selfAccepted = true;
/******/ 				else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 				else if (typeof dep === "object")
/******/ 					for (var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback || function() {};
/******/ 				else hot._acceptedDependencies[dep] = callback || function() {};
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if (dep === undefined) hot._selfDeclined = true;
/******/ 				else if (typeof dep === "object")
/******/ 					for (var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 				else hot._declinedDependencies[dep] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/ 			invalidate: function() {
/******/ 				this._selfInvalidated = true;
/******/ 				switch (hotStatus) {
/******/ 					case "idle":
/******/ 						hotUpdate = {};
/******/ 						hotUpdate[moduleId] = modules[moduleId];
/******/ 						hotSetStatus("ready");
/******/ 						break;
/******/ 					case "ready":
/******/ 						hotApplyInvalidatedModule(moduleId);
/******/ 						break;
/******/ 					case "prepare":
/******/ 					case "check":
/******/ 					case "dispose":
/******/ 					case "apply":
/******/ 						(hotQueuedInvalidatedModules =
/******/ 							hotQueuedInvalidatedModules || []).push(moduleId);
/******/ 						break;
/******/ 					default:
/******/ 						// ignore requests in error states
/******/ 						break;
/******/ 				}
/******/ 			},
/******/
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if (!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if (idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		hotCurrentChildModule = undefined;
/******/ 		return hot;
/******/ 	}
/******/
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for (var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailableFilesMap = {};
/******/ 	var hotDeferred;
/******/
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash, hotQueuedInvalidatedModules;
/******/
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = +id + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/
/******/ 	function hotCheck(apply) {
/******/ 		if (hotStatus !== "idle") {
/******/ 			throw new Error("check() is only allowed in idle status");
/******/ 		}
/******/ 		hotApplyOnUpdate = apply;
/******/ 		hotSetStatus("check");
/******/ 		return hotDownloadManifest(hotRequestTimeout).then(function(update) {
/******/ 			if (!update) {
/******/ 				hotSetStatus(hotApplyInvalidatedModules() ? "ready" : "idle");
/******/ 				return null;
/******/ 			}
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			hotAvailableFilesMap = update.c;
/******/ 			hotUpdateNewHash = update.h;
/******/
/******/ 			hotSetStatus("prepare");
/******/ 			var promise = new Promise(function(resolve, reject) {
/******/ 				hotDeferred = {
/******/ 					resolve: resolve,
/******/ 					reject: reject
/******/ 				};
/******/ 			});
/******/ 			hotUpdate = {};
/******/ 			var chunkId = "main";
/******/ 			// eslint-disable-next-line no-lone-blocks
/******/ 			{
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if (
/******/ 				hotStatus === "prepare" &&
/******/ 				hotChunksLoading === 0 &&
/******/ 				hotWaitingFiles === 0
/******/ 			) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 			return promise;
/******/ 		});
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) {
/******/ 		if (!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for (var moduleId in moreModules) {
/******/ 			if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if (--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if (!hotAvailableFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var deferred = hotDeferred;
/******/ 		hotDeferred = null;
/******/ 		if (!deferred) return;
/******/ 		if (hotApplyOnUpdate) {
/******/ 			// Wrap deferred object in Promise to mark it as a well-handled Promise to
/******/ 			// avoid triggering uncaught exception warning in Chrome.
/******/ 			// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666
/******/ 			Promise.resolve()
/******/ 				.then(function() {
/******/ 					return hotApply(hotApplyOnUpdate);
/******/ 				})
/******/ 				.then(
/******/ 					function(result) {
/******/ 						deferred.resolve(result);
/******/ 					},
/******/ 					function(err) {
/******/ 						deferred.reject(err);
/******/ 					}
/******/ 				);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for (var id in hotUpdate) {
/******/ 				if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			deferred.resolve(outdatedModules);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotApply(options) {
/******/ 		if (hotStatus !== "ready")
/******/ 			throw new Error("apply() is only allowed in ready status");
/******/ 		options = options || {};
/******/ 		return hotApplyInternal(options);
/******/ 	}
/******/
/******/ 	function hotApplyInternal(options) {
/******/ 		hotApplyInvalidatedModules();
/******/
/******/ 		var cb;
/******/ 		var i;
/******/ 		var j;
/******/ 		var module;
/******/ 		var moduleId;
/******/
/******/ 		function getAffectedStuff(updateModuleId) {
/******/ 			var outdatedModules = [updateModuleId];
/******/ 			var outdatedDependencies = {};
/******/
/******/ 			var queue = outdatedModules.map(function(id) {
/******/ 				return {
/******/ 					chain: [id],
/******/ 					id: id
/******/ 				};
/******/ 			});
/******/ 			while (queue.length > 0) {
/******/ 				var queueItem = queue.pop();
/******/ 				var moduleId = queueItem.id;
/******/ 				var chain = queueItem.chain;
/******/ 				module = installedModules[moduleId];
/******/ 				if (
/******/ 					!module ||
/******/ 					(module.hot._selfAccepted && !module.hot._selfInvalidated)
/******/ 				)
/******/ 					continue;
/******/ 				if (module.hot._selfDeclined) {
/******/ 					return {
/******/ 						type: "self-declined",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				if (module.hot._main) {
/******/ 					return {
/******/ 						type: "unaccepted",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				for (var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if (!parent) continue;
/******/ 					if (parent.hot._declinedDependencies[moduleId]) {
/******/ 						return {
/******/ 							type: "declined",
/******/ 							chain: chain.concat([parentId]),
/******/ 							moduleId: moduleId,
/******/ 							parentId: parentId
/******/ 						};
/******/ 					}
/******/ 					if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 					if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if (!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push({
/******/ 						chain: chain.concat([parentId]),
/******/ 						id: parentId
/******/ 					});
/******/ 				}
/******/ 			}
/******/
/******/ 			return {
/******/ 				type: "accepted",
/******/ 				moduleId: updateModuleId,
/******/ 				outdatedModules: outdatedModules,
/******/ 				outdatedDependencies: outdatedDependencies
/******/ 			};
/******/ 		}
/******/
/******/ 		function addAllToSet(a, b) {
/******/ 			for (var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if (a.indexOf(item) === -1) a.push(item);
/******/ 			}
/******/ 		}
/******/
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/
/******/ 		var warnUnexpectedRequire = function warnUnexpectedRequire() {
/******/ 			console.warn(
/******/ 				"[HMR] unexpected require(" + result.moduleId + ") to disposed module"
/******/ 			);
/******/ 		};
/******/
/******/ 		for (var id in hotUpdate) {
/******/ 			if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				moduleId = toModuleId(id);
/******/ 				/** @type {TODO} */
/******/ 				var result;
/******/ 				if (hotUpdate[id]) {
/******/ 					result = getAffectedStuff(moduleId);
/******/ 				} else {
/******/ 					result = {
/******/ 						type: "disposed",
/******/ 						moduleId: id
/******/ 					};
/******/ 				}
/******/ 				/** @type {Error|false} */
/******/ 				var abortError = false;
/******/ 				var doApply = false;
/******/ 				var doDispose = false;
/******/ 				var chainInfo = "";
/******/ 				if (result.chain) {
/******/ 					chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 				}
/******/ 				switch (result.type) {
/******/ 					case "self-declined":
/******/ 						if (options.onDeclined) options.onDeclined(result);
/******/ 						if (!options.ignoreDeclined)
/******/ 							abortError = new Error(
/******/ 								"Aborted because of self decline: " +
/******/ 									result.moduleId +
/******/ 									chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "declined":
/******/ 						if (options.onDeclined) options.onDeclined(result);
/******/ 						if (!options.ignoreDeclined)
/******/ 							abortError = new Error(
/******/ 								"Aborted because of declined dependency: " +
/******/ 									result.moduleId +
/******/ 									" in " +
/******/ 									result.parentId +
/******/ 									chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "unaccepted":
/******/ 						if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 						if (!options.ignoreUnaccepted)
/******/ 							abortError = new Error(
/******/ 								"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "accepted":
/******/ 						if (options.onAccepted) options.onAccepted(result);
/******/ 						doApply = true;
/******/ 						break;
/******/ 					case "disposed":
/******/ 						if (options.onDisposed) options.onDisposed(result);
/******/ 						doDispose = true;
/******/ 						break;
/******/ 					default:
/******/ 						throw new Error("Unexception type " + result.type);
/******/ 				}
/******/ 				if (abortError) {
/******/ 					hotSetStatus("abort");
/******/ 					return Promise.reject(abortError);
/******/ 				}
/******/ 				if (doApply) {
/******/ 					appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 					addAllToSet(outdatedModules, result.outdatedModules);
/******/ 					for (moduleId in result.outdatedDependencies) {
/******/ 						if (
/******/ 							Object.prototype.hasOwnProperty.call(
/******/ 								result.outdatedDependencies,
/******/ 								moduleId
/******/ 							)
/******/ 						) {
/******/ 							if (!outdatedDependencies[moduleId])
/******/ 								outdatedDependencies[moduleId] = [];
/******/ 							addAllToSet(
/******/ 								outdatedDependencies[moduleId],
/******/ 								result.outdatedDependencies[moduleId]
/******/ 							);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 				if (doDispose) {
/******/ 					addAllToSet(outdatedModules, [result.moduleId]);
/******/ 					appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for (i = 0; i < outdatedModules.length; i++) {
/******/ 			moduleId = outdatedModules[i];
/******/ 			if (
/******/ 				installedModules[moduleId] &&
/******/ 				installedModules[moduleId].hot._selfAccepted &&
/******/ 				// removed self-accepted modules should not be required
/******/ 				appliedUpdate[moduleId] !== warnUnexpectedRequire &&
/******/ 				// when called invalidate self-accepting is not possible
/******/ 				!installedModules[moduleId].hot._selfInvalidated
/******/ 			) {
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					parents: installedModules[moduleId].parents.slice(),
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 			}
/******/ 		}
/******/
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		Object.keys(hotAvailableFilesMap).forEach(function(chunkId) {
/******/ 			if (hotAvailableFilesMap[chunkId] === false) {
/******/ 				hotDisposeChunk(chunkId);
/******/ 			}
/******/ 		});
/******/
/******/ 		var idx;
/******/ 		var queue = outdatedModules.slice();
/******/ 		while (queue.length > 0) {
/******/ 			moduleId = queue.pop();
/******/ 			module = installedModules[moduleId];
/******/ 			if (!module) continue;
/******/
/******/ 			var data = {};
/******/
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for (j = 0; j < disposeHandlers.length; j++) {
/******/ 				cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/
/******/ 			// when disposing there is no need to call dispose handler
/******/ 			delete outdatedDependencies[moduleId];
/******/
/******/ 			// remove "parents" references from all children
/******/ 			for (j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if (!child) continue;
/******/ 				idx = child.parents.indexOf(moduleId);
/******/ 				if (idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// remove outdated dependency from module children
/******/ 		var dependency;
/******/ 		var moduleOutdatedDependencies;
/******/ 		for (moduleId in outdatedDependencies) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
/******/ 			) {
/******/ 				module = installedModules[moduleId];
/******/ 				if (module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 						dependency = moduleOutdatedDependencies[j];
/******/ 						idx = module.children.indexOf(dependency);
/******/ 						if (idx >= 0) module.children.splice(idx, 1);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Now in "apply" phase
/******/ 		hotSetStatus("apply");
/******/
/******/ 		if (hotUpdateNewHash !== undefined) {
/******/ 			hotCurrentHash = hotUpdateNewHash;
/******/ 			hotUpdateNewHash = undefined;
/******/ 		}
/******/ 		hotUpdate = undefined;
/******/
/******/ 		// insert new code
/******/ 		for (moduleId in appliedUpdate) {
/******/ 			if (Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for (moduleId in outdatedDependencies) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
/******/ 			) {
/******/ 				module = installedModules[moduleId];
/******/ 				if (module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					var callbacks = [];
/******/ 					for (i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 						dependency = moduleOutdatedDependencies[i];
/******/ 						cb = module.hot._acceptedDependencies[dependency];
/******/ 						if (cb) {
/******/ 							if (callbacks.indexOf(cb) !== -1) continue;
/******/ 							callbacks.push(cb);
/******/ 						}
/******/ 					}
/******/ 					for (i = 0; i < callbacks.length; i++) {
/******/ 						cb = callbacks[i];
/******/ 						try {
/******/ 							cb(moduleOutdatedDependencies);
/******/ 						} catch (err) {
/******/ 							if (options.onErrored) {
/******/ 								options.onErrored({
/******/ 									type: "accept-errored",
/******/ 									moduleId: moduleId,
/******/ 									dependencyId: moduleOutdatedDependencies[i],
/******/ 									error: err
/******/ 								});
/******/ 							}
/******/ 							if (!options.ignoreErrored) {
/******/ 								if (!error) error = err;
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Load self accepted modules
/******/ 		for (i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			moduleId = item.module;
/******/ 			hotCurrentParents = item.parents;
/******/ 			hotCurrentChildModule = moduleId;
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch (err) {
/******/ 				if (typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch (err2) {
/******/ 						if (options.onErrored) {
/******/ 							options.onErrored({
/******/ 								type: "self-accept-error-handler-errored",
/******/ 								moduleId: moduleId,
/******/ 								error: err2,
/******/ 								originalError: err
/******/ 							});
/******/ 						}
/******/ 						if (!options.ignoreErrored) {
/******/ 							if (!error) error = err2;
/******/ 						}
/******/ 						if (!error) error = err;
/******/ 					}
/******/ 				} else {
/******/ 					if (options.onErrored) {
/******/ 						options.onErrored({
/******/ 							type: "self-accept-errored",
/******/ 							moduleId: moduleId,
/******/ 							error: err
/******/ 						});
/******/ 					}
/******/ 					if (!options.ignoreErrored) {
/******/ 						if (!error) error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if (error) {
/******/ 			hotSetStatus("fail");
/******/ 			return Promise.reject(error);
/******/ 		}
/******/
/******/ 		if (hotQueuedInvalidatedModules) {
/******/ 			return hotApplyInternal(options).then(function(list) {
/******/ 				outdatedModules.forEach(function(moduleId) {
/******/ 					if (list.indexOf(moduleId) < 0) list.push(moduleId);
/******/ 				});
/******/ 				return list;
/******/ 			});
/******/ 		}
/******/
/******/ 		hotSetStatus("idle");
/******/ 		return new Promise(function(resolve) {
/******/ 			resolve(outdatedModules);
/******/ 		});
/******/ 	}
/******/
/******/ 	function hotApplyInvalidatedModules() {
/******/ 		if (hotQueuedInvalidatedModules) {
/******/ 			if (!hotUpdate) hotUpdate = {};
/******/ 			hotQueuedInvalidatedModules.forEach(hotApplyInvalidatedModule);
/******/ 			hotQueuedInvalidatedModules = undefined;
/******/ 			return true;
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotApplyInvalidatedModule(moduleId) {
/******/ 		if (!Object.prototype.hasOwnProperty.call(hotUpdate, moduleId))
/******/ 			hotUpdate[moduleId] = modules[moduleId];
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {},
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire(0)(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/abbrev/abbrev.js":
/*!***************************************!*\
  !*** ./node_modules/abbrev/abbrev.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = exports = abbrev.abbrev = abbrev

abbrev.monkeyPatch = monkeyPatch

function monkeyPatch () {
  Object.defineProperty(Array.prototype, 'abbrev', {
    value: function () { return abbrev(this) },
    enumerable: false, configurable: true, writable: true
  })

  Object.defineProperty(Object.prototype, 'abbrev', {
    value: function () { return abbrev(Object.keys(this)) },
    enumerable: false, configurable: true, writable: true
  })
}

function abbrev (list) {
  if (arguments.length !== 1 || !Array.isArray(list)) {
    list = Array.prototype.slice.call(arguments, 0)
  }
  for (var i = 0, l = list.length, args = [] ; i < l ; i ++) {
    args[i] = typeof list[i] === "string" ? list[i] : String(list[i])
  }

  // sort them lexicographically, so that they're next to their nearest kin
  args = args.sort(lexSort)

  // walk through each, seeing how much it has in common with the next and previous
  var abbrevs = {}
    , prev = ""
  for (var i = 0, l = args.length ; i < l ; i ++) {
    var current = args[i]
      , next = args[i + 1] || ""
      , nextMatches = true
      , prevMatches = true
    if (current === next) continue
    for (var j = 0, cl = current.length ; j < cl ; j ++) {
      var curChar = current.charAt(j)
      nextMatches = nextMatches && curChar === next.charAt(j)
      prevMatches = prevMatches && curChar === prev.charAt(j)
      if (!nextMatches && !prevMatches) {
        j ++
        break
      }
    }
    prev = current
    if (j === cl) {
      abbrevs[current] = current
      continue
    }
    for (var a = current.substr(0, j) ; j <= cl ; j ++) {
      abbrevs[a] = current
      a += current.charAt(j)
    }
  }
  return abbrevs
}

function lexSort (a, b) {
  return a === b ? 0 : a > b ? 1 : -1
}


/***/ }),

/***/ "./node_modules/are-we-there-yet/index.js":
/*!************************************************!*\
  !*** ./node_modules/are-we-there-yet/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.TrackerGroup = __webpack_require__(/*! ./tracker-group.js */ "./node_modules/are-we-there-yet/tracker-group.js")
exports.Tracker = __webpack_require__(/*! ./tracker.js */ "./node_modules/are-we-there-yet/tracker.js")
exports.TrackerStream = __webpack_require__(/*! ./tracker-stream.js */ "./node_modules/are-we-there-yet/tracker-stream.js")


/***/ }),

/***/ "./node_modules/are-we-there-yet/tracker-base.js":
/*!*******************************************************!*\
  !*** ./node_modules/are-we-there-yet/tracker-base.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var EventEmitter = __webpack_require__(/*! events */ "events").EventEmitter
var util = __webpack_require__(/*! util */ "util")

var trackerId = 0
var TrackerBase = module.exports = function (name) {
  EventEmitter.call(this)
  this.id = ++trackerId
  this.name = name
}
util.inherits(TrackerBase, EventEmitter)


/***/ }),

/***/ "./node_modules/are-we-there-yet/tracker-group.js":
/*!********************************************************!*\
  !*** ./node_modules/are-we-there-yet/tracker-group.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var util = __webpack_require__(/*! util */ "util")
var TrackerBase = __webpack_require__(/*! ./tracker-base.js */ "./node_modules/are-we-there-yet/tracker-base.js")
var Tracker = __webpack_require__(/*! ./tracker.js */ "./node_modules/are-we-there-yet/tracker.js")
var TrackerStream = __webpack_require__(/*! ./tracker-stream.js */ "./node_modules/are-we-there-yet/tracker-stream.js")

var TrackerGroup = module.exports = function (name) {
  TrackerBase.call(this, name)
  this.parentGroup = null
  this.trackers = []
  this.completion = {}
  this.weight = {}
  this.totalWeight = 0
  this.finished = false
  this.bubbleChange = bubbleChange(this)
}
util.inherits(TrackerGroup, TrackerBase)

function bubbleChange (trackerGroup) {
  return function (name, completed, tracker) {
    trackerGroup.completion[tracker.id] = completed
    if (trackerGroup.finished) return
    trackerGroup.emit('change', name || trackerGroup.name, trackerGroup.completed(), trackerGroup)
  }
}

TrackerGroup.prototype.nameInTree = function () {
  var names = []
  var from = this
  while (from) {
    names.unshift(from.name)
    from = from.parentGroup
  }
  return names.join('/')
}

TrackerGroup.prototype.addUnit = function (unit, weight) {
  if (unit.addUnit) {
    var toTest = this
    while (toTest) {
      if (unit === toTest) {
        throw new Error(
          'Attempted to add tracker group ' +
          unit.name + ' to tree that already includes it ' +
          this.nameInTree(this))
      }
      toTest = toTest.parentGroup
    }
    unit.parentGroup = this
  }
  this.weight[unit.id] = weight || 1
  this.totalWeight += this.weight[unit.id]
  this.trackers.push(unit)
  this.completion[unit.id] = unit.completed()
  unit.on('change', this.bubbleChange)
  if (!this.finished) this.emit('change', unit.name, this.completion[unit.id], unit)
  return unit
}

TrackerGroup.prototype.completed = function () {
  if (this.trackers.length === 0) return 0
  var valPerWeight = 1 / this.totalWeight
  var completed = 0
  for (var ii = 0; ii < this.trackers.length; ii++) {
    var trackerId = this.trackers[ii].id
    completed += valPerWeight * this.weight[trackerId] * this.completion[trackerId]
  }
  return completed
}

TrackerGroup.prototype.newGroup = function (name, weight) {
  return this.addUnit(new TrackerGroup(name), weight)
}

TrackerGroup.prototype.newItem = function (name, todo, weight) {
  return this.addUnit(new Tracker(name, todo), weight)
}

TrackerGroup.prototype.newStream = function (name, todo, weight) {
  return this.addUnit(new TrackerStream(name, todo), weight)
}

TrackerGroup.prototype.finish = function () {
  this.finished = true
  if (!this.trackers.length) this.addUnit(new Tracker(), 1, true)
  for (var ii = 0; ii < this.trackers.length; ii++) {
    var tracker = this.trackers[ii]
    tracker.finish()
    tracker.removeListener('change', this.bubbleChange)
  }
  this.emit('change', this.name, 1, this)
}

var buffer = '                                  '
TrackerGroup.prototype.debug = function (depth) {
  depth = depth || 0
  var indent = depth ? buffer.substr(0, depth) : ''
  var output = indent + (this.name || 'top') + ': ' + this.completed() + '\n'
  this.trackers.forEach(function (tracker) {
    if (tracker instanceof TrackerGroup) {
      output += tracker.debug(depth + 1)
    } else {
      output += indent + ' ' + tracker.name + ': ' + tracker.completed() + '\n'
    }
  })
  return output
}


/***/ }),

/***/ "./node_modules/are-we-there-yet/tracker-stream.js":
/*!*********************************************************!*\
  !*** ./node_modules/are-we-there-yet/tracker-stream.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var util = __webpack_require__(/*! util */ "util")
var stream = __webpack_require__(/*! readable-stream */ "readable-stream")
var delegate = __webpack_require__(/*! delegates */ "./node_modules/delegates/index.js")
var Tracker = __webpack_require__(/*! ./tracker.js */ "./node_modules/are-we-there-yet/tracker.js")

var TrackerStream = module.exports = function (name, size, options) {
  stream.Transform.call(this, options)
  this.tracker = new Tracker(name, size)
  this.name = name
  this.id = this.tracker.id
  this.tracker.on('change', delegateChange(this))
}
util.inherits(TrackerStream, stream.Transform)

function delegateChange (trackerStream) {
  return function (name, completion, tracker) {
    trackerStream.emit('change', name, completion, trackerStream)
  }
}

TrackerStream.prototype._transform = function (data, encoding, cb) {
  this.tracker.completeWork(data.length ? data.length : 1)
  this.push(data)
  cb()
}

TrackerStream.prototype._flush = function (cb) {
  this.tracker.finish()
  cb()
}

delegate(TrackerStream.prototype, 'tracker')
  .method('completed')
  .method('addWork')
  .method('finish')


/***/ }),

/***/ "./node_modules/are-we-there-yet/tracker.js":
/*!**************************************************!*\
  !*** ./node_modules/are-we-there-yet/tracker.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var util = __webpack_require__(/*! util */ "util")
var TrackerBase = __webpack_require__(/*! ./tracker-base.js */ "./node_modules/are-we-there-yet/tracker-base.js")

var Tracker = module.exports = function (name, todo) {
  TrackerBase.call(this, name)
  this.workDone = 0
  this.workTodo = todo || 0
}
util.inherits(Tracker, TrackerBase)

Tracker.prototype.completed = function () {
  return this.workTodo === 0 ? 0 : this.workDone / this.workTodo
}

Tracker.prototype.addWork = function (work) {
  this.workTodo += work
  this.emit('change', this.name, this.completed(), this)
}

Tracker.prototype.completeWork = function (work) {
  this.workDone += work
  if (this.workDone > this.workTodo) this.workDone = this.workTodo
  this.emit('change', this.name, this.completed(), this)
}

Tracker.prototype.finish = function () {
  this.workTodo = this.workDone = 1
  this.emit('change', this.name, 1, this)
}


/***/ }),

/***/ "./node_modules/bcrypt sync recursive":
/*!**********************************!*\
  !*** ./node_modules/bcrypt sync ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = "./node_modules/bcrypt sync recursive";

/***/ }),

/***/ "./node_modules/bcrypt/bcrypt.js":
/*!***************************************!*\
  !*** ./node_modules/bcrypt/bcrypt.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__dirname) {

var binary = __webpack_require__(/*! node-pre-gyp */ "./node_modules/node-pre-gyp/lib/node-pre-gyp.js");
var path = __webpack_require__(/*! path */ "path");
var binding_path = binary.find(path.resolve(path.join(__dirname, './package.json')));
var bindings = __webpack_require__("./node_modules/bcrypt sync recursive")(binding_path);

var crypto = __webpack_require__(/*! crypto */ "crypto");

var promises = __webpack_require__(/*! ./promises */ "./node_modules/bcrypt/promises.js");

/// generate a salt (sync)
/// @param {Number} [rounds] number of rounds (default 10)
/// @return {String} salt
module.exports.genSaltSync = function genSaltSync(rounds, minor) {
    // default 10 rounds
    if (!rounds) {
        rounds = 10;
    } else if (typeof rounds !== 'number') {
        throw new Error('rounds must be a number');
    }

    if(!minor) {
        minor = 'b';
    } else if(minor !== 'b' && minor !== 'a') {
        throw new Error('minor must be either "a" or "b"');
    }

    return bindings.gen_salt_sync(minor, rounds, crypto.randomBytes(16));
};

/// generate a salt
/// @param {Number} [rounds] number of rounds (default 10)
/// @param {Function} cb callback(err, salt)
module.exports.genSalt = function genSalt(rounds, minor, cb) {
    var error;

    // if callback is first argument, then use defaults for others
    if (typeof arguments[0] === 'function') {
        // have to set callback first otherwise arguments are overriden
        cb = arguments[0];
        rounds = 10;
        minor = 'b';
    // callback is second argument
    } else if (typeof arguments[1] === 'function') {
        // have to set callback first otherwise arguments are overriden
        cb = arguments[1];
        minor = 'b';
    }

    if (!cb) {
        return promises.promise(genSalt, this, [rounds, minor]);
    }

    // default 10 rounds
    if (!rounds) {
        rounds = 10;
    } else if (typeof rounds !== 'number') {
        // callback error asynchronously
        error = new Error('rounds must be a number');
        return process.nextTick(function() {
            cb(error);
        });
    }

    if(!minor) {
        minor = 'b'
    } else if(minor !== 'b' && minor !== 'a') {
        error = new Error('minor must be either "a" or "b"');
        return process.nextTick(function() {
            cb(error);
        });
    }

    crypto.randomBytes(16, function(error, randomBytes) {
        if (error) {
            cb(error);
            return;
        }

        bindings.gen_salt(minor, rounds, randomBytes, cb);
    });
};

/// hash data using a salt
/// @param {String} data the data to encrypt
/// @param {String} salt the salt to use when hashing
/// @return {String} hash
module.exports.hashSync = function hashSync(data, salt) {
    if (data == null || salt == null) {
        throw new Error('data and salt arguments required');
    }

    if (typeof data !== 'string' || (typeof salt !== 'string' && typeof salt !== 'number')) {
        throw new Error('data must be a string and salt must either be a salt string or a number of rounds');
    }

    if (typeof salt === 'number') {
        salt = module.exports.genSaltSync(salt);
    }

    return bindings.encrypt_sync(data, salt);
};

/// hash data using a salt
/// @param {String} data the data to encrypt
/// @param {String} salt the salt to use when hashing
/// @param {Function} cb callback(err, hash)
module.exports.hash = function hash(data, salt, cb) {
    var error;

    if (typeof data === 'function') {
        error = new Error('data must be a string and salt must either be a salt string or a number of rounds');
        return process.nextTick(function() {
            data(error);
        });
    }

    if (typeof salt === 'function') {
        error = new Error('data must be a string and salt must either be a salt string or a number of rounds');
        return process.nextTick(function() {
            salt(error);
        });
    }

    // cb exists but is not a function
    // return a rejecting promise
    if (cb && typeof cb !== 'function') {
        return promises.reject(new Error('cb must be a function or null to return a Promise'));
    }

    if (!cb) {
        return promises.promise(hash, this, [data, salt]);
    }

    if (data == null || salt == null) {
        error = new Error('data and salt arguments required');
        return process.nextTick(function() {
            cb(error);
        });
    }

    if (typeof data !== 'string' || (typeof salt !== 'string' && typeof salt !== 'number')) {
        error = new Error('data must be a string and salt must either be a salt string or a number of rounds');
        return process.nextTick(function() {
            cb(error);
        });
    }


    if (typeof salt === 'number') {
        return module.exports.genSalt(salt, function(err, salt) {
            return bindings.encrypt(data, salt, cb);
        });
    }

    return bindings.encrypt(data, salt, cb);
};

/// compare raw data to hash
/// @param {String} data the data to hash and compare
/// @param {String} hash expected hash
/// @return {bool} true if hashed data matches hash
module.exports.compareSync = function compareSync(data, hash) {
    if (data == null || hash == null) {
        throw new Error('data and hash arguments required');
    }

    if (typeof data !== 'string' || typeof hash !== 'string') {
        throw new Error('data and hash must be strings');
    }

    return bindings.compare_sync(data, hash);
};

/// compare raw data to hash
/// @param {String} data the data to hash and compare
/// @param {String} hash expected hash
/// @param {Function} cb callback(err, matched) - matched is true if hashed data matches hash
module.exports.compare = function compare(data, hash, cb) {
    var error;

    if (typeof data === 'function') {
        error = new Error('data and hash arguments required');
        return process.nextTick(function() {
            data(error);
        });
    }

    if (typeof hash === 'function') {
        error = new Error('data and hash arguments required');
        return process.nextTick(function() {
            hash(error);
        });
    }

    // cb exists but is not a function
    // return a rejecting promise
    if (cb && typeof cb !== 'function') {
        return promises.reject(new Error('cb must be a function or null to return a Promise'));
    }

    if (!cb) {
        return promises.promise(compare, this, [data, hash]);
    }

    if (data == null || hash == null) {
        error = new Error('data and hash arguments required');
        return process.nextTick(function() {
            cb(error);
        });
    }

    if (typeof data !== 'string' || typeof hash !== 'string') {
        error = new Error('data and hash must be strings');
        return process.nextTick(function() {
            cb(error);
        });
    }

    return bindings.compare(data, hash, cb);
};

/// @param {String} hash extract rounds from this hash
/// @return {Number} the number of rounds used to encrypt a given hash
module.exports.getRounds = function getRounds(hash) {
    if (hash == null) {
        throw new Error('hash argument required');
    }

    if (typeof hash !== 'string') {
        throw new Error('hash must be a string');
    }

    return bindings.get_rounds(hash);
};

/* WEBPACK VAR INJECTION */}.call(this, "/"))

/***/ }),

/***/ "./node_modules/bcrypt/promises.js":
/*!*****************************************!*\
  !*** ./node_modules/bcrypt/promises.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Promise = global.Promise;

/// encapsulate a method with a node-style callback in a Promise
/// @param {object} 'this' of the encapsulated function
/// @param {function} function to be encapsulated
/// @param {Array-like} args to be passed to the called function
/// @return {Promise} a Promise encapsulating the function
module.exports.promise = function (fn, context, args) {

    if (!Array.isArray(args)) {
        args = Array.prototype.slice.call(args);
    }

    if (typeof fn !== 'function') {
        return Promise.reject(new Error('fn must be a function'));
    }

    return new Promise(function(resolve, reject) {
        args.push(function(err, data) {
            if (err) {
                reject(err);
            } else {
                resolve(data);
            }
        });

        fn.apply(context, args);
    });
};

/// @param {err} the error to be thrown
module.exports.reject = function (err) {
    return Promise.reject(err);
};

/// changes the promise implementation that bcrypt uses
/// @param {Promise} the implementation to use
module.exports.use = function(promise) {
  Promise = promise;
};


/***/ }),

/***/ "./node_modules/console-control-strings/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/console-control-strings/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// These tables borrowed from `ansi`

var prefix = '\x1b['

exports.up = function up (num) {
  return prefix + (num || '') + 'A'
}

exports.down = function down (num) {
  return prefix + (num || '') + 'B'
}

exports.forward = function forward (num) {
  return prefix + (num || '') + 'C'
}

exports.back = function back (num) {
  return prefix + (num || '') + 'D'
}

exports.nextLine = function nextLine (num) {
  return prefix + (num || '') + 'E'
}

exports.previousLine = function previousLine (num) {
  return prefix + (num || '') + 'F'
}

exports.horizontalAbsolute = function horizontalAbsolute (num) {
  if (num == null) throw new Error('horizontalAboslute requires a column to position to')
  return prefix + num + 'G'
}

exports.eraseData = function eraseData () {
  return prefix + 'J'
}

exports.eraseLine = function eraseLine () {
  return prefix + 'K'
}

exports.goto = function (x, y) {
  return prefix + y + ';' + x + 'H'
}

exports.gotoSOL = function () {
  return '\r'
}

exports.beep = function () {
  return '\x07'
}

exports.hideCursor = function hideCursor () {
  return prefix + '?25l'
}

exports.showCursor = function showCursor () {
  return prefix + '?25h'
}

var colors = {
  reset: 0,
// styles
  bold: 1,
  italic: 3,
  underline: 4,
  inverse: 7,
// resets
  stopBold: 22,
  stopItalic: 23,
  stopUnderline: 24,
  stopInverse: 27,
// colors
  white: 37,
  black: 30,
  blue: 34,
  cyan: 36,
  green: 32,
  magenta: 35,
  red: 31,
  yellow: 33,
  bgWhite: 47,
  bgBlack: 40,
  bgBlue: 44,
  bgCyan: 46,
  bgGreen: 42,
  bgMagenta: 45,
  bgRed: 41,
  bgYellow: 43,

  grey: 90,
  brightBlack: 90,
  brightRed: 91,
  brightGreen: 92,
  brightYellow: 93,
  brightBlue: 94,
  brightMagenta: 95,
  brightCyan: 96,
  brightWhite: 97,

  bgGrey: 100,
  bgBrightBlack: 100,
  bgBrightRed: 101,
  bgBrightGreen: 102,
  bgBrightYellow: 103,
  bgBrightBlue: 104,
  bgBrightMagenta: 105,
  bgBrightCyan: 106,
  bgBrightWhite: 107
}

exports.color = function color (colorWith) {
  if (arguments.length !== 1 || !Array.isArray(colorWith)) {
    colorWith = Array.prototype.slice.call(arguments)
  }
  return prefix + colorWith.map(colorNameToCode).join(';') + 'm'
}

function colorNameToCode (color) {
  if (colors[color] != null) return colors[color]
  throw new Error('Unknown color or style name: ' + color)
}


/***/ }),

/***/ "./node_modules/deep-extend/lib/deep-extend.js":
/*!*****************************************************!*\
  !*** ./node_modules/deep-extend/lib/deep-extend.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * @description Recursive object extending
 * @author Viacheslav Lotsmanov <lotsmanov89@gmail.com>
 * @license MIT
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Viacheslav Lotsmanov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */



function isSpecificValue(val) {
	return (
		val instanceof Buffer
		|| val instanceof Date
		|| val instanceof RegExp
	) ? true : false;
}

function cloneSpecificValue(val) {
	if (val instanceof Buffer) {
		var x = Buffer.alloc
			? Buffer.alloc(val.length)
			: new Buffer(val.length);
		val.copy(x);
		return x;
	} else if (val instanceof Date) {
		return new Date(val.getTime());
	} else if (val instanceof RegExp) {
		return new RegExp(val);
	} else {
		throw new Error('Unexpected situation');
	}
}

/**
 * Recursive cloning array.
 */
function deepCloneArray(arr) {
	var clone = [];
	arr.forEach(function (item, index) {
		if (typeof item === 'object' && item !== null) {
			if (Array.isArray(item)) {
				clone[index] = deepCloneArray(item);
			} else if (isSpecificValue(item)) {
				clone[index] = cloneSpecificValue(item);
			} else {
				clone[index] = deepExtend({}, item);
			}
		} else {
			clone[index] = item;
		}
	});
	return clone;
}

function safeGetProperty(object, property) {
	return property === '__proto__' ? undefined : object[property];
}

/**
 * Extening object that entered in first argument.
 *
 * Returns extended object or false if have no target object or incorrect type.
 *
 * If you wish to clone source object (without modify it), just use empty new
 * object as first argument, like this:
 *   deepExtend({}, yourObj_1, [yourObj_N]);
 */
var deepExtend = module.exports = function (/*obj_1, [obj_2], [obj_N]*/) {
	if (arguments.length < 1 || typeof arguments[0] !== 'object') {
		return false;
	}

	if (arguments.length < 2) {
		return arguments[0];
	}

	var target = arguments[0];

	// convert arguments to array and cut off target object
	var args = Array.prototype.slice.call(arguments, 1);

	var val, src, clone;

	args.forEach(function (obj) {
		// skip argument if isn't an object, is null, or is an array
		if (typeof obj !== 'object' || obj === null || Array.isArray(obj)) {
			return;
		}

		Object.keys(obj).forEach(function (key) {
			src = safeGetProperty(target, key); // source value
			val = safeGetProperty(obj, key); // new value

			// recursion prevention
			if (val === target) {
				return;

			/**
			 * if new value isn't object then just overwrite by new value
			 * instead of extending.
			 */
			} else if (typeof val !== 'object' || val === null) {
				target[key] = val;
				return;

			// just clone arrays (and recursive clone objects inside)
			} else if (Array.isArray(val)) {
				target[key] = deepCloneArray(val);
				return;

			// custom cloning and overwrite for specific objects
			} else if (isSpecificValue(val)) {
				target[key] = cloneSpecificValue(val);
				return;

			// overwrite by new value if source isn't object or array
			} else if (typeof src !== 'object' || src === null || Array.isArray(src)) {
				target[key] = deepExtend({}, val);
				return;

			// source value and new value is objects both, extending...
			} else {
				target[key] = deepExtend(src, val);
				return;
			}
		});
	});

	return target;
};


/***/ }),

/***/ "./node_modules/delegates/index.js":
/*!*****************************************!*\
  !*** ./node_modules/delegates/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * Expose `Delegator`.
 */

module.exports = Delegator;

/**
 * Initialize a delegator.
 *
 * @param {Object} proto
 * @param {String} target
 * @api public
 */

function Delegator(proto, target) {
  if (!(this instanceof Delegator)) return new Delegator(proto, target);
  this.proto = proto;
  this.target = target;
  this.methods = [];
  this.getters = [];
  this.setters = [];
  this.fluents = [];
}

/**
 * Delegate method `name`.
 *
 * @param {String} name
 * @return {Delegator} self
 * @api public
 */

Delegator.prototype.method = function(name){
  var proto = this.proto;
  var target = this.target;
  this.methods.push(name);

  proto[name] = function(){
    return this[target][name].apply(this[target], arguments);
  };

  return this;
};

/**
 * Delegator accessor `name`.
 *
 * @param {String} name
 * @return {Delegator} self
 * @api public
 */

Delegator.prototype.access = function(name){
  return this.getter(name).setter(name);
};

/**
 * Delegator getter `name`.
 *
 * @param {String} name
 * @return {Delegator} self
 * @api public
 */

Delegator.prototype.getter = function(name){
  var proto = this.proto;
  var target = this.target;
  this.getters.push(name);

  proto.__defineGetter__(name, function(){
    return this[target][name];
  });

  return this;
};

/**
 * Delegator setter `name`.
 *
 * @param {String} name
 * @return {Delegator} self
 * @api public
 */

Delegator.prototype.setter = function(name){
  var proto = this.proto;
  var target = this.target;
  this.setters.push(name);

  proto.__defineSetter__(name, function(val){
    return this[target][name] = val;
  });

  return this;
};

/**
 * Delegator fluent accessor
 *
 * @param {String} name
 * @return {Delegator} self
 * @api public
 */

Delegator.prototype.fluent = function (name) {
  var proto = this.proto;
  var target = this.target;
  this.fluents.push(name);

  proto[name] = function(val){
    if ('undefined' != typeof val) {
      this[target][name] = val;
      return this;
    } else {
      return this[target][name];
    }
  };

  return this;
};


/***/ }),

/***/ "./node_modules/detect-libc/lib/detect-libc.js":
/*!*****************************************************!*\
  !*** ./node_modules/detect-libc/lib/detect-libc.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var platform = __webpack_require__(/*! os */ "os").platform();
var spawnSync = __webpack_require__(/*! child_process */ "child_process").spawnSync;
var readdirSync = __webpack_require__(/*! fs */ "fs").readdirSync;

var GLIBC = 'glibc';
var MUSL = 'musl';

var spawnOptions = {
  encoding: 'utf8',
  env: process.env
};

if (!spawnSync) {
  spawnSync = function () {
    return { status: 126, stdout: '', stderr: '' };
  };
}

function contains (needle) {
  return function (haystack) {
    return haystack.indexOf(needle) !== -1;
  };
}

function versionFromMuslLdd (out) {
  return out.split(/[\r\n]+/)[1].trim().split(/\s/)[1];
}

function safeReaddirSync (path) {
  try {
    return readdirSync(path);
  } catch (e) {}
  return [];
}

var family = '';
var version = '';
var method = '';

if (platform === 'linux') {
  // Try getconf
  var glibc = spawnSync('getconf', ['GNU_LIBC_VERSION'], spawnOptions);
  if (glibc.status === 0) {
    family = GLIBC;
    version = glibc.stdout.trim().split(' ')[1];
    method = 'getconf';
  } else {
    // Try ldd
    var ldd = spawnSync('ldd', ['--version'], spawnOptions);
    if (ldd.status === 0 && ldd.stdout.indexOf(MUSL) !== -1) {
      family = MUSL;
      version = versionFromMuslLdd(ldd.stdout);
      method = 'ldd';
    } else if (ldd.status === 1 && ldd.stderr.indexOf(MUSL) !== -1) {
      family = MUSL;
      version = versionFromMuslLdd(ldd.stderr);
      method = 'ldd';
    } else {
      // Try filesystem (family only)
      var lib = safeReaddirSync('/lib');
      if (lib.some(contains('-linux-gnu'))) {
        family = GLIBC;
        method = 'filesystem';
      } else if (lib.some(contains('libc.musl-'))) {
        family = MUSL;
        method = 'filesystem';
      } else if (lib.some(contains('ld-musl-'))) {
        family = MUSL;
        method = 'filesystem';
      } else {
        var usrSbin = safeReaddirSync('/usr/sbin');
        if (usrSbin.some(contains('glibc'))) {
          family = GLIBC;
          method = 'filesystem';
        }
      }
    }
  }
}

var isNonGlibcLinux = (family !== '' && family !== GLIBC);

module.exports = {
  GLIBC: GLIBC,
  MUSL: MUSL,
  family: family,
  version: version,
  method: method,
  isNonGlibcLinux: isNonGlibcLinux
};


/***/ }),

/***/ "./node_modules/fs-minipass/index.js":
/*!*******************************************!*\
  !*** ./node_modules/fs-minipass/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const MiniPass = __webpack_require__(/*! minipass */ "./node_modules/minipass/index.js")
const EE = __webpack_require__(/*! events */ "events").EventEmitter
const fs = __webpack_require__(/*! fs */ "fs")

// for writev
const binding = process.binding('fs')
const writeBuffers = binding.writeBuffers
/* istanbul ignore next */
const FSReqWrap = binding.FSReqWrap || binding.FSReqCallback

const _autoClose = Symbol('_autoClose')
const _close = Symbol('_close')
const _ended = Symbol('_ended')
const _fd = Symbol('_fd')
const _finished = Symbol('_finished')
const _flags = Symbol('_flags')
const _flush = Symbol('_flush')
const _handleChunk = Symbol('_handleChunk')
const _makeBuf = Symbol('_makeBuf')
const _mode = Symbol('_mode')
const _needDrain = Symbol('_needDrain')
const _onerror = Symbol('_onerror')
const _onopen = Symbol('_onopen')
const _onread = Symbol('_onread')
const _onwrite = Symbol('_onwrite')
const _open = Symbol('_open')
const _path = Symbol('_path')
const _pos = Symbol('_pos')
const _queue = Symbol('_queue')
const _read = Symbol('_read')
const _readSize = Symbol('_readSize')
const _reading = Symbol('_reading')
const _remain = Symbol('_remain')
const _size = Symbol('_size')
const _write = Symbol('_write')
const _writing = Symbol('_writing')
const _defaultFlag = Symbol('_defaultFlag')

class ReadStream extends MiniPass {
  constructor (path, opt) {
    opt = opt || {}
    super(opt)

    this.writable = false

    if (typeof path !== 'string')
      throw new TypeError('path must be a string')

    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null
    this[_path] = path
    this[_readSize] = opt.readSize || 16*1024*1024
    this[_reading] = false
    this[_size] = typeof opt.size === 'number' ? opt.size : Infinity
    this[_remain] = this[_size]
    this[_autoClose] = typeof opt.autoClose === 'boolean' ?
      opt.autoClose : true

    if (typeof this[_fd] === 'number')
      this[_read]()
    else
      this[_open]()
  }

  get fd () { return this[_fd] }
  get path () { return this[_path] }

  write () {
    throw new TypeError('this is a readable stream')
  }

  end () {
    throw new TypeError('this is a readable stream')
  }

  [_open] () {
    fs.open(this[_path], 'r', (er, fd) => this[_onopen](er, fd))
  }

  [_onopen] (er, fd) {
    if (er)
      this[_onerror](er)
    else {
      this[_fd] = fd
      this.emit('open', fd)
      this[_read]()
    }
  }

  [_makeBuf] () {
    return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]))
  }

  [_read] () {
    if (!this[_reading]) {
      this[_reading] = true
      const buf = this[_makeBuf]()
      /* istanbul ignore if */
      if (buf.length === 0) return process.nextTick(() => this[_onread](null, 0, buf))
      fs.read(this[_fd], buf, 0, buf.length, null, (er, br, buf) =>
        this[_onread](er, br, buf))
    }
  }

  [_onread] (er, br, buf) {
    this[_reading] = false
    if (er)
      this[_onerror](er)
    else if (this[_handleChunk](br, buf))
      this[_read]()
  }

  [_close] () {
    if (this[_autoClose] && typeof this[_fd] === 'number') {
      fs.close(this[_fd], _ => this.emit('close'))
      this[_fd] = null
    }
  }

  [_onerror] (er) {
    this[_reading] = true
    this[_close]()
    this.emit('error', er)
  }

  [_handleChunk] (br, buf) {
    let ret = false
    // no effect if infinite
    this[_remain] -= br
    if (br > 0)
      ret = super.write(br < buf.length ? buf.slice(0, br) : buf)

    if (br === 0 || this[_remain] <= 0) {
      ret = false
      this[_close]()
      super.end()
    }

    return ret
  }

  emit (ev, data) {
    switch (ev) {
      case 'prefinish':
      case 'finish':
        break

      case 'drain':
        if (typeof this[_fd] === 'number')
          this[_read]()
        break

      default:
        return super.emit(ev, data)
    }
  }
}

class ReadStreamSync extends ReadStream {
  [_open] () {
    let threw = true
    try {
      this[_onopen](null, fs.openSync(this[_path], 'r'))
      threw = false
    } finally {
      if (threw)
        this[_close]()
    }
  }

  [_read] () {
    let threw = true
    try {
      if (!this[_reading]) {
        this[_reading] = true
        do {
          const buf = this[_makeBuf]()
          /* istanbul ignore next */
          const br = buf.length === 0 ? 0 : fs.readSync(this[_fd], buf, 0, buf.length, null)
          if (!this[_handleChunk](br, buf))
            break
        } while (true)
        this[_reading] = false
      }
      threw = false
    } finally {
      if (threw)
        this[_close]()
    }
  }

  [_close] () {
    if (this[_autoClose] && typeof this[_fd] === 'number') {
      try {
        fs.closeSync(this[_fd])
      } catch (er) {}
      this[_fd] = null
      this.emit('close')
    }
  }
}

class WriteStream extends EE {
  constructor (path, opt) {
    opt = opt || {}
    super(opt)
    this.readable = false
    this[_writing] = false
    this[_ended] = false
    this[_needDrain] = false
    this[_queue] = []
    this[_path] = path
    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null
    this[_mode] = opt.mode === undefined ? 0o666 : opt.mode
    this[_pos] = typeof opt.start === 'number' ? opt.start : null
    this[_autoClose] = typeof opt.autoClose === 'boolean' ?
      opt.autoClose : true

    // truncating makes no sense when writing into the middle
    const defaultFlag = this[_pos] !== null ? 'r+' : 'w'
    this[_defaultFlag] = opt.flags === undefined
    this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags

    if (this[_fd] === null)
      this[_open]()
  }

  get fd () { return this[_fd] }
  get path () { return this[_path] }

  [_onerror] (er) {
    this[_close]()
    this[_writing] = true
    this.emit('error', er)
  }

  [_open] () {
    fs.open(this[_path], this[_flags], this[_mode],
      (er, fd) => this[_onopen](er, fd))
  }

  [_onopen] (er, fd) {
    if (this[_defaultFlag] &&
        this[_flags] === 'r+' &&
        er && er.code === 'ENOENT') {
      this[_flags] = 'w'
      this[_open]()
    } else if (er)
      this[_onerror](er)
    else {
      this[_fd] = fd
      this.emit('open', fd)
      this[_flush]()
    }
  }

  end (buf, enc) {
    if (buf)
      this.write(buf, enc)

    this[_ended] = true

    // synthetic after-write logic, where drain/finish live
    if (!this[_writing] && !this[_queue].length &&
        typeof this[_fd] === 'number')
      this[_onwrite](null, 0)
  }

  write (buf, enc) {
    if (typeof buf === 'string')
      buf = new Buffer(buf, enc)

    if (this[_ended]) {
      this.emit('error', new Error('write() after end()'))
      return false
    }

    if (this[_fd] === null || this[_writing] || this[_queue].length) {
      this[_queue].push(buf)
      this[_needDrain] = true
      return false
    }

    this[_writing] = true
    this[_write](buf)
    return true
  }

  [_write] (buf) {
    fs.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) =>
      this[_onwrite](er, bw))
  }

  [_onwrite] (er, bw) {
    if (er)
      this[_onerror](er)
    else {
      if (this[_pos] !== null)
        this[_pos] += bw
      if (this[_queue].length)
        this[_flush]()
      else {
        this[_writing] = false

        if (this[_ended] && !this[_finished]) {
          this[_finished] = true
          this[_close]()
          this.emit('finish')
        } else if (this[_needDrain]) {
          this[_needDrain] = false
          this.emit('drain')
        }
      }
    }
  }

  [_flush] () {
    if (this[_queue].length === 0) {
      if (this[_ended])
        this[_onwrite](null, 0)
    } else if (this[_queue].length === 1)
      this[_write](this[_queue].pop())
    else {
      const iovec = this[_queue]
      this[_queue] = []
      writev(this[_fd], iovec, this[_pos],
        (er, bw) => this[_onwrite](er, bw))
    }
  }

  [_close] () {
    if (this[_autoClose] && typeof this[_fd] === 'number') {
      fs.close(this[_fd], _ => this.emit('close'))
      this[_fd] = null
    }
  }
}

class WriteStreamSync extends WriteStream {
  [_open] () {
    let fd
    try {
      fd = fs.openSync(this[_path], this[_flags], this[_mode])
    } catch (er) {
      if (this[_defaultFlag] &&
          this[_flags] === 'r+' &&
          er && er.code === 'ENOENT') {
        this[_flags] = 'w'
        return this[_open]()
      } else
        throw er
    }
    this[_onopen](null, fd)
  }

  [_close] () {
    if (this[_autoClose] && typeof this[_fd] === 'number') {
      try {
        fs.closeSync(this[_fd])
      } catch (er) {}
      this[_fd] = null
      this.emit('close')
    }
  }

  [_write] (buf) {
    try {
      this[_onwrite](null,
        fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos]))
    } catch (er) {
      this[_onwrite](er, 0)
    }
  }
}

const writev = (fd, iovec, pos, cb) => {
  const done = (er, bw) => cb(er, bw, iovec)
  const req = new FSReqWrap()
  req.oncomplete = done
  binding.writeBuffers(fd, iovec, pos, req)
}

exports.ReadStream = ReadStream
exports.ReadStreamSync = ReadStreamSync

exports.WriteStream = WriteStream
exports.WriteStreamSync = WriteStreamSync


/***/ }),

/***/ "./node_modules/gauge/base-theme.js":
/*!******************************************!*\
  !*** ./node_modules/gauge/base-theme.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var spin = __webpack_require__(/*! ./spin.js */ "./node_modules/gauge/spin.js")
var progressBar = __webpack_require__(/*! ./progress-bar.js */ "./node_modules/gauge/progress-bar.js")

module.exports = {
  activityIndicator: function (values, theme, width) {
    if (values.spun == null) return
    return spin(theme, values.spun)
  },
  progressbar: function (values, theme, width) {
    if (values.completed == null) return
    return progressBar(theme, width, values.completed)
  }
}


/***/ }),

/***/ "./node_modules/gauge/error.js":
/*!*************************************!*\
  !*** ./node_modules/gauge/error.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var util = __webpack_require__(/*! util */ "util")

var User = exports.User = function User (msg) {
  var err = new Error(msg)
  Error.captureStackTrace(err, User)
  err.code = 'EGAUGE'
  return err
}

exports.MissingTemplateValue = function MissingTemplateValue (item, values) {
  var err = new User(util.format('Missing template value "%s"', item.type))
  Error.captureStackTrace(err, MissingTemplateValue)
  err.template = item
  err.values = values
  return err
}

exports.Internal = function Internal (msg) {
  var err = new Error(msg)
  Error.captureStackTrace(err, Internal)
  err.code = 'EGAUGEINTERNAL'
  return err
}


/***/ }),

/***/ "./node_modules/gauge/has-color.js":
/*!*****************************************!*\
  !*** ./node_modules/gauge/has-color.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = isWin32() || isColorTerm()

function isWin32 () {
  return process.platform === 'win32'
}

function isColorTerm () {
  var termHasColor = /^screen|^xterm|^vt100|color|ansi|cygwin|linux/i
  return !!process.env.COLORTERM || termHasColor.test(process.env.TERM)
}


/***/ }),

/***/ "./node_modules/gauge/index.js":
/*!*************************************!*\
  !*** ./node_modules/gauge/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Plumbing = __webpack_require__(/*! ./plumbing.js */ "./node_modules/gauge/plumbing.js")
var hasUnicode = __webpack_require__(/*! has-unicode */ "./node_modules/has-unicode/index.js")
var hasColor = __webpack_require__(/*! ./has-color.js */ "./node_modules/gauge/has-color.js")
var onExit = __webpack_require__(/*! signal-exit */ "signal-exit")
var defaultThemes = __webpack_require__(/*! ./themes */ "./node_modules/gauge/themes.js")
var setInterval = __webpack_require__(/*! ./set-interval.js */ "./node_modules/gauge/set-interval.js")
var process = __webpack_require__(/*! ./process.js */ "./node_modules/gauge/process.js")
var setImmediate = __webpack_require__(/*! ./set-immediate */ "./node_modules/gauge/set-immediate.js")

module.exports = Gauge

function callWith (obj, method) {
  return function () {
    return method.call(obj)
  }
}

function Gauge (arg1, arg2) {
  var options, writeTo
  if (arg1 && arg1.write) {
    writeTo = arg1
    options = arg2 || {}
  } else if (arg2 && arg2.write) {
    writeTo = arg2
    options = arg1 || {}
  } else {
    writeTo = process.stderr
    options = arg1 || arg2 || {}
  }

  this._status = {
    spun: 0,
    section: '',
    subsection: ''
  }
  this._paused = false // are we paused for back pressure?
  this._disabled = true // are all progress bar updates disabled?
  this._showing = false // do we WANT the progress bar on screen
  this._onScreen = false // IS the progress bar on screen
  this._needsRedraw = false // should we print something at next tick?
  this._hideCursor = options.hideCursor == null ? true : options.hideCursor
  this._fixedFramerate = options.fixedFramerate == null
    ? !(/^v0\.8\./.test(process.version))
    : options.fixedFramerate
  this._lastUpdateAt = null
  this._updateInterval = options.updateInterval == null ? 50 : options.updateInterval

  this._themes = options.themes || defaultThemes
  this._theme = options.theme
  var theme = this._computeTheme(options.theme)
  var template = options.template || [
    {type: 'progressbar', length: 20},
    {type: 'activityIndicator', kerning: 1, length: 1},
    {type: 'section', kerning: 1, default: ''},
    {type: 'subsection', kerning: 1, default: ''}
  ]
  this.setWriteTo(writeTo, options.tty)
  var PlumbingClass = options.Plumbing || Plumbing
  this._gauge = new PlumbingClass(theme, template, this.getWidth())

  this._$$doRedraw = callWith(this, this._doRedraw)
  this._$$handleSizeChange = callWith(this, this._handleSizeChange)

  this._cleanupOnExit = options.cleanupOnExit == null || options.cleanupOnExit
  this._removeOnExit = null

  if (options.enabled || (options.enabled == null && this._tty && this._tty.isTTY)) {
    this.enable()
  } else {
    this.disable()
  }
}
Gauge.prototype = {}

Gauge.prototype.isEnabled = function () {
  return !this._disabled
}

Gauge.prototype.setTemplate = function (template) {
  this._gauge.setTemplate(template)
  if (this._showing) this._requestRedraw()
}

Gauge.prototype._computeTheme = function (theme) {
  if (!theme) theme = {}
  if (typeof theme === 'string') {
    theme = this._themes.getTheme(theme)
  } else if (theme && (Object.keys(theme).length === 0 || theme.hasUnicode != null || theme.hasColor != null)) {
    var useUnicode = theme.hasUnicode == null ? hasUnicode() : theme.hasUnicode
    var useColor = theme.hasColor == null ? hasColor : theme.hasColor
    theme = this._themes.getDefault({hasUnicode: useUnicode, hasColor: useColor, platform: theme.platform})
  }
  return theme
}

Gauge.prototype.setThemeset = function (themes) {
  this._themes = themes
  this.setTheme(this._theme)
}

Gauge.prototype.setTheme = function (theme) {
  this._gauge.setTheme(this._computeTheme(theme))
  if (this._showing) this._requestRedraw()
  this._theme = theme
}

Gauge.prototype._requestRedraw = function () {
  this._needsRedraw = true
  if (!this._fixedFramerate) this._doRedraw()
}

Gauge.prototype.getWidth = function () {
  return ((this._tty && this._tty.columns) || 80) - 1
}

Gauge.prototype.setWriteTo = function (writeTo, tty) {
  var enabled = !this._disabled
  if (enabled) this.disable()
  this._writeTo = writeTo
  this._tty = tty ||
    (writeTo === process.stderr && process.stdout.isTTY && process.stdout) ||
    (writeTo.isTTY && writeTo) ||
    this._tty
  if (this._gauge) this._gauge.setWidth(this.getWidth())
  if (enabled) this.enable()
}

Gauge.prototype.enable = function () {
  if (!this._disabled) return
  this._disabled = false
  if (this._tty) this._enableEvents()
  if (this._showing) this.show()
}

Gauge.prototype.disable = function () {
  if (this._disabled) return
  if (this._showing) {
    this._lastUpdateAt = null
    this._showing = false
    this._doRedraw()
    this._showing = true
  }
  this._disabled = true
  if (this._tty) this._disableEvents()
}

Gauge.prototype._enableEvents = function () {
  if (this._cleanupOnExit) {
    this._removeOnExit = onExit(callWith(this, this.disable))
  }
  this._tty.on('resize', this._$$handleSizeChange)
  if (this._fixedFramerate) {
    this.redrawTracker = setInterval(this._$$doRedraw, this._updateInterval)
    if (this.redrawTracker.unref) this.redrawTracker.unref()
  }
}

Gauge.prototype._disableEvents = function () {
  this._tty.removeListener('resize', this._$$handleSizeChange)
  if (this._fixedFramerate) clearInterval(this.redrawTracker)
  if (this._removeOnExit) this._removeOnExit()
}

Gauge.prototype.hide = function (cb) {
  if (this._disabled) return cb && process.nextTick(cb)
  if (!this._showing) return cb && process.nextTick(cb)
  this._showing = false
  this._doRedraw()
  cb && setImmediate(cb)
}

Gauge.prototype.show = function (section, completed) {
  this._showing = true
  if (typeof section === 'string') {
    this._status.section = section
  } else if (typeof section === 'object') {
    var sectionKeys = Object.keys(section)
    for (var ii = 0; ii < sectionKeys.length; ++ii) {
      var key = sectionKeys[ii]
      this._status[key] = section[key]
    }
  }
  if (completed != null) this._status.completed = completed
  if (this._disabled) return
  this._requestRedraw()
}

Gauge.prototype.pulse = function (subsection) {
  this._status.subsection = subsection || ''
  this._status.spun ++
  if (this._disabled) return
  if (!this._showing) return
  this._requestRedraw()
}

Gauge.prototype._handleSizeChange = function () {
  this._gauge.setWidth(this._tty.columns - 1)
  this._requestRedraw()
}

Gauge.prototype._doRedraw = function () {
  if (this._disabled || this._paused) return
  if (!this._fixedFramerate) {
    var now = Date.now()
    if (this._lastUpdateAt && now - this._lastUpdateAt < this._updateInterval) return
    this._lastUpdateAt = now
  }
  if (!this._showing && this._onScreen) {
    this._onScreen = false
    var result = this._gauge.hide()
    if (this._hideCursor) {
      result += this._gauge.showCursor()
    }
    return this._writeTo.write(result)
  }
  if (!this._showing && !this._onScreen) return
  if (this._showing && !this._onScreen) {
    this._onScreen = true
    this._needsRedraw = true
    if (this._hideCursor) {
      this._writeTo.write(this._gauge.hideCursor())
    }
  }
  if (!this._needsRedraw) return
  if (!this._writeTo.write(this._gauge.show(this._status))) {
    this._paused = true
    this._writeTo.on('drain', callWith(this, function () {
      this._paused = false
      this._doRedraw()
    }))
  }
}


/***/ }),

/***/ "./node_modules/gauge/plumbing.js":
/*!****************************************!*\
  !*** ./node_modules/gauge/plumbing.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var consoleControl = __webpack_require__(/*! console-control-strings */ "./node_modules/console-control-strings/index.js")
var renderTemplate = __webpack_require__(/*! ./render-template.js */ "./node_modules/gauge/render-template.js")
var validate = __webpack_require__(/*! aproba */ "aproba")

var Plumbing = module.exports = function (theme, template, width) {
  if (!width) width = 80
  validate('OAN', [theme, template, width])
  this.showing = false
  this.theme = theme
  this.width = width
  this.template = template
}
Plumbing.prototype = {}

Plumbing.prototype.setTheme = function (theme) {
  validate('O', [theme])
  this.theme = theme
}

Plumbing.prototype.setTemplate = function (template) {
  validate('A', [template])
  this.template = template
}

Plumbing.prototype.setWidth = function (width) {
  validate('N', [width])
  this.width = width
}

Plumbing.prototype.hide = function () {
  return consoleControl.gotoSOL() + consoleControl.eraseLine()
}

Plumbing.prototype.hideCursor = consoleControl.hideCursor

Plumbing.prototype.showCursor = consoleControl.showCursor

Plumbing.prototype.show = function (status) {
  var values = Object.create(this.theme)
  for (var key in status) {
    values[key] = status[key]
  }

  return renderTemplate(this.width, this.template, values).trim() +
         consoleControl.color('reset') +
         consoleControl.eraseLine() + consoleControl.gotoSOL()
}


/***/ }),

/***/ "./node_modules/gauge/process.js":
/*!***************************************!*\
  !*** ./node_modules/gauge/process.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// this exists so we can replace it during testing
module.exports = process


/***/ }),

/***/ "./node_modules/gauge/progress-bar.js":
/*!********************************************!*\
  !*** ./node_modules/gauge/progress-bar.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var validate = __webpack_require__(/*! aproba */ "aproba")
var renderTemplate = __webpack_require__(/*! ./render-template.js */ "./node_modules/gauge/render-template.js")
var wideTruncate = __webpack_require__(/*! ./wide-truncate */ "./node_modules/gauge/wide-truncate.js")
var stringWidth = __webpack_require__(/*! string-width */ "string-width")

module.exports = function (theme, width, completed) {
  validate('ONN', [theme, width, completed])
  if (completed < 0) completed = 0
  if (completed > 1) completed = 1
  if (width <= 0) return ''
  var sofar = Math.round(width * completed)
  var rest = width - sofar
  var template = [
    {type: 'complete', value: repeat(theme.complete, sofar), length: sofar},
    {type: 'remaining', value: repeat(theme.remaining, rest), length: rest}
  ]
  return renderTemplate(width, template, theme)
}

// lodash's way of repeating
function repeat (string, width) {
  var result = ''
  var n = width
  do {
    if (n % 2) {
      result += string
    }
    n = Math.floor(n / 2)
    /*eslint no-self-assign: 0*/
    string += string
  } while (n && stringWidth(result) < width)

  return wideTruncate(result, width)
}


/***/ }),

/***/ "./node_modules/gauge/render-template.js":
/*!***********************************************!*\
  !*** ./node_modules/gauge/render-template.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var align = __webpack_require__(/*! wide-align */ "./node_modules/wide-align/align.js")
var validate = __webpack_require__(/*! aproba */ "aproba")
var objectAssign = __webpack_require__(/*! object-assign */ "object-assign")
var wideTruncate = __webpack_require__(/*! ./wide-truncate */ "./node_modules/gauge/wide-truncate.js")
var error = __webpack_require__(/*! ./error */ "./node_modules/gauge/error.js")
var TemplateItem = __webpack_require__(/*! ./template-item */ "./node_modules/gauge/template-item.js")

function renderValueWithValues (values) {
  return function (item) {
    return renderValue(item, values)
  }
}

var renderTemplate = module.exports = function (width, template, values) {
  var items = prepareItems(width, template, values)
  var rendered = items.map(renderValueWithValues(values)).join('')
  return align.left(wideTruncate(rendered, width), width)
}

function preType (item) {
  var cappedTypeName = item.type[0].toUpperCase() + item.type.slice(1)
  return 'pre' + cappedTypeName
}

function postType (item) {
  var cappedTypeName = item.type[0].toUpperCase() + item.type.slice(1)
  return 'post' + cappedTypeName
}

function hasPreOrPost (item, values) {
  if (!item.type) return
  return values[preType(item)] || values[postType(item)]
}

function generatePreAndPost (baseItem, parentValues) {
  var item = objectAssign({}, baseItem)
  var values = Object.create(parentValues)
  var template = []
  var pre = preType(item)
  var post = postType(item)
  if (values[pre]) {
    template.push({value: values[pre]})
    values[pre] = null
  }
  item.minLength = null
  item.length = null
  item.maxLength = null
  template.push(item)
  values[item.type] = values[item.type]
  if (values[post]) {
    template.push({value: values[post]})
    values[post] = null
  }
  return function ($1, $2, length) {
    return renderTemplate(length, template, values)
  }
}

function prepareItems (width, template, values) {
  function cloneAndObjectify (item, index, arr) {
    var cloned = new TemplateItem(item, width)
    var type = cloned.type
    if (cloned.value == null) {
      if (!(type in values)) {
        if (cloned.default == null) {
          throw new error.MissingTemplateValue(cloned, values)
        } else {
          cloned.value = cloned.default
        }
      } else {
        cloned.value = values[type]
      }
    }
    if (cloned.value == null || cloned.value === '') return null
    cloned.index = index
    cloned.first = index === 0
    cloned.last = index === arr.length - 1
    if (hasPreOrPost(cloned, values)) cloned.value = generatePreAndPost(cloned, values)
    return cloned
  }

  var output = template.map(cloneAndObjectify).filter(function (item) { return item != null })

  var outputLength = 0
  var remainingSpace = width
  var variableCount = output.length

  function consumeSpace (length) {
    if (length > remainingSpace) length = remainingSpace
    outputLength += length
    remainingSpace -= length
  }

  function finishSizing (item, length) {
    if (item.finished) throw new error.Internal('Tried to finish template item that was already finished')
    if (length === Infinity) throw new error.Internal('Length of template item cannot be infinity')
    if (length != null) item.length = length
    item.minLength = null
    item.maxLength = null
    --variableCount
    item.finished = true
    if (item.length == null) item.length = item.getBaseLength()
    if (item.length == null) throw new error.Internal('Finished template items must have a length')
    consumeSpace(item.getLength())
  }

  output.forEach(function (item) {
    if (!item.kerning) return
    var prevPadRight = item.first ? 0 : output[item.index - 1].padRight
    if (!item.first && prevPadRight < item.kerning) item.padLeft = item.kerning - prevPadRight
    if (!item.last) item.padRight = item.kerning
  })

  // Finish any that have a fixed (literal or intuited) length
  output.forEach(function (item) {
    if (item.getBaseLength() == null) return
    finishSizing(item)
  })

  var resized = 0
  var resizing
  var hunkSize
  do {
    resizing = false
    hunkSize = Math.round(remainingSpace / variableCount)
    output.forEach(function (item) {
      if (item.finished) return
      if (!item.maxLength) return
      if (item.getMaxLength() < hunkSize) {
        finishSizing(item, item.maxLength)
        resizing = true
      }
    })
  } while (resizing && resized++ < output.length)
  if (resizing) throw new error.Internal('Resize loop iterated too many times while determining maxLength')

  resized = 0
  do {
    resizing = false
    hunkSize = Math.round(remainingSpace / variableCount)
    output.forEach(function (item) {
      if (item.finished) return
      if (!item.minLength) return
      if (item.getMinLength() >= hunkSize) {
        finishSizing(item, item.minLength)
        resizing = true
      }
    })
  } while (resizing && resized++ < output.length)
  if (resizing) throw new error.Internal('Resize loop iterated too many times while determining minLength')

  hunkSize = Math.round(remainingSpace / variableCount)
  output.forEach(function (item) {
    if (item.finished) return
    finishSizing(item, hunkSize)
  })

  return output
}

function renderFunction (item, values, length) {
  validate('OON', arguments)
  if (item.type) {
    return item.value(values, values[item.type + 'Theme'] || {}, length)
  } else {
    return item.value(values, {}, length)
  }
}

function renderValue (item, values) {
  var length = item.getBaseLength()
  var value = typeof item.value === 'function' ? renderFunction(item, values, length) : item.value
  if (value == null || value === '') return ''
  var alignWith = align[item.align] || align.left
  var leftPadding = item.padLeft ? align.left('', item.padLeft) : ''
  var rightPadding = item.padRight ? align.right('', item.padRight) : ''
  var truncated = wideTruncate(String(value), length)
  var aligned = alignWith(truncated, length)
  return leftPadding + aligned + rightPadding
}


/***/ }),

/***/ "./node_modules/gauge/set-immediate.js":
/*!*********************************************!*\
  !*** ./node_modules/gauge/set-immediate.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var process = __webpack_require__(/*! ./process */ "./node_modules/gauge/process.js")
try {
  module.exports = setImmediate
} catch (ex) {
  module.exports = process.nextTick
}


/***/ }),

/***/ "./node_modules/gauge/set-interval.js":
/*!********************************************!*\
  !*** ./node_modules/gauge/set-interval.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// this exists so we can replace it during testing
module.exports = setInterval


/***/ }),

/***/ "./node_modules/gauge/spin.js":
/*!************************************!*\
  !*** ./node_modules/gauge/spin.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function spin (spinstr, spun) {
  return spinstr[spun % spinstr.length]
}


/***/ }),

/***/ "./node_modules/gauge/template-item.js":
/*!*********************************************!*\
  !*** ./node_modules/gauge/template-item.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var stringWidth = __webpack_require__(/*! string-width */ "string-width")

module.exports = TemplateItem

function isPercent (num) {
  if (typeof num !== 'string') return false
  return num.slice(-1) === '%'
}

function percent (num) {
  return Number(num.slice(0, -1)) / 100
}

function TemplateItem (values, outputLength) {
  this.overallOutputLength = outputLength
  this.finished = false
  this.type = null
  this.value = null
  this.length = null
  this.maxLength = null
  this.minLength = null
  this.kerning = null
  this.align = 'left'
  this.padLeft = 0
  this.padRight = 0
  this.index = null
  this.first = null
  this.last = null
  if (typeof values === 'string') {
    this.value = values
  } else {
    for (var prop in values) this[prop] = values[prop]
  }
  // Realize percents
  if (isPercent(this.length)) {
    this.length = Math.round(this.overallOutputLength * percent(this.length))
  }
  if (isPercent(this.minLength)) {
    this.minLength = Math.round(this.overallOutputLength * percent(this.minLength))
  }
  if (isPercent(this.maxLength)) {
    this.maxLength = Math.round(this.overallOutputLength * percent(this.maxLength))
  }
  return this
}

TemplateItem.prototype = {}

TemplateItem.prototype.getBaseLength = function () {
  var length = this.length
  if (length == null && typeof this.value === 'string' && this.maxLength == null && this.minLength == null) {
    length = stringWidth(this.value)
  }
  return length
}

TemplateItem.prototype.getLength = function () {
  var length = this.getBaseLength()
  if (length == null) return null
  return length + this.padLeft + this.padRight
}

TemplateItem.prototype.getMaxLength = function () {
  if (this.maxLength == null) return null
  return this.maxLength + this.padLeft + this.padRight
}

TemplateItem.prototype.getMinLength = function () {
  if (this.minLength == null) return null
  return this.minLength + this.padLeft + this.padRight
}



/***/ }),

/***/ "./node_modules/gauge/theme-set.js":
/*!*****************************************!*\
  !*** ./node_modules/gauge/theme-set.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var objectAssign = __webpack_require__(/*! object-assign */ "object-assign")

module.exports = function () {
  return ThemeSetProto.newThemeSet()
}

var ThemeSetProto = {}

ThemeSetProto.baseTheme = __webpack_require__(/*! ./base-theme.js */ "./node_modules/gauge/base-theme.js")

ThemeSetProto.newTheme = function (parent, theme) {
  if (!theme) {
    theme = parent
    parent = this.baseTheme
  }
  return objectAssign({}, parent, theme)
}

ThemeSetProto.getThemeNames = function () {
  return Object.keys(this.themes)
}

ThemeSetProto.addTheme = function (name, parent, theme) {
  this.themes[name] = this.newTheme(parent, theme)
}

ThemeSetProto.addToAllThemes = function (theme) {
  var themes = this.themes
  Object.keys(themes).forEach(function (name) {
    objectAssign(themes[name], theme)
  })
  objectAssign(this.baseTheme, theme)
}

ThemeSetProto.getTheme = function (name) {
  if (!this.themes[name]) throw this.newMissingThemeError(name)
  return this.themes[name]
}

ThemeSetProto.setDefault = function (opts, name) {
  if (name == null) {
    name = opts
    opts = {}
  }
  var platform = opts.platform == null ? 'fallback' : opts.platform
  var hasUnicode = !!opts.hasUnicode
  var hasColor = !!opts.hasColor
  if (!this.defaults[platform]) this.defaults[platform] = {true: {}, false: {}}
  this.defaults[platform][hasUnicode][hasColor] = name
}

ThemeSetProto.getDefault = function (opts) {
  if (!opts) opts = {}
  var platformName = opts.platform || process.platform
  var platform = this.defaults[platformName] || this.defaults.fallback
  var hasUnicode = !!opts.hasUnicode
  var hasColor = !!opts.hasColor
  if (!platform) throw this.newMissingDefaultThemeError(platformName, hasUnicode, hasColor)
  if (!platform[hasUnicode][hasColor]) {
    if (hasUnicode && hasColor && platform[!hasUnicode][hasColor]) {
      hasUnicode = false
    } else if (hasUnicode && hasColor && platform[hasUnicode][!hasColor]) {
      hasColor = false
    } else if (hasUnicode && hasColor && platform[!hasUnicode][!hasColor]) {
      hasUnicode = false
      hasColor = false
    } else if (hasUnicode && !hasColor && platform[!hasUnicode][hasColor]) {
      hasUnicode = false
    } else if (!hasUnicode && hasColor && platform[hasUnicode][!hasColor]) {
      hasColor = false
    } else if (platform === this.defaults.fallback) {
      throw this.newMissingDefaultThemeError(platformName, hasUnicode, hasColor)
    }
  }
  if (platform[hasUnicode][hasColor]) {
    return this.getTheme(platform[hasUnicode][hasColor])
  } else {
    return this.getDefault(objectAssign({}, opts, {platform: 'fallback'}))
  }
}

ThemeSetProto.newMissingThemeError = function newMissingThemeError (name) {
  var err = new Error('Could not find a gauge theme named "' + name + '"')
  Error.captureStackTrace.call(err, newMissingThemeError)
  err.theme = name
  err.code = 'EMISSINGTHEME'
  return err
}

ThemeSetProto.newMissingDefaultThemeError = function newMissingDefaultThemeError (platformName, hasUnicode, hasColor) {
  var err = new Error(
    'Could not find a gauge theme for your platform/unicode/color use combo:\n' +
    '    platform = ' + platformName + '\n' +
    '    hasUnicode = ' + hasUnicode + '\n' +
    '    hasColor = ' + hasColor)
  Error.captureStackTrace.call(err, newMissingDefaultThemeError)
  err.platform = platformName
  err.hasUnicode = hasUnicode
  err.hasColor = hasColor
  err.code = 'EMISSINGTHEME'
  return err
}

ThemeSetProto.newThemeSet = function () {
  var themeset = function (opts) {
    return themeset.getDefault(opts)
  }
  return objectAssign(themeset, ThemeSetProto, {
    themes: objectAssign({}, this.themes),
    baseTheme: objectAssign({}, this.baseTheme),
    defaults: JSON.parse(JSON.stringify(this.defaults || {}))
  })
}



/***/ }),

/***/ "./node_modules/gauge/themes.js":
/*!**************************************!*\
  !*** ./node_modules/gauge/themes.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var consoleControl = __webpack_require__(/*! console-control-strings */ "./node_modules/console-control-strings/index.js")
var ThemeSet = __webpack_require__(/*! ./theme-set.js */ "./node_modules/gauge/theme-set.js")

var themes = module.exports = new ThemeSet()

themes.addTheme('ASCII', {
  preProgressbar: '[',
  postProgressbar: ']',
  progressbarTheme: {
    complete: '#',
    remaining: '.'
  },
  activityIndicatorTheme: '-\\|/',
  preSubsection: '>'
})

themes.addTheme('colorASCII', themes.getTheme('ASCII'), {
  progressbarTheme: {
    preComplete: consoleControl.color('inverse'),
    complete: ' ',
    postComplete: consoleControl.color('stopInverse'),
    preRemaining: consoleControl.color('brightBlack'),
    remaining: '.',
    postRemaining: consoleControl.color('reset')
  }
})

themes.addTheme('brailleSpinner', {
  preProgressbar: '',
  postProgressbar: '',
  progressbarTheme: {
    complete: '',
    remaining: ''
  },
  activityIndicatorTheme: '',
  preSubsection: '>'
})

themes.addTheme('colorBrailleSpinner', themes.getTheme('brailleSpinner'), {
  progressbarTheme: {
    preComplete: consoleControl.color('inverse'),
    complete: ' ',
    postComplete: consoleControl.color('stopInverse'),
    preRemaining: consoleControl.color('brightBlack'),
    remaining: '',
    postRemaining: consoleControl.color('reset')
  }
})

themes.setDefault({}, 'ASCII')
themes.setDefault({hasColor: true}, 'colorASCII')
themes.setDefault({platform: 'darwin', hasUnicode: true}, 'brailleSpinner')
themes.setDefault({platform: 'darwin', hasUnicode: true, hasColor: true}, 'colorBrailleSpinner')


/***/ }),

/***/ "./node_modules/gauge/wide-truncate.js":
/*!*********************************************!*\
  !*** ./node_modules/gauge/wide-truncate.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var stringWidth = __webpack_require__(/*! string-width */ "string-width")
var stripAnsi = __webpack_require__(/*! strip-ansi */ "strip-ansi")

module.exports = wideTruncate

function wideTruncate (str, target) {
  if (stringWidth(str) === 0) return str
  if (target <= 0) return ''
  if (stringWidth(str) <= target) return str

  // We compute the number of bytes of ansi sequences here and add
  // that to our initial truncation to ensure that we don't slice one
  // that we want to keep in half.
  var noAnsi = stripAnsi(str)
  var ansiSize = str.length + noAnsi.length
  var truncated = str.slice(0, target + ansiSize)

  // we have to shrink the result to account for our ansi sequence buffer
  // (if an ansi sequence was truncated) and double width characters.
  while (stringWidth(truncated) > target) {
    truncated = truncated.slice(0, -1)
  }
  return truncated
}


/***/ }),

/***/ "./node_modules/has-unicode/index.js":
/*!*******************************************!*\
  !*** ./node_modules/has-unicode/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var os = __webpack_require__(/*! os */ "os")

var hasUnicode = module.exports = function () {
  // Recent Win32 platforms (>XP) CAN support unicode in the console but
  // don't have to, and in non-english locales often use traditional local
  // code pages. There's no way, short of windows system calls or execing
  // the chcp command line program to figure this out. As such, we default
  // this to false and encourage your users to override it via config if
  // appropriate.
  if (os.type() == "Windows_NT") { return false }

  var isUTF8 = /UTF-?8$/i
  var ctype = process.env.LC_ALL || process.env.LC_CTYPE || process.env.LANG
  return isUTF8.test(ctype)
}


/***/ }),

/***/ "./node_modules/ignore-walk/index.js":
/*!*******************************************!*\
  !*** ./node_modules/ignore-walk/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(/*! fs */ "fs")
const path = __webpack_require__(/*! path */ "path")
const EE = __webpack_require__(/*! events */ "events").EventEmitter
const Minimatch = __webpack_require__(/*! minimatch */ "minimatch").Minimatch

class Walker extends EE {
  constructor (opts) {
    opts = opts || {}
    super(opts)
    this.path = opts.path || process.cwd()
    this.basename = path.basename(this.path)
    this.ignoreFiles = opts.ignoreFiles || [ '.ignore' ]
    this.ignoreRules = {}
    this.parent = opts.parent || null
    this.includeEmpty = !!opts.includeEmpty
    this.root = this.parent ? this.parent.root : this.path
    this.follow = !!opts.follow
    this.result = this.parent ? this.parent.result : new Set()
    this.entries = null
    this.sawError = false
  }

  sort (a, b) {
    return a.localeCompare(b)
  }

  emit (ev, data) {
    let ret = false
    if (!(this.sawError && ev === 'error')) {
      if (ev === 'error')
        this.sawError = true
      else if (ev === 'done' && !this.parent) {
        data = Array.from(data)
          .map(e => /^@/.test(e) ? `./${e}` : e).sort(this.sort)
        this.result = data
      }

      if (ev === 'error' && this.parent)
        ret = this.parent.emit('error', data)
      else
        ret = super.emit(ev, data)
    }
    return ret
  }

  start () {
    fs.readdir(this.path, (er, entries) =>
      er ? this.emit('error', er) : this.onReaddir(entries))
    return this
  }

  isIgnoreFile (e) {
    return e !== "." &&
      e !== ".." &&
      -1 !== this.ignoreFiles.indexOf(e)
  }

  onReaddir (entries) {
    this.entries = entries
    if (entries.length === 0) {
      if (this.includeEmpty)
        this.result.add(this.path.substr(this.root.length + 1))
      this.emit('done', this.result)
    } else {
      const hasIg = this.entries.some(e =>
        this.isIgnoreFile(e))

      if (hasIg)
        this.addIgnoreFiles()
      else
        this.filterEntries()
    }
  }

  addIgnoreFiles () {
    const newIg = this.entries
      .filter(e => this.isIgnoreFile(e))

    let igCount = newIg.length
    const then = _ => {
      if (--igCount === 0)
        this.filterEntries()
    }

    newIg.forEach(e => this.addIgnoreFile(e, then))
  }

  addIgnoreFile (file, then) {
    const ig = path.resolve(this.path, file)
    fs.readFile(ig, 'utf8', (er, data) =>
      er ? this.emit('error', er) : this.onReadIgnoreFile(file, data, then))
  }

  onReadIgnoreFile (file, data, then) {
    const mmopt = {
      matchBase: true,
      dot: true,
      flipNegate: true,
      nocase: true
    }
    const rules = data.split(/\r?\n/)
      .filter(line => !/^#|^$/.test(line.trim()))
      .map(r => new Minimatch(r, mmopt))

    this.ignoreRules[file] = rules

    then()
  }

  filterEntries () {
    // at this point we either have ignore rules, or just inheriting
    // this exclusion is at the point where we know the list of
    // entries in the dir, but don't know what they are.  since
    // some of them *might* be directories, we have to run the
    // match in dir-mode as well, so that we'll pick up partials
    // of files that will be included later.  Anything included
    // at this point will be checked again later once we know
    // what it is.
    const filtered = this.entries.map(entry => {
      // at this point, we don't know if it's a dir or not.
      const passFile = this.filterEntry(entry)
      const passDir = this.filterEntry(entry, true)
      return (passFile || passDir) ? [entry, passFile, passDir] : false
    }).filter(e => e)

    // now we stat them all
    // if it's a dir, and passes as a dir, then recurse
    // if it's not a dir, but passes as a file, add to set
    let entryCount = filtered.length
    if (entryCount === 0) {
      this.emit('done', this.result)
    } else {
      const then = _ => {
        if (-- entryCount === 0)
          this.emit('done', this.result)
      }
      filtered.forEach(filt => {
        const entry = filt[0]
        const file = filt[1]
        const dir = filt[2]
        this.stat(entry, file, dir, then)
      })
    }
  }

  onstat (st, entry, file, dir, then) {
    const abs = this.path + '/' + entry
    if (!st.isDirectory()) {
      if (file)
        this.result.add(abs.substr(this.root.length + 1))
      then()
    } else {
      // is a directory
      if (dir)
        this.walker(entry, then)
      else
        then()
    }
  }

  stat (entry, file, dir, then) {
    const abs = this.path + '/' + entry
    fs[this.follow ? 'stat' : 'lstat'](abs, (er, st) => {
      if (er)
        this.emit('error', er)
      else
        this.onstat(st, entry, file, dir, then)
    })
  }

  walkerOpt (entry) {
    return {
      path: this.path + '/' + entry,
      parent: this,
      ignoreFiles: this.ignoreFiles,
      follow: this.follow,
      includeEmpty: this.includeEmpty
    }
  }

  walker (entry, then) {
    new Walker(this.walkerOpt(entry)).on('done', then).start()
  }

  filterEntry (entry, partial) {
    let included = true

    // this = /a/b/c
    // entry = d
    // parent /a/b sees c/d
    if (this.parent && this.parent.filterEntry) {
      var pt = this.basename + "/" + entry
      included = this.parent.filterEntry(pt, partial)
    }

    this.ignoreFiles.forEach(f => {
      if (this.ignoreRules[f]) {
        this.ignoreRules[f].forEach(rule => {
          // negation means inclusion
          // so if it's negated, and already included, no need to check
          // likewise if it's neither negated nor included
          if (rule.negate !== included) {
            // first, match against /foo/bar
            // then, against foo/bar
            // then, in the case of partials, match with a /
            const match = rule.match('/' + entry) ||
              rule.match(entry) ||
              (!!partial && (
                rule.match('/' + entry + '/') ||
                rule.match(entry + '/'))) ||
              (!!partial && rule.negate && (
                rule.match('/' + entry, true) ||
                rule.match(entry, true)))

            if (match)
              included = rule.negate
          }
        })
      }
    })

    return included
  }
}

class WalkerSync extends Walker {
  constructor (opt) {
    super(opt)
  }

  start () {
    this.onReaddir(fs.readdirSync(this.path))
    return this
  }

  addIgnoreFile (file, then) {
    const ig = path.resolve(this.path, file)
    this.onReadIgnoreFile(file, fs.readFileSync(ig, 'utf8'), then)
  }

  stat (entry, file, dir, then) {
    const abs = this.path + '/' + entry
    const st = fs[this.follow ? 'statSync' : 'lstatSync'](abs)
    this.onstat(st, entry, file, dir, then)
  }

  walker (entry, then) {
    new WalkerSync(this.walkerOpt(entry)).start()
    then()
  }
}

const walk = (options, callback) => {
  const p = new Promise((resolve, reject) => {
    new Walker(options).on('done', resolve).on('error', reject).start()
  })
  return callback ? p.then(res => callback(null, res), callback) : p
}

const walkSync = options => {
  return new WalkerSync(options).start().result
}

module.exports = walk
walk.sync = walkSync
walk.Walker = Walker
walk.WalkerSync = WalkerSync


/***/ }),

/***/ "./node_modules/minipass/index.js":
/*!****************************************!*\
  !*** ./node_modules/minipass/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const EE = __webpack_require__(/*! events */ "events")
const Yallist = __webpack_require__(/*! yallist */ "yallist")
const SD = __webpack_require__(/*! string_decoder */ "string_decoder").StringDecoder

const EOF = Symbol('EOF')
const MAYBE_EMIT_END = Symbol('maybeEmitEnd')
const EMITTED_END = Symbol('emittedEnd')
const EMITTING_END = Symbol('emittingEnd')
const CLOSED = Symbol('closed')
const READ = Symbol('read')
const FLUSH = Symbol('flush')
const FLUSHCHUNK = Symbol('flushChunk')
const ENCODING = Symbol('encoding')
const DECODER = Symbol('decoder')
const FLOWING = Symbol('flowing')
const PAUSED = Symbol('paused')
const RESUME = Symbol('resume')
const BUFFERLENGTH = Symbol('bufferLength')
const BUFFERPUSH = Symbol('bufferPush')
const BUFFERSHIFT = Symbol('bufferShift')
const OBJECTMODE = Symbol('objectMode')
const DESTROYED = Symbol('destroyed')

// TODO remove when Node v8 support drops
const doIter = global._MP_NO_ITERATOR_SYMBOLS_  !== '1'
const ASYNCITERATOR = doIter && Symbol.asyncIterator
  || Symbol('asyncIterator not implemented')
const ITERATOR = doIter && Symbol.iterator
  || Symbol('iterator not implemented')

// Buffer in node 4.x < 4.5.0 doesn't have working Buffer.from
// or Buffer.alloc, and Buffer in node 10 deprecated the ctor.
// .M, this is fine .\^/M..
const B = Buffer.alloc ? Buffer
  : /* istanbul ignore next */ __webpack_require__(/*! safe-buffer */ "safe-buffer").Buffer

// events that mean 'the stream is over'
// these are treated specially, and re-emitted
// if they are listened for after emitting.
const isEndish = ev =>
  ev === 'end' ||
  ev === 'finish' ||
  ev === 'prefinish'

const isArrayBuffer = b => b instanceof ArrayBuffer ||
  typeof b === 'object' &&
  b.constructor &&
  b.constructor.name === 'ArrayBuffer' &&
  b.byteLength >= 0

const isArrayBufferView = b => !B.isBuffer(b) && ArrayBuffer.isView(b)

module.exports = class Minipass extends EE {
  constructor (options) {
    super()
    this[FLOWING] = false
    // whether we're explicitly paused
    this[PAUSED] = false
    this.pipes = new Yallist()
    this.buffer = new Yallist()
    this[OBJECTMODE] = options && options.objectMode || false
    if (this[OBJECTMODE])
      this[ENCODING] = null
    else
      this[ENCODING] = options && options.encoding || null
    if (this[ENCODING] === 'buffer')
      this[ENCODING] = null
    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null
    this[EOF] = false
    this[EMITTED_END] = false
    this[EMITTING_END] = false
    this[CLOSED] = false
    this.writable = true
    this.readable = true
    this[BUFFERLENGTH] = 0
    this[DESTROYED] = false
  }

  get bufferLength () { return this[BUFFERLENGTH] }

  get encoding () { return this[ENCODING] }
  set encoding (enc) {
    if (this[OBJECTMODE])
      throw new Error('cannot set encoding in objectMode')

    if (this[ENCODING] && enc !== this[ENCODING] &&
        (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
      throw new Error('cannot change encoding')

    if (this[ENCODING] !== enc) {
      this[DECODER] = enc ? new SD(enc) : null
      if (this.buffer.length)
        this.buffer = this.buffer.map(chunk => this[DECODER].write(chunk))
    }

    this[ENCODING] = enc
  }

  setEncoding (enc) {
    this.encoding = enc
  }

  get objectMode () { return this[OBJECTMODE] }
  set objectMode ( ) { this[OBJECTMODE] = this[OBJECTMODE] || !!  }

  write (chunk, encoding, cb) {
    if (this[EOF])
      throw new Error('write after end')

    if (this[DESTROYED]) {
      this.emit('error', Object.assign(
        new Error('Cannot call write after a stream was destroyed'),
        { code: 'ERR_STREAM_DESTROYED' }
      ))
      return true
    }

    if (typeof encoding === 'function')
      cb = encoding, encoding = 'utf8'

    if (!encoding)
      encoding = 'utf8'

    // convert array buffers and typed array views into buffers
    // at some point in the future, we may want to do the opposite!
    // leave strings and buffers as-is
    // anything else switches us into object mode
    if (!this[OBJECTMODE] && !B.isBuffer(chunk)) {
      if (isArrayBufferView(chunk))
        chunk = B.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)
      else if (isArrayBuffer(chunk))
        chunk = B.from(chunk)
      else if (typeof chunk !== 'string')
        // use the setter so we throw if we have encoding set
        this.objectMode = true
    }

    // this ensures at this point that the chunk is a buffer or string
    // don't buffer it up or send it to the decoder
    if (!this.objectMode && !chunk.length) {
      const ret = this.flowing
      if (this[BUFFERLENGTH] !== 0)
        this.emit('readable')
      if (cb)
        cb()
      return ret
    }

    // fast-path writing strings of same encoding to a stream with
    // an empty buffer, skipping the buffer/decoder dance
    if (typeof chunk === 'string' && !this[OBJECTMODE] &&
        // unless it is a string already ready for us to use
        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
      chunk = B.from(chunk, encoding)
    }

    if (B.isBuffer(chunk) && this[ENCODING])
      chunk = this[DECODER].write(chunk)

    try {
      return this.flowing
        ? (this.emit('data', chunk), this.flowing)
        : (this[BUFFERPUSH](chunk), false)
    } finally {
      if (this[BUFFERLENGTH] !== 0)
        this.emit('readable')
      if (cb)
        cb()
    }
  }

  read (n) {
    if (this[DESTROYED])
      return null

    try {
      if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH])
        return null

      if (this[OBJECTMODE])
        n = null

      if (this.buffer.length > 1 && !this[OBJECTMODE]) {
        if (this.encoding)
          this.buffer = new Yallist([
            Array.from(this.buffer).join('')
          ])
        else
          this.buffer = new Yallist([
            B.concat(Array.from(this.buffer), this[BUFFERLENGTH])
          ])
      }

      return this[READ](n || null, this.buffer.head.value)
    } finally {
      this[MAYBE_EMIT_END]()
    }
  }

  [READ] (n, chunk) {
    if (n === chunk.length || n === null)
      this[BUFFERSHIFT]()
    else {
      this.buffer.head.value = chunk.slice(n)
      chunk = chunk.slice(0, n)
      this[BUFFERLENGTH] -= n
    }

    this.emit('data', chunk)

    if (!this.buffer.length && !this[EOF])
      this.emit('drain')

    return chunk
  }

  end (chunk, encoding, cb) {
    if (typeof chunk === 'function')
      cb = chunk, chunk = null
    if (typeof encoding === 'function')
      cb = encoding, encoding = 'utf8'
    if (chunk)
      this.write(chunk, encoding)
    if (cb)
      this.once('end', cb)
    this[EOF] = true
    this.writable = false

    // if we haven't written anything, then go ahead and emit,
    // even if we're not reading.
    // we'll re-emit if a new 'end' listener is added anyway.
    // This makes MP more suitable to write-only use cases.
    if (this.flowing || !this[PAUSED])
      this[MAYBE_EMIT_END]()
    return this
  }

  // don't let the internal resume be overwritten
  [RESUME] () {
    if (this[DESTROYED])
      return

    this[PAUSED] = false
    this[FLOWING] = true
    this.emit('resume')
    if (this.buffer.length)
      this[FLUSH]()
    else if (this[EOF])
      this[MAYBE_EMIT_END]()
    else
      this.emit('drain')
  }

  resume () {
    return this[RESUME]()
  }

  pause () {
    this[FLOWING] = false
    this[PAUSED] = true
  }

  get destroyed () {
    return this[DESTROYED]
  }

  get flowing () {
    return this[FLOWING]
  }

  get paused () {
    return this[PAUSED]
  }

  [BUFFERPUSH] (chunk) {
    if (this[OBJECTMODE])
      this[BUFFERLENGTH] += 1
    else
      this[BUFFERLENGTH] += chunk.length
    return this.buffer.push(chunk)
  }

  [BUFFERSHIFT] () {
    if (this.buffer.length) {
      if (this[OBJECTMODE])
        this[BUFFERLENGTH] -= 1
      else
        this[BUFFERLENGTH] -= this.buffer.head.value.length
    }
    return this.buffer.shift()
  }

  [FLUSH] () {
    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()))

    if (!this.buffer.length && !this[EOF])
      this.emit('drain')
  }

  [FLUSHCHUNK] (chunk) {
    return chunk ? (this.emit('data', chunk), this.flowing) : false
  }

  pipe (dest, opts) {
    if (this[DESTROYED])
      return

    const ended = this[EMITTED_END]
    opts = opts || {}
    if (dest === process.stdout || dest === process.stderr)
      opts.end = false
    else
      opts.end = opts.end !== false

    const p = { dest: dest, opts: opts, ondrain: _ => this[RESUME]() }
    this.pipes.push(p)

    dest.on('drain', p.ondrain)
    this[RESUME]()
    // piping an ended stream ends immediately
    if (ended && p.opts.end)
      p.dest.end()
    return dest
  }

  addListener (ev, fn) {
    return this.on(ev, fn)
  }

  on (ev, fn) {
    try {
      return super.on(ev, fn)
    } finally {
      if (ev === 'data' && !this.pipes.length && !this.flowing)
        this[RESUME]()
      else if (isEndish(ev) && this[EMITTED_END]) {
        super.emit(ev)
        this.removeAllListeners(ev)
      }
    }
  }

  get emittedEnd () {
    return this[EMITTED_END]
  }

  [MAYBE_EMIT_END] () {
    if (!this[EMITTING_END] &&
        !this[EMITTED_END] &&
        !this[DESTROYED] &&
        this.buffer.length === 0 &&
        this[EOF]) {
      this[EMITTING_END] = true
      this.emit('end')
      this.emit('prefinish')
      this.emit('finish')
      if (this[CLOSED])
        this.emit('close')
      this[EMITTING_END] = false
    }
  }

  emit (ev, data) {
    // error and close are only events allowed after calling destroy()
    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED])
      return
    else if (ev === 'data') {
      if (!data)
        return

      if (this.pipes.length)
        this.pipes.forEach(p =>
          p.dest.write(data) === false && this.pause())
    } else if (ev === 'end') {
      // only actual end gets this treatment
      if (this[EMITTED_END] === true)
        return

      this[EMITTED_END] = true
      this.readable = false

      if (this[DECODER]) {
        data = this[DECODER].end()
        if (data) {
          this.pipes.forEach(p => p.dest.write(data))
          super.emit('data', data)
        }
      }

      this.pipes.forEach(p => {
        p.dest.removeListener('drain', p.ondrain)
        if (p.opts.end)
          p.dest.end()
      })
    } else if (ev === 'close') {
      this[CLOSED] = true
      // don't emit close before 'end' and 'finish'
      if (!this[EMITTED_END] && !this[DESTROYED])
        return
    }

    // TODO: replace with a spread operator when Node v4 support drops
    const args = new Array(arguments.length)
    args[0] = ev
    args[1] = data
    if (arguments.length > 2) {
      for (let i = 2; i < arguments.length; i++) {
        args[i] = arguments[i]
      }
    }

    try {
      return super.emit.apply(this, args)
    } finally {
      if (!isEndish(ev))
        this[MAYBE_EMIT_END]()
      else
        this.removeAllListeners(ev)
    }
  }

  // const all = await stream.collect()
  collect () {
    const buf = []
    buf.dataLength = 0
    this.on('data', c => {
      buf.push(c)
      buf.dataLength += c.length
    })
    return this.promise().then(() => buf)
  }

  // const data = await stream.concat()
  concat () {
    return this[OBJECTMODE]
      ? Promise.reject(new Error('cannot concat in objectMode'))
      : this.collect().then(buf =>
          this[OBJECTMODE]
            ? Promise.reject(new Error('cannot concat in objectMode'))
            : this[ENCODING] ? buf.join('') : B.concat(buf, buf.dataLength))
  }

  // stream.promise().then(() => done, er => emitted error)
  promise () {
    return new Promise((resolve, reject) => {
      this.on(DESTROYED, () => reject(new Error('stream destroyed')))
      this.on('end', () => resolve())
      this.on('error', er => reject(er))
    })
  }

  // for await (let chunk of stream)
  [ASYNCITERATOR] () {
    const next = () => {
      const res = this.read()
      if (res !== null)
        return Promise.resolve({ done: false, value: res })

      if (this[EOF])
        return Promise.resolve({ done: true })

      let resolve = null
      let reject = null
      const onerr = er => {
        this.removeListener('data', ondata)
        this.removeListener('end', onend)
        reject(er)
      }
      const ondata = value => {
        this.removeListener('error', onerr)
        this.removeListener('end', onend)
        this.pause()
        resolve({ value: value, done: !!this[EOF] })
      }
      const onend = () => {
        this.removeListener('error', onerr)
        this.removeListener('data', ondata)
        resolve({ done: true })
      }
      const ondestroy = () => onerr(new Error('stream destroyed'))
      return new Promise((res, rej) => {
        reject = rej
        resolve = res
        this.once(DESTROYED, ondestroy)
        this.once('error', onerr)
        this.once('end', onend)
        this.once('data', ondata)
      })
    }

    return { next }
  }

  // for (let chunk of stream)
  [ITERATOR] () {
    const next = () => {
      const value = this.read()
      const done = value === null
      return { value, done }
    }
    return { next }
  }

  destroy (er) {
    if (this[DESTROYED]) {
      if (er)
        this.emit('error', er)
      else
        this.emit(DESTROYED)
      return this
    }

    this[DESTROYED] = true

    // throw away all buffered data, it's never coming out
    this.buffer = new Yallist()
    this[BUFFERLENGTH] = 0

    if (typeof this.close === 'function' && !this[CLOSED])
      this.close()

    if (er)
      this.emit('error', er)
    else // if no error to emit, still reject pending promises
      this.emit(DESTROYED)

    return this
  }

  static isStream (s) {
    return !!s && (s instanceof Minipass || s instanceof EE && (
      typeof s.pipe === 'function' || // readable
      (typeof s.write === 'function' && typeof s.end === 'function') // writable
    ))
  }
}


/***/ }),

/***/ "./node_modules/minizlib/constants.js":
/*!********************************************!*\
  !*** ./node_modules/minizlib/constants.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Update with any zlib constants that are added or changed in the future.
// Node v6 didn't export this, so we just hard code the version and rely
// on all the other hard-coded values from zlib v4736.  When node v6
// support drops, we can just export the realZlibConstants object.
const realZlibConstants = __webpack_require__(/*! zlib */ "zlib").constants ||
  /* istanbul ignore next */ { ZLIB_VERNUM: 4736 }

module.exports = Object.freeze(Object.assign(Object.create(null), {
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  Z_VERSION_ERROR: -6,
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  DEFLATE: 1,
  INFLATE: 2,
  GZIP: 3,
  GUNZIP: 4,
  DEFLATERAW: 5,
  INFLATERAW: 6,
  UNZIP: 7,
  BROTLI_DECODE: 8,
  BROTLI_ENCODE: 9,
  Z_MIN_WINDOWBITS: 8,
  Z_MAX_WINDOWBITS: 15,
  Z_DEFAULT_WINDOWBITS: 15,
  Z_MIN_CHUNK: 64,
  Z_MAX_CHUNK: Infinity,
  Z_DEFAULT_CHUNK: 16384,
  Z_MIN_MEMLEVEL: 1,
  Z_MAX_MEMLEVEL: 9,
  Z_DEFAULT_MEMLEVEL: 8,
  Z_MIN_LEVEL: -1,
  Z_MAX_LEVEL: 9,
  Z_DEFAULT_LEVEL: -1,
  BROTLI_OPERATION_PROCESS: 0,
  BROTLI_OPERATION_FLUSH: 1,
  BROTLI_OPERATION_FINISH: 2,
  BROTLI_OPERATION_EMIT_METADATA: 3,
  BROTLI_MODE_GENERIC: 0,
  BROTLI_MODE_TEXT: 1,
  BROTLI_MODE_FONT: 2,
  BROTLI_DEFAULT_MODE: 0,
  BROTLI_MIN_QUALITY: 0,
  BROTLI_MAX_QUALITY: 11,
  BROTLI_DEFAULT_QUALITY: 11,
  BROTLI_MIN_WINDOW_BITS: 10,
  BROTLI_MAX_WINDOW_BITS: 24,
  BROTLI_LARGE_MAX_WINDOW_BITS: 30,
  BROTLI_DEFAULT_WINDOW: 22,
  BROTLI_MIN_INPUT_BLOCK_BITS: 16,
  BROTLI_MAX_INPUT_BLOCK_BITS: 24,
  BROTLI_PARAM_MODE: 0,
  BROTLI_PARAM_QUALITY: 1,
  BROTLI_PARAM_LGWIN: 2,
  BROTLI_PARAM_LGBLOCK: 3,
  BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
  BROTLI_PARAM_SIZE_HINT: 5,
  BROTLI_PARAM_LARGE_WINDOW: 6,
  BROTLI_PARAM_NPOSTFIX: 7,
  BROTLI_PARAM_NDIRECT: 8,
  BROTLI_DECODER_RESULT_ERROR: 0,
  BROTLI_DECODER_RESULT_SUCCESS: 1,
  BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
  BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
  BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
  BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
  BROTLI_DECODER_NO_ERROR: 0,
  BROTLI_DECODER_SUCCESS: 1,
  BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
  BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
  BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
  BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
  BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
  BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
  BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
  BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
  BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
  BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
  BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
  BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
  BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
  BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
  BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
  BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
  BROTLI_DECODER_ERROR_UNREACHABLE: -31,
}, realZlibConstants))


/***/ }),

/***/ "./node_modules/minizlib/index.js":
/*!****************************************!*\
  !*** ./node_modules/minizlib/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const assert = __webpack_require__(/*! assert */ "assert")
const Buffer = __webpack_require__(/*! buffer */ "buffer").Buffer
const realZlib = __webpack_require__(/*! zlib */ "zlib")

const constants = exports.constants = __webpack_require__(/*! ./constants.js */ "./node_modules/minizlib/constants.js")
const Minipass = __webpack_require__(/*! minipass */ "./node_modules/minipass/index.js")

const OriginalBufferConcat = Buffer.concat

class ZlibError extends Error {
  constructor (err) {
    super('zlib: ' + err.message)
    this.code = err.code
    this.errno = err.errno
    /* istanbul ignore if */
    if (!this.code)
      this.code = 'ZLIB_ERROR'

    this.message = 'zlib: ' + err.message
    Error.captureStackTrace(this, this.constructor)
  }

  get name () {
    return 'ZlibError'
  }
}

// the Zlib class they all inherit from
// This thing manages the queue of requests, and returns
// true or false if there is anything in the queue when
// you call the .write() method.
const _opts = Symbol('opts')
const _flushFlag = Symbol('flushFlag')
const _finishFlushFlag = Symbol('finishFlushFlag')
const _fullFlushFlag = Symbol('fullFlushFlag')
const _handle = Symbol('handle')
const _onError = Symbol('onError')
const _sawError = Symbol('sawError')
const _level = Symbol('level')
const _strategy = Symbol('strategy')
const _ended = Symbol('ended')
const _defaultFullFlush = Symbol('_defaultFullFlush')

class ZlibBase extends Minipass {
  constructor (opts, mode) {
    if (!opts || typeof opts !== 'object')
      throw new TypeError('invalid options for ZlibBase constructor')

    super(opts)
    this[_ended] = false
    this[_opts] = opts

    this[_flushFlag] = opts.flush
    this[_finishFlushFlag] = opts.finishFlush
    // this will throw if any options are invalid for the class selected
    try {
      this[_handle] = new realZlib[mode](opts)
    } catch (er) {
      // make sure that all errors get decorated properly
      throw new ZlibError(er)
    }

    this[_onError] = (err) => {
      this[_sawError] = true
      // there is no way to cleanly recover.
      // continuing only obscures problems.
      this.close()
      this.emit('error', err)
    }

    this[_handle].on('error', er => this[_onError](new ZlibError(er)))
    this.once('end', () => this.close)
  }

  close () {
    if (this[_handle]) {
      this[_handle].close()
      this[_handle] = null
      this.emit('close')
    }
  }

  reset () {
    if (!this[_sawError]) {
      assert(this[_handle], 'zlib binding closed')
      return this[_handle].reset()
    }
  }

  flush (flushFlag) {
    if (this.ended)
      return

    if (typeof flushFlag !== 'number')
      flushFlag = this[_fullFlushFlag]
    this.write(Object.assign(Buffer.alloc(0), { [_flushFlag]: flushFlag }))
  }

  end (chunk, encoding, cb) {
    if (chunk)
      this.write(chunk, encoding)
    this.flush(this[_finishFlushFlag])
    this[_ended] = true
    return super.end(null, null, cb)
  }

  get ended () {
    return this[_ended]
  }

  write (chunk, encoding, cb) {
    // process the chunk using the sync process
    // then super.write() all the outputted chunks
    if (typeof encoding === 'function')
      cb = encoding, encoding = 'utf8'

    if (typeof chunk === 'string')
      chunk = Buffer.from(chunk, encoding)

    if (this[_sawError])
      return
    assert(this[_handle], 'zlib binding closed')

    // _processChunk tries to .close() the native handle after it's done, so we
    // intercept that by temporarily making it a no-op.
    const nativeHandle = this[_handle]._handle
    const originalNativeClose = nativeHandle.close
    nativeHandle.close = () => {}
    const originalClose = this[_handle].close
    this[_handle].close = () => {}
    // It also calls `Buffer.concat()` at the end, which may be convenient
    // for some, but which we are not interested in as it slows us down.
    Buffer.concat = (args) => args
    let result
    try {
      const flushFlag = typeof chunk[_flushFlag] === 'number'
        ? chunk[_flushFlag] : this[_flushFlag]
      result = this[_handle]._processChunk(chunk, flushFlag)
      // if we don't throw, reset it back how it was
      Buffer.concat = OriginalBufferConcat
    } catch (err) {
      // or if we do, put Buffer.concat() back before we emit error
      // Error events call into user code, which may call Buffer.concat()
      Buffer.concat = OriginalBufferConcat
      this[_onError](new ZlibError(err))
    } finally {
      if (this[_handle]) {
        // Core zlib resets `_handle` to null after attempting to close the
        // native handle. Our no-op handler prevented actual closure, but we
        // need to restore the `._handle` property.
        this[_handle]._handle = nativeHandle
        nativeHandle.close = originalNativeClose
        this[_handle].close = originalClose
        // `_processChunk()` adds an 'error' listener. If we don't remove it
        // after each call, these handlers start piling up.
        this[_handle].removeAllListeners('error')
      }
    }

    let writeReturn
    if (result) {
      if (Array.isArray(result) && result.length > 0) {
        // The first buffer is always `handle._outBuffer`, which would be
        // re-used for later invocations; so, we always have to copy that one.
        writeReturn = super.write(Buffer.from(result[0]))
        for (let i = 1; i < result.length; i++) {
          writeReturn = super.write(result[i])
        }
      } else {
        writeReturn = super.write(Buffer.from(result))
      }
    }

    if (cb)
      cb()
    return writeReturn
  }
}

class Zlib extends ZlibBase {
  constructor (opts, mode) {
    opts = opts || {}

    opts.flush = opts.flush || constants.Z_NO_FLUSH
    opts.finishFlush = opts.finishFlush || constants.Z_FINISH
    super(opts, mode)

    this[_fullFlushFlag] = constants.Z_FULL_FLUSH
    this[_level] = opts.level
    this[_strategy] = opts.strategy
  }

  params (level, strategy) {
    if (this[_sawError])
      return

    if (!this[_handle])
      throw new Error('cannot switch params when binding is closed')

    // no way to test this without also not supporting params at all
    /* istanbul ignore if */
    if (!this[_handle].params)
      throw new Error('not supported in this implementation')

    if (this[_level] !== level || this[_strategy] !== strategy) {
      this.flush(constants.Z_SYNC_FLUSH)
      assert(this[_handle], 'zlib binding closed')
      // .params() calls .flush(), but the latter is always async in the
      // core zlib. We override .flush() temporarily to intercept that and
      // flush synchronously.
      const origFlush = this[_handle].flush
      this[_handle].flush = (flushFlag, cb) => {
        this.flush(flushFlag)
        cb()
      }
      try {
        this[_handle].params(level, strategy)
      } finally {
        this[_handle].flush = origFlush
      }
      /* istanbul ignore else */
      if (this[_handle]) {
        this[_level] = level
        this[_strategy] = strategy
      }
    }
  }
}

// minimal 2-byte header
class Deflate extends Zlib {
  constructor (opts) {
    super(opts, 'Deflate')
  }
}

class Inflate extends Zlib {
  constructor (opts) {
    super(opts, 'Inflate')
  }
}

// gzip - bigger header, same deflate compression
class Gzip extends Zlib {
  constructor (opts) {
    super(opts, 'Gzip')
  }
}

class Gunzip extends Zlib {
  constructor (opts) {
    super(opts, 'Gunzip')
  }
}

// raw - no header
class DeflateRaw extends Zlib {
  constructor (opts) {
    super(opts, 'DeflateRaw')
  }
}

class InflateRaw extends Zlib {
  constructor (opts) {
    super(opts, 'InflateRaw')
  }
}

// auto-detect header.
class Unzip extends Zlib {
  constructor (opts) {
    super(opts, 'Unzip')
  }
}

class Brotli extends ZlibBase {
  constructor (opts, mode) {
    opts = opts || {}

    opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS
    opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH

    super(opts, mode)

    this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH
  }
}

class BrotliCompress extends Brotli {
  constructor (opts) {
    super(opts, 'BrotliCompress')
  }
}

class BrotliDecompress extends Brotli {
  constructor (opts) {
    super(opts, 'BrotliDecompress')
  }
}

exports.Deflate = Deflate
exports.Inflate = Inflate
exports.Gzip = Gzip
exports.Gunzip = Gunzip
exports.DeflateRaw = DeflateRaw
exports.InflateRaw = InflateRaw
exports.Unzip = Unzip
/* istanbul ignore else */
if (typeof realZlib.BrotliCompress === 'function') {
  exports.BrotliCompress = BrotliCompress
  exports.BrotliDecompress = BrotliDecompress
} else {
  exports.BrotliCompress = exports.BrotliDecompress = class {
    constructor () {
      throw new Error('Brotli is not supported in this version of Node.js')
    }
  }
}


/***/ }),

/***/ "./node_modules/needle/lib/auth.js":
/*!*****************************************!*\
  !*** ./node_modules/needle/lib/auth.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var createHash = __webpack_require__(/*! crypto */ "crypto").createHash;

function get_header(header, credentials, opts) {
  var type = header.split(' ')[0],
      user = credentials[0],
      pass = credentials[1];

  if (type == 'Digest') {
    return digest.generate(header, user, pass, opts.method, opts.path);
  } else if (type == 'Basic') {
    return basic(user, pass);
  }
}

////////////////////
// basic

function md5(string) {
  return createHash('md5').update(string).digest('hex');
}

function basic(user, pass) {
  var str  = typeof pass == 'undefined' ? user : [user, pass].join(':');
  return 'Basic ' + Buffer.from(str).toString('base64');
}

////////////////////
// digest
// logic inspired from https://github.com/simme/node-http-digest-client

var digest = {};

digest.parse_header = function(header) {
  var challenge = {},
      matches   = header.match(/([a-z0-9_-]+)="?([a-z0-9=\/\.@\s-]+)"?/gi);

  for (var i = 0, l = matches.length; i < l; i++) {
    var parts = matches[i].split('='),
        key   = parts.shift(),
        val   = parts.join('=').replace(/^"/, '').replace(/"$/, '');

    challenge[key] = val;
  }

  return challenge;
}

digest.update_nc = function(nc) {
  var max = 99999999;
  nc++;

  if (nc > max)
    nc = 1;

  var padding = new Array(8).join('0') + '';
  nc = nc + '';
  return padding.substr(0, 8 - nc.length) + nc;
}

digest.generate = function(header, user, pass, method, path) {

  var nc        = 1,
      cnonce    = null,
      challenge = digest.parse_header(header);

  var ha1  = md5(user + ':' + challenge.realm + ':' + pass),
      ha2  = md5(method.toUpperCase() + ':' + path),
      resp = [ha1, challenge.nonce];

  if (typeof challenge.qop === 'string') {
    cnonce = md5(Math.random().toString(36)).substr(0, 8);
    nc     = digest.update_nc(nc);
    resp   = resp.concat(nc, cnonce);
    resp   = resp.concat(challenge.qop, ha2);
  } else {
    resp   = resp.concat(ha2);
  }


  var params = {
    uri      : path,
    realm    : challenge.realm,
    nonce    : challenge.nonce,
    username : user,
    response : md5(resp.join(':'))
  }

  if (challenge.qop) {
    params.qop = challenge.qop;
  }

  if (challenge.opaque) {
    params.opaque = challenge.opaque;
  }

  if (cnonce) {
    params.nc = nc;
    params.cnonce = cnonce;
  }

  header = []
  for (var k in params)
    header.push(k + '="' + params[k] + '"')

  return 'Digest ' + header.join(', ');
}

module.exports = {
  header : get_header,
  basic  : basic,
  digest : digest.generate
}


/***/ }),

/***/ "./node_modules/needle/lib/cookies.js":
/*!********************************************!*\
  !*** ./node_modules/needle/lib/cookies.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


//  Simple cookie handling implementation based on the standard RFC 6265.
//
//  This module just has two functionalities:
//    - Parse a set-cookie-header as a key value object
//    - Write a cookie-string from a key value object
//
//  All cookie attributes are ignored.

var unescape = __webpack_require__(/*! querystring */ "querystring").unescape;

var COOKIE_PAIR        = /^([^=\s]+)\s*=\s*("?)\s*(.*)\s*\2\s*$/;
var EXCLUDED_CHARS     = /[\x00-\x1F\x7F\x3B\x3B\s\"\,\\"%]/g;
var TRAILING_SEMICOLON = /\x3B+$/;
var SEP_SEMICOLON      = /\s*\x3B\s*/;

// i know these should be 'const', but I'd like to keep
// supporting earlier node.js versions as long as I can. :)

var KEY_INDEX   = 1; // index of key from COOKIE_PAIR match
var VALUE_INDEX = 3; // index of value from COOKIE_PAIR match

// Returns a copy str trimmed and without trainling semicolon.
function cleanCookieString(str) {
  return str.trim().replace(/\x3B+$/, '');
}

function getFirstPair(str) {
  var index = str.indexOf('\x3B');
  return index === -1 ? str : str.substr(0, index);
}

// Returns a encoded copy of str based on RFC6265 S4.1.1.
function encodeCookieComponent(str) {
  return str.toString().replace(EXCLUDED_CHARS, encodeURIComponent);
}

// Parses a set-cookie-string based on the standard defined in RFC6265 S4.1.1.
function parseSetCookieString(str) {
  str = cleanCookieString(str);
  str = getFirstPair(str);

  var res = COOKIE_PAIR.exec(str);
  if (!res || !res[VALUE_INDEX]) return null;

  return {
    name  : unescape(res[KEY_INDEX]),
    value : unescape(res[VALUE_INDEX])
  };
}

// Parses a set-cookie-header and returns a key/value object.
// Each key represents the name of a cookie.
function parseSetCookieHeader(header) {
  if (!header) return {};
  header = Array.isArray(header) ? header : [header];

  return header.reduce(function(res, str) {
    var cookie = parseSetCookieString(str);
    if (cookie) res[cookie.name] = cookie.value;
    return res;
  }, {});
}

// Writes a set-cookie-string based on the standard definded in RFC6265 S4.1.1.
function writeCookieString(obj) {
  return Object.keys(obj).reduce(function(str, name) {
    var encodedName  = encodeCookieComponent(name);
    var encodedValue = encodeCookieComponent(obj[name]);
    str += (str ? '; ' : '') + encodedName + '=' + encodedValue;
    return str;
  }, '');
}

// returns a key/val object from an array of cookie strings
exports.read = parseSetCookieHeader;

// writes a cookie string header
exports.write = writeCookieString;


/***/ }),

/***/ "./node_modules/needle/lib/decoder.js":
/*!********************************************!*\
  !*** ./node_modules/needle/lib/decoder.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var iconv,
    inherits  = __webpack_require__(/*! util */ "util").inherits,
    stream    = __webpack_require__(/*! stream */ "stream");

var regex = /(?:charset|encoding)\s*=\s*['"]? *([\w\-]+)/i;

inherits(StreamDecoder, stream.Transform);

function StreamDecoder(charset) {
  if (!(this instanceof StreamDecoder))
    return new StreamDecoder(charset);

  stream.Transform.call(this, charset);
  this.charset = charset;
  this.parsed_chunk = false;
}

StreamDecoder.prototype._transform = function(chunk, encoding, done) {
  var res, found;

  // try get charset from chunk, just once
  if (this.charset == 'utf8' && !this.parsed_chunk) {
    this.parsed_chunk = true;

    var matches = regex.exec(chunk.toString());
    if (matches) {
      found = matches[1].toLowerCase();
      this.charset = found == 'utf-8' ? 'utf8' : found;
    }
  }

  try {
    res = iconv.decode(chunk, this.charset);
  } catch(e) { // something went wrong, just return original chunk
    res = chunk;
  }

  this.push(res);
  done();
}

module.exports = function(charset) {
  try {
    if (!iconv) iconv = __webpack_require__(/*! iconv-lite */ "iconv-lite");
  } catch(e) {
    /* iconv not found */
  }

  if (iconv)
    return new StreamDecoder(charset);
  else
    return new stream.PassThrough;
}


/***/ }),

/***/ "./node_modules/needle/lib/multipart.js":
/*!**********************************************!*\
  !*** ./node_modules/needle/lib/multipart.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var readFile = __webpack_require__(/*! fs */ "fs").readFile,
    basename = __webpack_require__(/*! path */ "path").basename;

exports.build = function(data, boundary, callback) {

  if (typeof data != 'object' || typeof data.pipe == 'function')
    return callback(new Error('Multipart builder expects data as key/val object.'));

  var body   = '',
      object = flatten(data),
      count  = Object.keys(object).length;

  if (count === 0)
    return callback(new Error('Empty multipart body. Invalid data.'))

  function done(err, section) {
    if (err) return callback(err);
    if (section) body += section;
    --count || callback(null, body + '--' + boundary + '--');
  };

  for (var key in object) {
    var value = object[key];
    if (value === null || typeof value == 'undefined') {
      done();
    } else if (Buffer.isBuffer(value)) {
      var part = { buffer: value, content_type: 'application/octet-stream' };
      generate_part(key, part, boundary, done);
    } else {
      var part = (value.buffer || value.file || value.content_type) ? value : { value: value };
      generate_part(key, part, boundary, done);
    }
  }

}

function generate_part(name, part, boundary, callback) {

  var return_part = '--' + boundary + '\r\n';
  return_part += 'Content-Disposition: form-data; name="' + name + '"';

  function append(data, filename) {

    if (data) {
      var binary = part.content_type.indexOf('text') == -1;
      return_part += '; filename="' + encodeURIComponent(filename) + '"\r\n';
      if (binary) return_part += 'Content-Transfer-Encoding: binary\r\n';
      return_part += 'Content-Type: ' + part.content_type + '\r\n\r\n';
      return_part += binary ? data.toString('binary') : data.toString('utf8');
    }

    callback(null, return_part + '\r\n');
  };

  if ((part.file || part.buffer) && part.content_type) {

    var filename = part.filename ? part.filename : part.file ? basename(part.file) : name;
    if (part.buffer) return append(part.buffer, filename);

    readFile(part.file, function(err, data) {
      if (err) return callback(err);
      append(data, filename);
    });

  } else {

    if (typeof part.value == 'object')
      return callback(new Error('Object received for ' + name + ', expected string.'))

    if (part.content_type) {
      return_part += '\r\n';
      return_part += 'Content-Type: ' + part.content_type;
    }

    return_part += '\r\n\r\n';
    return_part += Buffer.from(String(part.value), 'utf8').toString('binary');
    append();

  }

}

// flattens nested objects for multipart body
function flatten(object, into, prefix) {
  into = into || {};

  for(var key in object) {
    var prefix_key = prefix ? prefix + '[' + key + ']' : key;
    var prop = object[key];

    if (prop && typeof prop === 'object' && !(prop.buffer || prop.file || prop.content_type))
      flatten(prop, into, prefix_key)
    else
      into[prefix_key] = prop;
  }

  return into;
}


/***/ }),

/***/ "./node_modules/needle/lib/needle.js":
/*!*******************************************!*\
  !*** ./node_modules/needle/lib/needle.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//////////////////////////////////////////
// Needle -- HTTP Client for Node.js
// Written by Toms Pollak <tomas@forkhq.com>
// (c) 2012-2020 - Fork Ltd.
// MIT Licensed
//////////////////////////////////////////

var fs          = __webpack_require__(/*! fs */ "fs"),
    http        = __webpack_require__(/*! http */ "http"),
    https       = __webpack_require__(/*! https */ "https"),
    url         = __webpack_require__(/*! url */ "url"),
    stream      = __webpack_require__(/*! stream */ "stream"),
    debug       = __webpack_require__(/*! debug */ "debug")('needle'),
    stringify   = __webpack_require__(/*! ./querystring */ "./node_modules/needle/lib/querystring.js").build,
    multipart   = __webpack_require__(/*! ./multipart */ "./node_modules/needle/lib/multipart.js"),
    auth        = __webpack_require__(/*! ./auth */ "./node_modules/needle/lib/auth.js"),
    cookies     = __webpack_require__(/*! ./cookies */ "./node_modules/needle/lib/cookies.js"),
    parsers     = __webpack_require__(/*! ./parsers */ "./node_modules/needle/lib/parsers.js"),
    decoder     = __webpack_require__(/*! ./decoder */ "./node_modules/needle/lib/decoder.js");

//////////////////////////////////////////
// variabilia

var version     = __webpack_require__(/*! ../package.json */ "./node_modules/needle/package.json").version;

var user_agent  = 'Needle/' + version;
user_agent     += ' (Node.js ' + process.version + '; ' + process.platform + ' ' + process.arch + ')';

var tls_options = 'agent pfx key passphrase cert ca ciphers rejectUnauthorized secureProtocol checkServerIdentity family';

// older versions of node (< 0.11.4) prevent the runtime from exiting
// because of connections in keep-alive state. so if this is the case
// we'll default new requests to set a Connection: close header.
var close_by_default = !http.Agent || http.Agent.defaultMaxSockets != Infinity;

// see if we have Object.assign. otherwise fall back to util._extend
var extend = Object.assign ? Object.assign : __webpack_require__(/*! util */ "util")._extend;

// these are the status codes that Needle interprets as redirects.
var redirect_codes = [301, 302, 303, 307, 308];

//////////////////////////////////////////
// decompressors for gzip/deflate/br bodies

var decompressors = {};
var brotli_supported = false;

try {

  var zlib = __webpack_require__(/*! zlib */ "zlib");
  brotli_supported = typeof zlib.BrotliDecompress === 'function';
  decompressors['x-deflate'] = zlib.Inflate;
  decompressors['deflate']   = zlib.Inflate;
  decompressors['x-gzip']    = zlib.Gunzip;
  decompressors['gzip']      = zlib.Gunzip;
  if (brotli_supported) {
    decompressors['br']      = zlib.BrotliDecompress;
  }

  // Enable Z_SYNC_FLUSH to avoid Z_BUF_ERROR errors (Node PR #2595)
  var zlib_options = {
    flush: zlib.Z_SYNC_FLUSH,
    finishFlush: zlib.Z_SYNC_FLUSH
  }

} catch(e) { /* zlib not available */ }

//////////////////////////////////////////
// options and aliases

var defaults = {
  // data
  boundary                : '--------------------NODENEEDLEHTTPCLIENT',
  encoding                : 'utf8',
  parse_response          : 'all', // same as true. valid options: 'json', 'xml' or false/null
  proxy                   : null,

  // headers
  headers                 : {},
  accept                  : '*/*',
  user_agent              : user_agent,

  // numbers
  open_timeout            : 10000,
  response_timeout        : 0,
  read_timeout            : 0,
  follow_max              : 0,
  stream_length           : -1,

  // booleans
  compressed              : false,
  decode_response         : true,
  parse_cookies           : true,
  follow_set_cookies      : false,
  follow_set_referer      : false,
  follow_keep_method      : false,
  follow_if_same_host     : false,
  follow_if_same_protocol : false,
  follow_if_same_location : false
}

var aliased = {
  options: {
    decode  : 'decode_response',
    parse   : 'parse_response',
    timeout : 'open_timeout',
    follow  : 'follow_max'
  },
  inverted: {}
}

// only once, invert aliased keys so we can get passed options.
Object.keys(aliased.options).map(function(k) {
  var value = aliased.options[k];
  aliased.inverted[value] = k;
});

//////////////////////////////////////////
// helpers

function keys_by_type(type) {
  return Object.keys(defaults).map(function(el) {
    if (defaults[el] !== null && defaults[el].constructor == type)
      return el;
  }).filter(function(el) { return el })
}

function parse_content_type(header) {
  if (!header || header === '') return {};

  var found, charset = 'utf8', arr = header.split(';');

  if (arr.length > 1 && (found = arr[1].match(/charset=(.+)/)))
    charset = found[1];

  return { type: arr[0], charset: charset };
}

function is_stream(obj) {
  return typeof obj.pipe === 'function';
}

function get_stream_length(stream, given_length, cb) {
  if (given_length > 0)
    return cb(given_length);

  if (stream.end !== void 0 && stream.end !== Infinity && stream.start !== void 0)
    return cb((stream.end + 1) - (stream.start || 0));

  fs.stat(stream.path, function(err, stat) {
    cb(stat ? stat.size - (stream.start || 0) : null);
  });
}

//////////////////////////////////////////
// the main act

function Needle(method, uri, data, options, callback) {
  // if (!(this instanceof Needle)) {
  //   return new Needle(method, uri, data, options, callback);
  // }

  if (typeof uri !== 'string')
    throw new TypeError('URL must be a string, not ' + uri);

  this.method   = method;
  this.uri      = uri;
  this.data     = data;

  if (typeof options == 'function') {
    this.callback = options;
    this.options  = {};
  } else {
    this.callback = callback;
    this.options  = options;
  }

}

Needle.prototype.setup = function(uri, options) {

  function get_option(key, fallback) {
    // if original is in options, return that value
    if (typeof options[key] != 'undefined') return options[key];

    // otherwise, return value from alias or fallback/undefined
    return typeof options[aliased.inverted[key]] != 'undefined'
                ? options[aliased.inverted[key]] : fallback;
  }

  function check_value(expected, key) {
    var value = get_option(key),
        type  = typeof value;

    if (type != 'undefined' && type != expected)
      throw new TypeError(type + ' received for ' + key + ', but expected a ' + expected);

    return (type == expected) ? value : defaults[key];
  }

  //////////////////////////////////////////////////
  // the basics

  var config = {
    http_opts : {
      localAddress: get_option('localAddress', undefined)
    }, // passed later to http.request() directly
    headers   : {},
    output    : options.output,
    proxy     : get_option('proxy', defaults.proxy),
    parser    : get_option('parse_response', defaults.parse_response),
    encoding  : options.encoding || (options.multipart ? 'binary' : defaults.encoding)
  }

  keys_by_type(Boolean).forEach(function(key) {
    config[key] = check_value('boolean', key);
  })

  keys_by_type(Number).forEach(function(key) {
    config[key] = check_value('number', key);
  })

  // populate http_opts with given TLS options
  tls_options.split(' ').forEach(function(key) {
    if (typeof options[key] != 'undefined') {
      config.http_opts[key] = options[key];
      if (typeof options.agent == 'undefined')
        config.http_opts.agent = false; // otherwise tls options are skipped
    }
  });

  //////////////////////////////////////////////////
  // headers, cookies

  for (var key in defaults.headers)
    config.headers[key] = defaults.headers[key];

  config.headers['accept'] = options.accept || defaults.accept;
  config.headers['user-agent'] = options.user_agent || defaults.user_agent;

  if (options.content_type)
    config.headers['content-type'] = options.content_type;

  // set connection header if opts.connection was passed, or if node < 0.11.4 (close)
  if (options.connection || close_by_default)
    config.headers['connection'] = options.connection || 'close';

  if ((options.compressed || defaults.compressed) && typeof zlib != 'undefined')
    config.headers['accept-encoding'] = brotli_supported ? 'gzip, deflate, br' : 'gzip, deflate';

  if (options.cookies)
    config.headers['cookie'] = cookies.write(options.cookies);

  //////////////////////////////////////////////////
  // basic/digest auth

  if (uri.match(/[^\/]@/)) { // url contains user:pass@host, so parse it.
    var parts = (url.parse(uri).auth || '').split(':');
    options.username = parts[0];
    options.password = parts[1];
  }

  if (options.username) {
    if (options.auth && (options.auth == 'auto' || options.auth == 'digest')) {
      config.credentials = [options.username, options.password];
    } else {
      config.headers['authorization'] = auth.basic(options.username, options.password);
    }
  }

  // if proxy is present, set auth header from either url or proxy_user option.
  if (config.proxy) {
    if (config.proxy.indexOf('http') === -1)
      config.proxy = 'http://' + config.proxy;

    if (config.proxy.indexOf('@') !== -1) {
      var proxy = (url.parse(config.proxy).auth || '').split(':');
      options.proxy_user = proxy[0];
      options.proxy_pass = proxy[1];
    }

    if (options.proxy_user)
      config.headers['proxy-authorization'] = auth.basic(options.proxy_user, options.proxy_pass);
  }

  // now that all our headers are set, overwrite them if instructed.
  for (var h in options.headers)
    config.headers[h.toLowerCase()] = options.headers[h];

  config.uri_modifier = get_option('uri_modifier', null);

  return config;
}

Needle.prototype.start = function() {

  var out      = new stream.PassThrough({ objectMode: false }),
      uri      = this.uri,
      data     = this.data,
      method   = this.method,
      callback = (typeof this.options == 'function') ? this.options : this.callback,
      options  = this.options || {};

  // if no 'http' is found on URL, prepend it.
  if (uri.indexOf('http') === -1)
    uri = uri.replace(/^(\/\/)?/, 'http://');

  var self = this, body, waiting = false, config = this.setup(uri, options);

  // unless options.json was set to false, assume boss also wants JSON if content-type matches.
  var json = options.json || (options.json !== false && config.headers['content-type'] == 'application/json');

  if (data) {

    if (options.multipart) { // boss says we do multipart. so we do it.
      var boundary = options.boundary || defaults.boundary;

      waiting = true;
      multipart.build(data, boundary, function(err, parts) {
        if (err) throw(err);

        config.headers['content-type'] = 'multipart/form-data; boundary=' + boundary;
        next(parts);
      });

    } else if (is_stream(data)) {

      if (method.toUpperCase() == 'GET')
        throw new Error('Refusing to pipe() a stream via GET. Did you mean .post?');

      if (config.stream_length > 0 || (config.stream_length === 0 && data.path)) {
        // ok, let's get the stream's length and set it as the content-length header.
        // this prevents some servers from cutting us off before all the data is sent.
        waiting = true;
        get_stream_length(data, config.stream_length, function(length) {
          data.length = length;
          next(data);
        })

      } else {
        // if the boss doesn't want us to get the stream's length, or if it doesn't
        // have a file descriptor for that purpose, then just head on.
        body = data;
      }

    } else if (Buffer.isBuffer(data)) {

      body = data; // use the raw buffer as request body.

    } else if (method.toUpperCase() == 'GET' && !json) {

      // append the data to the URI as a querystring.
      uri = uri.replace(/\?.*|$/, '?' + stringify(data));

    } else { // string or object data, no multipart.

      // if string, leave it as it is, otherwise, stringify.
      body = (typeof(data) === 'string') ? data
             : json ? JSON.stringify(data) : stringify(data);

      // ensure we have a buffer so bytecount is correct.
      body = Buffer.from(body, config.encoding);
    }

  }

  function next(body) {
    if (body) {
      if (body.length) config.headers['content-length'] = body.length;

      // if no content-type was passed, determine if json or not.
      if (!config.headers['content-type']) {
        config.headers['content-type'] = json
        ? 'application/json; charset=utf-8'
        : 'application/x-www-form-urlencoded'; // no charset says W3 spec.
      }
    }

    // unless a specific accept header was set, assume json: true wants JSON back.
    if (options.json && (!options.accept && !(options.headers || {}).accept))
      config.headers['accept'] = 'application/json';

    self.send_request(1, method, uri, config, body, out, callback);
  }

  if (!waiting) next(body);
  return out;
}

Needle.prototype.get_request_opts = function(method, uri, config) {
  var opts      = config.http_opts,
      proxy     = config.proxy,
      remote    = proxy ? url.parse(proxy) : url.parse(uri);

  opts.protocol = remote.protocol;
  opts.host     = remote.hostname;
  opts.port     = remote.port || (remote.protocol == 'https:' ? 443 : 80);
  opts.path     = proxy ? uri : remote.pathname + (remote.search || '');
  opts.method   = method;
  opts.headers  = config.headers;

  if (!opts.headers['host']) {
    // if using proxy, make sure the host header shows the final destination
    var target = proxy ? url.parse(uri) : remote;
    opts.headers['host'] = target.hostname;

    // and if a non standard port was passed, append it to the port header
    if (target.port && [80, 443].indexOf(target.port) === -1) {
      opts.headers['host'] += ':' + target.port;
    }
  }

  return opts;
}

Needle.prototype.should_follow = function(location, config, original) {
  if (!location) return false;

  // returns true if location contains matching property (host or protocol)
  function matches(property) {
    var property = original[property];
    return location.indexOf(property) !== -1;
  }

  // first, check whether the requested location is actually different from the original
  if (!config.follow_if_same_location && location === original)
    return false;

  if (config.follow_if_same_host && !matches('host'))
    return false; // host does not match, so not following

  if (config.follow_if_same_protocol && !matches('protocol'))
    return false; // procotol does not match, so not following

  return true;
}

Needle.prototype.send_request = function(count, method, uri, config, post_data, out, callback) {

  if (typeof config.uri_modifier === 'function') {
    var modified_uri = config.uri_modifier(uri);
    debug('Modifying request URI', uri + ' => ' + modified_uri);
    uri = modified_uri;
  }

  var timer,
      returned     = 0,
      self         = this,
      request_opts = this.get_request_opts(method, uri, config),
      protocol     = request_opts.protocol == 'https:' ? https : http;

  function done(err, resp) {
    if (returned++ > 0)
      return debug('Already finished, stopping here.');

    if (timer) clearTimeout(timer);
    request.removeListener('error', had_error);

    if (callback)
      return callback(err, resp, resp ? resp.body : undefined);

    // NOTE: this event used to be called 'end', but the behaviour was confusing
    // when errors ocurred, because the stream would still emit an 'end' event.
    out.emit('done', err);
  }

  function had_error(err) {
    debug('Request error', err);
    out.emit('err', err);
    done(err || new Error('Unknown error when making request.'));
  }

  function set_timeout(type, milisecs) {
    if (timer) clearTimeout(timer);
    if (milisecs <= 0) return;

    timer = setTimeout(function() {
      out.emit('timeout', type);
      request.abort();
      // also invoke done() to terminate job on read_timeout
      if (type == 'read') done(new Error(type + ' timeout'));
    }, milisecs);
  }

  // handle errors on the underlying socket, that may be closed while writing
  // for an example case, see test/long_string_spec.js. we make sure this
  // scenario ocurred by verifying the socket's writable & destroyed states.
  function on_socket_end() {
    if (returned && !this.writable && this.destroyed === false) {
      this.destroy();
      had_error(new Error('Remote end closed socket abruptly.'))
    }
  }

  debug('Making request #' + count, request_opts);
  var request = protocol.request(request_opts, function(resp) {

    var headers = resp.headers;
    debug('Got response', resp.statusCode, headers);
    out.emit('response', resp);

    set_timeout('read', config.read_timeout);

    // if we got cookies, parse them unless we were instructed not to. make sure to include any
    // cookies that might have been set on previous redirects.
    if (config.parse_cookies && (headers['set-cookie'] || config.previous_resp_cookies)) {
      resp.cookies = extend(config.previous_resp_cookies || {}, cookies.read(headers['set-cookie']));
      debug('Got cookies', resp.cookies);
    }

    // if redirect code is found, determine if we should follow it according to the given options.
    if (redirect_codes.indexOf(resp.statusCode) !== -1 && self.should_follow(headers.location, config, uri)) {
      // clear timer before following redirects to prevent unexpected setTimeout consequence
      clearTimeout(timer);

      if (count <= config.follow_max) {
        out.emit('redirect', headers.location);

        // unless 'follow_keep_method' is true, rewrite the request to GET before continuing.
        if (!config.follow_keep_method) {
          method    = 'GET';
          post_data = null;
          delete config.headers['content-length']; // in case the original was a multipart POST request.
        }

        // if follow_set_cookies is true, insert cookies in the next request's headers.
        // we set both the original request cookies plus any response cookies we might have received.
        if (config.follow_set_cookies) {
          var request_cookies = cookies.read(config.headers['cookie']);
          config.previous_resp_cookies = resp.cookies;
          if (Object.keys(request_cookies).length || Object.keys(resp.cookies || {}).length) {
            config.headers['cookie'] = cookies.write(extend(request_cookies, resp.cookies));
          }
        } else if (config.headers['cookie']) {
          debug('Clearing original request cookie', config.headers['cookie']);
          delete config.headers['cookie'];
        }

        if (config.follow_set_referer)
          config.headers['referer'] = encodeURI(uri); // the original, not the destination URL.

        config.headers['host'] = null; // clear previous Host header to avoid conflicts.

        debug('Redirecting to ' + url.resolve(uri, headers.location));
        return self.send_request(++count, method, url.resolve(uri, headers.location), config, post_data, out, callback);
      } else if (config.follow_max > 0) {
        return done(new Error('Max redirects reached. Possible loop in: ' + headers.location));
      }
    }

    // if auth is requested and credentials were not passed, resend request, provided we have user/pass.
    if (resp.statusCode == 401 && headers['www-authenticate'] && config.credentials) {
      if (!config.headers['authorization']) { // only if authentication hasn't been sent
        var auth_header = auth.header(headers['www-authenticate'], config.credentials, request_opts);

        if (auth_header) {
          config.headers['authorization'] = auth_header;
          return self.send_request(count, method, uri, config, post_data, out, callback);
        }
      }
    }

    // ok, so we got a valid (non-redirect & authorized) response. let's notify the stream guys.
    out.emit('header', resp.statusCode, headers);
    out.emit('headers', headers);

    var pipeline      = [],
        mime          = parse_content_type(headers['content-type']),
        text_response = mime.type && mime.type.indexOf('text/') != -1;

    // To start, if our body is compressed and we're able to inflate it, do it.
    if (headers['content-encoding'] && decompressors[headers['content-encoding']]) {

      var decompressor = decompressors[headers['content-encoding']](zlib_options);

      // make sure we catch errors triggered by the decompressor.
      decompressor.on('error', had_error);
      pipeline.push(decompressor);
    }

    // If parse is enabled and we have a parser for it, then go for it.
    if (config.parser && parsers[mime.type]) {

      // If a specific parser was requested, make sure we don't parse other types.
      var parser_name = config.parser.toString().toLowerCase();
      if (['xml', 'json'].indexOf(parser_name) == -1 || parsers[mime.type].name == parser_name) {

        // OK, so either we're parsing all content types or the one requested matches.
        out.parser = parsers[mime.type].name;
        pipeline.push(parsers[mime.type].fn());

        // Set objectMode on out stream to improve performance.
        out._writableState.objectMode = true;
        out._readableState.objectMode = true;
      }

    // If we're not parsing, and unless decoding was disabled, we'll try
    // decoding non UTF-8 bodies to UTF-8, using the iconv-lite library.
    } else if (text_response && config.decode_response
      && mime.charset) {
        pipeline.push(decoder(mime.charset));
    }
    // And `out` is the stream we finally push the decoded/parsed output to.
    pipeline.push(out);

    // Now, release the kraken!
    var tmp = resp;
    while (pipeline.length) {
      tmp = tmp.pipe(pipeline.shift());
    }

    // If the user has requested and output file, pipe the output stream to it.
    // In stream mode, we will still get the response stream to play with.
    if (config.output && resp.statusCode == 200) {

      // for some reason, simply piping resp to the writable stream doesn't
      // work all the time (stream gets cut in the middle with no warning).
      // so we'll manually need to do the readable/write(chunk) trick.
      var file = fs.createWriteStream(config.output);
      file.on('error', had_error);

      out.on('end', function() {
        if (file.writable) file.end();
      });

      file.on('close', function() {
        delete out.file;
      })

      out.on('readable', function() {
        var chunk;
        while ((chunk = this.read()) !== null) {
          if (file.writable) file.write(chunk);

          // if callback was requested, also push it to resp.body
          if (resp.body) resp.body.push(chunk);
        }
      })

      out.file = file;
    }

    // Only aggregate the full body if a callback was requested.
    if (callback) {
      resp.raw   = [];
      resp.body  = [];
      resp.bytes = 0;

      // Gather and count the amount of (raw) bytes using a PassThrough stream.
      var clean_pipe = new stream.PassThrough();
      resp.pipe(clean_pipe);

      clean_pipe.on('readable', function() {
        var chunk;
        while ((chunk = this.read()) != null) {
          resp.bytes += chunk.length;
          resp.raw.push(chunk);
        }
      })

      // Listen on the 'readable' event to aggregate the chunks, but only if
      // file output wasn't requested. Otherwise we'd have two stream readers.
      if (!config.output || resp.statusCode != 200) {
        out.on('readable', function() {
          var chunk;
          while ((chunk = this.read()) !== null) {
            // We're either pushing buffers or objects, never strings.
            if (typeof chunk == 'string') chunk = Buffer.from(chunk);

            // Push all chunks to resp.body. We'll bind them in resp.end().
            resp.body.push(chunk);
          }
        })
      }
    }

    // And set the .body property once all data is in.
    out.on('end', function() {
      if (resp.body) { // callback mode

        // we want to be able to access to the raw data later, so keep a reference.
        resp.raw = Buffer.concat(resp.raw);

        // if parse was successful, we should have an array with one object
        if (resp.body[0] !== undefined && !Buffer.isBuffer(resp.body[0])) {

          // that's our body right there.
          resp.body = resp.body[0];

          // set the parser property on our response. we may want to check.
          if (out.parser) resp.parser = out.parser;

        } else { // we got one or several buffers. string or binary.
          resp.body = Buffer.concat(resp.body);

          // if we're here and parsed is true, it means we tried to but it didn't work.
          // so given that we got a text response, let's stringify it.
          if (text_response || out.parser) {
            resp.body = resp.body.toString();
          }
        }
      }

      // if an output file is being written to, make sure the callback
      // is triggered after all data has been written to it.
      if (out.file) {
        out.file.on('close', function() {
          done(null, resp, resp.body);
        })
      } else { // elvis has left the building.
        done(null, resp, resp.body);
      }

    });

  }); // end request call

  // unless open_timeout was disabled, set a timeout to abort the request.
  set_timeout('open', config.open_timeout);

  // handle errors on the request object. things might get bumpy.
  request.on('error', had_error);

  // make sure timer is cleared if request is aborted (issue #257)
  request.once('abort', function() {
    if (timer) clearTimeout(timer);
  })

  // handle socket 'end' event to ensure we don't get delayed EPIPE errors.
  request.once('socket', function(socket) {
    if (socket.connecting) {
      socket.once('connect', function() {
        set_timeout('response', config.response_timeout);
      })
    } else {
      set_timeout('response', config.response_timeout);
    }

    // console.log(socket);
    if (!socket.on_socket_end) {
      socket.on_socket_end = on_socket_end;
      socket.once('end', function() { process.nextTick(on_socket_end.bind(socket)) });
    }
  })

  if (post_data) {
    if (is_stream(post_data)) {
      post_data.pipe(request);
    } else {
      request.write(post_data, config.encoding);
      request.end();
    }
  } else {
    request.end();
  }

  out.request = request;
  return out;
}

//////////////////////////////////////////
// exports

if (typeof Promise !== 'undefined') {
  module.exports = function() {
    var verb, args = [].slice.call(arguments);

    if (args[0].match(/\.|\//)) // first argument looks like a URL
      verb = (args.length > 2) ? 'post' : 'get';
    else
      verb = args.shift();

    if (verb.match(/get|head/) && args.length == 2)
      args.splice(1, 0, null); // assume no data if head/get with two args (url, options)

    return new Promise(function(resolve, reject) {
      module.exports.request(verb, args[0], args[1], args[2], function(err, resp) {
        return err ? reject(err) : resolve(resp);
      });
    })
  }
}

module.exports.version = version;

module.exports.defaults = function(obj) {
  for (var key in obj) {
    var target_key = aliased.options[key] || key;

    if (defaults.hasOwnProperty(target_key) && typeof obj[key] != 'undefined') {
      if (target_key != 'parse_response' && target_key != 'proxy') {
        // ensure type matches the original, except for proxy/parse_response that can be null/bool or string
        var valid_type = defaults[target_key].constructor.name;

        if (obj[key].constructor.name != valid_type)
          throw new TypeError('Invalid type for ' + key + ', should be ' + valid_type);
      }
      defaults[target_key] = obj[key];
    } else {
      throw new Error('Invalid property for defaults:' + target_key);
    }
  }

  return defaults;
}

'head get'.split(' ').forEach(function(method) {
  module.exports[method] = function(uri, options, callback) {
    return new Needle(method, uri, null, options, callback).start();
  }
})

'post put patch delete'.split(' ').forEach(function(method) {
  module.exports[method] = function(uri, data, options, callback) {
    return new Needle(method, uri, data, options, callback).start();
  }
})

module.exports.request = function(method, uri, data, opts, callback) {
  return new Needle(method, uri, data, opts, callback).start();
};


/***/ }),

/***/ "./node_modules/needle/lib/parsers.js":
/*!********************************************!*\
  !*** ./node_modules/needle/lib/parsers.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//////////////////////////////////////////
// Defines mappings between content-type
// and the appropriate parsers.
//////////////////////////////////////////

var Transform = __webpack_require__(/*! stream */ "stream").Transform;
var sax = __webpack_require__(/*! sax */ "./node_modules/sax/lib/sax.js");

function parseXML(str, cb) {
  var obj, current, parser = sax.parser(true, { trim: true, lowercase: true })
  parser.onerror = parser.onend = done;

  function done(err) {
    parser.onerror = parser.onend = function() { }
    cb(err, obj)
  }

  function newElement(name, attributes) {
    return {
      name: name || '',
      value: '',
      attributes: attributes || {},
      children: []
    }
  }

  parser.oncdata = parser.ontext = function(t) {
    if (current) current.value += t
  }

  parser.onopentag = function(node) {
    var element = newElement(node.name, node.attributes)
    if (current) {
      element.parent = current
      current.children.push(element)
    } else { // root object
      obj = element
    }

    current = element
  };

  parser.onclosetag = function() {
    if (typeof current.parent !== 'undefined') {
      var just_closed = current
      current = current.parent
      delete just_closed.parent
    }
  }

  parser.write(str).close()
}

function parserFactory(name, fn) {

  function parser() {
    var chunks = [],
        stream = new Transform({ objectMode: true });

    // Buffer all our data
    stream._transform = function(chunk, encoding, done) {
      chunks.push(chunk);
      done();
    }

    // And call the parser when all is there.
    stream._flush = function(done) {
      var self = this,
          data = Buffer.concat(chunks);

      try {
        fn(data, function(err, result) {
          if (err) throw err;
          self.push(result);
        });
      } catch (err) {
        self.push(data); // just pass the original data
      } finally {
        done();
      }
    }

    return stream;
  }

  return { fn: parser, name: name };
}

var parsers = {}

function buildParser(name, types, fn) {
  var parser = parserFactory(name, fn);
  types.forEach(function(type) {
    parsers[type] = parser;
  })
}

buildParser('json', [
  'application/json',
  'text/javascript'
], function(buffer, cb) {
  var err, data;
  try { data = JSON.parse(buffer); } catch (e) { err = e; }
  cb(err, data);
});

buildParser('xml', [
  'text/xml',
  'application/xml',
  'application/rdf+xml',
  'application/rss+xml',
  'application/atom+xml'
], function(buffer, cb) {
  parseXML(buffer.toString(), function(err, obj) {
    cb(err, obj)
  })
});

module.exports = parsers;
module.exports.use = buildParser;


/***/ }),

/***/ "./node_modules/needle/lib/querystring.js":
/*!************************************************!*\
  !*** ./node_modules/needle/lib/querystring.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// based on the qs module, but handles null objects as expected
// fixes by Tomas Pollak.

var toString = Object.prototype.toString;

function stringify(obj, prefix) {
  if (prefix && (obj === null || typeof obj == 'undefined')) {
    return prefix + '=';
  } else if (toString.call(obj) == '[object Array]') {
    return stringifyArray(obj, prefix);
  } else if (toString.call(obj) == '[object Object]') {
    return stringifyObject(obj, prefix);
  } else if (toString.call(obj) == '[object Date]') {
    return obj.toISOString();
  } else if (prefix) { // string inside array or hash
    return prefix + '=' + encodeURIComponent(String(obj));
  } else if (String(obj).indexOf('=') !== -1) { // string with equal sign
    return String(obj);
  } else {
    throw new TypeError('Cannot build a querystring out of: ' + obj);
  }
};

function stringifyArray(arr, prefix) {
  var ret = [];

  for (var i = 0, len = arr.length; i < len; i++) {
    if (prefix)
      ret.push(stringify(arr[i], prefix + '[]'));
    else
      ret.push(stringify(arr[i]));
  }

  return ret.join('&');
}

function stringifyObject(obj, prefix) {
  var ret = [];

  Object.keys(obj).forEach(function(key) {
    ret.push(stringify(obj[key], prefix
      ? prefix + '[' + encodeURIComponent(key) + ']'
      : encodeURIComponent(key)));
  })

  return ret.join('&');
}

exports.build = stringify;


/***/ }),

/***/ "./node_modules/needle/package.json":
/*!******************************************!*\
  !*** ./node_modules/needle/package.json ***!
  \******************************************/
/*! exports provided: _from, _id, _inBundle, _integrity, _location, _phantomChildren, _requested, _requiredBy, _resolved, _shasum, _spec, _where, author, bin, bugs, bundleDependencies, dependencies, deprecated, description, devDependencies, directories, engines, homepage, keywords, license, main, name, repository, scripts, tags, version, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"_from\":\"needle@^2.5.0\",\"_id\":\"needle@2.5.0\",\"_inBundle\":false,\"_integrity\":\"sha512-o/qITSDR0JCyCKEQ1/1bnUXMmznxabbwi/Y4WwJElf+evwJNFNwIDMCCt5IigFVxgeGBJESLohGtIS9gEzo1fA==\",\"_location\":\"/needle\",\"_phantomChildren\":{\"ms\":\"2.1.2\"},\"_requested\":{\"type\":\"range\",\"registry\":true,\"raw\":\"needle@^2.5.0\",\"name\":\"needle\",\"escapedName\":\"needle\",\"rawSpec\":\"^2.5.0\",\"saveSpec\":null,\"fetchSpec\":\"^2.5.0\"},\"_requiredBy\":[\"/node-pre-gyp\"],\"_resolved\":\"https://registry.npmjs.org/needle/-/needle-2.5.0.tgz\",\"_shasum\":\"e6fc4b3cc6c25caed7554bd613a5cf0bac8c31c0\",\"_spec\":\"needle@^2.5.0\",\"_where\":\"/Users/nilswernecke/Documents/webdev/thesisproject/tripwiser/node_modules/node-pre-gyp\",\"author\":{\"name\":\"Toms Pollak\",\"email\":\"tomas@forkhq.com\"},\"bin\":{\"needle\":\"bin/needle\"},\"bugs\":{\"url\":\"https://github.com/tomas/needle/issues\"},\"bundleDependencies\":false,\"dependencies\":{\"debug\":\"^3.2.6\",\"iconv-lite\":\"^0.4.4\",\"sax\":\"^1.2.4\"},\"deprecated\":false,\"description\":\"The leanest and most handsome HTTP client in the Nodelands.\",\"devDependencies\":{\"JSONStream\":\"^1.3.5\",\"jschardet\":\"^1.6.0\",\"mocha\":\"^5.2.0\",\"q\":\"^1.5.1\",\"should\":\"^13.2.3\",\"sinon\":\"^2.3.0\",\"xml2js\":\"^0.4.19\"},\"directories\":{\"lib\":\"./lib\"},\"engines\":{\"node\":\">= 4.4.x\"},\"homepage\":\"https://github.com/tomas/needle#readme\",\"keywords\":[\"http\",\"https\",\"simple\",\"request\",\"client\",\"multipart\",\"upload\",\"proxy\",\"deflate\",\"timeout\",\"charset\",\"iconv\",\"cookie\",\"redirect\"],\"license\":\"MIT\",\"main\":\"./lib/needle\",\"name\":\"needle\",\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/tomas/needle.git\"},\"scripts\":{\"test\":\"mocha test\"},\"tags\":[\"http\",\"https\",\"simple\",\"request\",\"client\",\"multipart\",\"upload\",\"proxy\",\"deflate\",\"timeout\",\"charset\",\"iconv\",\"cookie\",\"redirect\"],\"version\":\"2.5.0\"}");

/***/ }),

/***/ "./node_modules/node-pre-gyp/lib sync recursive":
/*!********************************************!*\
  !*** ./node_modules/node-pre-gyp/lib sync ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = "./node_modules/node-pre-gyp/lib sync recursive";

/***/ }),

/***/ "./node_modules/node-pre-gyp/lib sync recursive ^\\.\\/.*$":
/*!*****************************************************!*\
  !*** ./node_modules/node-pre-gyp/lib sync ^\.\/.*$ ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./build": "./node_modules/node-pre-gyp/lib/build.js",
	"./build.js": "./node_modules/node-pre-gyp/lib/build.js",
	"./clean": "./node_modules/node-pre-gyp/lib/clean.js",
	"./clean.js": "./node_modules/node-pre-gyp/lib/clean.js",
	"./configure": "./node_modules/node-pre-gyp/lib/configure.js",
	"./configure.js": "./node_modules/node-pre-gyp/lib/configure.js",
	"./info": "./node_modules/node-pre-gyp/lib/info.js",
	"./info.js": "./node_modules/node-pre-gyp/lib/info.js",
	"./install": "./node_modules/node-pre-gyp/lib/install.js",
	"./install.js": "./node_modules/node-pre-gyp/lib/install.js",
	"./node-pre-gyp": "./node_modules/node-pre-gyp/lib/node-pre-gyp.js",
	"./node-pre-gyp.js": "./node_modules/node-pre-gyp/lib/node-pre-gyp.js",
	"./package": "./node_modules/node-pre-gyp/lib/package.js",
	"./package.js": "./node_modules/node-pre-gyp/lib/package.js",
	"./pre-binding": "./node_modules/node-pre-gyp/lib/pre-binding.js",
	"./pre-binding.js": "./node_modules/node-pre-gyp/lib/pre-binding.js",
	"./publish": "./node_modules/node-pre-gyp/lib/publish.js",
	"./publish.js": "./node_modules/node-pre-gyp/lib/publish.js",
	"./rebuild": "./node_modules/node-pre-gyp/lib/rebuild.js",
	"./rebuild.js": "./node_modules/node-pre-gyp/lib/rebuild.js",
	"./reinstall": "./node_modules/node-pre-gyp/lib/reinstall.js",
	"./reinstall.js": "./node_modules/node-pre-gyp/lib/reinstall.js",
	"./reveal": "./node_modules/node-pre-gyp/lib/reveal.js",
	"./reveal.js": "./node_modules/node-pre-gyp/lib/reveal.js",
	"./testbinary": "./node_modules/node-pre-gyp/lib/testbinary.js",
	"./testbinary.js": "./node_modules/node-pre-gyp/lib/testbinary.js",
	"./testpackage": "./node_modules/node-pre-gyp/lib/testpackage.js",
	"./testpackage.js": "./node_modules/node-pre-gyp/lib/testpackage.js",
	"./unpublish": "./node_modules/node-pre-gyp/lib/unpublish.js",
	"./unpublish.js": "./node_modules/node-pre-gyp/lib/unpublish.js",
	"./util/abi_crosswalk.json": "./node_modules/node-pre-gyp/lib/util/abi_crosswalk.json",
	"./util/compile": "./node_modules/node-pre-gyp/lib/util/compile.js",
	"./util/compile.js": "./node_modules/node-pre-gyp/lib/util/compile.js",
	"./util/handle_gyp_opts": "./node_modules/node-pre-gyp/lib/util/handle_gyp_opts.js",
	"./util/handle_gyp_opts.js": "./node_modules/node-pre-gyp/lib/util/handle_gyp_opts.js",
	"./util/napi": "./node_modules/node-pre-gyp/lib/util/napi.js",
	"./util/napi.js": "./node_modules/node-pre-gyp/lib/util/napi.js",
	"./util/nw-pre-gyp/index.html": "./node_modules/node-pre-gyp/lib/util/nw-pre-gyp/index.html",
	"./util/nw-pre-gyp/package.json": "./node_modules/node-pre-gyp/lib/util/nw-pre-gyp/package.json",
	"./util/s3_setup": "./node_modules/node-pre-gyp/lib/util/s3_setup.js",
	"./util/s3_setup.js": "./node_modules/node-pre-gyp/lib/util/s3_setup.js",
	"./util/versioning": "./node_modules/node-pre-gyp/lib/util/versioning.js",
	"./util/versioning.js": "./node_modules/node-pre-gyp/lib/util/versioning.js"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./node_modules/node-pre-gyp/lib sync recursive ^\\.\\/.*$";

/***/ }),

/***/ "./node_modules/node-pre-gyp/lib/build.js":
/*!************************************************!*\
  !*** ./node_modules/node-pre-gyp/lib/build.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = exports = build;

exports.usage = 'Attempts to compile the module by dispatching to node-gyp or nw-gyp';

var napi = __webpack_require__(/*! ./util/napi.js */ "./node_modules/node-pre-gyp/lib/util/napi.js");
var compile = __webpack_require__(/*! ./util/compile.js */ "./node_modules/node-pre-gyp/lib/util/compile.js");
var handle_gyp_opts = __webpack_require__(/*! ./util/handle_gyp_opts.js */ "./node_modules/node-pre-gyp/lib/util/handle_gyp_opts.js");
var configure = __webpack_require__(/*! ./configure.js */ "./node_modules/node-pre-gyp/lib/configure.js");

function do_build(gyp,argv,callback) {
    handle_gyp_opts(gyp,argv,function(err,result) {
        var final_args = ['build'].concat(result.gyp).concat(result.pre);
        if (result.unparsed.length > 0) {
            final_args = final_args.
                          concat(['--']).
                          concat(result.unparsed);
        }
        if (!err && result.opts.napi_build_version) {
            napi.swap_build_dir_in(result.opts.napi_build_version);
        }
        compile.run_gyp(final_args,result.opts,function(err) {
            if (result.opts.napi_build_version) {
                napi.swap_build_dir_out(result.opts.napi_build_version);
            }
            return callback(err);
        });
    });
}

function build(gyp, argv, callback) {

    // Form up commands to pass to node-gyp:
    // We map `node-pre-gyp build` to `node-gyp configure build` so that we do not
    // trigger a clean and therefore do not pay the penalty of a full recompile
    if (argv.length && (argv.indexOf('rebuild') > -1)) {
        argv.shift(); // remove `rebuild`
        // here we map `node-pre-gyp rebuild` to `node-gyp rebuild` which internally means
        // "clean + configure + build" and triggers a full recompile
        compile.run_gyp(['clean'],{},function(err) {
            if (err) return callback(err);
            configure(gyp,argv,function(err) {
                if (err) return callback(err);
                return do_build(gyp,argv,callback);
            });
        });
    } else {
        return do_build(gyp,argv,callback);        
    }
}


/***/ }),

/***/ "./node_modules/node-pre-gyp/lib/clean.js":
/*!************************************************!*\
  !*** ./node_modules/node-pre-gyp/lib/clean.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = exports = clean;

exports.usage = 'Removes the entire folder containing the compiled .node module';

var fs = __webpack_require__(/*! fs */ "fs");
var rm = __webpack_require__(/*! rimraf */ "rimraf");
var exists = __webpack_require__(/*! fs */ "fs").exists || __webpack_require__(/*! path */ "path").exists;
var versioning = __webpack_require__(/*! ./util/versioning.js */ "./node_modules/node-pre-gyp/lib/util/versioning.js");
var napi = __webpack_require__(/*! ./util/napi.js */ "./node_modules/node-pre-gyp/lib/util/napi.js");
var path = __webpack_require__(/*! path */ "path");

function clean (gyp, argv, callback) {
    var package_json = JSON.parse(fs.readFileSync('./package.json'));
    var napi_build_version = napi.get_napi_build_version_from_command_args(argv);
    var opts = versioning.evaluate(package_json, gyp.opts, napi_build_version);
    var to_delete = opts.module_path;
    if (!to_delete) {
        return callback(new Error("module_path is empty, refusing to delete"));
    } else if (path.normalize(to_delete) == path.normalize(process.cwd())) {
        return callback(new Error("module_path is not set, refusing to delete"));
    } else {
        exists(to_delete, function(found) {
            if (found) {
                if (!gyp.opts.silent_clean) console.log('['+package_json.name+'] Removing "%s"', to_delete);
                return rm(to_delete, callback);
            }
            return callback();
        });
    }
}


/***/ }),

/***/ "./node_modules/node-pre-gyp/lib/configure.js":
/*!****************************************************!*\
  !*** ./node_modules/node-pre-gyp/lib/configure.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = exports = configure;

exports.usage = 'Attempts to configure node-gyp or nw-gyp build';

var napi = __webpack_require__(/*! ./util/napi.js */ "./node_modules/node-pre-gyp/lib/util/napi.js");
var compile = __webpack_require__(/*! ./util/compile.js */ "./node_modules/node-pre-gyp/lib/util/compile.js");
var handle_gyp_opts = __webpack_require__(/*! ./util/handle_gyp_opts.js */ "./node_modules/node-pre-gyp/lib/util/handle_gyp_opts.js");

function configure(gyp, argv, callback) {
    handle_gyp_opts(gyp,argv,function(err,result) {
        var final_args = result.gyp.concat(result.pre);
        // pull select node-gyp configure options out of the npm environ
        var known_gyp_args = ['dist-url','python','nodedir','msvs_version'];
        known_gyp_args.forEach(function(key) {
            var val = gyp.opts[key] || gyp.opts[key.replace('-','_')];
            if (val) {
               final_args.push('--'+key+'='+val);
            }
        });
        // --ensure=false tell node-gyp to re-install node development headers
        // but it is only respected by node-gyp install, so we have to call install
        // as a separate step if the user passes it
        if (gyp.opts.ensure === false) {
            var install_args = final_args.concat(['install','--ensure=false']);
            compile.run_gyp(install_args,result.opts,function(err) {
                if (err) return callback(err);
                if (result.unparsed.length > 0) {
                    final_args = final_args.
                                  concat(['--']).
                                  concat(result.unparsed);
                }
                compile.run_gyp(['configure'].concat(final_args),result.opts,function(err) {
                    return callback(err);
                });
            });
        } else {
            if (result.unparsed.length > 0) {
                final_args = final_args.
                              concat(['--']).
                              concat(result.unparsed);
            }
            compile.run_gyp(['configure'].concat(final_args),result.opts,function(err) {
                if (!err && result.opts.napi_build_version) {
                    napi.swap_build_dir_out(result.opts.napi_build_version);
                }
                return callback(err);
            });
        }
    });
}


/***/ }),

/***/ "./node_modules/node-pre-gyp/lib/info.js":
/*!***********************************************!*\
  !*** ./node_modules/node-pre-gyp/lib/info.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = exports = unpublish;

exports.usage = 'Lists all published binaries (requires aws-sdk)';

var fs = __webpack_require__(/*! fs */ "fs");
var log = __webpack_require__(/*! npmlog */ "./node_modules/npmlog/log.js");
var versioning = __webpack_require__(/*! ./util/versioning.js */ "./node_modules/node-pre-gyp/lib/util/versioning.js");
var s3_setup = __webpack_require__(/*! ./util/s3_setup.js */ "./node_modules/node-pre-gyp/lib/util/s3_setup.js");
var config = __webpack_require__(/*! rc */ "./node_modules/rc/index.js")("node_pre_gyp",{acl:"public-read"});

function unpublish(gyp, argv, callback) {
    var AWS = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module 'aws-sdk'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
    var package_json = JSON.parse(fs.readFileSync('./package.json'));
    var opts = versioning.evaluate(package_json, gyp.opts);
    s3_setup.detect(opts.hosted_path,config);
    AWS.config.update(config);
    var s3 =  new AWS.S3();
    var s3_opts = {  Bucket: config.bucket,
                     Prefix: config.prefix
                  };
    s3.listObjects(s3_opts, function(err, meta){
        if (err && err.code == 'NotFound') {
            return callback(new Error('['+package_json.name+'] Not found: https://' + s3_opts.Bucket + '.s3.amazonaws.com/'+config.prefix));
        } else if(err) {
            return callback(err);
        } else {
            log.verbose(JSON.stringify(meta,null,1));
            if (meta && meta.Contents) {
                meta.Contents.forEach(function(obj) {
                    console.log(obj.Key);
                });
            } else {
                console.error('['+package_json.name+'] No objects found at https://' + s3_opts.Bucket + '.s3.amazonaws.com/'+config.prefix );
            }
            return callback();
        }
    });
}


/***/ }),

/***/ "./node_modules/node-pre-gyp/lib/install.js":
/*!**************************************************!*\
  !*** ./node_modules/node-pre-gyp/lib/install.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__dirname) {

module.exports = exports = install;

exports.usage = 'Attempts to install pre-built binary for module';

var fs = __webpack_require__(/*! fs */ "fs");
var path = __webpack_require__(/*! path */ "path");
var log = __webpack_require__(/*! npmlog */ "./node_modules/npmlog/log.js");
var existsAsync = fs.exists || path.exists;
var versioning = __webpack_require__(/*! ./util/versioning.js */ "./node_modules/node-pre-gyp/lib/util/versioning.js");
var napi = __webpack_require__(/*! ./util/napi.js */ "./node_modules/node-pre-gyp/lib/util/napi.js");
var mkdirp = __webpack_require__(/*! mkdirp */ "mkdirp");

var npgVersion = 'unknown';
try {
    // Read own package.json to get the current node-pre-pyp version.
    var ownPackageJSON = fs.readFileSync(path.join(__dirname, '..', 'package.json'), 'utf8');
    npgVersion = JSON.parse(ownPackageJSON).version;
} catch (e) {}

var http_get = {
    impl: undefined,
    type: undefined
};

try {
  http_get.impl = __webpack_require__(/*! request */ "request");
  http_get.type = 'request';
  log.warn("Using request for node-pre-gyp https download");
} catch (e) {
  http_get.impl = __webpack_require__(/*! needle */ "./node_modules/needle/lib/needle.js");
  http_get.type = 'needle';
  log.warn("Using needle for node-pre-gyp https download");
}

function download(uri,opts,callback) {
    log.http('GET', uri);

    var req = null;

    // Try getting version info from the currently running npm.
    var envVersionInfo = process.env.npm_config_user_agent ||
        'node ' + process.version;

    var requestOpts = {
        uri: uri.replace('+','%2B'),
        headers: {
          'User-Agent': 'node-pre-gyp (v' + npgVersion + ', ' + envVersionInfo + ')'
        },
        follow_max: 10,
    };

    if (opts.cafile) {
        try {
            requestOpts.ca = fs.readFileSync(opts.cafile);
        } catch (e) {
            return callback(e);
        }
    } else if (opts.ca) {
        requestOpts.ca = opts.ca;
    }

    var proxyUrl = opts.proxy ||
                    process.env.http_proxy ||
                    process.env.HTTP_PROXY ||
                    process.env.npm_config_proxy;
    if (proxyUrl) {
      if (/^https?:\/\//i.test(proxyUrl)) {
        log.verbose('download', 'using proxy url: "%s"', proxyUrl);
        requestOpts.proxy = proxyUrl;
      } else {
        log.warn('download', 'ignoring invalid "proxy" config setting: "%s"', proxyUrl);
      }
    }
    try {
        req = http_get.impl.get(requestOpts.uri, requestOpts);
    } catch (e) {
        return callback(e);
    }
    if (req) {
      req.on('response', function (res) {
        log.http(res.statusCode, uri);
      });
    }
    return callback(null,req);
}

function place_binary(from,to,opts,callback) {
    download(from,opts,function(err,req) {
        if (err) return callback(err);
        if (!req) return callback(new Error("empty req"));
        var badDownload = false;
        var hasResponse = false;

        function afterExtract(err, extractCount) {
            if (err) return callback(err);
            if (badDownload) return callback(new Error("bad download"));
            if (extractCount === 0) {
                return callback(new Error('There was a fatal problem while downloading/extracting the tarball'));
            }
            log.info('tarball', 'done parsing tarball');
            callback();
        }

        // for request compatibility
        req.on('error', function(err) {
            badDownload = true;
            if (!hasResponse) {
                hasResponse = true;
                return callback(err);
            }
        });

        // for needle compatibility
        req.on('err', function(err) {
            badDownload = true;
            if (!hasResponse) {
                hasResponse = true;
                return callback(err);
            }
        });

        req.on('close', function () {
            if (!hasResponse) {
                hasResponse = true;
                return callback(new Error('Connection closed while downloading tarball file'));
            }
        });

      req.on('response', function(res) {
            // ignore redirects, needle handles these automatically.
            if (http_get.type === 'needle' && res.headers.hasOwnProperty('location') && res.headers.location !== '') {
                return;
            }
            if (hasResponse) {
                return;
            }
            hasResponse = true;
            if (res.statusCode !== 200) {
                badDownload = true;
                var err = new Error(res.statusCode + ' status code downloading tarball ' + from);
                err.statusCode = res.statusCode;
                return callback(err);
            }
            // start unzipping and untaring
            req.pipe(extract(to, afterExtract));
        });
    });
}

function extract_from_local(from, to, callback) {
    if (!fs.existsSync(from)) {
        return callback(new Error('Cannot find file ' + from));
    }
    log.info('Found local file to extract from ' + from);
    function afterExtract(err, extractCount) {
        if (err) return callback(err);
        if (extractCount === 0) {
            return callback(new Error('There was a fatal problem while extracting the tarball'));
        }
        log.info('tarball', 'done parsing tarball');
        callback();
    }
    fs.createReadStream(from).pipe(extract(to, afterExtract));
}

function extract(to, callback) {
    var extractCount = 0;
    function filter_func(entry) {
        log.info('install','unpacking ' + entry.path);
        extractCount++;
    }

    function afterTarball(err) {
        callback(err, extractCount);
    }

    var tar = __webpack_require__(/*! tar */ "./node_modules/tar/index.js");
    return tar.extract({
        cwd: to,
        strip: 1,
        onentry: filter_func
    }).on('close', afterTarball).on('error', callback);
}


function do_build(gyp,argv,callback) {
  var args = ['rebuild'].concat(argv);
  gyp.todo.push( { name: 'build', args: args } );
  process.nextTick(callback);
}

function print_fallback_error(err,opts,package_json) {
    var fallback_message = ' (falling back to source compile with node-gyp)';
    var full_message = '';
    if (err.statusCode !== undefined) {
        // If we got a network response it but failed to download
        // it means remote binaries are not available, so let's try to help
        // the user/developer with the info to debug why
        full_message = "Pre-built binaries not found for " + package_json.name + "@" + package_json.version;
        full_message += " and " + opts.runtime + "@" + (opts.target || process.versions.node) + " (" + opts.node_abi + " ABI, " + opts.libc + ")";
        full_message += fallback_message;
        log.warn("Tried to download(" + err.statusCode + "): " + opts.hosted_tarball);
        log.warn(full_message);
        log.http(err.message);
    } else {
        // If we do not have a statusCode that means an unexpected error
        // happened and prevented an http response, so we output the exact error
        full_message = "Pre-built binaries not installable for " + package_json.name + "@" + package_json.version;
        full_message += " and " + opts.runtime + "@" + (opts.target || process.versions.node) + " (" + opts.node_abi + " ABI, " + opts.libc + ")";
        full_message += fallback_message;
        log.warn(full_message);
        log.warn("Hit error " + err.message);
    }
}

function install(gyp, argv, callback) {
    var package_json = JSON.parse(fs.readFileSync('./package.json'));
	var napi_build_version = napi.get_napi_build_version_from_command_args(argv);
    var source_build = gyp.opts['build-from-source'] || gyp.opts.build_from_source;
    var update_binary = gyp.opts['update-binary'] || gyp.opts.update_binary;
    var should_do_source_build = source_build === package_json.name || (source_build === true || source_build === 'true');
    if (should_do_source_build) {
        log.info('build','requesting source compile');
        return do_build(gyp,argv,callback);
    } else {
        var fallback_to_build = gyp.opts['fallback-to-build'] || gyp.opts.fallback_to_build;
        var should_do_fallback_build = fallback_to_build === package_json.name || (fallback_to_build === true || fallback_to_build === 'true');
        // but allow override from npm
        if (process.env.npm_config_argv) {
            var cooked = JSON.parse(process.env.npm_config_argv).cooked;
            var match = cooked.indexOf("--fallback-to-build");
            if (match > -1 && cooked.length > match && cooked[match+1] == "false") {
                should_do_fallback_build = false;
                log.info('install','Build fallback disabled via npm flag: --fallback-to-build=false');
            }
        }
        var opts;
        try {
            opts = versioning.evaluate(package_json, gyp.opts, napi_build_version);
        } catch (err) {
            return callback(err);
        }

        opts.ca = gyp.opts.ca;
        opts.cafile = gyp.opts.cafile;

        var from = opts.hosted_tarball;
        var to = opts.module_path;
        var binary_module = path.join(to,opts.module_name + '.node');
        existsAsync(binary_module,function(found) {
            if (found && !update_binary) {
                console.log('['+package_json.name+'] Success: "' + binary_module + '" already installed');
                console.log('Pass --update-binary to reinstall or --build-from-source to recompile');
                return callback();
            } else {
                if (!update_binary) log.info('check','checked for "' + binary_module + '" (not found)');
                mkdirp(to,function(err) {
                    if (err) {
                        after_place(err);
                    } else {
                        var fileName = from.startsWith('file://') && from.replace(/^file:\/\//, '');
                        if (fileName) {
                            extract_from_local(fileName, to, after_place);
                        } else {
                            place_binary(from,to,opts,after_place);
                        }
                    }
                });
            }
            function after_place(err) {
                if (err && should_do_fallback_build) {
                    print_fallback_error(err,opts,package_json);
                    return do_build(gyp,argv,callback);
                } else if (err) {
                    return callback(err);
                } else {
                    console.log('['+package_json.name+'] Success: "' + binary_module + '" is installed via remote');
                    return callback();
                }
            }
        });
    }
}

/* WEBPACK VAR INJECTION */}.call(this, "/"))

/***/ }),

/***/ "./node_modules/node-pre-gyp/lib/node-pre-gyp.js":
/*!*******************************************************!*\
  !*** ./node_modules/node-pre-gyp/lib/node-pre-gyp.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__dirname) {

/**
 * Module exports.
 */

module.exports = exports;

/**
 * Module dependencies.
 */

var fs = __webpack_require__(/*! fs */ "fs");
var path = __webpack_require__(/*! path */ "path");
var nopt = __webpack_require__(/*! nopt */ "./node_modules/nopt/lib/nopt.js");
var log = __webpack_require__(/*! npmlog */ "./node_modules/npmlog/log.js");
log.disableProgress();
var napi = __webpack_require__(/*! ./util/napi.js */ "./node_modules/node-pre-gyp/lib/util/napi.js");

var EE = __webpack_require__(/*! events */ "events").EventEmitter;
var inherits = __webpack_require__(/*! util */ "util").inherits;
var commands = [
      'clean',
      'install',
      'reinstall',
      'build',
      'rebuild',
      'package',
      'testpackage',
      'publish',
      'unpublish',
      'info',
      'testbinary',
      'reveal',
      'configure'
    ];
var aliases = {};

// differentiate node-pre-gyp's logs from npm's
log.heading = 'node-pre-gyp';

exports.find = __webpack_require__(/*! ./pre-binding */ "./node_modules/node-pre-gyp/lib/pre-binding.js").find;

function Run() {
  var self = this;

  this.commands = {};

  commands.forEach(function (command) {
    self.commands[command] = function (argv, callback) {
      log.verbose('command', command, argv);
      return __webpack_require__("./node_modules/node-pre-gyp/lib sync recursive ^\\.\\/.*$")("./" + command)(self, argv, callback);
    };
  });
}
inherits(Run, EE);
exports.Run = Run;
var proto = Run.prototype;

/**
 * Export the contents of the package.json.
 */

proto.package = __webpack_require__(/*! ../package.json */ "./node_modules/node-pre-gyp/package.json");

/**
 * nopt configuration definitions
 */

proto.configDefs = {
    help: Boolean,     // everywhere
    arch: String,      // 'configure'
    debug: Boolean,    // 'build'
    directory: String, // bin
    proxy: String,     // 'install'
    loglevel: String,  // everywhere
};

/**
 * nopt shorthands
 */

proto.shorthands = {
    release: '--no-debug',
    C: '--directory',
    debug: '--debug',
    j: '--jobs',
    silent: '--loglevel=silent',
    silly: '--loglevel=silly',
    verbose: '--loglevel=verbose',
};

/**
 * expose the command aliases for the bin file to use.
 */

proto.aliases = aliases;

/**
 * Parses the given argv array and sets the 'opts',
 * 'argv' and 'command' properties.
 */

proto.parseArgv = function parseOpts (argv) {
  this.opts = nopt(this.configDefs, this.shorthands, argv);
  this.argv = this.opts.argv.remain.slice();
  var commands = this.todo = [];

  // create a copy of the argv array with aliases mapped
  argv = this.argv.map(function (arg) {
    // is this an alias?
    if (arg in this.aliases) {
      arg = this.aliases[arg];
    }
    return arg;
  }, this);

  // process the mapped args into "command" objects ("name" and "args" props)
  argv.slice().forEach(function (arg) {
    if (arg in this.commands) {
      var args = argv.splice(0, argv.indexOf(arg));
      argv.shift();
      if (commands.length > 0) {
        commands[commands.length - 1].args = args;
      }
      commands.push({ name: arg, args: [] });
    }
  }, this);
  if (commands.length > 0) {
    commands[commands.length - 1].args = argv.splice(0);
  }

  // expand commands entries for multiple napi builds
  var dir = this.opts.directory;
  if (dir == null) dir = process.cwd();
  var package_json = JSON.parse(fs.readFileSync(path.join(dir,'package.json')));

  this.todo = napi.expand_commands (package_json, this.opts, commands);

  // support for inheriting config env variables from npm
  var npm_config_prefix = 'npm_config_';
  Object.keys(process.env).forEach(function (name) {
    if (name.indexOf(npm_config_prefix) !== 0) return;
    var val = process.env[name];
    if (name === npm_config_prefix + 'loglevel') {
      log.level = val;
    } else {
      // add the user-defined options to the config
      name = name.substring(npm_config_prefix.length);
      // avoid npm argv clobber already present args
      // which avoids problem of 'npm test' calling
      // script that runs unique npm install commands
      if (name === 'argv') {
         if (this.opts.argv &&
             this.opts.argv.remain &&
             this.opts.argv.remain.length) {
            // do nothing
         } else {
            this.opts[name] = val;
         }
      } else {
        this.opts[name] = val;
      }
    }
  }, this);

  if (this.opts.loglevel) {
    log.level = this.opts.loglevel;
  }
  log.resume();
};

/**
 * Returns the usage instructions for node-pre-gyp.
 */

proto.usage = function usage () {
  var str = [
      '',
      '  Usage: node-pre-gyp <command> [options]',
      '',
      '  where <command> is one of:',
      commands.map(function (c) {
        return '    - ' + c + ' - ' + __webpack_require__("./node_modules/node-pre-gyp/lib sync recursive ^\\.\\/.*$")("./" + c).usage;
      }).join('\n'),
      '',
      'node-pre-gyp@' + this.version + '  ' + path.resolve(__dirname, '..'),
      'node@' + process.versions.node
  ].join('\n');
  return str;
};

/**
 * Version number getter.
 */

Object.defineProperty(proto, 'version', {
    get: function () {
      return this.package.version;
    },
    enumerable: true
});


/* WEBPACK VAR INJECTION */}.call(this, "/"))

/***/ }),

/***/ "./node_modules/node-pre-gyp/lib/package.js":
/*!**************************************************!*\
  !*** ./node_modules/node-pre-gyp/lib/package.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = exports = _package;

exports.usage = 'Packs binary (and enclosing directory) into locally staged tarball';

var fs = __webpack_require__(/*! fs */ "fs");
var path = __webpack_require__(/*! path */ "path");
var log = __webpack_require__(/*! npmlog */ "./node_modules/npmlog/log.js");
var versioning = __webpack_require__(/*! ./util/versioning.js */ "./node_modules/node-pre-gyp/lib/util/versioning.js");
var napi = __webpack_require__(/*! ./util/napi.js */ "./node_modules/node-pre-gyp/lib/util/napi.js");
var write = __webpack_require__(/*! fs */ "fs").createWriteStream;
var existsAsync = fs.exists || path.exists;
var mkdirp = __webpack_require__(/*! mkdirp */ "mkdirp");
var tar = __webpack_require__(/*! tar */ "./node_modules/tar/index.js");

function _package(gyp, argv, callback) {
    var packlist = __webpack_require__(/*! npm-packlist */ "./node_modules/npm-packlist/index.js");
    var package_json = JSON.parse(fs.readFileSync('./package.json'));
    var napi_build_version = napi.get_napi_build_version_from_command_args(argv);
    var opts = versioning.evaluate(package_json, gyp.opts, napi_build_version);
    var from = opts.module_path;
    var binary_module = path.join(from,opts.module_name + '.node');
    existsAsync(binary_module,function(found) {
        if (!found) {
            return callback(new Error("Cannot package because " + binary_module + " missing: run `node-pre-gyp rebuild` first"));
        }
        var tarball = opts.staged_tarball;
        var filter_func = function(entry) {
            // ensure directories are +x
            // https://github.com/mapnik/node-mapnik/issues/262
            log.info('package','packing ' + entry.path);
            return true;
        };
        mkdirp(path.dirname(tarball),function(err) {
            if (err) return callback(err);
            packlist({ path: from }).then(function(files) {
                var base = path.basename(from);
                files = files.map(function(file) {
                    return path.join(base, file);
                });
                tar.create({
                    portable: true,
                    gzip: true,
                    onentry: filter_func,
                    file: tarball,
                    cwd: path.dirname(from)
                }, files, function(err) {
                    if (err)  console.error('['+package_json.name+'] ' + err.message);
                    else log.info('package','Binary staged at "' + tarball + '"');
                    return callback(err);
                });
            }, callback);
        });
    });
}


/***/ }),

/***/ "./node_modules/node-pre-gyp/lib/pre-binding.js":
/*!******************************************************!*\
  !*** ./node_modules/node-pre-gyp/lib/pre-binding.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var versioning = __webpack_require__(/*! ../lib/util/versioning.js */ "./node_modules/node-pre-gyp/lib/util/versioning.js");
var napi = __webpack_require__(/*! ../lib/util/napi.js */ "./node_modules/node-pre-gyp/lib/util/napi.js");
var existsSync = __webpack_require__(/*! fs */ "fs").existsSync || __webpack_require__(/*! path */ "path").existsSync;
var path = __webpack_require__(/*! path */ "path");

module.exports = exports;

exports.usage = 'Finds the require path for the node-pre-gyp installed module';

exports.validate = function(package_json,opts) {
    versioning.validate_config(package_json,opts);
};

exports.find = function(package_json_path,opts) {
   if (!existsSync(package_json_path)) {
        throw new Error("package.json does not exist at " + package_json_path);
   }
   var package_json = __webpack_require__("./node_modules/node-pre-gyp/lib sync recursive")(package_json_path);
   versioning.validate_config(package_json,opts);
   var napi_build_version;
   if (napi.get_napi_build_versions (package_json, opts)) {
       napi_build_version = napi.get_best_napi_build_version(package_json, opts);
   }
   opts = opts || {};
   if (!opts.module_root) opts.module_root = path.dirname(package_json_path);
   var meta = versioning.evaluate(package_json,opts,napi_build_version);
   return meta.module;
};


/***/ }),

/***/ "./node_modules/node-pre-gyp/lib/publish.js":
/*!**************************************************!*\
  !*** ./node_modules/node-pre-gyp/lib/publish.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = exports = publish;

exports.usage = 'Publishes pre-built binary (requires aws-sdk)';

var fs = __webpack_require__(/*! fs */ "fs");
var path = __webpack_require__(/*! path */ "path");
var log = __webpack_require__(/*! npmlog */ "./node_modules/npmlog/log.js");
var versioning = __webpack_require__(/*! ./util/versioning.js */ "./node_modules/node-pre-gyp/lib/util/versioning.js");
var napi = __webpack_require__(/*! ./util/napi.js */ "./node_modules/node-pre-gyp/lib/util/napi.js");
var s3_setup = __webpack_require__(/*! ./util/s3_setup.js */ "./node_modules/node-pre-gyp/lib/util/s3_setup.js");
var existsAsync = fs.exists || path.exists;
var url = __webpack_require__(/*! url */ "url");
var config = __webpack_require__(/*! rc */ "./node_modules/rc/index.js")("node_pre_gyp",{acl:"public-read"});

function publish(gyp, argv, callback) {
    var AWS = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module 'aws-sdk'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
    var package_json = JSON.parse(fs.readFileSync('./package.json'));
    var napi_build_version = napi.get_napi_build_version_from_command_args(argv);
    var opts = versioning.evaluate(package_json, gyp.opts, napi_build_version);
    var tarball = opts.staged_tarball;
    existsAsync(tarball,function(found) {
        if (!found) {
            return callback(new Error("Cannot publish because " + tarball + " missing: run `node-pre-gyp package` first"));
        }
        log.info('publish', 'Detecting s3 credentials');
        s3_setup.detect(opts.hosted_path,config);
        var key_name = url.resolve(config.prefix,opts.package_name);
        log.info('publish', 'Authenticating with s3');
        AWS.config.update(config);
        var s3 =  new AWS.S3();
        var s3_opts = {  Bucket: config.bucket,
                         Key: key_name
                      };
        var remote_package = 'https://' + s3_opts.Bucket + '.s3.amazonaws.com/' + s3_opts.Key;
        log.info('publish', 'Checking for existing binary at ' + remote_package);
        s3.headObject(s3_opts, function(err, meta){
            if (meta) log.info('publish', JSON.stringify(meta));
            if (err && err.code == 'NotFound') {
                // we are safe to publish because
                // the object does not already exist
                log.info('publish', 'Preparing to put object');
                var s3_put = new AWS.S3();
                var s3_put_opts = {  ACL: config.acl,
                                     Body: fs.createReadStream(tarball),
                                     Bucket: config.bucket,
                                     Key: key_name
                                  };
                log.info('publish', 'Putting object');
                try {
                    s3_put.putObject(s3_put_opts, function(err, resp){
                        log.info('publish', 'returned from putting object');
                        if(err) {
                           log.info('publish', 's3 putObject error: "' + err + '"');
                           return callback(err);
                        }
                        if (resp) log.info('publish', 's3 putObject response: "' + JSON.stringify(resp) + '"');
                        log.info('publish', 'successfully put object');
                        console.log('['+package_json.name+'] published to ' + remote_package);
                        return callback();
                    });
              } catch (err) {
                   log.info('publish', 's3 putObject error: "' + err + '"');
                   return callback(err);
              }
            } else if (err) {
                log.info('publish', 's3 headObject error: "' + err + '"');
                return callback(err);
            } else {
                log.error('publish','Cannot publish over existing version');
                log.error('publish',"Update the 'version' field in package.json and try again");
                log.error('publish','If the previous version was published in error see:');
                log.error('publish','\t node-pre-gyp unpublish');
                return callback(new Error('Failed publishing to ' + remote_package));
            }
        });
    });
}


/***/ }),

/***/ "./node_modules/node-pre-gyp/lib/rebuild.js":
/*!**************************************************!*\
  !*** ./node_modules/node-pre-gyp/lib/rebuild.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = exports = rebuild;

exports.usage = 'Runs "clean" and "build" at once';

var fs = __webpack_require__(/*! fs */ "fs");
var napi = __webpack_require__(/*! ./util/napi.js */ "./node_modules/node-pre-gyp/lib/util/napi.js");

function rebuild (gyp, argv, callback) {
  var package_json = JSON.parse(fs.readFileSync('./package.json'));
  var commands = [
    { name: 'clean', args: [] },
    { name: 'build', args: ['rebuild'] }
    ];
  commands = napi.expand_commands(package_json, gyp.opts, commands);
  for (var i = commands.length; i !== 0; i--) {
    gyp.todo.unshift(commands[i-1]);
  }
  process.nextTick(callback);
}


/***/ }),

/***/ "./node_modules/node-pre-gyp/lib/reinstall.js":
/*!****************************************************!*\
  !*** ./node_modules/node-pre-gyp/lib/reinstall.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = exports = rebuild;

exports.usage = 'Runs "clean" and "install" at once';

var fs = __webpack_require__(/*! fs */ "fs");
var napi = __webpack_require__(/*! ./util/napi.js */ "./node_modules/node-pre-gyp/lib/util/napi.js");

function rebuild (gyp, argv, callback) {
  var package_json = JSON.parse(fs.readFileSync('./package.json'));
  var installArgs = [];
  var napi_build_version = napi.get_best_napi_build_version(package_json, gyp.opts);
  if (napi_build_version != null) installArgs = [ napi.get_command_arg (napi_build_version) ];
  gyp.todo.unshift(
      { name: 'clean', args: [] },
      { name: 'install', args: installArgs }
  );
  process.nextTick(callback);
}


/***/ }),

/***/ "./node_modules/node-pre-gyp/lib/reveal.js":
/*!*************************************************!*\
  !*** ./node_modules/node-pre-gyp/lib/reveal.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = exports = reveal;

exports.usage = 'Reveals data on the versioned binary';

var fs = __webpack_require__(/*! fs */ "fs");
var versioning = __webpack_require__(/*! ./util/versioning.js */ "./node_modules/node-pre-gyp/lib/util/versioning.js");
var napi = __webpack_require__(/*! ./util/napi.js */ "./node_modules/node-pre-gyp/lib/util/napi.js");

function unix_paths(key, val) {
    return val && val.replace ? val.replace(/\\/g, '/') : val;
}

function reveal(gyp, argv, callback) {
    var package_json = JSON.parse(fs.readFileSync('./package.json'));
    var napi_build_version = napi.get_napi_build_version_from_command_args(argv);
    var opts = versioning.evaluate(package_json, gyp.opts, napi_build_version);
    var hit = false;
    // if a second arg is passed look to see
    // if it is a known option
    //console.log(JSON.stringify(gyp.opts,null,1))
    var remain = gyp.opts.argv.remain[gyp.opts.argv.remain.length-1];
    if (remain && opts.hasOwnProperty(remain)) {
        console.log(opts[remain].replace(/\\/g, '/'));
        hit = true;
    }
    // otherwise return all options as json
    if (!hit) {
        console.log(JSON.stringify(opts,unix_paths,2));
    }
    return callback();
}


/***/ }),

/***/ "./node_modules/node-pre-gyp/lib/testbinary.js":
/*!*****************************************************!*\
  !*** ./node_modules/node-pre-gyp/lib/testbinary.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__dirname) {

module.exports = exports = testbinary;

exports.usage = 'Tests that the binary.node can be required';

var fs = __webpack_require__(/*! fs */ "fs");
var path = __webpack_require__(/*! path */ "path");
var log = __webpack_require__(/*! npmlog */ "./node_modules/npmlog/log.js");
var cp = __webpack_require__(/*! child_process */ "child_process");
var versioning = __webpack_require__(/*! ./util/versioning.js */ "./node_modules/node-pre-gyp/lib/util/versioning.js");
var napi = __webpack_require__(/*! ./util/napi.js */ "./node_modules/node-pre-gyp/lib/util/napi.js");
var path = __webpack_require__(/*! path */ "path");

function testbinary(gyp, argv, callback) {
    var args = [];
    var options = {};
    var shell_cmd = process.execPath;
    var package_json = JSON.parse(fs.readFileSync('./package.json'));
    var napi_build_version = napi.get_napi_build_version_from_command_args(argv);
    var opts = versioning.evaluate(package_json, gyp.opts, napi_build_version);
    // skip validation for runtimes we don't explicitly support (like electron)
    if (opts.runtime &&
        opts.runtime !== 'node-webkit' &&
        opts.runtime !== 'node') {
        return callback();
    }
    var nw = (opts.runtime && opts.runtime === 'node-webkit');
    // ensure on windows that / are used for require path
    var binary_module = opts.module.replace(/\\/g, '/');
    if ((process.arch != opts.target_arch) ||
        (process.platform != opts.target_platform)) {
        var msg = "skipping validation since host platform/arch (";
        msg += process.platform+'/'+process.arch+")";
        msg += " does not match target (";
        msg += opts.target_platform+'/'+opts.target_arch+")";
        log.info('validate', msg);
        return callback();
    }
    if (nw) {
        options.timeout = 5000;
        if (process.platform === 'darwin') {
            shell_cmd = 'node-webkit';
        } else if (process.platform === 'win32') {
            shell_cmd = 'nw.exe';
        } else {
            shell_cmd = 'nw';
        }
        var modulePath = path.resolve(binary_module);
        var appDir = path.join(__dirname, 'util', 'nw-pre-gyp');
        args.push(appDir);
        args.push(modulePath);
        log.info("validate","Running test command: '" + shell_cmd + ' ' + args.join(' ') + "'");
        cp.execFile(shell_cmd, args, options, function(err, stdout, stderr) {
            // check for normal timeout for node-webkit
            if (err) {
                if (err.killed === true && err.signal && err.signal.indexOf('SIG') > -1) {
                    return callback();
                }
                var stderrLog = stderr.toString();
                log.info('stderr', stderrLog);
                if( /^\s*Xlib:\s*extension\s*"RANDR"\s*missing\s*on\s*display\s*":\d+\.\d+"\.\s*$/.test(stderrLog) ){
                    log.info('RANDR', 'stderr contains only RANDR error, ignored');
                    return callback();
                }
                return callback(err);
            }
            return callback();
        });
        return;
    }
    args.push('--eval');
    args.push("require('" + binary_module.replace(/'/g, '\'') +"')");
    log.info("validate","Running test command: '" + shell_cmd + ' ' + args.join(' ') + "'");
    cp.execFile(shell_cmd, args, options, function(err, stdout, stderr) {
        if (err) {
            return callback(err, { stdout:stdout, stderr:stderr});
        }
        return callback();
    });
}

/* WEBPACK VAR INJECTION */}.call(this, "/"))

/***/ }),

/***/ "./node_modules/node-pre-gyp/lib/testpackage.js":
/*!******************************************************!*\
  !*** ./node_modules/node-pre-gyp/lib/testpackage.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = exports = testpackage;

exports.usage = 'Tests that the staged package is valid';

var fs = __webpack_require__(/*! fs */ "fs");
var path = __webpack_require__(/*! path */ "path");
var log = __webpack_require__(/*! npmlog */ "./node_modules/npmlog/log.js");
var existsAsync = fs.exists || path.exists;
var versioning = __webpack_require__(/*! ./util/versioning.js */ "./node_modules/node-pre-gyp/lib/util/versioning.js");
var napi = __webpack_require__(/*! ./util/napi.js */ "./node_modules/node-pre-gyp/lib/util/napi.js");
var testbinary = __webpack_require__(/*! ./testbinary.js */ "./node_modules/node-pre-gyp/lib/testbinary.js");
var tar = __webpack_require__(/*! tar */ "./node_modules/tar/index.js");
var mkdirp = __webpack_require__(/*! mkdirp */ "mkdirp");

function testpackage(gyp, argv, callback) {
    var package_json = JSON.parse(fs.readFileSync('./package.json'));
    var napi_build_version = napi.get_napi_build_version_from_command_args(argv);
    var opts = versioning.evaluate(package_json, gyp.opts, napi_build_version);
    var tarball = opts.staged_tarball;
    existsAsync(tarball, function(found) {
        if (!found) {
            return callback(new Error("Cannot test package because " + tarball + " missing: run `node-pre-gyp package` first"));
        }
        var to = opts.module_path;
        function filter_func(entry) {
            log.info('install','unpacking [' + entry.path + ']');
        }

        mkdirp(to, function(err) {
            if (err) {
                return callback(err);
            } else {
                tar.extract({
                    file: tarball,
                    cwd: to,
                    strip: 1,
                    onentry: filter_func
                }).then(after_extract, callback);
            }
        });

        function after_extract() {
            testbinary(gyp,argv,function(err) {
                if (err) {
                    return callback(err);
                } else {
                    console.log('['+package_json.name+'] Package appears valid');
                    return callback();
                }
            });
        }
    });
}


/***/ }),

/***/ "./node_modules/node-pre-gyp/lib/unpublish.js":
/*!****************************************************!*\
  !*** ./node_modules/node-pre-gyp/lib/unpublish.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = exports = unpublish;

exports.usage = 'Unpublishes pre-built binary (requires aws-sdk)';

var fs = __webpack_require__(/*! fs */ "fs");
var log = __webpack_require__(/*! npmlog */ "./node_modules/npmlog/log.js");
var versioning = __webpack_require__(/*! ./util/versioning.js */ "./node_modules/node-pre-gyp/lib/util/versioning.js");
var napi = __webpack_require__(/*! ./util/napi.js */ "./node_modules/node-pre-gyp/lib/util/napi.js");
var s3_setup = __webpack_require__(/*! ./util/s3_setup.js */ "./node_modules/node-pre-gyp/lib/util/s3_setup.js");
var url = __webpack_require__(/*! url */ "url");
var config = __webpack_require__(/*! rc */ "./node_modules/rc/index.js")("node_pre_gyp",{acl:"public-read"});

function unpublish(gyp, argv, callback) {
    var AWS = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module 'aws-sdk'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
    var package_json = JSON.parse(fs.readFileSync('./package.json'));
    var napi_build_version = napi.get_napi_build_version_from_command_args(argv);
    var opts = versioning.evaluate(package_json, gyp.opts, napi_build_version);
    s3_setup.detect(opts.hosted_path,config);
    AWS.config.update(config);
    var key_name = url.resolve(config.prefix,opts.package_name);
    var s3 =  new AWS.S3();
    var s3_opts = {  Bucket: config.bucket,
                     Key: key_name
                  };
    s3.headObject(s3_opts, function(err, meta) {
        if (err && err.code == 'NotFound') {
            console.log('['+package_json.name+'] Not found: https://' + s3_opts.Bucket + '.s3.amazonaws.com/' + s3_opts.Key);
            return callback();
        } else if(err) {
            return callback(err);
        } else {
            log.info('unpublish', JSON.stringify(meta));
            s3.deleteObject(s3_opts, function(err, resp) {
                if (err) return callback(err);
                log.info(JSON.stringify(resp));
                console.log('['+package_json.name+'] Success: removed https://' + s3_opts.Bucket + '.s3.amazonaws.com/' + s3_opts.Key);
                return callback();
            });
        }
    });
}


/***/ }),

/***/ "./node_modules/node-pre-gyp/lib/util sync recursive":
/*!*************************************************!*\
  !*** ./node_modules/node-pre-gyp/lib/util sync ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = "./node_modules/node-pre-gyp/lib/util sync recursive";

/***/ }),

/***/ "./node_modules/node-pre-gyp/lib/util/abi_crosswalk.json":
/*!***************************************************************!*\
  !*** ./node_modules/node-pre-gyp/lib/util/abi_crosswalk.json ***!
  \***************************************************************/
/*! exports provided: 0.1.14, 0.1.15, 0.1.16, 0.1.17, 0.1.18, 0.1.19, 0.1.20, 0.1.21, 0.1.22, 0.1.23, 0.1.24, 0.1.25, 0.1.26, 0.1.27, 0.1.28, 0.1.29, 0.1.30, 0.1.31, 0.1.32, 0.1.33, 0.1.90, 0.1.91, 0.1.92, 0.1.93, 0.1.94, 0.1.95, 0.1.96, 0.1.97, 0.1.98, 0.1.99, 0.1.100, 0.1.101, 0.1.102, 0.1.103, 0.1.104, 0.2.0, 0.2.1, 0.2.2, 0.2.3, 0.2.4, 0.2.5, 0.2.6, 0.3.0, 0.3.1, 0.3.2, 0.3.3, 0.3.4, 0.3.5, 0.3.6, 0.3.7, 0.3.8, 0.4.0, 0.4.1, 0.4.2, 0.4.3, 0.4.4, 0.4.5, 0.4.6, 0.4.7, 0.4.8, 0.4.9, 0.4.10, 0.4.11, 0.4.12, 0.5.0, 0.5.1, 0.5.2, 0.5.3, 0.5.4, 0.5.5, 0.5.6, 0.5.7, 0.5.8, 0.5.9, 0.5.10, 0.6.0, 0.6.1, 0.6.2, 0.6.3, 0.6.4, 0.6.5, 0.6.6, 0.6.7, 0.6.8, 0.6.9, 0.6.10, 0.6.11, 0.6.12, 0.6.13, 0.6.14, 0.6.15, 0.6.16, 0.6.17, 0.6.18, 0.6.19, 0.6.20, 0.6.21, 0.7.0, 0.7.1, 0.7.2, 0.7.3, 0.7.4, 0.7.5, 0.7.6, 0.7.7, 0.7.8, 0.7.9, 0.7.10, 0.7.11, 0.7.12, 0.8.0, 0.8.1, 0.8.2, 0.8.3, 0.8.4, 0.8.5, 0.8.6, 0.8.7, 0.8.8, 0.8.9, 0.8.10, 0.8.11, 0.8.12, 0.8.13, 0.8.14, 0.8.15, 0.8.16, 0.8.17, 0.8.18, 0.8.19, 0.8.20, 0.8.21, 0.8.22, 0.8.23, 0.8.24, 0.8.25, 0.8.26, 0.8.27, 0.8.28, 0.9.0, 0.9.1, 0.9.2, 0.9.3, 0.9.4, 0.9.5, 0.9.6, 0.9.7, 0.9.8, 0.9.9, 0.9.10, 0.9.11, 0.9.12, 0.10.0, 0.10.1, 0.10.2, 0.10.3, 0.10.4, 0.10.5, 0.10.6, 0.10.7, 0.10.8, 0.10.9, 0.10.10, 0.10.11, 0.10.12, 0.10.13, 0.10.14, 0.10.15, 0.10.16, 0.10.17, 0.10.18, 0.10.19, 0.10.20, 0.10.21, 0.10.22, 0.10.23, 0.10.24, 0.10.25, 0.10.26, 0.10.27, 0.10.28, 0.10.29, 0.10.30, 0.10.31, 0.10.32, 0.10.33, 0.10.34, 0.10.35, 0.10.36, 0.10.37, 0.10.38, 0.10.39, 0.10.40, 0.10.41, 0.10.42, 0.10.43, 0.10.44, 0.10.45, 0.10.46, 0.10.47, 0.10.48, 0.11.0, 0.11.1, 0.11.2, 0.11.3, 0.11.4, 0.11.5, 0.11.6, 0.11.7, 0.11.8, 0.11.9, 0.11.10, 0.11.11, 0.11.12, 0.11.13, 0.11.14, 0.11.15, 0.11.16, 0.12.0, 0.12.1, 0.12.2, 0.12.3, 0.12.4, 0.12.5, 0.12.6, 0.12.7, 0.12.8, 0.12.9, 0.12.10, 0.12.11, 0.12.12, 0.12.13, 0.12.14, 0.12.15, 0.12.16, 0.12.17, 0.12.18, 1.0.0, 1.0.1, 1.0.2, 1.0.3, 1.0.4, 1.1.0, 1.2.0, 1.3.0, 1.4.1, 1.4.2, 1.4.3, 1.5.0, 1.5.1, 1.6.0, 1.6.1, 1.6.2, 1.6.3, 1.6.4, 1.7.1, 1.8.1, 1.8.2, 1.8.3, 1.8.4, 2.0.0, 2.0.1, 2.0.2, 2.1.0, 2.2.0, 2.2.1, 2.3.0, 2.3.1, 2.3.2, 2.3.3, 2.3.4, 2.4.0, 2.5.0, 3.0.0, 3.1.0, 3.2.0, 3.3.0, 3.3.1, 4.0.0, 4.1.0, 4.1.1, 4.1.2, 4.2.0, 4.2.1, 4.2.2, 4.2.3, 4.2.4, 4.2.5, 4.2.6, 4.3.0, 4.3.1, 4.3.2, 4.4.0, 4.4.1, 4.4.2, 4.4.3, 4.4.4, 4.4.5, 4.4.6, 4.4.7, 4.5.0, 4.6.0, 4.6.1, 4.6.2, 4.7.0, 4.7.1, 4.7.2, 4.7.3, 4.8.0, 4.8.1, 4.8.2, 4.8.3, 4.8.4, 4.8.5, 4.8.6, 4.8.7, 4.9.0, 4.9.1, 5.0.0, 5.1.0, 5.1.1, 5.2.0, 5.3.0, 5.4.0, 5.4.1, 5.5.0, 5.6.0, 5.7.0, 5.7.1, 5.8.0, 5.9.0, 5.9.1, 5.10.0, 5.10.1, 5.11.0, 5.11.1, 5.12.0, 6.0.0, 6.1.0, 6.2.0, 6.2.1, 6.2.2, 6.3.0, 6.3.1, 6.4.0, 6.5.0, 6.6.0, 6.7.0, 6.8.0, 6.8.1, 6.9.0, 6.9.1, 6.9.2, 6.9.3, 6.9.4, 6.9.5, 6.10.0, 6.10.1, 6.10.2, 6.10.3, 6.11.0, 6.11.1, 6.11.2, 6.11.3, 6.11.4, 6.11.5, 6.12.0, 6.12.1, 6.12.2, 6.12.3, 6.13.0, 6.13.1, 6.14.0, 6.14.1, 6.14.2, 6.14.3, 6.14.4, 6.15.0, 6.15.1, 6.16.0, 6.17.0, 6.17.1, 7.0.0, 7.1.0, 7.2.0, 7.2.1, 7.3.0, 7.4.0, 7.5.0, 7.6.0, 7.7.0, 7.7.1, 7.7.2, 7.7.3, 7.7.4, 7.8.0, 7.9.0, 7.10.0, 7.10.1, 8.0.0, 8.1.0, 8.1.1, 8.1.2, 8.1.3, 8.1.4, 8.2.0, 8.2.1, 8.3.0, 8.4.0, 8.5.0, 8.6.0, 8.7.0, 8.8.0, 8.8.1, 8.9.0, 8.9.1, 8.9.2, 8.9.3, 8.9.4, 8.10.0, 8.11.0, 8.11.1, 8.11.2, 8.11.3, 8.11.4, 8.12.0, 8.13.0, 8.14.0, 8.14.1, 8.15.0, 8.15.1, 8.16.0, 8.16.1, 8.16.2, 8.17.0, 9.0.0, 9.1.0, 9.2.0, 9.2.1, 9.3.0, 9.4.0, 9.5.0, 9.6.0, 9.6.1, 9.7.0, 9.7.1, 9.8.0, 9.9.0, 9.10.0, 9.10.1, 9.11.0, 9.11.1, 9.11.2, 10.0.0, 10.1.0, 10.2.0, 10.2.1, 10.3.0, 10.4.0, 10.4.1, 10.5.0, 10.6.0, 10.7.0, 10.8.0, 10.9.0, 10.10.0, 10.11.0, 10.12.0, 10.13.0, 10.14.0, 10.14.1, 10.14.2, 10.15.0, 10.15.1, 10.15.2, 10.15.3, 10.16.0, 10.16.1, 10.16.2, 10.16.3, 10.17.0, 10.18.0, 10.18.1, 10.19.0, 10.20.0, 10.20.1, 11.0.0, 11.1.0, 11.2.0, 11.3.0, 11.4.0, 11.5.0, 11.6.0, 11.7.0, 11.8.0, 11.9.0, 11.10.0, 11.10.1, 11.11.0, 11.12.0, 11.13.0, 11.14.0, 11.15.0, 12.0.0, 12.1.0, 12.2.0, 12.3.0, 12.3.1, 12.4.0, 12.5.0, 12.6.0, 12.7.0, 12.8.0, 12.8.1, 12.9.0, 12.9.1, 12.10.0, 12.11.0, 12.11.1, 12.12.0, 12.13.0, 12.13.1, 12.14.0, 12.14.1, 12.15.0, 12.16.0, 12.16.1, 12.16.2, 12.16.3, 13.0.0, 13.0.1, 13.1.0, 13.2.0, 13.3.0, 13.4.0, 13.5.0, 13.6.0, 13.7.0, 13.8.0, 13.9.0, 13.10.0, 13.10.1, 13.11.0, 13.12.0, 13.13.0, 13.14.0, 14.0.0, 14.1.0, 14.2.0, 14.3.0, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"0.1.14\":{\"node_abi\":null,\"v8\":\"1.3\"},\"0.1.15\":{\"node_abi\":null,\"v8\":\"1.3\"},\"0.1.16\":{\"node_abi\":null,\"v8\":\"1.3\"},\"0.1.17\":{\"node_abi\":null,\"v8\":\"1.3\"},\"0.1.18\":{\"node_abi\":null,\"v8\":\"1.3\"},\"0.1.19\":{\"node_abi\":null,\"v8\":\"2.0\"},\"0.1.20\":{\"node_abi\":null,\"v8\":\"2.0\"},\"0.1.21\":{\"node_abi\":null,\"v8\":\"2.0\"},\"0.1.22\":{\"node_abi\":null,\"v8\":\"2.0\"},\"0.1.23\":{\"node_abi\":null,\"v8\":\"2.0\"},\"0.1.24\":{\"node_abi\":null,\"v8\":\"2.0\"},\"0.1.25\":{\"node_abi\":null,\"v8\":\"2.0\"},\"0.1.26\":{\"node_abi\":null,\"v8\":\"2.0\"},\"0.1.27\":{\"node_abi\":null,\"v8\":\"2.1\"},\"0.1.28\":{\"node_abi\":null,\"v8\":\"2.1\"},\"0.1.29\":{\"node_abi\":null,\"v8\":\"2.1\"},\"0.1.30\":{\"node_abi\":null,\"v8\":\"2.1\"},\"0.1.31\":{\"node_abi\":null,\"v8\":\"2.1\"},\"0.1.32\":{\"node_abi\":null,\"v8\":\"2.1\"},\"0.1.33\":{\"node_abi\":null,\"v8\":\"2.1\"},\"0.1.90\":{\"node_abi\":null,\"v8\":\"2.2\"},\"0.1.91\":{\"node_abi\":null,\"v8\":\"2.2\"},\"0.1.92\":{\"node_abi\":null,\"v8\":\"2.2\"},\"0.1.93\":{\"node_abi\":null,\"v8\":\"2.2\"},\"0.1.94\":{\"node_abi\":null,\"v8\":\"2.2\"},\"0.1.95\":{\"node_abi\":null,\"v8\":\"2.2\"},\"0.1.96\":{\"node_abi\":null,\"v8\":\"2.2\"},\"0.1.97\":{\"node_abi\":null,\"v8\":\"2.2\"},\"0.1.98\":{\"node_abi\":null,\"v8\":\"2.2\"},\"0.1.99\":{\"node_abi\":null,\"v8\":\"2.2\"},\"0.1.100\":{\"node_abi\":null,\"v8\":\"2.2\"},\"0.1.101\":{\"node_abi\":null,\"v8\":\"2.3\"},\"0.1.102\":{\"node_abi\":null,\"v8\":\"2.3\"},\"0.1.103\":{\"node_abi\":null,\"v8\":\"2.3\"},\"0.1.104\":{\"node_abi\":null,\"v8\":\"2.3\"},\"0.2.0\":{\"node_abi\":1,\"v8\":\"2.3\"},\"0.2.1\":{\"node_abi\":1,\"v8\":\"2.3\"},\"0.2.2\":{\"node_abi\":1,\"v8\":\"2.3\"},\"0.2.3\":{\"node_abi\":1,\"v8\":\"2.3\"},\"0.2.4\":{\"node_abi\":1,\"v8\":\"2.3\"},\"0.2.5\":{\"node_abi\":1,\"v8\":\"2.3\"},\"0.2.6\":{\"node_abi\":1,\"v8\":\"2.3\"},\"0.3.0\":{\"node_abi\":1,\"v8\":\"2.5\"},\"0.3.1\":{\"node_abi\":1,\"v8\":\"2.5\"},\"0.3.2\":{\"node_abi\":1,\"v8\":\"3.0\"},\"0.3.3\":{\"node_abi\":1,\"v8\":\"3.0\"},\"0.3.4\":{\"node_abi\":1,\"v8\":\"3.0\"},\"0.3.5\":{\"node_abi\":1,\"v8\":\"3.0\"},\"0.3.6\":{\"node_abi\":1,\"v8\":\"3.0\"},\"0.3.7\":{\"node_abi\":1,\"v8\":\"3.0\"},\"0.3.8\":{\"node_abi\":1,\"v8\":\"3.1\"},\"0.4.0\":{\"node_abi\":1,\"v8\":\"3.1\"},\"0.4.1\":{\"node_abi\":1,\"v8\":\"3.1\"},\"0.4.2\":{\"node_abi\":1,\"v8\":\"3.1\"},\"0.4.3\":{\"node_abi\":1,\"v8\":\"3.1\"},\"0.4.4\":{\"node_abi\":1,\"v8\":\"3.1\"},\"0.4.5\":{\"node_abi\":1,\"v8\":\"3.1\"},\"0.4.6\":{\"node_abi\":1,\"v8\":\"3.1\"},\"0.4.7\":{\"node_abi\":1,\"v8\":\"3.1\"},\"0.4.8\":{\"node_abi\":1,\"v8\":\"3.1\"},\"0.4.9\":{\"node_abi\":1,\"v8\":\"3.1\"},\"0.4.10\":{\"node_abi\":1,\"v8\":\"3.1\"},\"0.4.11\":{\"node_abi\":1,\"v8\":\"3.1\"},\"0.4.12\":{\"node_abi\":1,\"v8\":\"3.1\"},\"0.5.0\":{\"node_abi\":1,\"v8\":\"3.1\"},\"0.5.1\":{\"node_abi\":1,\"v8\":\"3.4\"},\"0.5.2\":{\"node_abi\":1,\"v8\":\"3.4\"},\"0.5.3\":{\"node_abi\":1,\"v8\":\"3.4\"},\"0.5.4\":{\"node_abi\":1,\"v8\":\"3.5\"},\"0.5.5\":{\"node_abi\":1,\"v8\":\"3.5\"},\"0.5.6\":{\"node_abi\":1,\"v8\":\"3.6\"},\"0.5.7\":{\"node_abi\":1,\"v8\":\"3.6\"},\"0.5.8\":{\"node_abi\":1,\"v8\":\"3.6\"},\"0.5.9\":{\"node_abi\":1,\"v8\":\"3.6\"},\"0.5.10\":{\"node_abi\":1,\"v8\":\"3.7\"},\"0.6.0\":{\"node_abi\":1,\"v8\":\"3.6\"},\"0.6.1\":{\"node_abi\":1,\"v8\":\"3.6\"},\"0.6.2\":{\"node_abi\":1,\"v8\":\"3.6\"},\"0.6.3\":{\"node_abi\":1,\"v8\":\"3.6\"},\"0.6.4\":{\"node_abi\":1,\"v8\":\"3.6\"},\"0.6.5\":{\"node_abi\":1,\"v8\":\"3.6\"},\"0.6.6\":{\"node_abi\":1,\"v8\":\"3.6\"},\"0.6.7\":{\"node_abi\":1,\"v8\":\"3.6\"},\"0.6.8\":{\"node_abi\":1,\"v8\":\"3.6\"},\"0.6.9\":{\"node_abi\":1,\"v8\":\"3.6\"},\"0.6.10\":{\"node_abi\":1,\"v8\":\"3.6\"},\"0.6.11\":{\"node_abi\":1,\"v8\":\"3.6\"},\"0.6.12\":{\"node_abi\":1,\"v8\":\"3.6\"},\"0.6.13\":{\"node_abi\":1,\"v8\":\"3.6\"},\"0.6.14\":{\"node_abi\":1,\"v8\":\"3.6\"},\"0.6.15\":{\"node_abi\":1,\"v8\":\"3.6\"},\"0.6.16\":{\"node_abi\":1,\"v8\":\"3.6\"},\"0.6.17\":{\"node_abi\":1,\"v8\":\"3.6\"},\"0.6.18\":{\"node_abi\":1,\"v8\":\"3.6\"},\"0.6.19\":{\"node_abi\":1,\"v8\":\"3.6\"},\"0.6.20\":{\"node_abi\":1,\"v8\":\"3.6\"},\"0.6.21\":{\"node_abi\":1,\"v8\":\"3.6\"},\"0.7.0\":{\"node_abi\":1,\"v8\":\"3.8\"},\"0.7.1\":{\"node_abi\":1,\"v8\":\"3.8\"},\"0.7.2\":{\"node_abi\":1,\"v8\":\"3.8\"},\"0.7.3\":{\"node_abi\":1,\"v8\":\"3.9\"},\"0.7.4\":{\"node_abi\":1,\"v8\":\"3.9\"},\"0.7.5\":{\"node_abi\":1,\"v8\":\"3.9\"},\"0.7.6\":{\"node_abi\":1,\"v8\":\"3.9\"},\"0.7.7\":{\"node_abi\":1,\"v8\":\"3.9\"},\"0.7.8\":{\"node_abi\":1,\"v8\":\"3.9\"},\"0.7.9\":{\"node_abi\":1,\"v8\":\"3.11\"},\"0.7.10\":{\"node_abi\":1,\"v8\":\"3.9\"},\"0.7.11\":{\"node_abi\":1,\"v8\":\"3.11\"},\"0.7.12\":{\"node_abi\":1,\"v8\":\"3.11\"},\"0.8.0\":{\"node_abi\":1,\"v8\":\"3.11\"},\"0.8.1\":{\"node_abi\":1,\"v8\":\"3.11\"},\"0.8.2\":{\"node_abi\":1,\"v8\":\"3.11\"},\"0.8.3\":{\"node_abi\":1,\"v8\":\"3.11\"},\"0.8.4\":{\"node_abi\":1,\"v8\":\"3.11\"},\"0.8.5\":{\"node_abi\":1,\"v8\":\"3.11\"},\"0.8.6\":{\"node_abi\":1,\"v8\":\"3.11\"},\"0.8.7\":{\"node_abi\":1,\"v8\":\"3.11\"},\"0.8.8\":{\"node_abi\":1,\"v8\":\"3.11\"},\"0.8.9\":{\"node_abi\":1,\"v8\":\"3.11\"},\"0.8.10\":{\"node_abi\":1,\"v8\":\"3.11\"},\"0.8.11\":{\"node_abi\":1,\"v8\":\"3.11\"},\"0.8.12\":{\"node_abi\":1,\"v8\":\"3.11\"},\"0.8.13\":{\"node_abi\":1,\"v8\":\"3.11\"},\"0.8.14\":{\"node_abi\":1,\"v8\":\"3.11\"},\"0.8.15\":{\"node_abi\":1,\"v8\":\"3.11\"},\"0.8.16\":{\"node_abi\":1,\"v8\":\"3.11\"},\"0.8.17\":{\"node_abi\":1,\"v8\":\"3.11\"},\"0.8.18\":{\"node_abi\":1,\"v8\":\"3.11\"},\"0.8.19\":{\"node_abi\":1,\"v8\":\"3.11\"},\"0.8.20\":{\"node_abi\":1,\"v8\":\"3.11\"},\"0.8.21\":{\"node_abi\":1,\"v8\":\"3.11\"},\"0.8.22\":{\"node_abi\":1,\"v8\":\"3.11\"},\"0.8.23\":{\"node_abi\":1,\"v8\":\"3.11\"},\"0.8.24\":{\"node_abi\":1,\"v8\":\"3.11\"},\"0.8.25\":{\"node_abi\":1,\"v8\":\"3.11\"},\"0.8.26\":{\"node_abi\":1,\"v8\":\"3.11\"},\"0.8.27\":{\"node_abi\":1,\"v8\":\"3.11\"},\"0.8.28\":{\"node_abi\":1,\"v8\":\"3.11\"},\"0.9.0\":{\"node_abi\":1,\"v8\":\"3.11\"},\"0.9.1\":{\"node_abi\":10,\"v8\":\"3.11\"},\"0.9.2\":{\"node_abi\":10,\"v8\":\"3.11\"},\"0.9.3\":{\"node_abi\":10,\"v8\":\"3.13\"},\"0.9.4\":{\"node_abi\":10,\"v8\":\"3.13\"},\"0.9.5\":{\"node_abi\":10,\"v8\":\"3.13\"},\"0.9.6\":{\"node_abi\":10,\"v8\":\"3.15\"},\"0.9.7\":{\"node_abi\":10,\"v8\":\"3.15\"},\"0.9.8\":{\"node_abi\":10,\"v8\":\"3.15\"},\"0.9.9\":{\"node_abi\":11,\"v8\":\"3.15\"},\"0.9.10\":{\"node_abi\":11,\"v8\":\"3.15\"},\"0.9.11\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.9.12\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.0\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.1\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.2\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.3\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.4\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.5\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.6\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.7\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.8\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.9\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.10\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.11\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.12\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.13\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.14\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.15\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.16\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.17\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.18\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.19\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.20\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.21\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.22\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.23\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.24\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.25\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.26\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.27\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.28\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.29\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.30\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.31\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.32\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.33\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.34\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.35\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.36\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.37\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.38\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.39\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.40\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.41\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.42\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.43\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.44\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.45\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.46\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.47\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.10.48\":{\"node_abi\":11,\"v8\":\"3.14\"},\"0.11.0\":{\"node_abi\":12,\"v8\":\"3.17\"},\"0.11.1\":{\"node_abi\":12,\"v8\":\"3.18\"},\"0.11.2\":{\"node_abi\":12,\"v8\":\"3.19\"},\"0.11.3\":{\"node_abi\":12,\"v8\":\"3.19\"},\"0.11.4\":{\"node_abi\":12,\"v8\":\"3.20\"},\"0.11.5\":{\"node_abi\":12,\"v8\":\"3.20\"},\"0.11.6\":{\"node_abi\":12,\"v8\":\"3.20\"},\"0.11.7\":{\"node_abi\":12,\"v8\":\"3.20\"},\"0.11.8\":{\"node_abi\":13,\"v8\":\"3.21\"},\"0.11.9\":{\"node_abi\":13,\"v8\":\"3.22\"},\"0.11.10\":{\"node_abi\":13,\"v8\":\"3.22\"},\"0.11.11\":{\"node_abi\":14,\"v8\":\"3.22\"},\"0.11.12\":{\"node_abi\":14,\"v8\":\"3.22\"},\"0.11.13\":{\"node_abi\":14,\"v8\":\"3.25\"},\"0.11.14\":{\"node_abi\":14,\"v8\":\"3.26\"},\"0.11.15\":{\"node_abi\":14,\"v8\":\"3.28\"},\"0.11.16\":{\"node_abi\":14,\"v8\":\"3.28\"},\"0.12.0\":{\"node_abi\":14,\"v8\":\"3.28\"},\"0.12.1\":{\"node_abi\":14,\"v8\":\"3.28\"},\"0.12.2\":{\"node_abi\":14,\"v8\":\"3.28\"},\"0.12.3\":{\"node_abi\":14,\"v8\":\"3.28\"},\"0.12.4\":{\"node_abi\":14,\"v8\":\"3.28\"},\"0.12.5\":{\"node_abi\":14,\"v8\":\"3.28\"},\"0.12.6\":{\"node_abi\":14,\"v8\":\"3.28\"},\"0.12.7\":{\"node_abi\":14,\"v8\":\"3.28\"},\"0.12.8\":{\"node_abi\":14,\"v8\":\"3.28\"},\"0.12.9\":{\"node_abi\":14,\"v8\":\"3.28\"},\"0.12.10\":{\"node_abi\":14,\"v8\":\"3.28\"},\"0.12.11\":{\"node_abi\":14,\"v8\":\"3.28\"},\"0.12.12\":{\"node_abi\":14,\"v8\":\"3.28\"},\"0.12.13\":{\"node_abi\":14,\"v8\":\"3.28\"},\"0.12.14\":{\"node_abi\":14,\"v8\":\"3.28\"},\"0.12.15\":{\"node_abi\":14,\"v8\":\"3.28\"},\"0.12.16\":{\"node_abi\":14,\"v8\":\"3.28\"},\"0.12.17\":{\"node_abi\":14,\"v8\":\"3.28\"},\"0.12.18\":{\"node_abi\":14,\"v8\":\"3.28\"},\"1.0.0\":{\"node_abi\":42,\"v8\":\"3.31\"},\"1.0.1\":{\"node_abi\":42,\"v8\":\"3.31\"},\"1.0.2\":{\"node_abi\":42,\"v8\":\"3.31\"},\"1.0.3\":{\"node_abi\":42,\"v8\":\"4.1\"},\"1.0.4\":{\"node_abi\":42,\"v8\":\"4.1\"},\"1.1.0\":{\"node_abi\":43,\"v8\":\"4.1\"},\"1.2.0\":{\"node_abi\":43,\"v8\":\"4.1\"},\"1.3.0\":{\"node_abi\":43,\"v8\":\"4.1\"},\"1.4.1\":{\"node_abi\":43,\"v8\":\"4.1\"},\"1.4.2\":{\"node_abi\":43,\"v8\":\"4.1\"},\"1.4.3\":{\"node_abi\":43,\"v8\":\"4.1\"},\"1.5.0\":{\"node_abi\":43,\"v8\":\"4.1\"},\"1.5.1\":{\"node_abi\":43,\"v8\":\"4.1\"},\"1.6.0\":{\"node_abi\":43,\"v8\":\"4.1\"},\"1.6.1\":{\"node_abi\":43,\"v8\":\"4.1\"},\"1.6.2\":{\"node_abi\":43,\"v8\":\"4.1\"},\"1.6.3\":{\"node_abi\":43,\"v8\":\"4.1\"},\"1.6.4\":{\"node_abi\":43,\"v8\":\"4.1\"},\"1.7.1\":{\"node_abi\":43,\"v8\":\"4.1\"},\"1.8.1\":{\"node_abi\":43,\"v8\":\"4.1\"},\"1.8.2\":{\"node_abi\":43,\"v8\":\"4.1\"},\"1.8.3\":{\"node_abi\":43,\"v8\":\"4.1\"},\"1.8.4\":{\"node_abi\":43,\"v8\":\"4.1\"},\"2.0.0\":{\"node_abi\":44,\"v8\":\"4.2\"},\"2.0.1\":{\"node_abi\":44,\"v8\":\"4.2\"},\"2.0.2\":{\"node_abi\":44,\"v8\":\"4.2\"},\"2.1.0\":{\"node_abi\":44,\"v8\":\"4.2\"},\"2.2.0\":{\"node_abi\":44,\"v8\":\"4.2\"},\"2.2.1\":{\"node_abi\":44,\"v8\":\"4.2\"},\"2.3.0\":{\"node_abi\":44,\"v8\":\"4.2\"},\"2.3.1\":{\"node_abi\":44,\"v8\":\"4.2\"},\"2.3.2\":{\"node_abi\":44,\"v8\":\"4.2\"},\"2.3.3\":{\"node_abi\":44,\"v8\":\"4.2\"},\"2.3.4\":{\"node_abi\":44,\"v8\":\"4.2\"},\"2.4.0\":{\"node_abi\":44,\"v8\":\"4.2\"},\"2.5.0\":{\"node_abi\":44,\"v8\":\"4.2\"},\"3.0.0\":{\"node_abi\":45,\"v8\":\"4.4\"},\"3.1.0\":{\"node_abi\":45,\"v8\":\"4.4\"},\"3.2.0\":{\"node_abi\":45,\"v8\":\"4.4\"},\"3.3.0\":{\"node_abi\":45,\"v8\":\"4.4\"},\"3.3.1\":{\"node_abi\":45,\"v8\":\"4.4\"},\"4.0.0\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.1.0\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.1.1\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.1.2\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.2.0\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.2.1\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.2.2\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.2.3\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.2.4\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.2.5\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.2.6\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.3.0\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.3.1\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.3.2\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.4.0\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.4.1\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.4.2\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.4.3\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.4.4\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.4.5\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.4.6\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.4.7\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.5.0\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.6.0\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.6.1\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.6.2\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.7.0\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.7.1\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.7.2\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.7.3\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.8.0\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.8.1\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.8.2\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.8.3\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.8.4\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.8.5\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.8.6\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.8.7\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.9.0\":{\"node_abi\":46,\"v8\":\"4.5\"},\"4.9.1\":{\"node_abi\":46,\"v8\":\"4.5\"},\"5.0.0\":{\"node_abi\":47,\"v8\":\"4.6\"},\"5.1.0\":{\"node_abi\":47,\"v8\":\"4.6\"},\"5.1.1\":{\"node_abi\":47,\"v8\":\"4.6\"},\"5.2.0\":{\"node_abi\":47,\"v8\":\"4.6\"},\"5.3.0\":{\"node_abi\":47,\"v8\":\"4.6\"},\"5.4.0\":{\"node_abi\":47,\"v8\":\"4.6\"},\"5.4.1\":{\"node_abi\":47,\"v8\":\"4.6\"},\"5.5.0\":{\"node_abi\":47,\"v8\":\"4.6\"},\"5.6.0\":{\"node_abi\":47,\"v8\":\"4.6\"},\"5.7.0\":{\"node_abi\":47,\"v8\":\"4.6\"},\"5.7.1\":{\"node_abi\":47,\"v8\":\"4.6\"},\"5.8.0\":{\"node_abi\":47,\"v8\":\"4.6\"},\"5.9.0\":{\"node_abi\":47,\"v8\":\"4.6\"},\"5.9.1\":{\"node_abi\":47,\"v8\":\"4.6\"},\"5.10.0\":{\"node_abi\":47,\"v8\":\"4.6\"},\"5.10.1\":{\"node_abi\":47,\"v8\":\"4.6\"},\"5.11.0\":{\"node_abi\":47,\"v8\":\"4.6\"},\"5.11.1\":{\"node_abi\":47,\"v8\":\"4.6\"},\"5.12.0\":{\"node_abi\":47,\"v8\":\"4.6\"},\"6.0.0\":{\"node_abi\":48,\"v8\":\"5.0\"},\"6.1.0\":{\"node_abi\":48,\"v8\":\"5.0\"},\"6.2.0\":{\"node_abi\":48,\"v8\":\"5.0\"},\"6.2.1\":{\"node_abi\":48,\"v8\":\"5.0\"},\"6.2.2\":{\"node_abi\":48,\"v8\":\"5.0\"},\"6.3.0\":{\"node_abi\":48,\"v8\":\"5.0\"},\"6.3.1\":{\"node_abi\":48,\"v8\":\"5.0\"},\"6.4.0\":{\"node_abi\":48,\"v8\":\"5.0\"},\"6.5.0\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.6.0\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.7.0\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.8.0\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.8.1\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.9.0\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.9.1\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.9.2\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.9.3\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.9.4\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.9.5\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.10.0\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.10.1\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.10.2\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.10.3\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.11.0\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.11.1\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.11.2\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.11.3\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.11.4\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.11.5\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.12.0\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.12.1\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.12.2\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.12.3\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.13.0\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.13.1\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.14.0\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.14.1\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.14.2\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.14.3\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.14.4\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.15.0\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.15.1\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.16.0\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.17.0\":{\"node_abi\":48,\"v8\":\"5.1\"},\"6.17.1\":{\"node_abi\":48,\"v8\":\"5.1\"},\"7.0.0\":{\"node_abi\":51,\"v8\":\"5.4\"},\"7.1.0\":{\"node_abi\":51,\"v8\":\"5.4\"},\"7.2.0\":{\"node_abi\":51,\"v8\":\"5.4\"},\"7.2.1\":{\"node_abi\":51,\"v8\":\"5.4\"},\"7.3.0\":{\"node_abi\":51,\"v8\":\"5.4\"},\"7.4.0\":{\"node_abi\":51,\"v8\":\"5.4\"},\"7.5.0\":{\"node_abi\":51,\"v8\":\"5.4\"},\"7.6.0\":{\"node_abi\":51,\"v8\":\"5.5\"},\"7.7.0\":{\"node_abi\":51,\"v8\":\"5.5\"},\"7.7.1\":{\"node_abi\":51,\"v8\":\"5.5\"},\"7.7.2\":{\"node_abi\":51,\"v8\":\"5.5\"},\"7.7.3\":{\"node_abi\":51,\"v8\":\"5.5\"},\"7.7.4\":{\"node_abi\":51,\"v8\":\"5.5\"},\"7.8.0\":{\"node_abi\":51,\"v8\":\"5.5\"},\"7.9.0\":{\"node_abi\":51,\"v8\":\"5.5\"},\"7.10.0\":{\"node_abi\":51,\"v8\":\"5.5\"},\"7.10.1\":{\"node_abi\":51,\"v8\":\"5.5\"},\"8.0.0\":{\"node_abi\":57,\"v8\":\"5.8\"},\"8.1.0\":{\"node_abi\":57,\"v8\":\"5.8\"},\"8.1.1\":{\"node_abi\":57,\"v8\":\"5.8\"},\"8.1.2\":{\"node_abi\":57,\"v8\":\"5.8\"},\"8.1.3\":{\"node_abi\":57,\"v8\":\"5.8\"},\"8.1.4\":{\"node_abi\":57,\"v8\":\"5.8\"},\"8.2.0\":{\"node_abi\":57,\"v8\":\"5.8\"},\"8.2.1\":{\"node_abi\":57,\"v8\":\"5.8\"},\"8.3.0\":{\"node_abi\":57,\"v8\":\"6.0\"},\"8.4.0\":{\"node_abi\":57,\"v8\":\"6.0\"},\"8.5.0\":{\"node_abi\":57,\"v8\":\"6.0\"},\"8.6.0\":{\"node_abi\":57,\"v8\":\"6.0\"},\"8.7.0\":{\"node_abi\":57,\"v8\":\"6.1\"},\"8.8.0\":{\"node_abi\":57,\"v8\":\"6.1\"},\"8.8.1\":{\"node_abi\":57,\"v8\":\"6.1\"},\"8.9.0\":{\"node_abi\":57,\"v8\":\"6.1\"},\"8.9.1\":{\"node_abi\":57,\"v8\":\"6.1\"},\"8.9.2\":{\"node_abi\":57,\"v8\":\"6.1\"},\"8.9.3\":{\"node_abi\":57,\"v8\":\"6.1\"},\"8.9.4\":{\"node_abi\":57,\"v8\":\"6.1\"},\"8.10.0\":{\"node_abi\":57,\"v8\":\"6.2\"},\"8.11.0\":{\"node_abi\":57,\"v8\":\"6.2\"},\"8.11.1\":{\"node_abi\":57,\"v8\":\"6.2\"},\"8.11.2\":{\"node_abi\":57,\"v8\":\"6.2\"},\"8.11.3\":{\"node_abi\":57,\"v8\":\"6.2\"},\"8.11.4\":{\"node_abi\":57,\"v8\":\"6.2\"},\"8.12.0\":{\"node_abi\":57,\"v8\":\"6.2\"},\"8.13.0\":{\"node_abi\":57,\"v8\":\"6.2\"},\"8.14.0\":{\"node_abi\":57,\"v8\":\"6.2\"},\"8.14.1\":{\"node_abi\":57,\"v8\":\"6.2\"},\"8.15.0\":{\"node_abi\":57,\"v8\":\"6.2\"},\"8.15.1\":{\"node_abi\":57,\"v8\":\"6.2\"},\"8.16.0\":{\"node_abi\":57,\"v8\":\"6.2\"},\"8.16.1\":{\"node_abi\":57,\"v8\":\"6.2\"},\"8.16.2\":{\"node_abi\":57,\"v8\":\"6.2\"},\"8.17.0\":{\"node_abi\":57,\"v8\":\"6.2\"},\"9.0.0\":{\"node_abi\":59,\"v8\":\"6.2\"},\"9.1.0\":{\"node_abi\":59,\"v8\":\"6.2\"},\"9.2.0\":{\"node_abi\":59,\"v8\":\"6.2\"},\"9.2.1\":{\"node_abi\":59,\"v8\":\"6.2\"},\"9.3.0\":{\"node_abi\":59,\"v8\":\"6.2\"},\"9.4.0\":{\"node_abi\":59,\"v8\":\"6.2\"},\"9.5.0\":{\"node_abi\":59,\"v8\":\"6.2\"},\"9.6.0\":{\"node_abi\":59,\"v8\":\"6.2\"},\"9.6.1\":{\"node_abi\":59,\"v8\":\"6.2\"},\"9.7.0\":{\"node_abi\":59,\"v8\":\"6.2\"},\"9.7.1\":{\"node_abi\":59,\"v8\":\"6.2\"},\"9.8.0\":{\"node_abi\":59,\"v8\":\"6.2\"},\"9.9.0\":{\"node_abi\":59,\"v8\":\"6.2\"},\"9.10.0\":{\"node_abi\":59,\"v8\":\"6.2\"},\"9.10.1\":{\"node_abi\":59,\"v8\":\"6.2\"},\"9.11.0\":{\"node_abi\":59,\"v8\":\"6.2\"},\"9.11.1\":{\"node_abi\":59,\"v8\":\"6.2\"},\"9.11.2\":{\"node_abi\":59,\"v8\":\"6.2\"},\"10.0.0\":{\"node_abi\":64,\"v8\":\"6.6\"},\"10.1.0\":{\"node_abi\":64,\"v8\":\"6.6\"},\"10.2.0\":{\"node_abi\":64,\"v8\":\"6.6\"},\"10.2.1\":{\"node_abi\":64,\"v8\":\"6.6\"},\"10.3.0\":{\"node_abi\":64,\"v8\":\"6.6\"},\"10.4.0\":{\"node_abi\":64,\"v8\":\"6.7\"},\"10.4.1\":{\"node_abi\":64,\"v8\":\"6.7\"},\"10.5.0\":{\"node_abi\":64,\"v8\":\"6.7\"},\"10.6.0\":{\"node_abi\":64,\"v8\":\"6.7\"},\"10.7.0\":{\"node_abi\":64,\"v8\":\"6.7\"},\"10.8.0\":{\"node_abi\":64,\"v8\":\"6.7\"},\"10.9.0\":{\"node_abi\":64,\"v8\":\"6.8\"},\"10.10.0\":{\"node_abi\":64,\"v8\":\"6.8\"},\"10.11.0\":{\"node_abi\":64,\"v8\":\"6.8\"},\"10.12.0\":{\"node_abi\":64,\"v8\":\"6.8\"},\"10.13.0\":{\"node_abi\":64,\"v8\":\"6.8\"},\"10.14.0\":{\"node_abi\":64,\"v8\":\"6.8\"},\"10.14.1\":{\"node_abi\":64,\"v8\":\"6.8\"},\"10.14.2\":{\"node_abi\":64,\"v8\":\"6.8\"},\"10.15.0\":{\"node_abi\":64,\"v8\":\"6.8\"},\"10.15.1\":{\"node_abi\":64,\"v8\":\"6.8\"},\"10.15.2\":{\"node_abi\":64,\"v8\":\"6.8\"},\"10.15.3\":{\"node_abi\":64,\"v8\":\"6.8\"},\"10.16.0\":{\"node_abi\":64,\"v8\":\"6.8\"},\"10.16.1\":{\"node_abi\":64,\"v8\":\"6.8\"},\"10.16.2\":{\"node_abi\":64,\"v8\":\"6.8\"},\"10.16.3\":{\"node_abi\":64,\"v8\":\"6.8\"},\"10.17.0\":{\"node_abi\":64,\"v8\":\"6.8\"},\"10.18.0\":{\"node_abi\":64,\"v8\":\"6.8\"},\"10.18.1\":{\"node_abi\":64,\"v8\":\"6.8\"},\"10.19.0\":{\"node_abi\":64,\"v8\":\"6.8\"},\"10.20.0\":{\"node_abi\":64,\"v8\":\"6.8\"},\"10.20.1\":{\"node_abi\":64,\"v8\":\"6.8\"},\"11.0.0\":{\"node_abi\":67,\"v8\":\"7.0\"},\"11.1.0\":{\"node_abi\":67,\"v8\":\"7.0\"},\"11.2.0\":{\"node_abi\":67,\"v8\":\"7.0\"},\"11.3.0\":{\"node_abi\":67,\"v8\":\"7.0\"},\"11.4.0\":{\"node_abi\":67,\"v8\":\"7.0\"},\"11.5.0\":{\"node_abi\":67,\"v8\":\"7.0\"},\"11.6.0\":{\"node_abi\":67,\"v8\":\"7.0\"},\"11.7.0\":{\"node_abi\":67,\"v8\":\"7.0\"},\"11.8.0\":{\"node_abi\":67,\"v8\":\"7.0\"},\"11.9.0\":{\"node_abi\":67,\"v8\":\"7.0\"},\"11.10.0\":{\"node_abi\":67,\"v8\":\"7.0\"},\"11.10.1\":{\"node_abi\":67,\"v8\":\"7.0\"},\"11.11.0\":{\"node_abi\":67,\"v8\":\"7.0\"},\"11.12.0\":{\"node_abi\":67,\"v8\":\"7.0\"},\"11.13.0\":{\"node_abi\":67,\"v8\":\"7.0\"},\"11.14.0\":{\"node_abi\":67,\"v8\":\"7.0\"},\"11.15.0\":{\"node_abi\":67,\"v8\":\"7.0\"},\"12.0.0\":{\"node_abi\":72,\"v8\":\"7.4\"},\"12.1.0\":{\"node_abi\":72,\"v8\":\"7.4\"},\"12.2.0\":{\"node_abi\":72,\"v8\":\"7.4\"},\"12.3.0\":{\"node_abi\":72,\"v8\":\"7.4\"},\"12.3.1\":{\"node_abi\":72,\"v8\":\"7.4\"},\"12.4.0\":{\"node_abi\":72,\"v8\":\"7.4\"},\"12.5.0\":{\"node_abi\":72,\"v8\":\"7.5\"},\"12.6.0\":{\"node_abi\":72,\"v8\":\"7.5\"},\"12.7.0\":{\"node_abi\":72,\"v8\":\"7.5\"},\"12.8.0\":{\"node_abi\":72,\"v8\":\"7.5\"},\"12.8.1\":{\"node_abi\":72,\"v8\":\"7.5\"},\"12.9.0\":{\"node_abi\":72,\"v8\":\"7.6\"},\"12.9.1\":{\"node_abi\":72,\"v8\":\"7.6\"},\"12.10.0\":{\"node_abi\":72,\"v8\":\"7.6\"},\"12.11.0\":{\"node_abi\":72,\"v8\":\"7.7\"},\"12.11.1\":{\"node_abi\":72,\"v8\":\"7.7\"},\"12.12.0\":{\"node_abi\":72,\"v8\":\"7.7\"},\"12.13.0\":{\"node_abi\":72,\"v8\":\"7.7\"},\"12.13.1\":{\"node_abi\":72,\"v8\":\"7.7\"},\"12.14.0\":{\"node_abi\":72,\"v8\":\"7.7\"},\"12.14.1\":{\"node_abi\":72,\"v8\":\"7.7\"},\"12.15.0\":{\"node_abi\":72,\"v8\":\"7.7\"},\"12.16.0\":{\"node_abi\":72,\"v8\":\"7.8\"},\"12.16.1\":{\"node_abi\":72,\"v8\":\"7.8\"},\"12.16.2\":{\"node_abi\":72,\"v8\":\"7.8\"},\"12.16.3\":{\"node_abi\":72,\"v8\":\"7.8\"},\"13.0.0\":{\"node_abi\":79,\"v8\":\"7.8\"},\"13.0.1\":{\"node_abi\":79,\"v8\":\"7.8\"},\"13.1.0\":{\"node_abi\":79,\"v8\":\"7.8\"},\"13.2.0\":{\"node_abi\":79,\"v8\":\"7.9\"},\"13.3.0\":{\"node_abi\":79,\"v8\":\"7.9\"},\"13.4.0\":{\"node_abi\":79,\"v8\":\"7.9\"},\"13.5.0\":{\"node_abi\":79,\"v8\":\"7.9\"},\"13.6.0\":{\"node_abi\":79,\"v8\":\"7.9\"},\"13.7.0\":{\"node_abi\":79,\"v8\":\"7.9\"},\"13.8.0\":{\"node_abi\":79,\"v8\":\"7.9\"},\"13.9.0\":{\"node_abi\":79,\"v8\":\"7.9\"},\"13.10.0\":{\"node_abi\":79,\"v8\":\"7.9\"},\"13.10.1\":{\"node_abi\":79,\"v8\":\"7.9\"},\"13.11.0\":{\"node_abi\":79,\"v8\":\"7.9\"},\"13.12.0\":{\"node_abi\":79,\"v8\":\"7.9\"},\"13.13.0\":{\"node_abi\":79,\"v8\":\"7.9\"},\"13.14.0\":{\"node_abi\":79,\"v8\":\"7.9\"},\"14.0.0\":{\"node_abi\":83,\"v8\":\"8.1\"},\"14.1.0\":{\"node_abi\":83,\"v8\":\"8.1\"},\"14.2.0\":{\"node_abi\":83,\"v8\":\"8.1\"},\"14.3.0\":{\"node_abi\":83,\"v8\":\"8.1\"}}");

/***/ }),

/***/ "./node_modules/node-pre-gyp/lib/util/compile.js":
/*!*******************************************************!*\
  !*** ./node_modules/node-pre-gyp/lib/util/compile.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = exports;

var fs = __webpack_require__(/*! fs */ "fs");
var path = __webpack_require__(/*! path */ "path");
var win = process.platform == 'win32';
var existsSync = fs.existsSync || path.existsSync;
var cp = __webpack_require__(/*! child_process */ "child_process");

// try to build up the complete path to node-gyp
/* priority:
  - node-gyp on ENV:npm_config_node_gyp (https://github.com/npm/npm/pull/4887)
  - node-gyp on NODE_PATH
  - node-gyp inside npm on NODE_PATH (ignore on iojs)
  - node-gyp inside npm beside node exe
*/
function which_node_gyp() {
    var node_gyp_bin;
    if (process.env.npm_config_node_gyp) {
      try {
          node_gyp_bin = process.env.npm_config_node_gyp;
          if (existsSync(node_gyp_bin)) {
              return node_gyp_bin;
          }
      } catch (err) { }
    }
    try {
        var node_gyp_main = /*require.resolve*/(!(function webpackMissingModule() { var e = new Error("Cannot find module 'node-gyp'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
        node_gyp_bin = path.join(path.dirname(
                                     path.dirname(node_gyp_main)),
                                     'bin/node-gyp.js');
        if (existsSync(node_gyp_bin)) {
            return node_gyp_bin;
        }
    } catch (err) { }
    if (process.execPath.indexOf('iojs') === -1) {
        try {
            var npm_main = /*require.resolve*/(!(function webpackMissingModule() { var e = new Error("Cannot find module 'npm'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
            node_gyp_bin = path.join(path.dirname(
                                         path.dirname(npm_main)),
                                         'node_modules/node-gyp/bin/node-gyp.js');
            if (existsSync(node_gyp_bin)) {
                return node_gyp_bin;
            }
        } catch (err) { }
    }
    var npm_base = path.join(path.dirname(
                             path.dirname(process.execPath)),
                             'lib/node_modules/npm/');
    node_gyp_bin = path.join(npm_base, 'node_modules/node-gyp/bin/node-gyp.js');
    if (existsSync(node_gyp_bin)) {
        return node_gyp_bin;
    }
}

module.exports.run_gyp = function(args,opts,callback) {
    var shell_cmd = '';
    var cmd_args = [];
    if (opts.runtime && opts.runtime == 'node-webkit') {
        shell_cmd = 'nw-gyp';
        if (win) shell_cmd += '.cmd';
    } else {
        var node_gyp_path = which_node_gyp();
        if (node_gyp_path) {
            shell_cmd = process.execPath;
            cmd_args.push(node_gyp_path);
        } else {
            shell_cmd = 'node-gyp';
            if (win) shell_cmd += '.cmd';
        }
    }
    var final_args = cmd_args.concat(args);
    var cmd = cp.spawn(shell_cmd, final_args, {cwd: undefined, env: process.env, stdio: [ 0, 1, 2]});
    cmd.on('error', function (err) {
        if (err) {
            return callback(new Error("Failed to execute '" + shell_cmd + ' ' + final_args.join(' ') + "' (" + err + ")"));
        }
        callback(null,opts);
    });
    cmd.on('close', function (code) {
        if (code && code !== 0) {
            return callback(new Error("Failed to execute '" + shell_cmd + ' ' + final_args.join(' ') + "' (" + code + ")"));
        }
        callback(null,opts);
    });
};


/***/ }),

/***/ "./node_modules/node-pre-gyp/lib/util/handle_gyp_opts.js":
/*!***************************************************************!*\
  !*** ./node_modules/node-pre-gyp/lib/util/handle_gyp_opts.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = exports = handle_gyp_opts;

var fs = __webpack_require__(/*! fs */ "fs");
var versioning = __webpack_require__(/*! ./versioning.js */ "./node_modules/node-pre-gyp/lib/util/versioning.js");
var napi = __webpack_require__(/*! ./napi.js */ "./node_modules/node-pre-gyp/lib/util/napi.js");

/*

Here we gather node-pre-gyp generated options (from versioning) and pass them along to node-gyp.

We massage the args and options slightly to account for differences in what commands mean between
node-pre-gyp and node-gyp (e.g. see the difference between "build" and "rebuild" below)

Keep in mind: the values inside `argv` and `gyp.opts` below are different depending on whether
node-pre-gyp is called directory, or if it is called in a `run-script` phase of npm.

We also try to preserve any command line options that might have been passed to npm or node-pre-gyp.
But this is fairly difficult without passing way to much through. For example `gyp.opts` contains all
the process.env and npm pushes a lot of variables into process.env which node-pre-gyp inherits. So we have
to be very selective about what we pass through.

For example:

`npm install --build-from-source` will give:

argv == [ 'rebuild' ]
gyp.opts.argv == { remain: [ 'install' ],
  cooked: [ 'install', '--fallback-to-build' ],
  original: [ 'install', '--fallback-to-build' ] }

`./bin/node-pre-gyp build` will give:

argv == []
gyp.opts.argv == { remain: [ 'build' ],
  cooked: [ 'build' ],
  original: [ '-C', 'test/app1', 'build' ] }

*/

// select set of node-pre-gyp versioning info
// to share with node-gyp
var share_with_node_gyp = [
  'module',
  'module_name',
  'module_path',
  'napi_version',
  'node_abi_napi',
  'napi_build_version',
  'node_napi_label'
];

function handle_gyp_opts(gyp, argv, callback) {

    // Collect node-pre-gyp specific variables to pass to node-gyp
    var node_pre_gyp_options = [];
    // generate custom node-pre-gyp versioning info
    var napi_build_version = napi.get_napi_build_version_from_command_args(argv);
    var opts = versioning.evaluate(JSON.parse(fs.readFileSync('./package.json')), gyp.opts, napi_build_version);
    share_with_node_gyp.forEach(function(key) {
        var val = opts[key];
        if (val) {
            node_pre_gyp_options.push('--' + key + '=' + val);
        } else if (key === 'napi_build_version') {
            node_pre_gyp_options.push('--' + key + '=0');
        } else {
            if (key !== 'napi_version' && key !== 'node_abi_napi')
                return callback(new Error("Option " + key + " required but not found by node-pre-gyp"));
        }
    });

    // Collect options that follow the special -- which disables nopt parsing
    var unparsed_options = [];
    var double_hyphen_found = false;
    gyp.opts.argv.original.forEach(function(opt) {
        if (double_hyphen_found) {
            unparsed_options.push(opt);
        }
        if (opt == '--') {
            double_hyphen_found = true;
        }
    });

    // We try respect and pass through remaining command
    // line options (like --foo=bar) to node-gyp
    var cooked = gyp.opts.argv.cooked;
    var node_gyp_options = [];
    cooked.forEach(function(value) {
        if (value.length > 2 && value.slice(0,2) == '--') {
            var key = value.slice(2);
            var val = cooked[cooked.indexOf(value)+1];
            if (val && val.indexOf('--') === -1) { // handle '--foo=bar' or ['--foo','bar']
                node_gyp_options.push('--' + key + '=' + val);
            } else { // pass through --foo
                node_gyp_options.push(value);
            }
        }
    });

    var result = {'opts':opts,'gyp':node_gyp_options,'pre':node_pre_gyp_options,'unparsed':unparsed_options};
    return callback(null,result);
}


/***/ }),

/***/ "./node_modules/node-pre-gyp/lib/util/napi.js":
/*!****************************************************!*\
  !*** ./node_modules/node-pre-gyp/lib/util/napi.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fs = __webpack_require__(/*! fs */ "fs");

module.exports = exports;

var versionArray = process.version
	.substr(1)
	.replace(/-.*$/, '')
	.split('.')
	.map(function(item) {
		return +item;
	});

var napi_multiple_commands = [
	'build',
	'clean',
	'configure',
	'package',
	'publish',
	'reveal',
	'testbinary',
	'testpackage',
	'unpublish'
];

var napi_build_version_tag = 'napi_build_version=';

module.exports.get_napi_version = function(target) { // target may be undefined
	// returns the non-zero numeric napi version or undefined if napi is not supported.
	// correctly supporting target requires an updated cross-walk
	var version = process.versions.napi; // can be undefined
	if (!version) { // this code should never need to be updated
		if (versionArray[0] === 9 && versionArray[1] >= 3) version = 2; // 9.3.0+
		else if (versionArray[0] === 8) version = 1; // 8.0.0+
	}
	return version;
};

module.exports.get_napi_version_as_string = function(target) {
	// returns the napi version as a string or an empty string if napi is not supported.
	var version = module.exports.get_napi_version(target);
	return version ? ''+version : '';
};

module.exports.validate_package_json = function(package_json, opts) { // throws Error

	var binary = package_json.binary;
	var module_path_ok = pathOK(binary.module_path);
	var remote_path_ok = pathOK(binary.remote_path);
	var package_name_ok = pathOK(binary.package_name);
	var napi_build_versions = module.exports.get_napi_build_versions(package_json,opts,true);
	var napi_build_versions_raw = module.exports.get_napi_build_versions_raw(package_json);

	if (napi_build_versions) {
		napi_build_versions.forEach(function(napi_build_version){
			if (!(parseInt(napi_build_version,10) === napi_build_version && napi_build_version > 0)) {
				throw new Error("All values specified in napi_versions must be positive integers.");
			}
		});
	}

	if (napi_build_versions && (!module_path_ok || (!remote_path_ok && !package_name_ok))) {
		throw new Error("When napi_versions is specified; module_path and either remote_path or " +
			"package_name must contain the substitution string '{napi_build_version}`.");
	}

	if ((module_path_ok || remote_path_ok || package_name_ok) && !napi_build_versions_raw) {
		throw new Error("When the substitution string '{napi_build_version}` is specified in " +
			"module_path, remote_path, or package_name; napi_versions must also be specified.");
	}

	if (napi_build_versions && !module.exports.get_best_napi_build_version(package_json, opts) && 
	module.exports.build_napi_only(package_json)) {
		throw new Error(
			'The N-API version of this Node instance is ' + module.exports.get_napi_version(opts ? opts.target : undefined) + '. ' +
			'This module supports N-API version(s) ' + module.exports.get_napi_build_versions_raw(package_json) + '. ' +
			'This Node instance cannot run this module.');
	}

	if (napi_build_versions_raw && !napi_build_versions && module.exports.build_napi_only(package_json)) {
		throw new Error(
			'The N-API version of this Node instance is ' + module.exports.get_napi_version(opts ? opts.target : undefined) + '. ' +
			'This module supports N-API version(s) ' + module.exports.get_napi_build_versions_raw(package_json) + '. ' +
			'This Node instance cannot run this module.');
	}

};

function pathOK (path) {
	return path && (path.indexOf('{napi_build_version}') !== -1 || path.indexOf('{node_napi_label}') !== -1);
}

module.exports.expand_commands = function(package_json, opts, commands) {
	var expanded_commands = [];
	var napi_build_versions = module.exports.get_napi_build_versions(package_json, opts);
	commands.forEach(function(command){
		if (napi_build_versions && command.name === 'install') {
			var napi_build_version = module.exports.get_best_napi_build_version(package_json, opts);
			var args = napi_build_version ? [ napi_build_version_tag+napi_build_version ] : [ ];
			expanded_commands.push ({ name: command.name, args: args });
		} else if (napi_build_versions && napi_multiple_commands.indexOf(command.name) !== -1) {
			napi_build_versions.forEach(function(napi_build_version){
				var args = command.args.slice();
				args.push (napi_build_version_tag+napi_build_version);
				expanded_commands.push ({ name: command.name, args: args });
			});
		} else {
			expanded_commands.push (command);
		}
	});
	return expanded_commands;
};

module.exports.get_napi_build_versions = function(package_json, opts, warnings) { // opts may be undefined
	var log = __webpack_require__(/*! npmlog */ "./node_modules/npmlog/log.js");
	var napi_build_versions = [];
	var supported_napi_version = module.exports.get_napi_version(opts ? opts.target : undefined);
	// remove duplicates, verify each napi version can actaully be built
	if (package_json.binary && package_json.binary.napi_versions) {
		package_json.binary.napi_versions.forEach(function(napi_version) {
			var duplicated = napi_build_versions.indexOf(napi_version) !== -1;
			if (!duplicated && supported_napi_version && napi_version <= supported_napi_version) {
				napi_build_versions.push(napi_version);
			} else if (warnings && !duplicated && supported_napi_version) {
				log.info('This Node instance does not support builds for N-API version', napi_version);
			}
		});
	}
	if (opts && opts["build-latest-napi-version-only"]) {
		var latest_version = 0;
		napi_build_versions.forEach(function(napi_version) {
			if (napi_version > latest_version) latest_version = napi_version;
		});
		napi_build_versions = latest_version ? [ latest_version ] : [];
	}
	return napi_build_versions.length ? napi_build_versions : undefined;
};

module.exports.get_napi_build_versions_raw = function(package_json) {
	var napi_build_versions = [];
	// remove duplicates
	if (package_json.binary && package_json.binary.napi_versions) {
		package_json.binary.napi_versions.forEach(function(napi_version) {
			if (napi_build_versions.indexOf(napi_version) === -1) {
				napi_build_versions.push(napi_version);
			}
		});
	}
	return napi_build_versions.length ? napi_build_versions : undefined;
};

module.exports.get_command_arg = function(napi_build_version) {
	return napi_build_version_tag + napi_build_version;
};

module.exports.get_napi_build_version_from_command_args = function(command_args) {
	for (var i = 0; i < command_args.length; i++) {
		var arg = command_args[i];
		if (arg.indexOf(napi_build_version_tag) === 0) {
			return parseInt(arg.substr(napi_build_version_tag.length),10);
		}
	}
	return undefined;
};

module.exports.swap_build_dir_out = function(napi_build_version) {
	if (napi_build_version) {
		var rm = __webpack_require__(/*! rimraf */ "rimraf");
		rm.sync(module.exports.get_build_dir(napi_build_version));
		fs.renameSync('build', module.exports.get_build_dir(napi_build_version));
	}
};

module.exports.swap_build_dir_in = function(napi_build_version) {
	if (napi_build_version) {
		var rm = __webpack_require__(/*! rimraf */ "rimraf");
		rm.sync('build');
		fs.renameSync(module.exports.get_build_dir(napi_build_version), 'build');
	}
};

module.exports.get_build_dir = function(napi_build_version) {
	return 'build-tmp-napi-v'+napi_build_version;
};

module.exports.get_best_napi_build_version = function(package_json, opts) {
	var best_napi_build_version = 0;
	var napi_build_versions = module.exports.get_napi_build_versions (package_json, opts);
	if (napi_build_versions) {
		var our_napi_version = module.exports.get_napi_version(opts ? opts.target : undefined);
		napi_build_versions.forEach(function(napi_build_version){
			if (napi_build_version > best_napi_build_version &&
				napi_build_version <= our_napi_version) {
				best_napi_build_version = napi_build_version;
			}
		});
	}
	return best_napi_build_version === 0 ? undefined : best_napi_build_version;
};

module.exports.build_napi_only = function(package_json) {
	return package_json.binary && package_json.binary.package_name && 
	package_json.binary.package_name.indexOf('{node_napi_label}') === -1;
};

/***/ }),

/***/ "./node_modules/node-pre-gyp/lib/util/nw-pre-gyp/index.html":
/*!******************************************************************!*\
  !*** ./node_modules/node-pre-gyp/lib/util/nw-pre-gyp/index.html ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

throw new Error("Module parse failed: Unexpected token (1:0)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> <!doctype html>\n| <html>\n| <head>");

/***/ }),

/***/ "./node_modules/node-pre-gyp/lib/util/nw-pre-gyp/package.json":
/*!********************************************************************!*\
  !*** ./node_modules/node-pre-gyp/lib/util/nw-pre-gyp/package.json ***!
  \********************************************************************/
/*! exports provided: main, name, description, version, window, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"main\":\"index.html\",\"name\":\"nw-pre-gyp-module-test\",\"description\":\"Node-webkit-based module test.\",\"version\":\"0.0.1\",\"window\":{\"show\":false}}");

/***/ }),

/***/ "./node_modules/node-pre-gyp/lib/util/s3_setup.js":
/*!********************************************************!*\
  !*** ./node_modules/node-pre-gyp/lib/util/s3_setup.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = exports;

var url = __webpack_require__(/*! url */ "url");

var URI_REGEX="^(.*)\.(s3(?:-.*)?)\.amazonaws\.com$";

module.exports.detect = function(to,config) {
    var uri = url.parse(to);
    var hostname_matches = uri.hostname.match(URI_REGEX);
    config.prefix = (!uri.pathname || uri.pathname == '/') ? '' : uri.pathname.replace('/','');
    if(!hostname_matches) {
        return;
    }
    if (!config.bucket) {
        config.bucket = hostname_matches[1];
    }
    if (!config.region) {
        var s3_domain = hostname_matches[2];
        if (s3_domain.slice(0,3) == 's3-' &&
            s3_domain.length >= 3) {
            // it appears the region is explicit in the url
            config.region = s3_domain.replace('s3-','');
        }
    }
};


/***/ }),

/***/ "./node_modules/node-pre-gyp/lib/util/versioning.js":
/*!**********************************************************!*\
  !*** ./node_modules/node-pre-gyp/lib/util/versioning.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = exports;

var path = __webpack_require__(/*! path */ "path");
var semver = __webpack_require__(/*! semver */ "semver");
var url = __webpack_require__(/*! url */ "url");
var detect_libc = __webpack_require__(/*! detect-libc */ "./node_modules/detect-libc/lib/detect-libc.js");
var napi = __webpack_require__(/*! ./napi.js */ "./node_modules/node-pre-gyp/lib/util/napi.js");

var abi_crosswalk;

// This is used for unit testing to provide a fake
// ABI crosswalk that emulates one that is not updated
// for the current version
if (process.env.NODE_PRE_GYP_ABI_CROSSWALK) {
    abi_crosswalk = __webpack_require__("./node_modules/node-pre-gyp/lib/util sync recursive")(process.env.NODE_PRE_GYP_ABI_CROSSWALK);
} else {
    abi_crosswalk = __webpack_require__(/*! ./abi_crosswalk.json */ "./node_modules/node-pre-gyp/lib/util/abi_crosswalk.json");
}

var major_versions = {};
Object.keys(abi_crosswalk).forEach(function(v) {
    var major = v.split('.')[0];
    if (!major_versions[major]) {
        major_versions[major] = v;
    }
});

function get_electron_abi(runtime, target_version) {
    if (!runtime) {
        throw new Error("get_electron_abi requires valid runtime arg");
    }
    if (typeof target_version === 'undefined') {
        // erroneous CLI call
        throw new Error("Empty target version is not supported if electron is the target.");
    }
    // Electron guarantees that patch version update won't break native modules.
    var sem_ver = semver.parse(target_version);
    return runtime + '-v' + sem_ver.major + '.' + sem_ver.minor;
}
module.exports.get_electron_abi = get_electron_abi;

function get_node_webkit_abi(runtime, target_version) {
    if (!runtime) {
        throw new Error("get_node_webkit_abi requires valid runtime arg");
    }
    if (typeof target_version === 'undefined') {
        // erroneous CLI call
        throw new Error("Empty target version is not supported if node-webkit is the target.");
    }
    return runtime + '-v' + target_version;
}
module.exports.get_node_webkit_abi = get_node_webkit_abi;

function get_node_abi(runtime, versions) {
    if (!runtime) {
        throw new Error("get_node_abi requires valid runtime arg");
    }
    if (!versions) {
        throw new Error("get_node_abi requires valid process.versions object");
    }
    var sem_ver = semver.parse(versions.node);
    if (sem_ver.major === 0 && sem_ver.minor % 2) { // odd series
        // https://github.com/mapbox/node-pre-gyp/issues/124
        return runtime+'-v'+versions.node;
    } else {
        // process.versions.modules added in >= v0.10.4 and v0.11.7
        // https://github.com/joyent/node/commit/ccabd4a6fa8a6eb79d29bc3bbe9fe2b6531c2d8e
        return versions.modules ? runtime+'-v' + (+versions.modules) :
            'v8-' + versions.v8.split('.').slice(0,2).join('.');
    }
}
module.exports.get_node_abi = get_node_abi;

function get_runtime_abi(runtime, target_version) {
    if (!runtime) {
        throw new Error("get_runtime_abi requires valid runtime arg");
    }
    if (runtime === 'node-webkit') {
        return get_node_webkit_abi(runtime, target_version || process.versions['node-webkit']);
    } else if (runtime === 'electron') {
        return get_electron_abi(runtime, target_version || process.versions.electron);
    } else {
        if (runtime != 'node') {
            throw new Error("Unknown Runtime: '" + runtime + "'");
        }
        if (!target_version) {
            return get_node_abi(runtime,process.versions);
        } else {
            var cross_obj;
            // abi_crosswalk generated with ./scripts/abi_crosswalk.js
            if (abi_crosswalk[target_version]) {
                cross_obj = abi_crosswalk[target_version];
            } else {
                var target_parts = target_version.split('.').map(function(i) { return +i; });
                if (target_parts.length != 3) { // parse failed
                    throw new Error("Unknown target version: " + target_version);
                }
                /*
                    The below code tries to infer the last known ABI compatible version
                    that we have recorded in the abi_crosswalk.json when an exact match
                    is not possible. The reasons for this to exist are complicated:

                       - We support passing --target to be able to allow developers to package binaries for versions of node
                         that are not the same one as they are running. This might also be used in combination with the
                         --target_arch or --target_platform flags to also package binaries for alternative platforms
                       - When --target is passed we can't therefore determine the ABI (process.versions.modules) from the node
                         version that is running in memory
                       - So, therefore node-pre-gyp keeps an "ABI crosswalk" (lib/util/abi_crosswalk.json) to be able to look
                         this info up for all versions
                       - But we cannot easily predict what the future ABI will be for released versions
                       - And node-pre-gyp needs to be a `bundledDependency` in apps that depend on it in order to work correctly
                         by being fully available at install time.
                       - So, the speed of node releases and the bundled nature of node-pre-gyp mean that a new node-pre-gyp release
                         need to happen for every node.js/io.js/node-webkit/nw.js/atom-shell/etc release that might come online if
                         you want the `--target` flag to keep working for the latest version
                       - Which is impractical ^^
                       - Hence the below code guesses about future ABI to make the need to update node-pre-gyp less demanding.

                    In practice then you can have a dependency of your app like `node-sqlite3` that bundles a `node-pre-gyp` that
                    only knows about node v0.10.33 in the `abi_crosswalk.json` but target node v0.10.34 (which is assumed to be
                    ABI compatible with v0.10.33).

                    TODO: use semver module instead of custom version parsing
                */
                var major = target_parts[0];
                var minor = target_parts[1];
                var patch = target_parts[2];
                // io.js: yeah if node.js ever releases 1.x this will break
                // but that is unlikely to happen: https://github.com/iojs/io.js/pull/253#issuecomment-69432616
                if (major === 1) {
                    // look for last release that is the same major version
                    // e.g. we assume io.js 1.x is ABI compatible with >= 1.0.0
                    while (true) {
                        if (minor > 0) --minor;
                        if (patch > 0) --patch;
                        var new_iojs_target = '' + major + '.' + minor + '.' + patch;
                        if (abi_crosswalk[new_iojs_target]) {
                            cross_obj = abi_crosswalk[new_iojs_target];
                            console.log('Warning: node-pre-gyp could not find exact match for ' + target_version);
                            console.log('Warning: but node-pre-gyp successfully choose ' + new_iojs_target + ' as ABI compatible target');
                            break;
                        }
                        if (minor === 0 && patch === 0) {
                            break;
                        }
                    }
                } else if (major >= 2) {
                    // look for last release that is the same major version
                    if (major_versions[major]) {
                        cross_obj = abi_crosswalk[major_versions[major]];
                        console.log('Warning: node-pre-gyp could not find exact match for ' + target_version);
                        console.log('Warning: but node-pre-gyp successfully choose ' + major_versions[major] + ' as ABI compatible target');
                    }
                } else if (major === 0) { // node.js
                    if (target_parts[1] % 2 === 0) { // for stable/even node.js series
                        // look for the last release that is the same minor release
                        // e.g. we assume node 0.10.x is ABI compatible with >= 0.10.0
                        while (--patch > 0) {
                            var new_node_target = '' + major + '.' + minor + '.' + patch;
                            if (abi_crosswalk[new_node_target]) {
                                cross_obj = abi_crosswalk[new_node_target];
                                console.log('Warning: node-pre-gyp could not find exact match for ' + target_version);
                                console.log('Warning: but node-pre-gyp successfully choose ' + new_node_target + ' as ABI compatible target');
                                break;
                            }
                        }
                    }
                }
            }
            if (!cross_obj) {
                throw new Error("Unsupported target version: " + target_version);
            }
            // emulate process.versions
            var versions_obj = {
                node: target_version,
                v8: cross_obj.v8+'.0',
                // abi_crosswalk uses 1 for node versions lacking process.versions.modules
                // process.versions.modules added in >= v0.10.4 and v0.11.7
                modules: cross_obj.node_abi > 1 ? cross_obj.node_abi : undefined
            };
            return get_node_abi(runtime, versions_obj);
        }
    }
}
module.exports.get_runtime_abi = get_runtime_abi;

var required_parameters = [
    'module_name',
    'module_path',
    'host'
];

function validate_config(package_json,opts) {
    var msg = package_json.name + ' package.json is not node-pre-gyp ready:\n';
    var missing = [];
    if (!package_json.main) {
        missing.push('main');
    }
    if (!package_json.version) {
        missing.push('version');
    }
    if (!package_json.name) {
        missing.push('name');
    }
    if (!package_json.binary) {
        missing.push('binary');
    }
    var o = package_json.binary;
    required_parameters.forEach(function(p) {
        if (missing.indexOf('binary') > -1) {
            missing.pop('binary');
        }
        if (!o || o[p] === undefined || o[p] === "") {
            missing.push('binary.' + p);
        }
    });
    if (missing.length >= 1) {
        throw new Error(msg+"package.json must declare these properties: \n" + missing.join('\n'));
    }
    if (o) {
        // enforce https over http
        var protocol = url.parse(o.host).protocol;
        if (protocol === 'http:') {
            throw new Error("'host' protocol ("+protocol+") is invalid - only 'https:' is accepted");
        }
    }
    napi.validate_package_json(package_json,opts);
}

module.exports.validate_config = validate_config;

function eval_template(template,opts) {
    Object.keys(opts).forEach(function(key) {
        var pattern = '{'+key+'}';
        while (template.indexOf(pattern) > -1) {
            template = template.replace(pattern,opts[key]);
        }
    });
    return template;
}

// url.resolve needs single trailing slash
// to behave correctly, otherwise a double slash
// may end up in the url which breaks requests
// and a lacking slash may not lead to proper joining
function fix_slashes(pathname) {
    if (pathname.slice(-1) != '/') {
        return pathname + '/';
    }
    return pathname;
}

// remove double slashes
// note: path.normalize will not work because
// it will convert forward to back slashes
function drop_double_slashes(pathname) {
    return pathname.replace(/\/\//g,'/');
}

function get_process_runtime(versions) {
    var runtime = 'node';
    if (versions['node-webkit']) {
        runtime = 'node-webkit';
    } else if (versions.electron) {
        runtime = 'electron';
    }
    return runtime;
}

module.exports.get_process_runtime = get_process_runtime;

var default_package_name = '{module_name}-v{version}-{node_abi}-{platform}-{arch}.tar.gz';
var default_remote_path = '';

module.exports.evaluate = function(package_json,options,napi_build_version) {
    options = options || {};
    validate_config(package_json,options); // options is a suitable substitute for opts in this case
    var v = package_json.version;
    var module_version = semver.parse(v);
    var runtime = options.runtime || get_process_runtime(process.versions);
    var opts = {
        name: package_json.name,
        configuration: Boolean(options.debug) ? 'Debug' : 'Release',
        debug: options.debug,
        module_name: package_json.binary.module_name,
        version: module_version.version,
        prerelease: module_version.prerelease.length ? module_version.prerelease.join('.') : '',
        build: module_version.build.length ? module_version.build.join('.') : '',
        major: module_version.major,
        minor: module_version.minor,
        patch: module_version.patch,
        runtime: runtime,
        node_abi: get_runtime_abi(runtime,options.target),
        node_abi_napi: napi.get_napi_version(options.target) ? 'napi' : get_runtime_abi(runtime,options.target),
        napi_version: napi.get_napi_version(options.target), // non-zero numeric, undefined if unsupported
        napi_build_version: napi_build_version || '',
        node_napi_label: napi_build_version ? 'napi-v' + napi_build_version : get_runtime_abi(runtime,options.target),
        target: options.target || '',
        platform: options.target_platform || process.platform,
        target_platform: options.target_platform || process.platform,
        arch: options.target_arch || process.arch,
        target_arch: options.target_arch || process.arch,
        libc: options.target_libc || detect_libc.family || 'unknown',
        module_main: package_json.main,
        toolset : options.toolset || '' // address https://github.com/mapbox/node-pre-gyp/issues/119
    };
    // support host mirror with npm config `--{module_name}_binary_host_mirror`
    // e.g.: https://github.com/node-inspector/v8-profiler/blob/master/package.json#L25
    // > npm install v8-profiler --profiler_binary_host_mirror=https://npm.taobao.org/mirrors/node-inspector/
    var host = process.env['npm_config_' + opts.module_name + '_binary_host_mirror'] || package_json.binary.host;
    opts.host = fix_slashes(eval_template(host,opts));
    opts.module_path = eval_template(package_json.binary.module_path,opts);
    // now we resolve the module_path to ensure it is absolute so that binding.gyp variables work predictably
    if (options.module_root) {
        // resolve relative to known module root: works for pre-binding require
        opts.module_path = path.join(options.module_root,opts.module_path);
    } else {
        // resolve relative to current working directory: works for node-pre-gyp commands
        opts.module_path = path.resolve(opts.module_path);
    }
    opts.module = path.join(opts.module_path,opts.module_name + '.node');
    opts.remote_path = package_json.binary.remote_path ? drop_double_slashes(fix_slashes(eval_template(package_json.binary.remote_path,opts))) : default_remote_path;
    var package_name = package_json.binary.package_name ? package_json.binary.package_name : default_package_name;
    opts.package_name = eval_template(package_name,opts);
    opts.staged_tarball = path.join('build/stage',opts.remote_path,opts.package_name);
    opts.hosted_path = url.resolve(opts.host,opts.remote_path);
    opts.hosted_tarball = url.resolve(opts.hosted_path,opts.package_name);
    return opts;
};


/***/ }),

/***/ "./node_modules/node-pre-gyp/package.json":
/*!************************************************!*\
  !*** ./node_modules/node-pre-gyp/package.json ***!
  \************************************************/
/*! exports provided: _from, _id, _inBundle, _integrity, _location, _phantomChildren, _requested, _requiredBy, _resolved, _shasum, _spec, _where, author, bin, bugs, bundleDependencies, dependencies, deprecated, description, devDependencies, homepage, jshintConfig, keywords, license, main, name, repository, scripts, version, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"_from\":\"node-pre-gyp@0.15.0\",\"_id\":\"node-pre-gyp@0.15.0\",\"_inBundle\":false,\"_integrity\":\"sha512-7QcZa8/fpaU/BKenjcaeFF9hLz2+7S9AqyXFhlH/rilsQ/hPZKK32RtR5EQHJElgu+q5RfbJ34KriI79UWaorA==\",\"_location\":\"/node-pre-gyp\",\"_phantomChildren\":{},\"_requested\":{\"type\":\"version\",\"registry\":true,\"raw\":\"node-pre-gyp@0.15.0\",\"name\":\"node-pre-gyp\",\"escapedName\":\"node-pre-gyp\",\"rawSpec\":\"0.15.0\",\"saveSpec\":null,\"fetchSpec\":\"0.15.0\"},\"_requiredBy\":[\"/bcrypt\"],\"_resolved\":\"https://registry.npmjs.org/node-pre-gyp/-/node-pre-gyp-0.15.0.tgz\",\"_shasum\":\"c2fc383276b74c7ffa842925241553e8b40f1087\",\"_spec\":\"node-pre-gyp@0.15.0\",\"_where\":\"/Users/nilswernecke/Documents/webdev/thesisproject/tripwiser/node_modules/bcrypt\",\"author\":{\"name\":\"Dane Springmeyer\",\"email\":\"dane@mapbox.com\"},\"bin\":{\"node-pre-gyp\":\"bin/node-pre-gyp\"},\"bugs\":{\"url\":\"https://github.com/mapbox/node-pre-gyp/issues\"},\"bundleDependencies\":false,\"dependencies\":{\"detect-libc\":\"^1.0.2\",\"mkdirp\":\"^0.5.3\",\"needle\":\"^2.5.0\",\"nopt\":\"^4.0.1\",\"npm-packlist\":\"^1.1.6\",\"npmlog\":\"^4.0.2\",\"rc\":\"^1.2.7\",\"rimraf\":\"^2.6.1\",\"semver\":\"^5.3.0\",\"tar\":\"^4.4.2\"},\"deprecated\":false,\"description\":\"Node.js native addon binary install tool\",\"devDependencies\":{\"aws-sdk\":\"^2.28.0\",\"jshint\":\"^2.9.5\",\"nock\":\"^9.2.3\",\"tape\":\"^4.6.3\"},\"homepage\":\"https://github.com/mapbox/node-pre-gyp#readme\",\"jshintConfig\":{\"node\":true,\"globalstrict\":true,\"undef\":true,\"unused\":false,\"noarg\":true},\"keywords\":[\"native\",\"addon\",\"module\",\"c\",\"c++\",\"bindings\",\"binary\"],\"license\":\"BSD-3-Clause\",\"main\":\"./lib/node-pre-gyp.js\",\"name\":\"node-pre-gyp\",\"repository\":{\"type\":\"git\",\"url\":\"git://github.com/mapbox/node-pre-gyp.git\"},\"scripts\":{\"pretest\":\"jshint test/build.test.js test/s3_setup.test.js test/versioning.test.js test/fetch.test.js lib lib/util scripts bin/node-pre-gyp\",\"test\":\"jshint lib lib/util scripts bin/node-pre-gyp && tape test/*test.js\",\"update-crosswalk\":\"node scripts/abi_crosswalk.js\"},\"version\":\"0.15.0\"}");

/***/ }),

/***/ "./node_modules/nopt/lib/nopt.js":
/*!***************************************!*\
  !*** ./node_modules/nopt/lib/nopt.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// info about each config option.

var debug = process.env.DEBUG_NOPT || process.env.NOPT_DEBUG
  ? function () { console.error.apply(console, arguments) }
  : function () {}

var url = __webpack_require__(/*! url */ "url")
  , path = __webpack_require__(/*! path */ "path")
  , Stream = __webpack_require__(/*! stream */ "stream").Stream
  , abbrev = __webpack_require__(/*! abbrev */ "./node_modules/abbrev/abbrev.js")
  , osenv = __webpack_require__(/*! osenv */ "./node_modules/osenv/osenv.js")

module.exports = exports = nopt
exports.clean = clean

exports.typeDefs =
  { String  : { type: String,  validate: validateString  }
  , Boolean : { type: Boolean, validate: validateBoolean }
  , url     : { type: url,     validate: validateUrl     }
  , Number  : { type: Number,  validate: validateNumber  }
  , path    : { type: path,    validate: validatePath    }
  , Stream  : { type: Stream,  validate: validateStream  }
  , Date    : { type: Date,    validate: validateDate    }
  }

function nopt (types, shorthands, args, slice) {
  args = args || process.argv
  types = types || {}
  shorthands = shorthands || {}
  if (typeof slice !== "number") slice = 2

  debug(types, shorthands, args, slice)

  args = args.slice(slice)
  var data = {}
    , key
    , argv = {
        remain: [],
        cooked: args,
        original: args.slice(0)
      }

  parse(args, data, argv.remain, types, shorthands)
  // now data is full
  clean(data, types, exports.typeDefs)
  data.argv = argv
  Object.defineProperty(data.argv, 'toString', { value: function () {
    return this.original.map(JSON.stringify).join(" ")
  }, enumerable: false })
  return data
}

function clean (data, types, typeDefs) {
  typeDefs = typeDefs || exports.typeDefs
  var remove = {}
    , typeDefault = [false, true, null, String, Array]

  Object.keys(data).forEach(function (k) {
    if (k === "argv") return
    var val = data[k]
      , isArray = Array.isArray(val)
      , type = types[k]
    if (!isArray) val = [val]
    if (!type) type = typeDefault
    if (type === Array) type = typeDefault.concat(Array)
    if (!Array.isArray(type)) type = [type]

    debug("val=%j", val)
    debug("types=", type)
    val = val.map(function (val) {
      // if it's an unknown value, then parse false/true/null/numbers/dates
      if (typeof val === "string") {
        debug("string %j", val)
        val = val.trim()
        if ((val === "null" && ~type.indexOf(null))
            || (val === "true" &&
               (~type.indexOf(true) || ~type.indexOf(Boolean)))
            || (val === "false" &&
               (~type.indexOf(false) || ~type.indexOf(Boolean)))) {
          val = JSON.parse(val)
          debug("jsonable %j", val)
        } else if (~type.indexOf(Number) && !isNaN(val)) {
          debug("convert to number", val)
          val = +val
        } else if (~type.indexOf(Date) && !isNaN(Date.parse(val))) {
          debug("convert to date", val)
          val = new Date(val)
        }
      }

      if (!types.hasOwnProperty(k)) {
        return val
      }

      // allow `--no-blah` to set 'blah' to null if null is allowed
      if (val === false && ~type.indexOf(null) &&
          !(~type.indexOf(false) || ~type.indexOf(Boolean))) {
        val = null
      }

      var d = {}
      d[k] = val
      debug("prevalidated val", d, val, types[k])
      if (!validate(d, k, val, types[k], typeDefs)) {
        if (exports.invalidHandler) {
          exports.invalidHandler(k, val, types[k], data)
        } else if (exports.invalidHandler !== false) {
          debug("invalid: "+k+"="+val, types[k])
        }
        return remove
      }
      debug("validated val", d, val, types[k])
      return d[k]
    }).filter(function (val) { return val !== remove })

    // if we allow Array specifically, then an empty array is how we
    // express 'no value here', not null.  Allow it.
    if (!val.length && type.indexOf(Array) === -1) {
      debug('VAL HAS NO LENGTH, DELETE IT', val, k, type.indexOf(Array))
      delete data[k]
    }
    else if (isArray) {
      debug(isArray, data[k], val)
      data[k] = val
    } else data[k] = val[0]

    debug("k=%s val=%j", k, val, data[k])
  })
}

function validateString (data, k, val) {
  data[k] = String(val)
}

function validatePath (data, k, val) {
  if (val === true) return false
  if (val === null) return true

  val = String(val)

  var isWin       = process.platform === 'win32'
    , homePattern = isWin ? /^~(\/|\\)/ : /^~\//
    , home        = osenv.home()

  if (home && val.match(homePattern)) {
    data[k] = path.resolve(home, val.substr(2))
  } else {
    data[k] = path.resolve(val)
  }
  return true
}

function validateNumber (data, k, val) {
  debug("validate Number %j %j %j", k, val, isNaN(val))
  if (isNaN(val)) return false
  data[k] = +val
}

function validateDate (data, k, val) {
  var s = Date.parse(val)
  debug("validate Date %j %j %j", k, val, s)
  if (isNaN(s)) return false
  data[k] = new Date(val)
}

function validateBoolean (data, k, val) {
  if (val instanceof Boolean) val = val.valueOf()
  else if (typeof val === "string") {
    if (!isNaN(val)) val = !!(+val)
    else if (val === "null" || val === "false") val = false
    else val = true
  } else val = !!val
  data[k] = val
}

function validateUrl (data, k, val) {
  val = url.parse(String(val))
  if (!val.host) return false
  data[k] = val.href
}

function validateStream (data, k, val) {
  if (!(val instanceof Stream)) return false
  data[k] = val
}

function validate (data, k, val, type, typeDefs) {
  // arrays are lists of types.
  if (Array.isArray(type)) {
    for (var i = 0, l = type.length; i < l; i ++) {
      if (type[i] === Array) continue
      if (validate(data, k, val, type[i], typeDefs)) return true
    }
    delete data[k]
    return false
  }

  // an array of anything?
  if (type === Array) return true

  // NaN is poisonous.  Means that something is not allowed.
  if (type !== type) {
    debug("Poison NaN", k, val, type)
    delete data[k]
    return false
  }

  // explicit list of values
  if (val === type) {
    debug("Explicitly allowed %j", val)
    // if (isArray) (data[k] = data[k] || []).push(val)
    // else data[k] = val
    data[k] = val
    return true
  }

  // now go through the list of typeDefs, validate against each one.
  var ok = false
    , types = Object.keys(typeDefs)
  for (var i = 0, l = types.length; i < l; i ++) {
    debug("test type %j %j %j", k, val, types[i])
    var t = typeDefs[types[i]]
    if (t &&
      ((type && type.name && t.type && t.type.name) ? (type.name === t.type.name) : (type === t.type))) {
      var d = {}
      ok = false !== t.validate(d, k, val)
      val = d[k]
      if (ok) {
        // if (isArray) (data[k] = data[k] || []).push(val)
        // else data[k] = val
        data[k] = val
        break
      }
    }
  }
  debug("OK? %j (%j %j %j)", ok, k, val, types[i])

  if (!ok) delete data[k]
  return ok
}

function parse (args, data, remain, types, shorthands) {
  debug("parse", args, data, remain)

  var key = null
    , abbrevs = abbrev(Object.keys(types))
    , shortAbbr = abbrev(Object.keys(shorthands))

  for (var i = 0; i < args.length; i ++) {
    var arg = args[i]
    debug("arg", arg)

    if (arg.match(/^-{2,}$/)) {
      // done with keys.
      // the rest are args.
      remain.push.apply(remain, args.slice(i + 1))
      args[i] = "--"
      break
    }
    var hadEq = false
    if (arg.charAt(0) === "-" && arg.length > 1) {
      var at = arg.indexOf('=')
      if (at > -1) {
        hadEq = true
        var v = arg.substr(at + 1)
        arg = arg.substr(0, at)
        args.splice(i, 1, arg, v)
      }

      // see if it's a shorthand
      // if so, splice and back up to re-parse it.
      var shRes = resolveShort(arg, shorthands, shortAbbr, abbrevs)
      debug("arg=%j shRes=%j", arg, shRes)
      if (shRes) {
        debug(arg, shRes)
        args.splice.apply(args, [i, 1].concat(shRes))
        if (arg !== shRes[0]) {
          i --
          continue
        }
      }
      arg = arg.replace(/^-+/, "")
      var no = null
      while (arg.toLowerCase().indexOf("no-") === 0) {
        no = !no
        arg = arg.substr(3)
      }

      if (abbrevs[arg]) arg = abbrevs[arg]

      var argType = types[arg]
      var isTypeArray = Array.isArray(argType)
      if (isTypeArray && argType.length === 1) {
        isTypeArray = false
        argType = argType[0]
      }

      var isArray = argType === Array ||
        isTypeArray && argType.indexOf(Array) !== -1

      // allow unknown things to be arrays if specified multiple times.
      if (!types.hasOwnProperty(arg) && data.hasOwnProperty(arg)) {
        if (!Array.isArray(data[arg]))
          data[arg] = [data[arg]]
        isArray = true
      }

      var val
        , la = args[i + 1]

      var isBool = typeof no === 'boolean' ||
        argType === Boolean ||
        isTypeArray && argType.indexOf(Boolean) !== -1 ||
        (typeof argType === 'undefined' && !hadEq) ||
        (la === "false" &&
         (argType === null ||
          isTypeArray && ~argType.indexOf(null)))

      if (isBool) {
        // just set and move along
        val = !no
        // however, also support --bool true or --bool false
        if (la === "true" || la === "false") {
          val = JSON.parse(la)
          la = null
          if (no) val = !val
          i ++
        }

        // also support "foo":[Boolean, "bar"] and "--foo bar"
        if (isTypeArray && la) {
          if (~argType.indexOf(la)) {
            // an explicit type
            val = la
            i ++
          } else if ( la === "null" && ~argType.indexOf(null) ) {
            // null allowed
            val = null
            i ++
          } else if ( !la.match(/^-{2,}[^-]/) &&
                      !isNaN(la) &&
                      ~argType.indexOf(Number) ) {
            // number
            val = +la
            i ++
          } else if ( !la.match(/^-[^-]/) && ~argType.indexOf(String) ) {
            // string
            val = la
            i ++
          }
        }

        if (isArray) (data[arg] = data[arg] || []).push(val)
        else data[arg] = val

        continue
      }

      if (argType === String) {
        if (la === undefined) {
          la = ""
        } else if (la.match(/^-{1,2}[^-]+/)) {
          la = ""
          i --
        }
      }

      if (la && la.match(/^-{2,}$/)) {
        la = undefined
        i --
      }

      val = la === undefined ? true : la
      if (isArray) (data[arg] = data[arg] || []).push(val)
      else data[arg] = val

      i ++
      continue
    }
    remain.push(arg)
  }
}

function resolveShort (arg, shorthands, shortAbbr, abbrevs) {
  // handle single-char shorthands glommed together, like
  // npm ls -glp, but only if there is one dash, and only if
  // all of the chars are single-char shorthands, and it's
  // not a match to some other abbrev.
  arg = arg.replace(/^-+/, '')

  // if it's an exact known option, then don't go any further
  if (abbrevs[arg] === arg)
    return null

  // if it's an exact known shortopt, same deal
  if (shorthands[arg]) {
    // make it an array, if it's a list of words
    if (shorthands[arg] && !Array.isArray(shorthands[arg]))
      shorthands[arg] = shorthands[arg].split(/\s+/)

    return shorthands[arg]
  }

  // first check to see if this arg is a set of single-char shorthands
  var singles = shorthands.___singles
  if (!singles) {
    singles = Object.keys(shorthands).filter(function (s) {
      return s.length === 1
    }).reduce(function (l,r) {
      l[r] = true
      return l
    }, {})
    shorthands.___singles = singles
    debug('shorthand singles', singles)
  }

  var chrs = arg.split("").filter(function (c) {
    return singles[c]
  })

  if (chrs.join("") === arg) return chrs.map(function (c) {
    return shorthands[c]
  }).reduce(function (l, r) {
    return l.concat(r)
  }, [])


  // if it's an arg abbrev, and not a literal shorthand, then prefer the arg
  if (abbrevs[arg] && !shorthands[arg])
    return null

  // if it's an abbr for a shorthand, then use that
  if (shortAbbr[arg])
    arg = shortAbbr[arg]

  // make it an array, if it's a list of words
  if (shorthands[arg] && !Array.isArray(shorthands[arg]))
    shorthands[arg] = shorthands[arg].split(/\s+/)

  return shorthands[arg]
}


/***/ }),

/***/ "./node_modules/npm-bundled/index.js":
/*!*******************************************!*\
  !*** ./node_modules/npm-bundled/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// walk the tree of deps starting from the top level list of bundled deps
// Any deps at the top level that are depended on by a bundled dep that
// does not have that dep in its own node_modules folder are considered
// bundled deps as well.  This list of names can be passed to npm-packlist
// as the "bundled" argument.  Additionally, packageJsonCache is shared so
// packlist doesn't have to re-read files already consumed in this pass

const fs = __webpack_require__(/*! fs */ "fs")
const path = __webpack_require__(/*! path */ "path")
const EE = __webpack_require__(/*! events */ "events").EventEmitter
// we don't care about the package bins, but we share a pj cache
// with other modules that DO care about it, so keep it nice.
const normalizePackageBin = __webpack_require__(/*! npm-normalize-package-bin */ "./node_modules/npm-normalize-package-bin/index.js")

class BundleWalker extends EE {
  constructor (opt) {
    opt = opt || {}
    super(opt)
    this.path = path.resolve(opt.path || process.cwd())

    this.parent = opt.parent || null
    if (this.parent) {
      this.result = this.parent.result
      // only collect results in node_modules folders at the top level
      // since the node_modules in a bundled dep is included always
      if (!this.parent.parent) {
        const base = path.basename(this.path)
        const scope = path.basename(path.dirname(this.path))
        this.result.add(/^@/.test(scope) ? scope + '/' + base : base)
      }
      this.root = this.parent.root
      this.packageJsonCache = this.parent.packageJsonCache
    } else {
      this.result = new Set()
      this.root = this.path
      this.packageJsonCache = opt.packageJsonCache || new Map()
    }

    this.seen = new Set()
    this.didDone = false
    this.children = 0
    this.node_modules = []
    this.package = null
    this.bundle = null
  }

  addListener (ev, fn) {
    return this.on(ev, fn)
  }

  on (ev, fn) {
    const ret = super.on(ev, fn)
    if (ev === 'done' && this.didDone) {
      this.emit('done', this.result)
    }
    return ret
  }

  done () {
    if (!this.didDone) {
      this.didDone = true
      if (!this.parent) {
        const res = Array.from(this.result)
        this.result = res
        this.emit('done', res)
      } else {
        this.emit('done')
      }
    }
  }

  start () {
    const pj = path.resolve(this.path, 'package.json')
    if (this.packageJsonCache.has(pj))
      this.onPackage(this.packageJsonCache.get(pj))
    else
      this.readPackageJson(pj)
    return this
  }

  readPackageJson (pj) {
    fs.readFile(pj, (er, data) =>
      er ? this.done() : this.onPackageJson(pj, data))
  }

  onPackageJson (pj, data) {
    try {
      this.package = normalizePackageBin(JSON.parse(data + ''))
    } catch (er) {
      return this.done()
    }
    this.packageJsonCache.set(pj, this.package)
    this.onPackage(this.package)
  }

  allDepsBundled (pkg) {
    return Object.keys(pkg.dependencies || {}).concat(
      Object.keys(pkg.optionalDependencies || {}))
  }

  onPackage (pkg) {
    // all deps are bundled if we got here as a child.
    // otherwise, only bundle bundledDeps
    // Get a unique-ified array with a short-lived Set
    const bdRaw = this.parent ? this.allDepsBundled(pkg)
      : pkg.bundleDependencies || pkg.bundledDependencies || []

    const bd = Array.from(new Set(
      Array.isArray(bdRaw) ? bdRaw
      : bdRaw === true ? this.allDepsBundled(pkg)
      : Object.keys(bdRaw)))

    if (!bd.length)
      return this.done()

    this.bundle = bd
    const nm = this.path + '/node_modules'
    this.readModules()
  }

  readModules () {
    readdirNodeModules(this.path + '/node_modules', (er, nm) =>
      er ? this.onReaddir([]) : this.onReaddir(nm))
  }

  onReaddir (nm) {
    // keep track of what we have, in case children need it
    this.node_modules = nm

    this.bundle.forEach(dep => this.childDep(dep))
    if (this.children === 0)
      this.done()
  }

  childDep (dep) {
    if (this.node_modules.indexOf(dep) !== -1 && !this.seen.has(dep)) {
      this.seen.add(dep)
      this.child(dep)
    } else if (this.parent) {
      this.parent.childDep(dep)
    }
  }

  child (dep) {
    const p = this.path + '/node_modules/' + dep
    this.children += 1
    const child = new BundleWalker({
      path: p,
      parent: this
    })
    child.on('done', _ => {
      if (--this.children === 0)
        this.done()
    })
    child.start()
  }
}

class BundleWalkerSync extends BundleWalker {
  constructor (opt) {
    super(opt)
  }

  start () {
    super.start()
    this.done()
    return this
  }

  readPackageJson (pj) {
    try {
      this.onPackageJson(pj, fs.readFileSync(pj))
    } catch (er) {}
    return this
  }

  readModules () {
    try {
      this.onReaddir(readdirNodeModulesSync(this.path + '/node_modules'))
    } catch (er) {
      this.onReaddir([])
    }
  }

  child (dep) {
    new BundleWalkerSync({
      path: this.path + '/node_modules/' + dep,
      parent: this
    }).start()
  }
}

const readdirNodeModules = (nm, cb) => {
  fs.readdir(nm, (er, set) => {
    if (er)
      cb(er)
    else {
      const scopes = set.filter(f => /^@/.test(f))
      if (!scopes.length)
        cb(null, set)
      else {
        const unscoped = set.filter(f => !/^@/.test(f))
        let count = scopes.length
        scopes.forEach(scope => {
          fs.readdir(nm + '/' + scope, (er, pkgs) => {
            if (er || !pkgs.length)
              unscoped.push(scope)
            else
              unscoped.push.apply(unscoped, pkgs.map(p => scope + '/' + p))
            if (--count === 0)
              cb(null, unscoped)
          })
        })
      }
    }
  })
}

const readdirNodeModulesSync = nm => {
  const set = fs.readdirSync(nm)
  const unscoped = set.filter(f => !/^@/.test(f))
  const scopes = set.filter(f => /^@/.test(f)).map(scope => {
    try {
      const pkgs = fs.readdirSync(nm + '/' + scope)
      return pkgs.length ? pkgs.map(p => scope + '/' + p) : [scope]
    } catch (er) {
      return [scope]
    }
  }).reduce((a, b) => a.concat(b), [])
  return unscoped.concat(scopes)
}

const walk = (options, callback) => {
  const p = new Promise((resolve, reject) => {
    new BundleWalker(options).on('done', resolve).on('error', reject).start()
  })
  return callback ? p.then(res => callback(null, res), callback) : p
}

const walkSync = options => {
  return new BundleWalkerSync(options).start().result
}

module.exports = walk
walk.sync = walkSync
walk.BundleWalker = BundleWalker
walk.BundleWalkerSync = BundleWalkerSync


/***/ }),

/***/ "./node_modules/npm-normalize-package-bin/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/npm-normalize-package-bin/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// pass in a manifest with a 'bin' field here, and it'll turn it
// into a properly santized bin object
const {join, basename} = __webpack_require__(/*! path */ "path")

const normalize = pkg =>
  !pkg.bin ? removeBin(pkg)
  : typeof pkg.bin === 'string' ? normalizeString(pkg)
  : Array.isArray(pkg.bin) ? normalizeArray(pkg)
  : typeof pkg.bin === 'object' ? normalizeObject(pkg)
  : removeBin(pkg)

const normalizeString = pkg => {
  if (!pkg.name)
    return removeBin(pkg)
  pkg.bin = { [pkg.name]: pkg.bin }
  return normalizeObject(pkg)
}

const normalizeArray = pkg => {
  pkg.bin = pkg.bin.reduce((acc, k) => {
    acc[basename(k)] = k
    return acc
  }, {})
  return normalizeObject(pkg)
}

const removeBin = pkg => {
  delete pkg.bin
  return pkg
}

const normalizeObject = pkg => {
  const orig = pkg.bin
  const clean = {}
  let hasBins = false
  Object.keys(orig).forEach(binKey => {
    const base = join('/', basename(binKey.replace(/\\|:/g, '/'))).substr(1)

    if (typeof orig[binKey] !== 'string' || !base)
      return

    const binTarget = join('/', orig[binKey])
      .replace(/\\/g, '/').substr(1)

    if (!binTarget)
      return

    clean[base] = binTarget
    hasBins = true
  })

  if (hasBins)
    pkg.bin = clean
  else
    delete pkg.bin

  return pkg
}

module.exports = normalize


/***/ }),

/***/ "./node_modules/npm-packlist/index.js":
/*!********************************************!*\
  !*** ./node_modules/npm-packlist/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Do a two-pass walk, first to get the list of packages that need to be
// bundled, then again to get the actual files and folders.
// Keep a cache of node_modules content and package.json data, so that the
// second walk doesn't have to re-do all the same work.

const bundleWalk = __webpack_require__(/*! npm-bundled */ "./node_modules/npm-bundled/index.js")
const BundleWalker = bundleWalk.BundleWalker
const BundleWalkerSync = bundleWalk.BundleWalkerSync

const ignoreWalk = __webpack_require__(/*! ignore-walk */ "./node_modules/ignore-walk/index.js")
const IgnoreWalker = ignoreWalk.Walker
const IgnoreWalkerSync = ignoreWalk.WalkerSync

const rootBuiltinRules = Symbol('root-builtin-rules')
const packageNecessaryRules = Symbol('package-necessary-rules')
const path = __webpack_require__(/*! path */ "path")

const normalizePackageBin = __webpack_require__(/*! npm-normalize-package-bin */ "./node_modules/npm-normalize-package-bin/index.js")

const defaultRules = [
  '.npmignore',
  '.gitignore',
  '**/.git',
  '**/.svn',
  '**/.hg',
  '**/CVS',
  '**/.git/**',
  '**/.svn/**',
  '**/.hg/**',
  '**/CVS/**',
  '/.lock-wscript',
  '/.wafpickle-*',
  '/build/config.gypi',
  'npm-debug.log',
  '**/.npmrc',
  '.*.swp',
  '.DS_Store',
  '**/.DS_Store/**',
  '._*',
  '**/._*/**',
  '*.orig',
  '/package-lock.json',
  '/yarn.lock',
  'archived-packages/**',
  'core',
  '!core/',
  '!**/core/',
  '*.core',
  '*.vgcore',
  'vgcore.*',
  'core.+([0-9])',
]

// There may be others, but :?|<> are handled by node-tar
const nameIsBadForWindows = file => /\*/.test(file)

// a decorator that applies our custom rules to an ignore walker
const npmWalker = Class => class Walker extends Class {
  constructor (opt) {
    opt = opt || {}

    // the order in which rules are applied.
    opt.ignoreFiles = [
      rootBuiltinRules,
      'package.json',
      '.npmignore',
      '.gitignore',
      packageNecessaryRules
    ]

    opt.includeEmpty = false
    opt.path = opt.path || process.cwd()
    const dirName = path.basename(opt.path)
    const parentName = path.basename(path.dirname(opt.path))
    opt.follow =
      dirName === 'node_modules' ||
      (parentName === 'node_modules' && /^@/.test(dirName))
    super(opt)

    // ignore a bunch of things by default at the root level.
    // also ignore anything in node_modules, except bundled dependencies
    if (!this.parent) {
      this.bundled = opt.bundled || []
      this.bundledScopes = Array.from(new Set(
        this.bundled.filter(f => /^@/.test(f))
        .map(f => f.split('/')[0])))
      const rules = defaultRules.join('\n') + '\n'
      this.packageJsonCache = opt.packageJsonCache || new Map()
      super.onReadIgnoreFile(rootBuiltinRules, rules, _=>_)
    } else {
      this.bundled = []
      this.bundledScopes = []
      this.packageJsonCache = this.parent.packageJsonCache
    }
  }

  onReaddir (entries) {
    if (!this.parent) {
      entries = entries.filter(e =>
        e !== '.git' &&
        !(e === 'node_modules' && this.bundled.length === 0)
      )
    }
    return super.onReaddir(entries)
  }

  filterEntry (entry, partial) {
    // get the partial path from the root of the walk
    const p = this.path.substr(this.root.length + 1)
    const pkgre = /^node_modules\/(@[^\/]+\/?[^\/]+|[^\/]+)(\/.*)?$/
    const isRoot = !this.parent
    const pkg = isRoot && pkgre.test(entry) ?
      entry.replace(pkgre, '$1') : null
    const rootNM = isRoot && entry === 'node_modules'
    const rootPJ = isRoot && entry === 'package.json'

    return (
      // if we're in a bundled package, check with the parent.
      /^node_modules($|\/)/i.test(p) ? this.parent.filterEntry(
          this.basename + '/' + entry, partial)

      // if package is bundled, all files included
      // also include @scope dirs for bundled scoped deps
      // they'll be ignored if no files end up in them.
      // However, this only matters if we're in the root.
      // node_modules folders elsewhere, like lib/node_modules,
      // should be included normally unless ignored.
      : pkg ? -1 !== this.bundled.indexOf(pkg) ||
        -1 !== this.bundledScopes.indexOf(pkg)

      // only walk top node_modules if we want to bundle something
      : rootNM ? !!this.bundled.length

      // always include package.json at the root.
      : rootPJ ? true

      // otherwise, follow ignore-walk's logic
      : super.filterEntry(entry, partial)
    )
  }

  filterEntries () {
    if (this.ignoreRules['package.json'])
      this.ignoreRules['.gitignore'] = this.ignoreRules['.npmignore'] = null
    else if (this.ignoreRules['.npmignore'])
      this.ignoreRules['.gitignore'] = null
    this.filterEntries = super.filterEntries
    super.filterEntries()
  }

  addIgnoreFile (file, then) {
    const ig = path.resolve(this.path, file)
    if (this.packageJsonCache.has(ig))
      this.onPackageJson(ig, this.packageJsonCache.get(ig), then)
    else
      super.addIgnoreFile(file, then)
  }

  onPackageJson (ig, pkg, then) {
    this.packageJsonCache.set(ig, pkg)

    // if there's a bin, browser or main, make sure we don't ignore it
    // also, don't ignore the package.json itself!
    //
    // Weird side-effect of this: a readme (etc) file will be included
    // if it exists anywhere within a folder with a package.json file.
    // The original intent was only to include these files in the root,
    // but now users in the wild are dependent on that behavior for
    // localized documentation and other use cases.  Adding a `/` to
    // these rules, while tempting and arguably more "correct", is a
    // breaking change.
    const rules = [
      pkg.browser ? '!' + pkg.browser : '',
      pkg.main ? '!' + pkg.main : '',
      '!package.json',
      '!npm-shrinkwrap.json',
      '!@(readme|copying|license|licence|notice|changes|changelog|history){,.*[^~$]}'
    ]
    if (pkg.bin) {
      // always an object, because normalized already
      for (const key in pkg.bin)
        rules.push('!' + pkg.bin[key])
    }

    const data = rules.filter(f => f).join('\n') + '\n'
    super.onReadIgnoreFile(packageNecessaryRules, data, _=>_)

    if (Array.isArray(pkg.files))
      super.onReadIgnoreFile('package.json', '*\n' + pkg.files.map(
        f => '!' + f + '\n!' + f.replace(/\/+$/, '') + '/**'
      ).join('\n') + '\n', then)
    else
      then()
  }

  // override parent stat function to completely skip any filenames
  // that will break windows entirely.
  // XXX(isaacs) Next major version should make this an error instead.
  stat (entry, file, dir, then) {
    if (nameIsBadForWindows(entry))
      then()
    else
      super.stat(entry, file, dir, then)
  }

  // override parent onstat function to nix all symlinks
  onstat (st, entry, file, dir, then) {
    if (st.isSymbolicLink())
      then()
    else
      super.onstat(st, entry, file, dir, then)
  }

  onReadIgnoreFile (file, data, then) {
    if (file === 'package.json')
      try {
        const ig = path.resolve(this.path, file)
        this.onPackageJson(ig, normalizePackageBin(JSON.parse(data)), then)
      } catch (er) {
        // ignore package.json files that are not json
        then()
      }
    else
      super.onReadIgnoreFile(file, data, then)
  }

  sort (a, b) {
    return sort(a, b)
  }
}

class Walker extends npmWalker(IgnoreWalker) {
  walker (entry, then) {
    new Walker(this.walkerOpt(entry)).on('done', then).start()
  }
}

class WalkerSync extends npmWalker(IgnoreWalkerSync) {
  walker (entry, then) {
    new WalkerSync(this.walkerOpt(entry)).start()
    then()
  }
}

const walk = (options, callback) => {
  options = options || {}
  const p = new Promise((resolve, reject) => {
    const bw = new BundleWalker(options)
    bw.on('done', bundled => {
      options.bundled = bundled
      options.packageJsonCache = bw.packageJsonCache
      new Walker(options).on('done', resolve).on('error', reject).start()
    })
    bw.start()
  })
  return callback ? p.then(res => callback(null, res), callback) : p
}

const walkSync = options => {
  options = options || {}
  const bw = new BundleWalkerSync(options).start()
  options.bundled = bw.result
  options.packageJsonCache = bw.packageJsonCache
  const walker = new WalkerSync(options)
  walker.start()
  return walker.result
}

// optimize for compressibility
// extname, then basename, then locale alphabetically
// https://twitter.com/isntitvacant/status/1131094910923231232
const sort = (a, b) => {
  const exta = path.extname(a).toLowerCase()
  const extb = path.extname(b).toLowerCase()
  const basea = path.basename(a).toLowerCase()
  const baseb = path.basename(b).toLowerCase()

  return exta.localeCompare(extb) ||
    basea.localeCompare(baseb) ||
    a.localeCompare(b)
}


module.exports = walk
walk.sync = walkSync
walk.Walker = Walker
walk.WalkerSync = WalkerSync


/***/ }),

/***/ "./node_modules/npmlog/log.js":
/*!************************************!*\
  !*** ./node_modules/npmlog/log.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Progress = __webpack_require__(/*! are-we-there-yet */ "./node_modules/are-we-there-yet/index.js")
var Gauge = __webpack_require__(/*! gauge */ "./node_modules/gauge/index.js")
var EE = __webpack_require__(/*! events */ "events").EventEmitter
var log = exports = module.exports = new EE()
var util = __webpack_require__(/*! util */ "util")

var setBlocking = __webpack_require__(/*! set-blocking */ "set-blocking")
var consoleControl = __webpack_require__(/*! console-control-strings */ "./node_modules/console-control-strings/index.js")

setBlocking(true)
var stream = process.stderr
Object.defineProperty(log, 'stream', {
  set: function (newStream) {
    stream = newStream
    if (this.gauge) this.gauge.setWriteTo(stream, stream)
  },
  get: function () {
    return stream
  }
})

// by default, decide based on tty-ness.
var colorEnabled
log.useColor = function () {
  return colorEnabled != null ? colorEnabled : stream.isTTY
}

log.enableColor = function () {
  colorEnabled = true
  this.gauge.setTheme({hasColor: colorEnabled, hasUnicode: unicodeEnabled})
}
log.disableColor = function () {
  colorEnabled = false
  this.gauge.setTheme({hasColor: colorEnabled, hasUnicode: unicodeEnabled})
}

// default level
log.level = 'info'

log.gauge = new Gauge(stream, {
  enabled: false, // no progress bars unless asked
  theme: {hasColor: log.useColor()},
  template: [
    {type: 'progressbar', length: 20},
    {type: 'activityIndicator', kerning: 1, length: 1},
    {type: 'section', default: ''},
    ':',
    {type: 'logline', kerning: 1, default: ''}
  ]
})

log.tracker = new Progress.TrackerGroup()

// we track this separately as we may need to temporarily disable the
// display of the status bar for our own loggy purposes.
log.progressEnabled = log.gauge.isEnabled()

var unicodeEnabled

log.enableUnicode = function () {
  unicodeEnabled = true
  this.gauge.setTheme({hasColor: this.useColor(), hasUnicode: unicodeEnabled})
}

log.disableUnicode = function () {
  unicodeEnabled = false
  this.gauge.setTheme({hasColor: this.useColor(), hasUnicode: unicodeEnabled})
}

log.setGaugeThemeset = function (themes) {
  this.gauge.setThemeset(themes)
}

log.setGaugeTemplate = function (template) {
  this.gauge.setTemplate(template)
}

log.enableProgress = function () {
  if (this.progressEnabled) return
  this.progressEnabled = true
  this.tracker.on('change', this.showProgress)
  if (this._pause) return
  this.gauge.enable()
}

log.disableProgress = function () {
  if (!this.progressEnabled) return
  this.progressEnabled = false
  this.tracker.removeListener('change', this.showProgress)
  this.gauge.disable()
}

var trackerConstructors = ['newGroup', 'newItem', 'newStream']

var mixinLog = function (tracker) {
  // mixin the public methods from log into the tracker
  // (except: conflicts and one's we handle specially)
  Object.keys(log).forEach(function (P) {
    if (P[0] === '_') return
    if (trackerConstructors.filter(function (C) { return C === P }).length) return
    if (tracker[P]) return
    if (typeof log[P] !== 'function') return
    var func = log[P]
    tracker[P] = function () {
      return func.apply(log, arguments)
    }
  })
  // if the new tracker is a group, make sure any subtrackers get
  // mixed in too
  if (tracker instanceof Progress.TrackerGroup) {
    trackerConstructors.forEach(function (C) {
      var func = tracker[C]
      tracker[C] = function () { return mixinLog(func.apply(tracker, arguments)) }
    })
  }
  return tracker
}

// Add tracker constructors to the top level log object
trackerConstructors.forEach(function (C) {
  log[C] = function () { return mixinLog(this.tracker[C].apply(this.tracker, arguments)) }
})

log.clearProgress = function (cb) {
  if (!this.progressEnabled) return cb && process.nextTick(cb)
  this.gauge.hide(cb)
}

log.showProgress = function (name, completed) {
  if (!this.progressEnabled) return
  var values = {}
  if (name) values.section = name
  var last = log.record[log.record.length - 1]
  if (last) {
    values.subsection = last.prefix
    var disp = log.disp[last.level] || last.level
    var logline = this._format(disp, log.style[last.level])
    if (last.prefix) logline += ' ' + this._format(last.prefix, this.prefixStyle)
    logline += ' ' + last.message.split(/\r?\n/)[0]
    values.logline = logline
  }
  values.completed = completed || this.tracker.completed()
  this.gauge.show(values)
}.bind(log) // bind for use in tracker's on-change listener

// temporarily stop emitting, but don't drop
log.pause = function () {
  this._paused = true
  if (this.progressEnabled) this.gauge.disable()
}

log.resume = function () {
  if (!this._paused) return
  this._paused = false

  var b = this._buffer
  this._buffer = []
  b.forEach(function (m) {
    this.emitLog(m)
  }, this)
  if (this.progressEnabled) this.gauge.enable()
}

log._buffer = []

var id = 0
log.record = []
log.maxRecordSize = 10000
log.log = function (lvl, prefix, message) {
  var l = this.levels[lvl]
  if (l === undefined) {
    return this.emit('error', new Error(util.format(
      'Undefined log level: %j', lvl)))
  }

  var a = new Array(arguments.length - 2)
  var stack = null
  for (var i = 2; i < arguments.length; i++) {
    var arg = a[i - 2] = arguments[i]

    // resolve stack traces to a plain string.
    if (typeof arg === 'object' && arg &&
        (arg instanceof Error) && arg.stack) {

      Object.defineProperty(arg, 'stack', {
        value: stack = arg.stack + '',
        enumerable: true,
        writable: true
      })
    }
  }
  if (stack) a.unshift(stack + '\n')
  message = util.format.apply(util, a)

  var m = { id: id++,
            level: lvl,
            prefix: String(prefix || ''),
            message: message,
            messageRaw: a }

  this.emit('log', m)
  this.emit('log.' + lvl, m)
  if (m.prefix) this.emit(m.prefix, m)

  this.record.push(m)
  var mrs = this.maxRecordSize
  var n = this.record.length - mrs
  if (n > mrs / 10) {
    var newSize = Math.floor(mrs * 0.9)
    this.record = this.record.slice(-1 * newSize)
  }

  this.emitLog(m)
}.bind(log)

log.emitLog = function (m) {
  if (this._paused) {
    this._buffer.push(m)
    return
  }
  if (this.progressEnabled) this.gauge.pulse(m.prefix)
  var l = this.levels[m.level]
  if (l === undefined) return
  if (l < this.levels[this.level]) return
  if (l > 0 && !isFinite(l)) return

  // If 'disp' is null or undefined, use the lvl as a default
  // Allows: '', 0 as valid disp
  var disp = log.disp[m.level] != null ? log.disp[m.level] : m.level
  this.clearProgress()
  m.message.split(/\r?\n/).forEach(function (line) {
    if (this.heading) {
      this.write(this.heading, this.headingStyle)
      this.write(' ')
    }
    this.write(disp, log.style[m.level])
    var p = m.prefix || ''
    if (p) this.write(' ')
    this.write(p, this.prefixStyle)
    this.write(' ' + line + '\n')
  }, this)
  this.showProgress()
}

log._format = function (msg, style) {
  if (!stream) return

  var output = ''
  if (this.useColor()) {
    style = style || {}
    var settings = []
    if (style.fg) settings.push(style.fg)
    if (style.bg) settings.push('bg' + style.bg[0].toUpperCase() + style.bg.slice(1))
    if (style.bold) settings.push('bold')
    if (style.underline) settings.push('underline')
    if (style.inverse) settings.push('inverse')
    if (settings.length) output += consoleControl.color(settings)
    if (style.beep) output += consoleControl.beep()
  }
  output += msg
  if (this.useColor()) {
    output += consoleControl.color('reset')
  }
  return output
}

log.write = function (msg, style) {
  if (!stream) return

  stream.write(this._format(msg, style))
}

log.addLevel = function (lvl, n, style, disp) {
  // If 'disp' is null or undefined, use the lvl as a default
  if (disp == null) disp = lvl
  this.levels[lvl] = n
  this.style[lvl] = style
  if (!this[lvl]) {
    this[lvl] = function () {
      var a = new Array(arguments.length + 1)
      a[0] = lvl
      for (var i = 0; i < arguments.length; i++) {
        a[i + 1] = arguments[i]
      }
      return this.log.apply(this, a)
    }.bind(this)
  }
  this.disp[lvl] = disp
}

log.prefixStyle = { fg: 'magenta' }
log.headingStyle = { fg: 'white', bg: 'black' }

log.style = {}
log.levels = {}
log.disp = {}
log.addLevel('silly', -Infinity, { inverse: true }, 'sill')
log.addLevel('verbose', 1000, { fg: 'blue', bg: 'black' }, 'verb')
log.addLevel('info', 2000, { fg: 'green' })
log.addLevel('timing', 2500, { fg: 'green', bg: 'black' })
log.addLevel('http', 3000, { fg: 'green', bg: 'black' })
log.addLevel('notice', 3500, { fg: 'blue', bg: 'black' })
log.addLevel('warn', 4000, { fg: 'black', bg: 'yellow' }, 'WARN')
log.addLevel('error', 5000, { fg: 'red', bg: 'black' }, 'ERR!')
log.addLevel('silent', Infinity)

// allow 'error' prefix
log.on('error', function () {})


/***/ }),

/***/ "./node_modules/os-homedir/index.js":
/*!******************************************!*\
  !*** ./node_modules/os-homedir/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var os = __webpack_require__(/*! os */ "os");

function homedir() {
	var env = process.env;
	var home = env.HOME;
	var user = env.LOGNAME || env.USER || env.LNAME || env.USERNAME;

	if (process.platform === 'win32') {
		return env.USERPROFILE || env.HOMEDRIVE + env.HOMEPATH || home || null;
	}

	if (process.platform === 'darwin') {
		return home || (user ? '/Users/' + user : null);
	}

	if (process.platform === 'linux') {
		return home || (process.getuid() === 0 ? '/root' : (user ? '/home/' + user : null));
	}

	return home || null;
}

module.exports = typeof os.homedir === 'function' ? os.homedir : homedir;


/***/ }),

/***/ "./node_modules/osenv/osenv.js":
/*!*************************************!*\
  !*** ./node_modules/osenv/osenv.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isWindows = process.platform === 'win32'
var path = __webpack_require__(/*! path */ "path")
var exec = __webpack_require__(/*! child_process */ "child_process").exec
var osTmpdir = __webpack_require__(/*! os-tmpdir */ "os-tmpdir")
var osHomedir = __webpack_require__(/*! os-homedir */ "./node_modules/os-homedir/index.js")

// looking up envs is a bit costly.
// Also, sometimes we want to have a fallback
// Pass in a callback to wait for the fallback on failures
// After the first lookup, always returns the same thing.
function memo (key, lookup, fallback) {
  var fell = false
  var falling = false
  exports[key] = function (cb) {
    var val = lookup()
    if (!val && !fell && !falling && fallback) {
      fell = true
      falling = true
      exec(fallback, function (er, output, stderr) {
        falling = false
        if (er) return // oh well, we tried
        val = output.trim()
      })
    }
    exports[key] = function (cb) {
      if (cb) process.nextTick(cb.bind(null, null, val))
      return val
    }
    if (cb && !falling) process.nextTick(cb.bind(null, null, val))
    return val
  }
}

memo('user', function () {
  return ( isWindows
         ? process.env.USERDOMAIN + '\\' + process.env.USERNAME
         : process.env.USER
         )
}, 'whoami')

memo('prompt', function () {
  return isWindows ? process.env.PROMPT : process.env.PS1
})

memo('hostname', function () {
  return isWindows ? process.env.COMPUTERNAME : process.env.HOSTNAME
}, 'hostname')

memo('tmpdir', function () {
  return osTmpdir()
})

memo('home', function () {
  return osHomedir()
})

memo('path', function () {
  return (process.env.PATH ||
          process.env.Path ||
          process.env.path).split(isWindows ? ';' : ':')
})

memo('editor', function () {
  return process.env.EDITOR ||
         process.env.VISUAL ||
         (isWindows ? 'notepad.exe' : 'vi')
})

memo('shell', function () {
  return isWindows ? process.env.ComSpec || 'cmd'
         : process.env.SHELL || 'bash'
})


/***/ }),

/***/ "./node_modules/rc/index.js":
/*!**********************************!*\
  !*** ./node_modules/rc/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var cc   = __webpack_require__(/*! ./lib/utils */ "./node_modules/rc/lib/utils.js")
var join = __webpack_require__(/*! path */ "path").join
var deepExtend = __webpack_require__(/*! deep-extend */ "./node_modules/deep-extend/lib/deep-extend.js")
var etc = '/etc'
var win = process.platform === "win32"
var home = win
           ? process.env.USERPROFILE
           : process.env.HOME

module.exports = function (name, defaults, argv, parse) {
  if('string' !== typeof name)
    throw new Error('rc(name): name *must* be string')
  if(!argv)
    argv = __webpack_require__(/*! minimist */ "minimist")(process.argv.slice(2))
  defaults = (
      'string' === typeof defaults
    ? cc.json(defaults) : defaults
    ) || {}

  parse = parse || cc.parse

  var env = cc.env(name + '_')

  var configs = [defaults]
  var configFiles = []
  function addConfigFile (file) {
    if (configFiles.indexOf(file) >= 0) return
    var fileConfig = cc.file(file)
    if (fileConfig) {
      configs.push(parse(fileConfig))
      configFiles.push(file)
    }
  }

  // which files do we look at?
  if (!win)
   [join(etc, name, 'config'),
    join(etc, name + 'rc')].forEach(addConfigFile)
  if (home)
   [join(home, '.config', name, 'config'),
    join(home, '.config', name),
    join(home, '.' + name, 'config'),
    join(home, '.' + name + 'rc')].forEach(addConfigFile)
  addConfigFile(cc.find('.'+name+'rc'))
  if (env.config) addConfigFile(env.config)
  if (argv.config) addConfigFile(argv.config)

  return deepExtend.apply(null, configs.concat([
    env,
    argv,
    configFiles.length ? {configs: configFiles, config: configFiles[configFiles.length - 1]} : undefined,
  ]))
}


/***/ }),

/***/ "./node_modules/rc/lib/utils.js":
/*!**************************************!*\
  !*** ./node_modules/rc/lib/utils.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fs   = __webpack_require__(/*! fs */ "fs")
var ini  = __webpack_require__(/*! ini */ "ini")
var path = __webpack_require__(/*! path */ "path")
var stripJsonComments = __webpack_require__(/*! strip-json-comments */ "strip-json-comments")

var parse = exports.parse = function (content) {

  //if it ends in .json or starts with { then it must be json.
  //must be done this way, because ini accepts everything.
  //can't just try and parse it and let it throw if it's not ini.
  //everything is ini. even json with a syntax error.

  if(/^\s*{/.test(content))
    return JSON.parse(stripJsonComments(content))
  return ini.parse(content)

}

var file = exports.file = function () {
  var args = [].slice.call(arguments).filter(function (arg) { return arg != null })

  //path.join breaks if it's a not a string, so just skip this.
  for(var i in args)
    if('string' !== typeof args[i])
      return

  var file = path.join.apply(null, args)
  var content
  try {
    return fs.readFileSync(file,'utf-8')
  } catch (err) {
    return
  }
}

var json = exports.json = function () {
  var content = file.apply(null, arguments)
  return content ? parse(content) : null
}

var env = exports.env = function (prefix, env) {
  env = env || process.env
  var obj = {}
  var l = prefix.length
  for(var k in env) {
    if(k.toLowerCase().indexOf(prefix.toLowerCase()) === 0) {

      var keypath = k.substring(l).split('__')

      // Trim empty strings from keypath array
      var _emptyStringIndex
      while ((_emptyStringIndex=keypath.indexOf('')) > -1) {
        keypath.splice(_emptyStringIndex, 1)
      }

      var cursor = obj
      keypath.forEach(function _buildSubObj(_subkey,i){

        // (check for _subkey first so we ignore empty strings)
        // (check for cursor to avoid assignment to primitive objects)
        if (!_subkey || typeof cursor !== 'object')
          return

        // If this is the last key, just stuff the value in there
        // Assigns actual value from env variable to final key
        // (unless it's just an empty string- in that case use the last valid key)
        if (i === keypath.length-1)
          cursor[_subkey] = env[k]


        // Build sub-object if nothing already exists at the keypath
        if (cursor[_subkey] === undefined)
          cursor[_subkey] = {}

        // Increment cursor used to track the object at the current depth
        cursor = cursor[_subkey]

      })

    }

  }

  return obj
}

var find = exports.find = function () {
  var rel = path.join.apply(null, [].slice.call(arguments))

  function find(start, rel) {
    var file = path.join(start, rel)
    try {
      fs.statSync(file)
      return file
    } catch (err) {
      if(path.dirname(start) !== start) // root
        return find(path.dirname(start), rel)
    }
  }
  return find(process.cwd(), rel)
}




/***/ }),

/***/ "./node_modules/sax/lib/sax.js":
/*!*************************************!*\
  !*** ./node_modules/sax/lib/sax.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

;(function (sax) { // wrapper for non-node envs
  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }
  sax.SAXParser = SAXParser
  sax.SAXStream = SAXStream
  sax.createStream = createStream

  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
  // since that's the earliest that a buffer overrun could occur.  This way, checks are
  // as rare as required, but as often as necessary to ensure never crossing this bound.
  // Furthermore, buffers are only tested at most once per write(), so passing a very
  // large string into write() might have undesirable effects, but this is manageable by
  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
  // edge case, result in creating at most one complete copy of the string passed in.
  // Set to Infinity to have unlimited buffers.
  sax.MAX_BUFFER_LENGTH = 64 * 1024

  var buffers = [
    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',
    'procInstName', 'procInstBody', 'entity', 'attribName',
    'attribValue', 'cdata', 'script'
  ]

  sax.EVENTS = [
    'text',
    'processinginstruction',
    'sgmldeclaration',
    'doctype',
    'comment',
    'opentagstart',
    'attribute',
    'opentag',
    'closetag',
    'opencdata',
    'cdata',
    'closecdata',
    'error',
    'end',
    'ready',
    'script',
    'opennamespace',
    'closenamespace'
  ]

  function SAXParser (strict, opt) {
    if (!(this instanceof SAXParser)) {
      return new SAXParser(strict, opt)
    }

    var parser = this
    clearBuffers(parser)
    parser.q = parser.c = ''
    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH
    parser.opt = opt || {}
    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'
    parser.tags = []
    parser.closed = parser.closedRoot = parser.sawRoot = false
    parser.tag = parser.error = null
    parser.strict = !!strict
    parser.noscript = !!(strict || parser.opt.noscript)
    parser.state = S.BEGIN
    parser.strictEntities = parser.opt.strictEntities
    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)
    parser.attribList = []

    // namespaces form a prototype chain.
    // it always points at the current tag,
    // which protos to its parent tag.
    if (parser.opt.xmlns) {
      parser.ns = Object.create(rootNS)
    }

    // mostly just for error reporting
    parser.trackPosition = parser.opt.position !== false
    if (parser.trackPosition) {
      parser.position = parser.line = parser.column = 0
    }
    emit(parser, 'onready')
  }

  if (!Object.create) {
    Object.create = function (o) {
      function F () {}
      F.prototype = o
      var newf = new F()
      return newf
    }
  }

  if (!Object.keys) {
    Object.keys = function (o) {
      var a = []
      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)
      return a
    }
  }

  function checkBufferLength (parser) {
    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)
    var maxActual = 0
    for (var i = 0, l = buffers.length; i < l; i++) {
      var len = parser[buffers[i]].length
      if (len > maxAllowed) {
        // Text/cdata nodes can get big, and since they're buffered,
        // we can get here under normal conditions.
        // Avoid issues by emitting the text node now,
        // so at least it won't get any bigger.
        switch (buffers[i]) {
          case 'textNode':
            closeText(parser)
            break

          case 'cdata':
            emitNode(parser, 'oncdata', parser.cdata)
            parser.cdata = ''
            break

          case 'script':
            emitNode(parser, 'onscript', parser.script)
            parser.script = ''
            break

          default:
            error(parser, 'Max buffer length exceeded: ' + buffers[i])
        }
      }
      maxActual = Math.max(maxActual, len)
    }
    // schedule the next check for the earliest possible buffer overrun.
    var m = sax.MAX_BUFFER_LENGTH - maxActual
    parser.bufferCheckPosition = m + parser.position
  }

  function clearBuffers (parser) {
    for (var i = 0, l = buffers.length; i < l; i++) {
      parser[buffers[i]] = ''
    }
  }

  function flushBuffers (parser) {
    closeText(parser)
    if (parser.cdata !== '') {
      emitNode(parser, 'oncdata', parser.cdata)
      parser.cdata = ''
    }
    if (parser.script !== '') {
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }
  }

  SAXParser.prototype = {
    end: function () { end(this) },
    write: write,
    resume: function () { this.error = null; return this },
    close: function () { return this.write(null) },
    flush: function () { flushBuffers(this) }
  }

  var Stream
  try {
    Stream = __webpack_require__(/*! stream */ "stream").Stream
  } catch (ex) {
    Stream = function () {}
  }

  var streamWraps = sax.EVENTS.filter(function (ev) {
    return ev !== 'error' && ev !== 'end'
  })

  function createStream (strict, opt) {
    return new SAXStream(strict, opt)
  }

  function SAXStream (strict, opt) {
    if (!(this instanceof SAXStream)) {
      return new SAXStream(strict, opt)
    }

    Stream.apply(this)

    this._parser = new SAXParser(strict, opt)
    this.writable = true
    this.readable = true

    var me = this

    this._parser.onend = function () {
      me.emit('end')
    }

    this._parser.onerror = function (er) {
      me.emit('error', er)

      // if didn't throw, then means error was handled.
      // go ahead and clear error, so we can write again.
      me._parser.error = null
    }

    this._decoder = null

    streamWraps.forEach(function (ev) {
      Object.defineProperty(me, 'on' + ev, {
        get: function () {
          return me._parser['on' + ev]
        },
        set: function (h) {
          if (!h) {
            me.removeAllListeners(ev)
            me._parser['on' + ev] = h
            return h
          }
          me.on(ev, h)
        },
        enumerable: true,
        configurable: false
      })
    })
  }

  SAXStream.prototype = Object.create(Stream.prototype, {
    constructor: {
      value: SAXStream
    }
  })

  SAXStream.prototype.write = function (data) {
    if (typeof Buffer === 'function' &&
      typeof Buffer.isBuffer === 'function' &&
      Buffer.isBuffer(data)) {
      if (!this._decoder) {
        var SD = __webpack_require__(/*! string_decoder */ "string_decoder").StringDecoder
        this._decoder = new SD('utf8')
      }
      data = this._decoder.write(data)
    }

    this._parser.write(data.toString())
    this.emit('data', data)
    return true
  }

  SAXStream.prototype.end = function (chunk) {
    if (chunk && chunk.length) {
      this.write(chunk)
    }
    this._parser.end()
    return true
  }

  SAXStream.prototype.on = function (ev, handler) {
    var me = this
    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
      me._parser['on' + ev] = function () {
        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)
        args.splice(0, 0, ev)
        me.emit.apply(me, args)
      }
    }

    return Stream.prototype.on.call(me, ev, handler)
  }

  // this really needs to be replaced with character classes.
  // XML allows all manner of ridiculous numbers and digits.
  var CDATA = '[CDATA['
  var DOCTYPE = 'DOCTYPE'
  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'
  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'
  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }

  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
  // This implementation works on strings, a single character at a time
  // as such, it cannot ever support astral-plane characters (10000-EFFFF)
  // without a significant breaking change to either this  parser, or the
  // JavaScript language.  Implementation of an emoji-capable xml parser
  // is left as an exercise for the reader.
  var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/

  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/

  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/
  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/

  function isWhitespace (c) {
    return c === ' ' || c === '\n' || c === '\r' || c === '\t'
  }

  function isQuote (c) {
    return c === '"' || c === '\''
  }

  function isAttribEnd (c) {
    return c === '>' || isWhitespace(c)
  }

  function isMatch (regex, c) {
    return regex.test(c)
  }

  function notMatch (regex, c) {
    return !isMatch(regex, c)
  }

  var S = 0
  sax.STATE = {
    BEGIN: S++, // leading byte order mark or whitespace
    BEGIN_WHITESPACE: S++, // leading whitespace
    TEXT: S++, // general stuff
    TEXT_ENTITY: S++, // &amp and such.
    OPEN_WAKA: S++, // <
    SGML_DECL: S++, // <!BLARG
    SGML_DECL_QUOTED: S++, // <!BLARG foo "bar
    DOCTYPE: S++, // <!DOCTYPE
    DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah
    DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...
    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo
    COMMENT_STARTING: S++, // <!-
    COMMENT: S++, // <!--
    COMMENT_ENDING: S++, // <!-- blah -
    COMMENT_ENDED: S++, // <!-- blah --
    CDATA: S++, // <![CDATA[ something
    CDATA_ENDING: S++, // ]
    CDATA_ENDING_2: S++, // ]]
    PROC_INST: S++, // <?hi
    PROC_INST_BODY: S++, // <?hi there
    PROC_INST_ENDING: S++, // <?hi "there" ?
    OPEN_TAG: S++, // <strong
    OPEN_TAG_SLASH: S++, // <strong /
    ATTRIB: S++, // <a
    ATTRIB_NAME: S++, // <a foo
    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _
    ATTRIB_VALUE: S++, // <a foo=
    ATTRIB_VALUE_QUOTED: S++, // <a foo="bar
    ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"
    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar
    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"
    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot
    CLOSE_TAG: S++, // </a
    CLOSE_TAG_SAW_WHITE: S++, // </a   >
    SCRIPT: S++, // <script> ...
    SCRIPT_ENDING: S++ // <script> ... <
  }

  sax.XML_ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'"
  }

  sax.ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'",
    'AElig': 198,
    'Aacute': 193,
    'Acirc': 194,
    'Agrave': 192,
    'Aring': 197,
    'Atilde': 195,
    'Auml': 196,
    'Ccedil': 199,
    'ETH': 208,
    'Eacute': 201,
    'Ecirc': 202,
    'Egrave': 200,
    'Euml': 203,
    'Iacute': 205,
    'Icirc': 206,
    'Igrave': 204,
    'Iuml': 207,
    'Ntilde': 209,
    'Oacute': 211,
    'Ocirc': 212,
    'Ograve': 210,
    'Oslash': 216,
    'Otilde': 213,
    'Ouml': 214,
    'THORN': 222,
    'Uacute': 218,
    'Ucirc': 219,
    'Ugrave': 217,
    'Uuml': 220,
    'Yacute': 221,
    'aacute': 225,
    'acirc': 226,
    'aelig': 230,
    'agrave': 224,
    'aring': 229,
    'atilde': 227,
    'auml': 228,
    'ccedil': 231,
    'eacute': 233,
    'ecirc': 234,
    'egrave': 232,
    'eth': 240,
    'euml': 235,
    'iacute': 237,
    'icirc': 238,
    'igrave': 236,
    'iuml': 239,
    'ntilde': 241,
    'oacute': 243,
    'ocirc': 244,
    'ograve': 242,
    'oslash': 248,
    'otilde': 245,
    'ouml': 246,
    'szlig': 223,
    'thorn': 254,
    'uacute': 250,
    'ucirc': 251,
    'ugrave': 249,
    'uuml': 252,
    'yacute': 253,
    'yuml': 255,
    'copy': 169,
    'reg': 174,
    'nbsp': 160,
    'iexcl': 161,
    'cent': 162,
    'pound': 163,
    'curren': 164,
    'yen': 165,
    'brvbar': 166,
    'sect': 167,
    'uml': 168,
    'ordf': 170,
    'laquo': 171,
    'not': 172,
    'shy': 173,
    'macr': 175,
    'deg': 176,
    'plusmn': 177,
    'sup1': 185,
    'sup2': 178,
    'sup3': 179,
    'acute': 180,
    'micro': 181,
    'para': 182,
    'middot': 183,
    'cedil': 184,
    'ordm': 186,
    'raquo': 187,
    'frac14': 188,
    'frac12': 189,
    'frac34': 190,
    'iquest': 191,
    'times': 215,
    'divide': 247,
    'OElig': 338,
    'oelig': 339,
    'Scaron': 352,
    'scaron': 353,
    'Yuml': 376,
    'fnof': 402,
    'circ': 710,
    'tilde': 732,
    'Alpha': 913,
    'Beta': 914,
    'Gamma': 915,
    'Delta': 916,
    'Epsilon': 917,
    'Zeta': 918,
    'Eta': 919,
    'Theta': 920,
    'Iota': 921,
    'Kappa': 922,
    'Lambda': 923,
    'Mu': 924,
    'Nu': 925,
    'Xi': 926,
    'Omicron': 927,
    'Pi': 928,
    'Rho': 929,
    'Sigma': 931,
    'Tau': 932,
    'Upsilon': 933,
    'Phi': 934,
    'Chi': 935,
    'Psi': 936,
    'Omega': 937,
    'alpha': 945,
    'beta': 946,
    'gamma': 947,
    'delta': 948,
    'epsilon': 949,
    'zeta': 950,
    'eta': 951,
    'theta': 952,
    'iota': 953,
    'kappa': 954,
    'lambda': 955,
    'mu': 956,
    'nu': 957,
    'xi': 958,
    'omicron': 959,
    'pi': 960,
    'rho': 961,
    'sigmaf': 962,
    'sigma': 963,
    'tau': 964,
    'upsilon': 965,
    'phi': 966,
    'chi': 967,
    'psi': 968,
    'omega': 969,
    'thetasym': 977,
    'upsih': 978,
    'piv': 982,
    'ensp': 8194,
    'emsp': 8195,
    'thinsp': 8201,
    'zwnj': 8204,
    'zwj': 8205,
    'lrm': 8206,
    'rlm': 8207,
    'ndash': 8211,
    'mdash': 8212,
    'lsquo': 8216,
    'rsquo': 8217,
    'sbquo': 8218,
    'ldquo': 8220,
    'rdquo': 8221,
    'bdquo': 8222,
    'dagger': 8224,
    'Dagger': 8225,
    'bull': 8226,
    'hellip': 8230,
    'permil': 8240,
    'prime': 8242,
    'Prime': 8243,
    'lsaquo': 8249,
    'rsaquo': 8250,
    'oline': 8254,
    'frasl': 8260,
    'euro': 8364,
    'image': 8465,
    'weierp': 8472,
    'real': 8476,
    'trade': 8482,
    'alefsym': 8501,
    'larr': 8592,
    'uarr': 8593,
    'rarr': 8594,
    'darr': 8595,
    'harr': 8596,
    'crarr': 8629,
    'lArr': 8656,
    'uArr': 8657,
    'rArr': 8658,
    'dArr': 8659,
    'hArr': 8660,
    'forall': 8704,
    'part': 8706,
    'exist': 8707,
    'empty': 8709,
    'nabla': 8711,
    'isin': 8712,
    'notin': 8713,
    'ni': 8715,
    'prod': 8719,
    'sum': 8721,
    'minus': 8722,
    'lowast': 8727,
    'radic': 8730,
    'prop': 8733,
    'infin': 8734,
    'ang': 8736,
    'and': 8743,
    'or': 8744,
    'cap': 8745,
    'cup': 8746,
    'int': 8747,
    'there4': 8756,
    'sim': 8764,
    'cong': 8773,
    'asymp': 8776,
    'ne': 8800,
    'equiv': 8801,
    'le': 8804,
    'ge': 8805,
    'sub': 8834,
    'sup': 8835,
    'nsub': 8836,
    'sube': 8838,
    'supe': 8839,
    'oplus': 8853,
    'otimes': 8855,
    'perp': 8869,
    'sdot': 8901,
    'lceil': 8968,
    'rceil': 8969,
    'lfloor': 8970,
    'rfloor': 8971,
    'lang': 9001,
    'rang': 9002,
    'loz': 9674,
    'spades': 9824,
    'clubs': 9827,
    'hearts': 9829,
    'diams': 9830
  }

  Object.keys(sax.ENTITIES).forEach(function (key) {
    var e = sax.ENTITIES[key]
    var s = typeof e === 'number' ? String.fromCharCode(e) : e
    sax.ENTITIES[key] = s
  })

  for (var s in sax.STATE) {
    sax.STATE[sax.STATE[s]] = s
  }

  // shorthand
  S = sax.STATE

  function emit (parser, event, data) {
    parser[event] && parser[event](data)
  }

  function emitNode (parser, nodeType, data) {
    if (parser.textNode) closeText(parser)
    emit(parser, nodeType, data)
  }

  function closeText (parser) {
    parser.textNode = textopts(parser.opt, parser.textNode)
    if (parser.textNode) emit(parser, 'ontext', parser.textNode)
    parser.textNode = ''
  }

  function textopts (opt, text) {
    if (opt.trim) text = text.trim()
    if (opt.normalize) text = text.replace(/\s+/g, ' ')
    return text
  }

  function error (parser, er) {
    closeText(parser)
    if (parser.trackPosition) {
      er += '\nLine: ' + parser.line +
        '\nColumn: ' + parser.column +
        '\nChar: ' + parser.c
    }
    er = new Error(er)
    parser.error = er
    emit(parser, 'onerror', er)
    return parser
  }

  function end (parser) {
    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')
    if ((parser.state !== S.BEGIN) &&
      (parser.state !== S.BEGIN_WHITESPACE) &&
      (parser.state !== S.TEXT)) {
      error(parser, 'Unexpected end')
    }
    closeText(parser)
    parser.c = ''
    parser.closed = true
    emit(parser, 'onend')
    SAXParser.call(parser, parser.strict, parser.opt)
    return parser
  }

  function strictFail (parser, message) {
    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
      throw new Error('bad call to strictFail')
    }
    if (parser.strict) {
      error(parser, message)
    }
  }

  function newTag (parser) {
    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()
    var parent = parser.tags[parser.tags.length - 1] || parser
    var tag = parser.tag = { name: parser.tagName, attributes: {} }

    // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
    if (parser.opt.xmlns) {
      tag.ns = parent.ns
    }
    parser.attribList.length = 0
    emitNode(parser, 'onopentagstart', tag)
  }

  function qname (name, attribute) {
    var i = name.indexOf(':')
    var qualName = i < 0 ? [ '', name ] : name.split(':')
    var prefix = qualName[0]
    var local = qualName[1]

    // <x "xmlns"="http://foo">
    if (attribute && name === 'xmlns') {
      prefix = 'xmlns'
      local = ''
    }

    return { prefix: prefix, local: local }
  }

  function attrib (parser) {
    if (!parser.strict) {
      parser.attribName = parser.attribName[parser.looseCase]()
    }

    if (parser.attribList.indexOf(parser.attribName) !== -1 ||
      parser.tag.attributes.hasOwnProperty(parser.attribName)) {
      parser.attribName = parser.attribValue = ''
      return
    }

    if (parser.opt.xmlns) {
      var qn = qname(parser.attribName, true)
      var prefix = qn.prefix
      var local = qn.local

      if (prefix === 'xmlns') {
        // namespace binding attribute. push the binding into scope
        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
          strictFail(parser,
            'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
          strictFail(parser,
            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else {
          var tag = parser.tag
          var parent = parser.tags[parser.tags.length - 1] || parser
          if (tag.ns === parent.ns) {
            tag.ns = Object.create(parent.ns)
          }
          tag.ns[local] = parser.attribValue
        }
      }

      // defer onattribute events until all attributes have been seen
      // so any new bindings can take effect. preserve attribute order
      // so deferred events can be emitted in document order
      parser.attribList.push([parser.attribName, parser.attribValue])
    } else {
      // in non-xmlns mode, we can emit the event right away
      parser.tag.attributes[parser.attribName] = parser.attribValue
      emitNode(parser, 'onattribute', {
        name: parser.attribName,
        value: parser.attribValue
      })
    }

    parser.attribName = parser.attribValue = ''
  }

  function openTag (parser, selfClosing) {
    if (parser.opt.xmlns) {
      // emit namespace binding events
      var tag = parser.tag

      // add namespace info to tag
      var qn = qname(parser.tagName)
      tag.prefix = qn.prefix
      tag.local = qn.local
      tag.uri = tag.ns[qn.prefix] || ''

      if (tag.prefix && !tag.uri) {
        strictFail(parser, 'Unbound namespace prefix: ' +
          JSON.stringify(parser.tagName))
        tag.uri = qn.prefix
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (tag.ns && parent.ns !== tag.ns) {
        Object.keys(tag.ns).forEach(function (p) {
          emitNode(parser, 'onopennamespace', {
            prefix: p,
            uri: tag.ns[p]
          })
        })
      }

      // handle deferred onattribute events
      // Note: do not apply default ns to attributes:
      //   http://www.w3.org/TR/REC-xml-names/#defaulting
      for (var i = 0, l = parser.attribList.length; i < l; i++) {
        var nv = parser.attribList[i]
        var name = nv[0]
        var value = nv[1]
        var qualName = qname(name, true)
        var prefix = qualName.prefix
        var local = qualName.local
        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')
        var a = {
          name: name,
          value: value,
          prefix: prefix,
          local: local,
          uri: uri
        }

        // if there's any attributes with an undefined namespace,
        // then fail on them now.
        if (prefix && prefix !== 'xmlns' && !uri) {
          strictFail(parser, 'Unbound namespace prefix: ' +
            JSON.stringify(prefix))
          a.uri = prefix
        }
        parser.tag.attributes[name] = a
        emitNode(parser, 'onattribute', a)
      }
      parser.attribList.length = 0
    }

    parser.tag.isSelfClosing = !!selfClosing

    // process the tag
    parser.sawRoot = true
    parser.tags.push(parser.tag)
    emitNode(parser, 'onopentag', parser.tag)
    if (!selfClosing) {
      // special case for <script> in non-strict mode.
      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
        parser.state = S.SCRIPT
      } else {
        parser.state = S.TEXT
      }
      parser.tag = null
      parser.tagName = ''
    }
    parser.attribName = parser.attribValue = ''
    parser.attribList.length = 0
  }

  function closeTag (parser) {
    if (!parser.tagName) {
      strictFail(parser, 'Weird empty close tag.')
      parser.textNode += '</>'
      parser.state = S.TEXT
      return
    }

    if (parser.script) {
      if (parser.tagName !== 'script') {
        parser.script += '</' + parser.tagName + '>'
        parser.tagName = ''
        parser.state = S.SCRIPT
        return
      }
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }

    // first make sure that the closing tag actually exists.
    // <a><b></c></b></a> will close everything, otherwise.
    var t = parser.tags.length
    var tagName = parser.tagName
    if (!parser.strict) {
      tagName = tagName[parser.looseCase]()
    }
    var closeTo = tagName
    while (t--) {
      var close = parser.tags[t]
      if (close.name !== closeTo) {
        // fail the first time in strict mode
        strictFail(parser, 'Unexpected close tag')
      } else {
        break
      }
    }

    // didn't find it.  we already failed for strict, so just abort.
    if (t < 0) {
      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)
      parser.textNode += '</' + parser.tagName + '>'
      parser.state = S.TEXT
      return
    }
    parser.tagName = tagName
    var s = parser.tags.length
    while (s-- > t) {
      var tag = parser.tag = parser.tags.pop()
      parser.tagName = parser.tag.name
      emitNode(parser, 'onclosetag', parser.tagName)

      var x = {}
      for (var i in tag.ns) {
        x[i] = tag.ns[i]
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (parser.opt.xmlns && tag.ns !== parent.ns) {
        // remove namespace bindings introduced by tag
        Object.keys(tag.ns).forEach(function (p) {
          var n = tag.ns[p]
          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })
        })
      }
    }
    if (t === 0) parser.closedRoot = true
    parser.tagName = parser.attribValue = parser.attribName = ''
    parser.attribList.length = 0
    parser.state = S.TEXT
  }

  function parseEntity (parser) {
    var entity = parser.entity
    var entityLC = entity.toLowerCase()
    var num
    var numStr = ''

    if (parser.ENTITIES[entity]) {
      return parser.ENTITIES[entity]
    }
    if (parser.ENTITIES[entityLC]) {
      return parser.ENTITIES[entityLC]
    }
    entity = entityLC
    if (entity.charAt(0) === '#') {
      if (entity.charAt(1) === 'x') {
        entity = entity.slice(2)
        num = parseInt(entity, 16)
        numStr = num.toString(16)
      } else {
        entity = entity.slice(1)
        num = parseInt(entity, 10)
        numStr = num.toString(10)
      }
    }
    entity = entity.replace(/^0+/, '')
    if (isNaN(num) || numStr.toLowerCase() !== entity) {
      strictFail(parser, 'Invalid character entity')
      return '&' + parser.entity + ';'
    }

    return String.fromCodePoint(num)
  }

  function beginWhiteSpace (parser, c) {
    if (c === '<') {
      parser.state = S.OPEN_WAKA
      parser.startTagPosition = parser.position
    } else if (!isWhitespace(c)) {
      // have to process this as a text node.
      // weird, but happens.
      strictFail(parser, 'Non-whitespace before first tag.')
      parser.textNode = c
      parser.state = S.TEXT
    }
  }

  function charAt (chunk, i) {
    var result = ''
    if (i < chunk.length) {
      result = chunk.charAt(i)
    }
    return result
  }

  function write (chunk) {
    var parser = this
    if (this.error) {
      throw this.error
    }
    if (parser.closed) {
      return error(parser,
        'Cannot write after close. Assign an onready handler.')
    }
    if (chunk === null) {
      return end(parser)
    }
    if (typeof chunk === 'object') {
      chunk = chunk.toString()
    }
    var i = 0
    var c = ''
    while (true) {
      c = charAt(chunk, i++)
      parser.c = c

      if (!c) {
        break
      }

      if (parser.trackPosition) {
        parser.position++
        if (c === '\n') {
          parser.line++
          parser.column = 0
        } else {
          parser.column++
        }
      }

      switch (parser.state) {
        case S.BEGIN:
          parser.state = S.BEGIN_WHITESPACE
          if (c === '\uFEFF') {
            continue
          }
          beginWhiteSpace(parser, c)
          continue

        case S.BEGIN_WHITESPACE:
          beginWhiteSpace(parser, c)
          continue

        case S.TEXT:
          if (parser.sawRoot && !parser.closedRoot) {
            var starti = i - 1
            while (c && c !== '<' && c !== '&') {
              c = charAt(chunk, i++)
              if (c && parser.trackPosition) {
                parser.position++
                if (c === '\n') {
                  parser.line++
                  parser.column = 0
                } else {
                  parser.column++
                }
              }
            }
            parser.textNode += chunk.substring(starti, i - 1)
          }
          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
            parser.state = S.OPEN_WAKA
            parser.startTagPosition = parser.position
          } else {
            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
              strictFail(parser, 'Text data outside of root node.')
            }
            if (c === '&') {
              parser.state = S.TEXT_ENTITY
            } else {
              parser.textNode += c
            }
          }
          continue

        case S.SCRIPT:
          // only non-strict
          if (c === '<') {
            parser.state = S.SCRIPT_ENDING
          } else {
            parser.script += c
          }
          continue

        case S.SCRIPT_ENDING:
          if (c === '/') {
            parser.state = S.CLOSE_TAG
          } else {
            parser.script += '<' + c
            parser.state = S.SCRIPT
          }
          continue

        case S.OPEN_WAKA:
          // either a /, ?, !, or text is coming next.
          if (c === '!') {
            parser.state = S.SGML_DECL
            parser.sgmlDecl = ''
          } else if (isWhitespace(c)) {
            // wait for it...
          } else if (isMatch(nameStart, c)) {
            parser.state = S.OPEN_TAG
            parser.tagName = c
          } else if (c === '/') {
            parser.state = S.CLOSE_TAG
            parser.tagName = ''
          } else if (c === '?') {
            parser.state = S.PROC_INST
            parser.procInstName = parser.procInstBody = ''
          } else {
            strictFail(parser, 'Unencoded <')
            // if there was some whitespace, then add that in.
            if (parser.startTagPosition + 1 < parser.position) {
              var pad = parser.position - parser.startTagPosition
              c = new Array(pad).join(' ') + c
            }
            parser.textNode += '<' + c
            parser.state = S.TEXT
          }
          continue

        case S.SGML_DECL:
          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
            emitNode(parser, 'onopencdata')
            parser.state = S.CDATA
            parser.sgmlDecl = ''
            parser.cdata = ''
          } else if (parser.sgmlDecl + c === '--') {
            parser.state = S.COMMENT
            parser.comment = ''
            parser.sgmlDecl = ''
          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
            parser.state = S.DOCTYPE
            if (parser.doctype || parser.sawRoot) {
              strictFail(parser,
                'Inappropriately located doctype declaration')
            }
            parser.doctype = ''
            parser.sgmlDecl = ''
          } else if (c === '>') {
            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)
            parser.sgmlDecl = ''
            parser.state = S.TEXT
          } else if (isQuote(c)) {
            parser.state = S.SGML_DECL_QUOTED
            parser.sgmlDecl += c
          } else {
            parser.sgmlDecl += c
          }
          continue

        case S.SGML_DECL_QUOTED:
          if (c === parser.q) {
            parser.state = S.SGML_DECL
            parser.q = ''
          }
          parser.sgmlDecl += c
          continue

        case S.DOCTYPE:
          if (c === '>') {
            parser.state = S.TEXT
            emitNode(parser, 'ondoctype', parser.doctype)
            parser.doctype = true // just remember that we saw it.
          } else {
            parser.doctype += c
            if (c === '[') {
              parser.state = S.DOCTYPE_DTD
            } else if (isQuote(c)) {
              parser.state = S.DOCTYPE_QUOTED
              parser.q = c
            }
          }
          continue

        case S.DOCTYPE_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.q = ''
            parser.state = S.DOCTYPE
          }
          continue

        case S.DOCTYPE_DTD:
          parser.doctype += c
          if (c === ']') {
            parser.state = S.DOCTYPE
          } else if (isQuote(c)) {
            parser.state = S.DOCTYPE_DTD_QUOTED
            parser.q = c
          }
          continue

        case S.DOCTYPE_DTD_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.state = S.DOCTYPE_DTD
            parser.q = ''
          }
          continue

        case S.COMMENT:
          if (c === '-') {
            parser.state = S.COMMENT_ENDING
          } else {
            parser.comment += c
          }
          continue

        case S.COMMENT_ENDING:
          if (c === '-') {
            parser.state = S.COMMENT_ENDED
            parser.comment = textopts(parser.opt, parser.comment)
            if (parser.comment) {
              emitNode(parser, 'oncomment', parser.comment)
            }
            parser.comment = ''
          } else {
            parser.comment += '-' + c
            parser.state = S.COMMENT
          }
          continue

        case S.COMMENT_ENDED:
          if (c !== '>') {
            strictFail(parser, 'Malformed comment')
            // allow <!-- blah -- bloo --> in non-strict mode,
            // which is a comment of " blah -- bloo "
            parser.comment += '--' + c
            parser.state = S.COMMENT
          } else {
            parser.state = S.TEXT
          }
          continue

        case S.CDATA:
          if (c === ']') {
            parser.state = S.CDATA_ENDING
          } else {
            parser.cdata += c
          }
          continue

        case S.CDATA_ENDING:
          if (c === ']') {
            parser.state = S.CDATA_ENDING_2
          } else {
            parser.cdata += ']' + c
            parser.state = S.CDATA
          }
          continue

        case S.CDATA_ENDING_2:
          if (c === '>') {
            if (parser.cdata) {
              emitNode(parser, 'oncdata', parser.cdata)
            }
            emitNode(parser, 'onclosecdata')
            parser.cdata = ''
            parser.state = S.TEXT
          } else if (c === ']') {
            parser.cdata += ']'
          } else {
            parser.cdata += ']]' + c
            parser.state = S.CDATA
          }
          continue

        case S.PROC_INST:
          if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else if (isWhitespace(c)) {
            parser.state = S.PROC_INST_BODY
          } else {
            parser.procInstName += c
          }
          continue

        case S.PROC_INST_BODY:
          if (!parser.procInstBody && isWhitespace(c)) {
            continue
          } else if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else {
            parser.procInstBody += c
          }
          continue

        case S.PROC_INST_ENDING:
          if (c === '>') {
            emitNode(parser, 'onprocessinginstruction', {
              name: parser.procInstName,
              body: parser.procInstBody
            })
            parser.procInstName = parser.procInstBody = ''
            parser.state = S.TEXT
          } else {
            parser.procInstBody += '?' + c
            parser.state = S.PROC_INST_BODY
          }
          continue

        case S.OPEN_TAG:
          if (isMatch(nameBody, c)) {
            parser.tagName += c
          } else {
            newTag(parser)
            if (c === '>') {
              openTag(parser)
            } else if (c === '/') {
              parser.state = S.OPEN_TAG_SLASH
            } else {
              if (!isWhitespace(c)) {
                strictFail(parser, 'Invalid character in tag name')
              }
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.OPEN_TAG_SLASH:
          if (c === '>') {
            openTag(parser, true)
            closeTag(parser)
          } else {
            strictFail(parser, 'Forward-slash in opening tag not followed by >')
            parser.state = S.ATTRIB
          }
          continue

        case S.ATTRIB:
          // haven't read the attribute name yet.
          if (isWhitespace(c)) {
            continue
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (isMatch(nameStart, c)) {
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (c === '>') {
            strictFail(parser, 'Attribute without value')
            parser.attribValue = parser.attribName
            attrib(parser)
            openTag(parser)
          } else if (isWhitespace(c)) {
            parser.state = S.ATTRIB_NAME_SAW_WHITE
          } else if (isMatch(nameBody, c)) {
            parser.attribName += c
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME_SAW_WHITE:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (isWhitespace(c)) {
            continue
          } else {
            strictFail(parser, 'Attribute without value')
            parser.tag.attributes[parser.attribName] = ''
            parser.attribValue = ''
            emitNode(parser, 'onattribute', {
              name: parser.attribName,
              value: ''
            })
            parser.attribName = ''
            if (c === '>') {
              openTag(parser)
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c
              parser.state = S.ATTRIB_NAME
            } else {
              strictFail(parser, 'Invalid attribute name')
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.ATTRIB_VALUE:
          if (isWhitespace(c)) {
            continue
          } else if (isQuote(c)) {
            parser.q = c
            parser.state = S.ATTRIB_VALUE_QUOTED
          } else {
            strictFail(parser, 'Unquoted attribute value')
            parser.state = S.ATTRIB_VALUE_UNQUOTED
            parser.attribValue = c
          }
          continue

        case S.ATTRIB_VALUE_QUOTED:
          if (c !== parser.q) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_Q
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          parser.q = ''
          parser.state = S.ATTRIB_VALUE_CLOSED
          continue

        case S.ATTRIB_VALUE_CLOSED:
          if (isWhitespace(c)) {
            parser.state = S.ATTRIB
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (isMatch(nameStart, c)) {
            strictFail(parser, 'No whitespace between attributes')
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_VALUE_UNQUOTED:
          if (!isAttribEnd(c)) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_U
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          if (c === '>') {
            openTag(parser)
          } else {
            parser.state = S.ATTRIB
          }
          continue

        case S.CLOSE_TAG:
          if (!parser.tagName) {
            if (isWhitespace(c)) {
              continue
            } else if (notMatch(nameStart, c)) {
              if (parser.script) {
                parser.script += '</' + c
                parser.state = S.SCRIPT
              } else {
                strictFail(parser, 'Invalid tagname in closing tag.')
              }
            } else {
              parser.tagName = c
            }
          } else if (c === '>') {
            closeTag(parser)
          } else if (isMatch(nameBody, c)) {
            parser.tagName += c
          } else if (parser.script) {
            parser.script += '</' + parser.tagName
            parser.tagName = ''
            parser.state = S.SCRIPT
          } else {
            if (!isWhitespace(c)) {
              strictFail(parser, 'Invalid tagname in closing tag')
            }
            parser.state = S.CLOSE_TAG_SAW_WHITE
          }
          continue

        case S.CLOSE_TAG_SAW_WHITE:
          if (isWhitespace(c)) {
            continue
          }
          if (c === '>') {
            closeTag(parser)
          } else {
            strictFail(parser, 'Invalid characters in closing tag')
          }
          continue

        case S.TEXT_ENTITY:
        case S.ATTRIB_VALUE_ENTITY_Q:
        case S.ATTRIB_VALUE_ENTITY_U:
          var returnState
          var buffer
          switch (parser.state) {
            case S.TEXT_ENTITY:
              returnState = S.TEXT
              buffer = 'textNode'
              break

            case S.ATTRIB_VALUE_ENTITY_Q:
              returnState = S.ATTRIB_VALUE_QUOTED
              buffer = 'attribValue'
              break

            case S.ATTRIB_VALUE_ENTITY_U:
              returnState = S.ATTRIB_VALUE_UNQUOTED
              buffer = 'attribValue'
              break
          }

          if (c === ';') {
            parser[buffer] += parseEntity(parser)
            parser.entity = ''
            parser.state = returnState
          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
            parser.entity += c
          } else {
            strictFail(parser, 'Invalid character in entity name')
            parser[buffer] += '&' + parser.entity + c
            parser.entity = ''
            parser.state = returnState
          }

          continue

        default:
          throw new Error(parser, 'Unknown state: ' + parser.state)
      }
    } // while

    if (parser.position >= parser.bufferCheckPosition) {
      checkBufferLength(parser)
    }
    return parser
  }

  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
  /* istanbul ignore next */
  if (!String.fromCodePoint) {
    (function () {
      var stringFromCharCode = String.fromCharCode
      var floor = Math.floor
      var fromCodePoint = function () {
        var MAX_SIZE = 0x4000
        var codeUnits = []
        var highSurrogate
        var lowSurrogate
        var index = -1
        var length = arguments.length
        if (!length) {
          return ''
        }
        var result = ''
        while (++index < length) {
          var codePoint = Number(arguments[index])
          if (
            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
            codePoint < 0 || // not a valid Unicode code point
            codePoint > 0x10FFFF || // not a valid Unicode code point
            floor(codePoint) !== codePoint // not an integer
          ) {
            throw RangeError('Invalid code point: ' + codePoint)
          }
          if (codePoint <= 0xFFFF) { // BMP code point
            codeUnits.push(codePoint)
          } else { // Astral code point; split in surrogate halves
            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            codePoint -= 0x10000
            highSurrogate = (codePoint >> 10) + 0xD800
            lowSurrogate = (codePoint % 0x400) + 0xDC00
            codeUnits.push(highSurrogate, lowSurrogate)
          }
          if (index + 1 === length || codeUnits.length > MAX_SIZE) {
            result += stringFromCharCode.apply(null, codeUnits)
            codeUnits.length = 0
          }
        }
        return result
      }
      /* istanbul ignore next */
      if (Object.defineProperty) {
        Object.defineProperty(String, 'fromCodePoint', {
          value: fromCodePoint,
          configurable: true,
          writable: true
        })
      } else {
        String.fromCodePoint = fromCodePoint
      }
    }())
  }
})( false ? undefined : exports)


/***/ }),

/***/ "./node_modules/tar/index.js":
/*!***********************************!*\
  !*** ./node_modules/tar/index.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// high-level commands
exports.c = exports.create = __webpack_require__(/*! ./lib/create.js */ "./node_modules/tar/lib/create.js")
exports.r = exports.replace = __webpack_require__(/*! ./lib/replace.js */ "./node_modules/tar/lib/replace.js")
exports.t = exports.list = __webpack_require__(/*! ./lib/list.js */ "./node_modules/tar/lib/list.js")
exports.u = exports.update = __webpack_require__(/*! ./lib/update.js */ "./node_modules/tar/lib/update.js")
exports.x = exports.extract = __webpack_require__(/*! ./lib/extract.js */ "./node_modules/tar/lib/extract.js")

// classes
exports.Pack = __webpack_require__(/*! ./lib/pack.js */ "./node_modules/tar/lib/pack.js")
exports.Unpack = __webpack_require__(/*! ./lib/unpack.js */ "./node_modules/tar/lib/unpack.js")
exports.Parse = __webpack_require__(/*! ./lib/parse.js */ "./node_modules/tar/lib/parse.js")
exports.ReadEntry = __webpack_require__(/*! ./lib/read-entry.js */ "./node_modules/tar/lib/read-entry.js")
exports.WriteEntry = __webpack_require__(/*! ./lib/write-entry.js */ "./node_modules/tar/lib/write-entry.js")
exports.Header = __webpack_require__(/*! ./lib/header.js */ "./node_modules/tar/lib/header.js")
exports.Pax = __webpack_require__(/*! ./lib/pax.js */ "./node_modules/tar/lib/pax.js")
exports.types = __webpack_require__(/*! ./lib/types.js */ "./node_modules/tar/lib/types.js")


/***/ }),

/***/ "./node_modules/tar/lib/buffer.js":
/*!****************************************!*\
  !*** ./node_modules/tar/lib/buffer.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Buffer in node 4.x < 4.5.0 doesn't have working Buffer.from
// or Buffer.alloc, and Buffer in node 10 deprecated the ctor.
// .M, this is fine .\^/M..
let B = Buffer
/* istanbul ignore next */
if (!B.alloc) {
  B = __webpack_require__(/*! safe-buffer */ "safe-buffer").Buffer
}
module.exports = B


/***/ }),

/***/ "./node_modules/tar/lib/create.js":
/*!****************************************!*\
  !*** ./node_modules/tar/lib/create.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// tar -c
const hlo = __webpack_require__(/*! ./high-level-opt.js */ "./node_modules/tar/lib/high-level-opt.js")

const Pack = __webpack_require__(/*! ./pack.js */ "./node_modules/tar/lib/pack.js")
const fs = __webpack_require__(/*! fs */ "fs")
const fsm = __webpack_require__(/*! fs-minipass */ "./node_modules/fs-minipass/index.js")
const t = __webpack_require__(/*! ./list.js */ "./node_modules/tar/lib/list.js")
const path = __webpack_require__(/*! path */ "path")

const c = module.exports = (opt_, files, cb) => {
  if (typeof files === 'function')
    cb = files

  if (Array.isArray(opt_))
    files = opt_, opt_ = {}

  if (!files || !Array.isArray(files) || !files.length)
    throw new TypeError('no files or directories specified')

  files = Array.from(files)

  const opt = hlo(opt_)

  if (opt.sync && typeof cb === 'function')
    throw new TypeError('callback not supported for sync tar functions')

  if (!opt.file && typeof cb === 'function')
    throw new TypeError('callback only supported with file option')

  return opt.file && opt.sync ? createFileSync(opt, files)
    : opt.file ? createFile(opt, files, cb)
    : opt.sync ? createSync(opt, files)
    : create(opt, files)
}

const createFileSync = (opt, files) => {
  const p = new Pack.Sync(opt)
  const stream = new fsm.WriteStreamSync(opt.file, {
    mode: opt.mode || 0o666
  })
  p.pipe(stream)
  addFilesSync(p, files)
}

const createFile = (opt, files, cb) => {
  const p = new Pack(opt)
  const stream = new fsm.WriteStream(opt.file, {
    mode: opt.mode || 0o666
  })
  p.pipe(stream)

  const promise = new Promise((res, rej) => {
    stream.on('error', rej)
    stream.on('close', res)
    p.on('error', rej)
  })

  addFilesAsync(p, files)

  return cb ? promise.then(cb, cb) : promise
}

const addFilesSync = (p, files) => {
  files.forEach(file => {
    if (file.charAt(0) === '@')
      t({
        file: path.resolve(p.cwd, file.substr(1)),
        sync: true,
        noResume: true,
        onentry: entry => p.add(entry)
      })
    else
      p.add(file)
  })
  p.end()
}

const addFilesAsync = (p, files) => {
  while (files.length) {
    const file = files.shift()
    if (file.charAt(0) === '@')
      return t({
        file: path.resolve(p.cwd, file.substr(1)),
        noResume: true,
        onentry: entry => p.add(entry)
      }).then(_ => addFilesAsync(p, files))
    else
      p.add(file)
  }
  p.end()
}

const createSync = (opt, files) => {
  const p = new Pack.Sync(opt)
  addFilesSync(p, files)
  return p
}

const create = (opt, files) => {
  const p = new Pack(opt)
  addFilesAsync(p, files)
  return p
}


/***/ }),

/***/ "./node_modules/tar/lib/extract.js":
/*!*****************************************!*\
  !*** ./node_modules/tar/lib/extract.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// tar -x
const hlo = __webpack_require__(/*! ./high-level-opt.js */ "./node_modules/tar/lib/high-level-opt.js")
const Unpack = __webpack_require__(/*! ./unpack.js */ "./node_modules/tar/lib/unpack.js")
const fs = __webpack_require__(/*! fs */ "fs")
const fsm = __webpack_require__(/*! fs-minipass */ "./node_modules/fs-minipass/index.js")
const path = __webpack_require__(/*! path */ "path")

const x = module.exports = (opt_, files, cb) => {
  if (typeof opt_ === 'function')
    cb = opt_, files = null, opt_ = {}
  else if (Array.isArray(opt_))
    files = opt_, opt_ = {}

  if (typeof files === 'function')
    cb = files, files = null

  if (!files)
    files = []
  else
    files = Array.from(files)

  const opt = hlo(opt_)

  if (opt.sync && typeof cb === 'function')
    throw new TypeError('callback not supported for sync tar functions')

  if (!opt.file && typeof cb === 'function')
    throw new TypeError('callback only supported with file option')

  if (files.length)
    filesFilter(opt, files)

  return opt.file && opt.sync ? extractFileSync(opt)
    : opt.file ? extractFile(opt, cb)
    : opt.sync ? extractSync(opt)
    : extract(opt)
}

// construct a filter that limits the file entries listed
// include child entries if a dir is included
const filesFilter = (opt, files) => {
  const map = new Map(files.map(f => [f.replace(/\/+$/, ''), true]))
  const filter = opt.filter

  const mapHas = (file, r) => {
    const root = r || path.parse(file).root || '.'
    const ret = file === root ? false
      : map.has(file) ? map.get(file)
      : mapHas(path.dirname(file), root)

    map.set(file, ret)
    return ret
  }

  opt.filter = filter
    ? (file, entry) => filter(file, entry) && mapHas(file.replace(/\/+$/, ''))
    : file => mapHas(file.replace(/\/+$/, ''))
}

const extractFileSync = opt => {
  const u = new Unpack.Sync(opt)

  const file = opt.file
  let threw = true
  let fd
  const stat = fs.statSync(file)
  // This trades a zero-byte read() syscall for a stat
  // However, it will usually result in less memory allocation
  const readSize = opt.maxReadSize || 16*1024*1024
  const stream = new fsm.ReadStreamSync(file, {
    readSize: readSize,
    size: stat.size
  })
  stream.pipe(u)
}

const extractFile = (opt, cb) => {
  const u = new Unpack(opt)
  const readSize = opt.maxReadSize || 16*1024*1024

  const file = opt.file
  const p = new Promise((resolve, reject) => {
    u.on('error', reject)
    u.on('close', resolve)

    // This trades a zero-byte read() syscall for a stat
    // However, it will usually result in less memory allocation
    fs.stat(file, (er, stat) => {
      if (er)
        reject(er)
      else {
        const stream = new fsm.ReadStream(file, {
          readSize: readSize,
          size: stat.size
        })
        stream.on('error', reject)
        stream.pipe(u)
      }
    })
  })
  return cb ? p.then(cb, cb) : p
}

const extractSync = opt => {
  return new Unpack.Sync(opt)
}

const extract = opt => {
  return new Unpack(opt)
}


/***/ }),

/***/ "./node_modules/tar/lib/header.js":
/*!****************************************!*\
  !*** ./node_modules/tar/lib/header.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// parse a 512-byte header block to a data object, or vice-versa
// encode returns `true` if a pax extended header is needed, because
// the data could not be faithfully encoded in a simple header.
// (Also, check header.needPax to see if it needs a pax header.)

const Buffer = __webpack_require__(/*! ./buffer.js */ "./node_modules/tar/lib/buffer.js")
const types = __webpack_require__(/*! ./types.js */ "./node_modules/tar/lib/types.js")
const pathModule = __webpack_require__(/*! path */ "path").posix
const large = __webpack_require__(/*! ./large-numbers.js */ "./node_modules/tar/lib/large-numbers.js")

const SLURP = Symbol('slurp')
const TYPE = Symbol('type')

class Header {
  constructor (data, off, ex, gex) {
    this.cksumValid = false
    this.needPax = false
    this.nullBlock = false

    this.block = null
    this.path = null
    this.mode = null
    this.uid = null
    this.gid = null
    this.size = null
    this.mtime = null
    this.cksum = null
    this[TYPE] = '0'
    this.linkpath = null
    this.uname = null
    this.gname = null
    this.devmaj = 0
    this.devmin = 0
    this.atime = null
    this.ctime = null

    if (Buffer.isBuffer(data))
      this.decode(data, off || 0, ex, gex)
    else if (data)
      this.set(data)
  }

  decode (buf, off, ex, gex) {
    if (!off)
      off = 0

    if (!buf || !(buf.length >= off + 512))
      throw new Error('need 512 bytes for header')

    this.path = decString(buf, off, 100)
    this.mode = decNumber(buf, off + 100, 8)
    this.uid = decNumber(buf, off + 108, 8)
    this.gid = decNumber(buf, off + 116, 8)
    this.size = decNumber(buf, off + 124, 12)
    this.mtime = decDate(buf, off + 136, 12)
    this.cksum = decNumber(buf, off + 148, 12)

    // if we have extended or global extended headers, apply them now
    // See https://github.com/npm/node-tar/pull/187
    this[SLURP](ex)
    this[SLURP](gex, true)

    // old tar versions marked dirs as a file with a trailing /
    this[TYPE] = decString(buf, off + 156, 1)
    if (this[TYPE] === '')
      this[TYPE] = '0'
    if (this[TYPE] === '0' && this.path.substr(-1) === '/')
      this[TYPE] = '5'

    // tar implementations sometimes incorrectly put the stat(dir).size
    // as the size in the tarball, even though Directory entries are
    // not able to have any body at all.  In the very rare chance that
    // it actually DOES have a body, we weren't going to do anything with
    // it anyway, and it'll just be a warning about an invalid header.
    if (this[TYPE] === '5')
      this.size = 0

    this.linkpath = decString(buf, off + 157, 100)
    if (buf.slice(off + 257, off + 265).toString() === 'ustar\u000000') {
      this.uname = decString(buf, off + 265, 32)
      this.gname = decString(buf, off + 297, 32)
      this.devmaj = decNumber(buf, off + 329, 8)
      this.devmin = decNumber(buf, off + 337, 8)
      if (buf[off + 475] !== 0) {
        // definitely a prefix, definitely >130 chars.
        const prefix = decString(buf, off + 345, 155)
        this.path = prefix + '/' + this.path
      } else {
        const prefix = decString(buf, off + 345, 130)
        if (prefix)
          this.path = prefix + '/' + this.path
        this.atime = decDate(buf, off + 476, 12)
        this.ctime = decDate(buf, off + 488, 12)
      }
    }

    let sum = 8 * 0x20
    for (let i = off; i < off + 148; i++) {
      sum += buf[i]
    }
    for (let i = off + 156; i < off + 512; i++) {
      sum += buf[i]
    }
    this.cksumValid = sum === this.cksum
    if (this.cksum === null && sum === 8 * 0x20)
      this.nullBlock = true
  }

  [SLURP] (ex, global) {
    for (let k in ex) {
      // we slurp in everything except for the path attribute in
      // a global extended header, because that's weird.
      if (ex[k] !== null && ex[k] !== undefined &&
          !(global && k === 'path'))
        this[k] = ex[k]
    }
  }

  encode (buf, off) {
    if (!buf) {
      buf = this.block = Buffer.alloc(512)
      off = 0
    }

    if (!off)
      off = 0

    if (!(buf.length >= off + 512))
      throw new Error('need 512 bytes for header')

    const prefixSize = this.ctime || this.atime ? 130 : 155
    const split = splitPrefix(this.path || '', prefixSize)
    const path = split[0]
    const prefix = split[1]
    this.needPax = split[2]

    this.needPax = encString(buf, off, 100, path) || this.needPax
    this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax
    this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax
    this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax
    this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax
    this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax
    buf[off + 156] = this[TYPE].charCodeAt(0)
    this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax
    buf.write('ustar\u000000', off + 257, 8)
    this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax
    this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax
    this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax
    this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax
    this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax
    if (buf[off + 475] !== 0)
      this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax
    else {
      this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax
      this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax
      this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax
    }

    let sum = 8 * 0x20
    for (let i = off; i < off + 148; i++) {
      sum += buf[i]
    }
    for (let i = off + 156; i < off + 512; i++) {
      sum += buf[i]
    }
    this.cksum = sum
    encNumber(buf, off + 148, 8, this.cksum)
    this.cksumValid = true

    return this.needPax
  }

  set (data) {
    for (let i in data) {
      if (data[i] !== null && data[i] !== undefined)
        this[i] = data[i]
    }
  }

  get type () {
    return types.name.get(this[TYPE]) || this[TYPE]
  }

  get typeKey () {
    return this[TYPE]
  }

  set type (type) {
    if (types.code.has(type))
      this[TYPE] = types.code.get(type)
    else
      this[TYPE] = type
  }
}

const splitPrefix = (p, prefixSize) => {
  const pathSize = 100
  let pp = p
  let prefix = ''
  let ret
  const root = pathModule.parse(p).root || '.'

  if (Buffer.byteLength(pp) < pathSize)
    ret = [pp, prefix, false]
  else {
    // first set prefix to the dir, and path to the base
    prefix = pathModule.dirname(pp)
    pp = pathModule.basename(pp)

    do {
      // both fit!
      if (Buffer.byteLength(pp) <= pathSize &&
          Buffer.byteLength(prefix) <= prefixSize)
        ret = [pp, prefix, false]

      // prefix fits in prefix, but path doesn't fit in path
      else if (Buffer.byteLength(pp) > pathSize &&
          Buffer.byteLength(prefix) <= prefixSize)
        ret = [pp.substr(0, pathSize - 1), prefix, true]

      else {
        // make path take a bit from prefix
        pp = pathModule.join(pathModule.basename(prefix), pp)
        prefix = pathModule.dirname(prefix)
      }
    } while (prefix !== root && !ret)

    // at this point, found no resolution, just truncate
    if (!ret)
      ret = [p.substr(0, pathSize - 1), '', true]
  }
  return ret
}

const decString = (buf, off, size) =>
  buf.slice(off, off + size).toString('utf8').replace(/\0.*/, '')

const decDate = (buf, off, size) =>
  numToDate(decNumber(buf, off, size))

const numToDate = num => num === null ? null : new Date(num * 1000)

const decNumber = (buf, off, size) =>
  buf[off] & 0x80 ? large.parse(buf.slice(off, off + size))
    : decSmallNumber(buf, off, size)

const nanNull = value => isNaN(value) ? null : value

const decSmallNumber = (buf, off, size) =>
  nanNull(parseInt(
    buf.slice(off, off + size)
      .toString('utf8').replace(/\0.*$/, '').trim(), 8))

// the maximum encodable as a null-terminated octal, by field size
const MAXNUM = {
  12: 0o77777777777,
  8 : 0o7777777
}

const encNumber = (buf, off, size, number) =>
  number === null ? false :
  number > MAXNUM[size] || number < 0
    ? (large.encode(number, buf.slice(off, off + size)), true)
    : (encSmallNumber(buf, off, size, number), false)

const encSmallNumber = (buf, off, size, number) =>
  buf.write(octalString(number, size), off, size, 'ascii')

const octalString = (number, size) =>
  padOctal(Math.floor(number).toString(8), size)

const padOctal = (string, size) =>
  (string.length === size - 1 ? string
  : new Array(size - string.length - 1).join('0') + string + ' ') + '\0'

const encDate = (buf, off, size, date) =>
  date === null ? false :
  encNumber(buf, off, size, date.getTime() / 1000)

// enough to fill the longest string we've got
const NULLS = new Array(156).join('\0')
// pad with nulls, return true if it's longer or non-ascii
const encString = (buf, off, size, string) =>
  string === null ? false :
  (buf.write(string + NULLS, off, size, 'utf8'),
   string.length !== Buffer.byteLength(string) || string.length > size)

module.exports = Header


/***/ }),

/***/ "./node_modules/tar/lib/high-level-opt.js":
/*!************************************************!*\
  !*** ./node_modules/tar/lib/high-level-opt.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// turn tar(1) style args like `C` into the more verbose things like `cwd`

const argmap = new Map([
  ['C', 'cwd'],
  ['f', 'file'],
  ['z', 'gzip'],
  ['P', 'preservePaths'],
  ['U', 'unlink'],
  ['strip-components', 'strip'],
  ['stripComponents', 'strip'],
  ['keep-newer', 'newer'],
  ['keepNewer', 'newer'],
  ['keep-newer-files', 'newer'],
  ['keepNewerFiles', 'newer'],
  ['k', 'keep'],
  ['keep-existing', 'keep'],
  ['keepExisting', 'keep'],
  ['m', 'noMtime'],
  ['no-mtime', 'noMtime'],
  ['p', 'preserveOwner'],
  ['L', 'follow'],
  ['h', 'follow']
])

const parse = module.exports = opt => opt ? Object.keys(opt).map(k => [
  argmap.has(k) ? argmap.get(k) : k, opt[k]
]).reduce((set, kv) => (set[kv[0]] = kv[1], set), Object.create(null)) : {}


/***/ }),

/***/ "./node_modules/tar/lib/large-numbers.js":
/*!***********************************************!*\
  !*** ./node_modules/tar/lib/large-numbers.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Tar can encode large and negative numbers using a leading byte of
// 0xff for negative, and 0x80 for positive.

const encode = exports.encode = (num, buf) => {
  if (!Number.isSafeInteger(num))
    // The number is so large that javascript cannot represent it with integer
    // precision.
    throw TypeError('cannot encode number outside of javascript safe integer range')
  else if (num < 0)
    encodeNegative(num, buf)
  else
    encodePositive(num, buf)
  return buf
}

const encodePositive = (num, buf) => {
  buf[0] = 0x80

  for (var i = buf.length; i > 1; i--) {
    buf[i-1] = num & 0xff
    num = Math.floor(num / 0x100)
  }
}

const encodeNegative = (num, buf) => {
  buf[0] = 0xff
  var flipped = false
  num = num * -1
  for (var i = buf.length; i > 1; i--) {
    var byte = num & 0xff
    num = Math.floor(num / 0x100)
    if (flipped)
      buf[i-1] = onesComp(byte)
    else if (byte === 0)
      buf[i-1] = 0
    else {
      flipped = true
      buf[i-1] = twosComp(byte)
    }
  }
}

const parse = exports.parse = (buf) => {
  var post = buf[buf.length - 1]
  var pre = buf[0]
  var value;
  if (pre === 0x80)
    value = pos(buf.slice(1, buf.length))
  else if (pre === 0xff)
    value = twos(buf)
  else
    throw TypeError('invalid base256 encoding')

  if (!Number.isSafeInteger(value))
    // The number is so large that javascript cannot represent it with integer
    // precision.
    throw TypeError('parsed number outside of javascript safe integer range')

  return value
}

const twos = (buf) => {
  var len = buf.length
  var sum = 0
  var flipped = false
  for (var i = len - 1; i > -1; i--) {
    var byte = buf[i]
    var f
    if (flipped)
      f = onesComp(byte)
    else if (byte === 0)
      f = byte
    else {
      flipped = true
      f = twosComp(byte)
    }
    if (f !== 0)
      sum -= f * Math.pow(256, len - i - 1)
  }
  return sum
}

const pos = (buf) => {
  var len = buf.length
  var sum = 0
  for (var i = len - 1; i > -1; i--) {
    var byte = buf[i]
    if (byte !== 0)
      sum += byte * Math.pow(256, len - i - 1)
  }
  return sum
}

const onesComp = byte => (0xff ^ byte) & 0xff

const twosComp = byte => ((0xff ^ byte) + 1) & 0xff


/***/ }),

/***/ "./node_modules/tar/lib/list.js":
/*!**************************************!*\
  !*** ./node_modules/tar/lib/list.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Buffer = __webpack_require__(/*! ./buffer.js */ "./node_modules/tar/lib/buffer.js")

// XXX: This shares a lot in common with extract.js
// maybe some DRY opportunity here?

// tar -t
const hlo = __webpack_require__(/*! ./high-level-opt.js */ "./node_modules/tar/lib/high-level-opt.js")
const Parser = __webpack_require__(/*! ./parse.js */ "./node_modules/tar/lib/parse.js")
const fs = __webpack_require__(/*! fs */ "fs")
const fsm = __webpack_require__(/*! fs-minipass */ "./node_modules/fs-minipass/index.js")
const path = __webpack_require__(/*! path */ "path")

const t = module.exports = (opt_, files, cb) => {
  if (typeof opt_ === 'function')
    cb = opt_, files = null, opt_ = {}
  else if (Array.isArray(opt_))
    files = opt_, opt_ = {}

  if (typeof files === 'function')
    cb = files, files = null

  if (!files)
    files = []
  else
    files = Array.from(files)

  const opt = hlo(opt_)

  if (opt.sync && typeof cb === 'function')
    throw new TypeError('callback not supported for sync tar functions')

  if (!opt.file && typeof cb === 'function')
    throw new TypeError('callback only supported with file option')

  if (files.length)
    filesFilter(opt, files)

  if (!opt.noResume)
    onentryFunction(opt)

  return opt.file && opt.sync ? listFileSync(opt)
    : opt.file ? listFile(opt, cb)
    : list(opt)
}

const onentryFunction = opt => {
  const onentry = opt.onentry
  opt.onentry = onentry ? e => {
    onentry(e)
    e.resume()
  } : e => e.resume()
}

// construct a filter that limits the file entries listed
// include child entries if a dir is included
const filesFilter = (opt, files) => {
  const map = new Map(files.map(f => [f.replace(/\/+$/, ''), true]))
  const filter = opt.filter

  const mapHas = (file, r) => {
    const root = r || path.parse(file).root || '.'
    const ret = file === root ? false
      : map.has(file) ? map.get(file)
      : mapHas(path.dirname(file), root)

    map.set(file, ret)
    return ret
  }

  opt.filter = filter
    ? (file, entry) => filter(file, entry) && mapHas(file.replace(/\/+$/, ''))
    : file => mapHas(file.replace(/\/+$/, ''))
}

const listFileSync = opt => {
  const p = list(opt)
  const file = opt.file
  let threw = true
  let fd
  try {
    const stat = fs.statSync(file)
    const readSize = opt.maxReadSize || 16*1024*1024
    if (stat.size < readSize) {
      p.end(fs.readFileSync(file))
    } else {
      let pos = 0
      const buf = Buffer.allocUnsafe(readSize)
      fd = fs.openSync(file, 'r')
      while (pos < stat.size) {
        let bytesRead = fs.readSync(fd, buf, 0, readSize, pos)
        pos += bytesRead
        p.write(buf.slice(0, bytesRead))
      }
      p.end()
    }
    threw = false
  } finally {
    if (threw && fd)
      try { fs.closeSync(fd) } catch (er) {}
  }
}

const listFile = (opt, cb) => {
  const parse = new Parser(opt)
  const readSize = opt.maxReadSize || 16*1024*1024

  const file = opt.file
  const p = new Promise((resolve, reject) => {
    parse.on('error', reject)
    parse.on('end', resolve)

    fs.stat(file, (er, stat) => {
      if (er)
        reject(er)
      else {
        const stream = new fsm.ReadStream(file, {
          readSize: readSize,
          size: stat.size
        })
        stream.on('error', reject)
        stream.pipe(parse)
      }
    })
  })
  return cb ? p.then(cb, cb) : p
}

const list = opt => new Parser(opt)


/***/ }),

/***/ "./node_modules/tar/lib/mkdir.js":
/*!***************************************!*\
  !*** ./node_modules/tar/lib/mkdir.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// wrapper around mkdirp for tar's needs.

// TODO: This should probably be a class, not functionally
// passing around state in a gazillion args.

const mkdirp = __webpack_require__(/*! mkdirp */ "mkdirp")
const fs = __webpack_require__(/*! fs */ "fs")
const path = __webpack_require__(/*! path */ "path")
const chownr = __webpack_require__(/*! chownr */ "chownr")

class SymlinkError extends Error {
  constructor (symlink, path) {
    super('Cannot extract through symbolic link')
    this.path = path
    this.symlink = symlink
  }

  get name () {
    return 'SylinkError'
  }
}

class CwdError extends Error {
  constructor (path, code) {
    super(code + ': Cannot cd into \'' + path + '\'')
    this.path = path
    this.code = code
  }

  get name () {
    return 'CwdError'
  }
}

const mkdir = module.exports = (dir, opt, cb) => {
  // if there's any overlap between mask and mode,
  // then we'll need an explicit chmod
  const umask = opt.umask
  const mode = opt.mode | 0o0700
  const needChmod = (mode & umask) !== 0

  const uid = opt.uid
  const gid = opt.gid
  const doChown = typeof uid === 'number' &&
    typeof gid === 'number' &&
    ( uid !== opt.processUid || gid !== opt.processGid )

  const preserve = opt.preserve
  const unlink = opt.unlink
  const cache = opt.cache
  const cwd = opt.cwd

  const done = (er, created) => {
    if (er)
      cb(er)
    else {
      cache.set(dir, true)
      if (created && doChown)
        chownr(created, uid, gid, er => done(er))
      else if (needChmod)
        fs.chmod(dir, mode, cb)
      else
        cb()
    }
  }

  if (cache && cache.get(dir) === true)
    return done()

  if (dir === cwd)
    return fs.stat(dir, (er, st) => {
      if (er || !st.isDirectory())
        er = new CwdError(dir, er && er.code || 'ENOTDIR')
      done(er)
    })

  if (preserve)
    return mkdirp(dir, mode, done)

  const sub = path.relative(cwd, dir)
  const parts = sub.split(/\/|\\/)
  mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done)
}

const mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {
  if (!parts.length)
    return cb(null, created)
  const p = parts.shift()
  const part = base + '/' + p
  if (cache.get(part))
    return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)
  fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))
}

const onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => er => {
  if (er) {
    if (er.path && path.dirname(er.path) === cwd &&
        (er.code === 'ENOTDIR' || er.code === 'ENOENT'))
      return cb(new CwdError(cwd, er.code))

    fs.lstat(part, (statEr, st) => {
      if (statEr)
        cb(statEr)
      else if (st.isDirectory())
        mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)
      else if (unlink)
        fs.unlink(part, er => {
          if (er)
            return cb(er)
          fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))
        })
      else if (st.isSymbolicLink())
        return cb(new SymlinkError(part, part + '/' + parts.join('/')))
      else
        cb(er)
    })
  } else {
    created = created || part
    mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)
  }
}

const mkdirSync = module.exports.sync = (dir, opt) => {
  // if there's any overlap between mask and mode,
  // then we'll need an explicit chmod
  const umask = opt.umask
  const mode = opt.mode | 0o0700
  const needChmod = (mode & umask) !== 0

  const uid = opt.uid
  const gid = opt.gid
  const doChown = typeof uid === 'number' &&
    typeof gid === 'number' &&
    ( uid !== opt.processUid || gid !== opt.processGid )

  const preserve = opt.preserve
  const unlink = opt.unlink
  const cache = opt.cache
  const cwd = opt.cwd

  const done = (created) => {
    cache.set(dir, true)
    if (created && doChown)
      chownr.sync(created, uid, gid)
    if (needChmod)
      fs.chmodSync(dir, mode)
  }

  if (cache && cache.get(dir) === true)
    return done()

  if (dir === cwd) {
    let ok = false
    let code = 'ENOTDIR'
    try {
      ok = fs.statSync(dir).isDirectory()
    } catch (er) {
      code = er.code
    } finally {
      if (!ok)
        throw new CwdError(dir, code)
    }
    done()
    return
  }

  if (preserve)
    return done(mkdirp.sync(dir, mode))

  const sub = path.relative(cwd, dir)
  const parts = sub.split(/\/|\\/)
  let created = null
  for (let p = parts.shift(), part = cwd;
       p && (part += '/' + p);
       p = parts.shift()) {

    if (cache.get(part))
      continue

    try {
      fs.mkdirSync(part, mode)
      created = created || part
      cache.set(part, true)
    } catch (er) {
      if (er.path && path.dirname(er.path) === cwd &&
          (er.code === 'ENOTDIR' || er.code === 'ENOENT'))
        return new CwdError(cwd, er.code)

      const st = fs.lstatSync(part)
      if (st.isDirectory()) {
        cache.set(part, true)
        continue
      } else if (unlink) {
        fs.unlinkSync(part)
        fs.mkdirSync(part, mode)
        created = created || part
        cache.set(part, true)
        continue
      } else if (st.isSymbolicLink())
        return new SymlinkError(part, part + '/' + parts.join('/'))
    }
  }

  return done(created)
}


/***/ }),

/***/ "./node_modules/tar/lib/mode-fix.js":
/*!******************************************!*\
  !*** ./node_modules/tar/lib/mode-fix.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = (mode, isDir) => {
  mode &= 0o7777
  // if dirs are readable, then they should be listable
  if (isDir) {
    if (mode & 0o400)
      mode |= 0o100
    if (mode & 0o40)
      mode |= 0o10
    if (mode & 0o4)
      mode |= 0o1
  }
  return mode
}


/***/ }),

/***/ "./node_modules/tar/lib/pack.js":
/*!**************************************!*\
  !*** ./node_modules/tar/lib/pack.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Buffer = __webpack_require__(/*! ./buffer.js */ "./node_modules/tar/lib/buffer.js")

// A readable tar stream creator
// Technically, this is a transform stream that you write paths into,
// and tar format comes out of.
// The `add()` method is like `write()` but returns this,
// and end() return `this` as well, so you can
// do `new Pack(opt).add('files').add('dir').end().pipe(output)
// You could also do something like:
// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))

class PackJob {
  constructor (path, absolute) {
    this.path = path || './'
    this.absolute = absolute
    this.entry = null
    this.stat = null
    this.readdir = null
    this.pending = false
    this.ignore = false
    this.piped = false
  }
}

const MiniPass = __webpack_require__(/*! minipass */ "./node_modules/minipass/index.js")
const zlib = __webpack_require__(/*! minizlib */ "./node_modules/minizlib/index.js")
const ReadEntry = __webpack_require__(/*! ./read-entry.js */ "./node_modules/tar/lib/read-entry.js")
const WriteEntry = __webpack_require__(/*! ./write-entry.js */ "./node_modules/tar/lib/write-entry.js")
const WriteEntrySync = WriteEntry.Sync
const WriteEntryTar = WriteEntry.Tar
const Yallist = __webpack_require__(/*! yallist */ "yallist")
const EOF = Buffer.alloc(1024)
const ONSTAT = Symbol('onStat')
const ENDED = Symbol('ended')
const QUEUE = Symbol('queue')
const CURRENT = Symbol('current')
const PROCESS = Symbol('process')
const PROCESSING = Symbol('processing')
const PROCESSJOB = Symbol('processJob')
const JOBS = Symbol('jobs')
const JOBDONE = Symbol('jobDone')
const ADDFSENTRY = Symbol('addFSEntry')
const ADDTARENTRY = Symbol('addTarEntry')
const STAT = Symbol('stat')
const READDIR = Symbol('readdir')
const ONREADDIR = Symbol('onreaddir')
const PIPE = Symbol('pipe')
const ENTRY = Symbol('entry')
const ENTRYOPT = Symbol('entryOpt')
const WRITEENTRYCLASS = Symbol('writeEntryClass')
const WRITE = Symbol('write')
const ONDRAIN = Symbol('ondrain')

const fs = __webpack_require__(/*! fs */ "fs")
const path = __webpack_require__(/*! path */ "path")
const warner = __webpack_require__(/*! ./warn-mixin.js */ "./node_modules/tar/lib/warn-mixin.js")

const Pack = warner(class Pack extends MiniPass {
  constructor (opt) {
    super(opt)
    opt = opt || Object.create(null)
    this.opt = opt
    this.cwd = opt.cwd || process.cwd()
    this.maxReadSize = opt.maxReadSize
    this.preservePaths = !!opt.preservePaths
    this.strict = !!opt.strict
    this.noPax = !!opt.noPax
    this.prefix = (opt.prefix || '').replace(/(\\|\/)+$/, '')
    this.linkCache = opt.linkCache || new Map()
    this.statCache = opt.statCache || new Map()
    this.readdirCache = opt.readdirCache || new Map()

    this[WRITEENTRYCLASS] = WriteEntry
    if (typeof opt.onwarn === 'function')
      this.on('warn', opt.onwarn)

    this.zip = null
    if (opt.gzip) {
      if (typeof opt.gzip !== 'object')
        opt.gzip = {}
      this.zip = new zlib.Gzip(opt.gzip)
      this.zip.on('data', chunk => super.write(chunk))
      this.zip.on('end', _ => super.end())
      this.zip.on('drain', _ => this[ONDRAIN]())
      this.on('resume', _ => this.zip.resume())
    } else
      this.on('drain', this[ONDRAIN])

    this.portable = !!opt.portable
    this.noDirRecurse = !!opt.noDirRecurse
    this.follow = !!opt.follow
    this.noMtime = !!opt.noMtime
    this.mtime = opt.mtime || null

    this.filter = typeof opt.filter === 'function' ? opt.filter : _ => true

    this[QUEUE] = new Yallist
    this[JOBS] = 0
    this.jobs = +opt.jobs || 4
    this[PROCESSING] = false
    this[ENDED] = false
  }

  [WRITE] (chunk) {
    return super.write(chunk)
  }

  add (path) {
    this.write(path)
    return this
  }

  end (path) {
    if (path)
      this.write(path)
    this[ENDED] = true
    this[PROCESS]()
    return this
  }

  write (path) {
    if (this[ENDED])
      throw new Error('write after end')

    if (path instanceof ReadEntry)
      this[ADDTARENTRY](path)
    else
      this[ADDFSENTRY](path)
    return this.flowing
  }

  [ADDTARENTRY] (p) {
    const absolute = path.resolve(this.cwd, p.path)
    if (this.prefix)
      p.path = this.prefix + '/' + p.path.replace(/^\.(\/+|$)/, '')

    // in this case, we don't have to wait for the stat
    if (!this.filter(p.path, p))
      p.resume()
    else {
      const job = new PackJob(p.path, absolute, false)
      job.entry = new WriteEntryTar(p, this[ENTRYOPT](job))
      job.entry.on('end', _ => this[JOBDONE](job))
      this[JOBS] += 1
      this[QUEUE].push(job)
    }

    this[PROCESS]()
  }

  [ADDFSENTRY] (p) {
    const absolute = path.resolve(this.cwd, p)
    if (this.prefix)
      p = this.prefix + '/' + p.replace(/^\.(\/+|$)/, '')

    this[QUEUE].push(new PackJob(p, absolute))
    this[PROCESS]()
  }

  [STAT] (job) {
    job.pending = true
    this[JOBS] += 1
    const stat = this.follow ? 'stat' : 'lstat'
    fs[stat](job.absolute, (er, stat) => {
      job.pending = false
      this[JOBS] -= 1
      if (er)
        this.emit('error', er)
      else
        this[ONSTAT](job, stat)
    })
  }

  [ONSTAT] (job, stat) {
    this.statCache.set(job.absolute, stat)
    job.stat = stat

    // now we have the stat, we can filter it.
    if (!this.filter(job.path, stat))
      job.ignore = true

    this[PROCESS]()
  }

  [READDIR] (job) {
    job.pending = true
    this[JOBS] += 1
    fs.readdir(job.absolute, (er, entries) => {
      job.pending = false
      this[JOBS] -= 1
      if (er)
        return this.emit('error', er)
      this[ONREADDIR](job, entries)
    })
  }

  [ONREADDIR] (job, entries) {
    this.readdirCache.set(job.absolute, entries)
    job.readdir = entries
    this[PROCESS]()
  }

  [PROCESS] () {
    if (this[PROCESSING])
      return

    this[PROCESSING] = true
    for (let w = this[QUEUE].head;
         w !== null && this[JOBS] < this.jobs;
         w = w.next) {
      this[PROCESSJOB](w.value)
      if (w.value.ignore) {
        const p = w.next
        this[QUEUE].removeNode(w)
        w.next = p
      }
    }

    this[PROCESSING] = false

    if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {
      if (this.zip)
        this.zip.end(EOF)
      else {
        super.write(EOF)
        super.end()
      }
    }
  }

  get [CURRENT] () {
    return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value
  }

  [JOBDONE] (job) {
    this[QUEUE].shift()
    this[JOBS] -= 1
    this[PROCESS]()
  }

  [PROCESSJOB] (job) {
    if (job.pending)
      return

    if (job.entry) {
      if (job === this[CURRENT] && !job.piped)
        this[PIPE](job)
      return
    }

    if (!job.stat) {
      if (this.statCache.has(job.absolute))
        this[ONSTAT](job, this.statCache.get(job.absolute))
      else
        this[STAT](job)
    }
    if (!job.stat)
      return

    // filtered out!
    if (job.ignore)
      return

    if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {
      if (this.readdirCache.has(job.absolute))
        this[ONREADDIR](job, this.readdirCache.get(job.absolute))
      else
        this[READDIR](job)
      if (!job.readdir)
        return
    }

    // we know it doesn't have an entry, because that got checked above
    job.entry = this[ENTRY](job)
    if (!job.entry) {
      job.ignore = true
      return
    }

    if (job === this[CURRENT] && !job.piped)
      this[PIPE](job)
  }

  [ENTRYOPT] (job) {
    return {
      onwarn: (msg, data) => {
        this.warn(msg, data)
      },
      noPax: this.noPax,
      cwd: this.cwd,
      absolute: job.absolute,
      preservePaths: this.preservePaths,
      maxReadSize: this.maxReadSize,
      strict: this.strict,
      portable: this.portable,
      linkCache: this.linkCache,
      statCache: this.statCache,
      noMtime: this.noMtime,
      mtime: this.mtime
    }
  }

  [ENTRY] (job) {
    this[JOBS] += 1
    try {
      return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job))
        .on('end', () => this[JOBDONE](job))
        .on('error', er => this.emit('error', er))
    } catch (er) {
      this.emit('error', er)
    }
  }

  [ONDRAIN] () {
    if (this[CURRENT] && this[CURRENT].entry)
      this[CURRENT].entry.resume()
  }

  // like .pipe() but using super, because our write() is special
  [PIPE] (job) {
    job.piped = true

    if (job.readdir)
      job.readdir.forEach(entry => {
        const p = this.prefix ?
          job.path.slice(this.prefix.length + 1) || './'
          : job.path

        const base = p === './' ? '' : p.replace(/\/*$/, '/')
        this[ADDFSENTRY](base + entry)
      })

    const source = job.entry
    const zip = this.zip

    if (zip)
      source.on('data', chunk => {
        if (!zip.write(chunk))
          source.pause()
      })
    else
      source.on('data', chunk => {
        if (!super.write(chunk))
          source.pause()
      })
  }

  pause () {
    if (this.zip)
      this.zip.pause()
    return super.pause()
  }
})

class PackSync extends Pack {
  constructor (opt) {
    super(opt)
    this[WRITEENTRYCLASS] = WriteEntrySync
  }

  // pause/resume are no-ops in sync streams.
  pause () {}
  resume () {}

  [STAT] (job) {
    const stat = this.follow ? 'statSync' : 'lstatSync'
    this[ONSTAT](job, fs[stat](job.absolute))
  }

  [READDIR] (job, stat) {
    this[ONREADDIR](job, fs.readdirSync(job.absolute))
  }

  // gotta get it all in this tick
  [PIPE] (job) {
    const source = job.entry
    const zip = this.zip

    if (job.readdir)
      job.readdir.forEach(entry => {
        const p = this.prefix ?
          job.path.slice(this.prefix.length + 1) || './'
          : job.path

        const base = p === './' ? '' : p.replace(/\/*$/, '/')
        this[ADDFSENTRY](base + entry)
      })

    if (zip)
      source.on('data', chunk => {
        zip.write(chunk)
      })
    else
      source.on('data', chunk => {
        super[WRITE](chunk)
      })
  }
}

Pack.Sync = PackSync

module.exports = Pack


/***/ }),

/***/ "./node_modules/tar/lib/parse.js":
/*!***************************************!*\
  !*** ./node_modules/tar/lib/parse.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// this[BUFFER] is the remainder of a chunk if we're waiting for
// the full 512 bytes of a header to come in.  We will Buffer.concat()
// it to the next write(), which is a mem copy, but a small one.
//
// this[QUEUE] is a Yallist of entries that haven't been emitted
// yet this can only get filled up if the user keeps write()ing after
// a write() returns false, or does a write() with more than one entry
//
// We don't buffer chunks, we always parse them and either create an
// entry, or push it into the active entry.  The ReadEntry class knows
// to throw data away if .ignore=true
//
// Shift entry off the buffer when it emits 'end', and emit 'entry' for
// the next one in the list.
//
// At any time, we're pushing body chunks into the entry at WRITEENTRY,
// and waiting for 'end' on the entry at READENTRY
//
// ignored entries get .resume() called on them straight away

const warner = __webpack_require__(/*! ./warn-mixin.js */ "./node_modules/tar/lib/warn-mixin.js")
const path = __webpack_require__(/*! path */ "path")
const Header = __webpack_require__(/*! ./header.js */ "./node_modules/tar/lib/header.js")
const EE = __webpack_require__(/*! events */ "events")
const Yallist = __webpack_require__(/*! yallist */ "yallist")
const maxMetaEntrySize = 1024 * 1024
const Entry = __webpack_require__(/*! ./read-entry.js */ "./node_modules/tar/lib/read-entry.js")
const Pax = __webpack_require__(/*! ./pax.js */ "./node_modules/tar/lib/pax.js")
const zlib = __webpack_require__(/*! minizlib */ "./node_modules/minizlib/index.js")
const Buffer = __webpack_require__(/*! ./buffer.js */ "./node_modules/tar/lib/buffer.js")

const gzipHeader = Buffer.from([0x1f, 0x8b])
const STATE = Symbol('state')
const WRITEENTRY = Symbol('writeEntry')
const READENTRY = Symbol('readEntry')
const NEXTENTRY = Symbol('nextEntry')
const PROCESSENTRY = Symbol('processEntry')
const EX = Symbol('extendedHeader')
const GEX = Symbol('globalExtendedHeader')
const META = Symbol('meta')
const EMITMETA = Symbol('emitMeta')
const BUFFER = Symbol('buffer')
const QUEUE = Symbol('queue')
const ENDED = Symbol('ended')
const EMITTEDEND = Symbol('emittedEnd')
const EMIT = Symbol('emit')
const UNZIP = Symbol('unzip')
const CONSUMECHUNK = Symbol('consumeChunk')
const CONSUMECHUNKSUB = Symbol('consumeChunkSub')
const CONSUMEBODY = Symbol('consumeBody')
const CONSUMEMETA = Symbol('consumeMeta')
const CONSUMEHEADER = Symbol('consumeHeader')
const CONSUMING = Symbol('consuming')
const BUFFERCONCAT = Symbol('bufferConcat')
const MAYBEEND = Symbol('maybeEnd')
const WRITING = Symbol('writing')
const ABORTED = Symbol('aborted')
const DONE = Symbol('onDone')

const noop = _ => true

module.exports = warner(class Parser extends EE {
  constructor (opt) {
    opt = opt || {}
    super(opt)

    if (opt.ondone)
      this.on(DONE, opt.ondone)
    else
      this.on(DONE, _ => {
        this.emit('prefinish')
        this.emit('finish')
        this.emit('end')
        this.emit('close')
      })

    this.strict = !!opt.strict
    this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize
    this.filter = typeof opt.filter === 'function' ? opt.filter : noop

    // have to set this so that streams are ok piping into it
    this.writable = true
    this.readable = false

    this[QUEUE] = new Yallist()
    this[BUFFER] = null
    this[READENTRY] = null
    this[WRITEENTRY] = null
    this[STATE] = 'begin'
    this[META] = ''
    this[EX] = null
    this[GEX] = null
    this[ENDED] = false
    this[UNZIP] = null
    this[ABORTED] = false
    if (typeof opt.onwarn === 'function')
      this.on('warn', opt.onwarn)
    if (typeof opt.onentry === 'function')
      this.on('entry', opt.onentry)
  }

  [CONSUMEHEADER] (chunk, position) {
    let header
    try {
      header = new Header(chunk, position, this[EX], this[GEX])
    } catch (er) {
      return this.warn('invalid entry', er)
    }

    if (header.nullBlock)
      this[EMIT]('nullBlock')
    else if (!header.cksumValid)
      this.warn('invalid entry', header)
    else if (!header.path)
      this.warn('invalid: path is required', header)
    else {
      const type = header.type
      if (/^(Symbolic)?Link$/.test(type) && !header.linkpath)
        this.warn('invalid: linkpath required', header)
      else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath)
        this.warn('invalid: linkpath forbidden', header)
      else {
        const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX])

        if (entry.meta) {
          if (entry.size > this.maxMetaEntrySize) {
            entry.ignore = true
            this[EMIT]('ignoredEntry', entry)
            this[STATE] = 'ignore'
          } else if (entry.size > 0) {
            this[META] = ''
            entry.on('data', c => this[META] += c)
            this[STATE] = 'meta'
          }
        } else {

          this[EX] = null
          entry.ignore = entry.ignore || !this.filter(entry.path, entry)
          if (entry.ignore) {
            this[EMIT]('ignoredEntry', entry)
            this[STATE] = entry.remain ? 'ignore' : 'begin'
          } else {
            if (entry.remain)
              this[STATE] = 'body'
            else {
              this[STATE] = 'begin'
              entry.end()
            }

            if (!this[READENTRY]) {
              this[QUEUE].push(entry)
              this[NEXTENTRY]()
            } else
              this[QUEUE].push(entry)
          }
        }
      }
    }
  }

  [PROCESSENTRY] (entry) {
    let go = true

    if (!entry) {
      this[READENTRY] = null
      go = false
    } else if (Array.isArray(entry))
      this.emit.apply(this, entry)
    else {
      this[READENTRY] = entry
      this.emit('entry', entry)
      if (!entry.emittedEnd) {
        entry.on('end', _ => this[NEXTENTRY]())
        go = false
      }
    }

    return go
  }

  [NEXTENTRY] () {
    do {} while (this[PROCESSENTRY](this[QUEUE].shift()))

    if (!this[QUEUE].length) {
      // At this point, there's nothing in the queue, but we may have an
      // entry which is being consumed (readEntry).
      // If we don't, then we definitely can handle more data.
      // If we do, and either it's flowing, or it has never had any data
      // written to it, then it needs more.
      // The only other possibility is that it has returned false from a
      // write() call, so we wait for the next drain to continue.
      const re = this[READENTRY]
      const drainNow = !re || re.flowing || re.size === re.remain
      if (drainNow) {
        if (!this[WRITING])
          this.emit('drain')
      } else
        re.once('drain', _ => this.emit('drain'))
     }
  }

  [CONSUMEBODY] (chunk, position) {
    // write up to but no  more than writeEntry.blockRemain
    const entry = this[WRITEENTRY]
    const br = entry.blockRemain
    const c = (br >= chunk.length && position === 0) ? chunk
      : chunk.slice(position, position + br)

    entry.write(c)

    if (!entry.blockRemain) {
      this[STATE] = 'begin'
      this[WRITEENTRY] = null
      entry.end()
    }

    return c.length
  }

  [CONSUMEMETA] (chunk, position) {
    const entry = this[WRITEENTRY]
    const ret = this[CONSUMEBODY](chunk, position)

    // if we finished, then the entry is reset
    if (!this[WRITEENTRY])
      this[EMITMETA](entry)

    return ret
  }

  [EMIT] (ev, data, extra) {
    if (!this[QUEUE].length && !this[READENTRY])
      this.emit(ev, data, extra)
    else
      this[QUEUE].push([ev, data, extra])
  }

  [EMITMETA] (entry) {
    this[EMIT]('meta', this[META])
    switch (entry.type) {
      case 'ExtendedHeader':
      case 'OldExtendedHeader':
        this[EX] = Pax.parse(this[META], this[EX], false)
        break

      case 'GlobalExtendedHeader':
        this[GEX] = Pax.parse(this[META], this[GEX], true)
        break

      case 'NextFileHasLongPath':
      case 'OldGnuLongPath':
        this[EX] = this[EX] || Object.create(null)
        this[EX].path = this[META].replace(/\0.*/, '')
        break

      case 'NextFileHasLongLinkpath':
        this[EX] = this[EX] || Object.create(null)
        this[EX].linkpath = this[META].replace(/\0.*/, '')
        break

      /* istanbul ignore next */
      default: throw new Error('unknown meta: ' + entry.type)
    }
  }

  abort (msg, error) {
    this[ABORTED] = true
    this.warn(msg, error)
    this.emit('abort', error)
    this.emit('error', error)
  }

  write (chunk) {
    if (this[ABORTED])
      return

    // first write, might be gzipped
    if (this[UNZIP] === null && chunk) {
      if (this[BUFFER]) {
        chunk = Buffer.concat([this[BUFFER], chunk])
        this[BUFFER] = null
      }
      if (chunk.length < gzipHeader.length) {
        this[BUFFER] = chunk
        return true
      }
      for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {
        if (chunk[i] !== gzipHeader[i])
          this[UNZIP] = false
      }
      if (this[UNZIP] === null) {
        const ended = this[ENDED]
        this[ENDED] = false
        this[UNZIP] = new zlib.Unzip()
        this[UNZIP].on('data', chunk => this[CONSUMECHUNK](chunk))
        this[UNZIP].on('error', er =>
          this.abort(er.message, er))
        this[UNZIP].on('end', _ => {
          this[ENDED] = true
          this[CONSUMECHUNK]()
        })
        this[WRITING] = true
        const ret = this[UNZIP][ended ? 'end' : 'write' ](chunk)
        this[WRITING] = false
        return ret
      }
    }

    this[WRITING] = true
    if (this[UNZIP])
      this[UNZIP].write(chunk)
    else
      this[CONSUMECHUNK](chunk)
    this[WRITING] = false

    // return false if there's a queue, or if the current entry isn't flowing
    const ret =
      this[QUEUE].length ? false :
      this[READENTRY] ? this[READENTRY].flowing :
      true

    // if we have no queue, then that means a clogged READENTRY
    if (!ret && !this[QUEUE].length)
      this[READENTRY].once('drain', _ => this.emit('drain'))

    return ret
  }

  [BUFFERCONCAT] (c) {
    if (c && !this[ABORTED])
      this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c
  }

  [MAYBEEND] () {
    if (this[ENDED] &&
        !this[EMITTEDEND] &&
        !this[ABORTED] &&
        !this[CONSUMING]) {
      this[EMITTEDEND] = true
      const entry = this[WRITEENTRY]
      if (entry && entry.blockRemain) {
        const have = this[BUFFER] ? this[BUFFER].length : 0
        this.warn('Truncated input (needed ' + entry.blockRemain +
                  ' more bytes, only ' + have + ' available)', entry)
        if (this[BUFFER])
          entry.write(this[BUFFER])
        entry.end()
      }
      this[EMIT](DONE)
    }
  }

  [CONSUMECHUNK] (chunk) {
    if (this[CONSUMING]) {
      this[BUFFERCONCAT](chunk)
    } else if (!chunk && !this[BUFFER]) {
      this[MAYBEEND]()
    } else {
      this[CONSUMING] = true
      if (this[BUFFER]) {
        this[BUFFERCONCAT](chunk)
        const c = this[BUFFER]
        this[BUFFER] = null
        this[CONSUMECHUNKSUB](c)
      } else {
        this[CONSUMECHUNKSUB](chunk)
      }

      while (this[BUFFER] && this[BUFFER].length >= 512 && !this[ABORTED]) {
        const c = this[BUFFER]
        this[BUFFER] = null
        this[CONSUMECHUNKSUB](c)
      }
      this[CONSUMING] = false
    }

    if (!this[BUFFER] || this[ENDED])
      this[MAYBEEND]()
  }

  [CONSUMECHUNKSUB] (chunk) {
    // we know that we are in CONSUMING mode, so anything written goes into
    // the buffer.  Advance the position and put any remainder in the buffer.
    let position = 0
    let length = chunk.length
    while (position + 512 <= length && !this[ABORTED]) {
      switch (this[STATE]) {
        case 'begin':
          this[CONSUMEHEADER](chunk, position)
          position += 512
          break

        case 'ignore':
        case 'body':
          position += this[CONSUMEBODY](chunk, position)
          break

        case 'meta':
          position += this[CONSUMEMETA](chunk, position)
          break

        /* istanbul ignore next */
        default:
          throw new Error('invalid state: ' + this[STATE])
      }
    }

    if (position < length) {
      if (this[BUFFER])
        this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]])
      else
        this[BUFFER] = chunk.slice(position)
    }
  }

  end (chunk) {
    if (!this[ABORTED]) {
      if (this[UNZIP])
        this[UNZIP].end(chunk)
      else {
        this[ENDED] = true
        this.write(chunk)
      }
    }
  }
})


/***/ }),

/***/ "./node_modules/tar/lib/pax.js":
/*!*************************************!*\
  !*** ./node_modules/tar/lib/pax.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const Buffer = __webpack_require__(/*! ./buffer.js */ "./node_modules/tar/lib/buffer.js")
const Header = __webpack_require__(/*! ./header.js */ "./node_modules/tar/lib/header.js")
const path = __webpack_require__(/*! path */ "path")

class Pax {
  constructor (obj, global) {
    this.atime = obj.atime || null
    this.charset = obj.charset || null
    this.comment = obj.comment || null
    this.ctime = obj.ctime || null
    this.gid = obj.gid || null
    this.gname = obj.gname || null
    this.linkpath = obj.linkpath || null
    this.mtime = obj.mtime || null
    this.path = obj.path || null
    this.size = obj.size || null
    this.uid = obj.uid || null
    this.uname = obj.uname || null
    this.dev = obj.dev || null
    this.ino = obj.ino || null
    this.nlink = obj.nlink || null
    this.global = global || false
  }

  encode () {
    const body = this.encodeBody()
    if (body === '')
      return null

    const bodyLen = Buffer.byteLength(body)
    // round up to 512 bytes
    // add 512 for header
    const bufLen = 512 * Math.ceil(1 + bodyLen / 512)
    const buf = Buffer.allocUnsafe(bufLen)

    // 0-fill the header section, it might not hit every field
    for (let i = 0; i < 512; i++) {
      buf[i] = 0
    }

    new Header({
      // XXX split the path
      // then the path should be PaxHeader + basename, but less than 99,
      // prepend with the dirname
      path: ('PaxHeader/' + path.basename(this.path)).slice(0, 99),
      mode: this.mode || 0o644,
      uid: this.uid || null,
      gid: this.gid || null,
      size: bodyLen,
      mtime: this.mtime || null,
      type: this.global ? 'GlobalExtendedHeader' : 'ExtendedHeader',
      linkpath: '',
      uname: this.uname || '',
      gname: this.gname || '',
      devmaj: 0,
      devmin: 0,
      atime: this.atime || null,
      ctime: this.ctime || null
    }).encode(buf)

    buf.write(body, 512, bodyLen, 'utf8')

    // null pad after the body
    for (let i = bodyLen + 512; i < buf.length; i++) {
      buf[i] = 0
    }

    return buf
  }

  encodeBody () {
    return (
      this.encodeField('path') +
      this.encodeField('ctime') +
      this.encodeField('atime') +
      this.encodeField('dev') +
      this.encodeField('ino') +
      this.encodeField('nlink') +
      this.encodeField('charset') +
      this.encodeField('comment') +
      this.encodeField('gid') +
      this.encodeField('gname') +
      this.encodeField('linkpath') +
      this.encodeField('mtime') +
      this.encodeField('size') +
      this.encodeField('uid') +
      this.encodeField('uname')
    )
  }

  encodeField (field) {
    if (this[field] === null || this[field] === undefined)
      return ''
    const v = this[field] instanceof Date ? this[field].getTime() / 1000
      : this[field]
    const s = ' ' +
      (field === 'dev' || field === 'ino' || field === 'nlink'
       ? 'SCHILY.' : '') +
      field + '=' + v + '\n'
    const byteLen = Buffer.byteLength(s)
    // the digits includes the length of the digits in ascii base-10
    // so if it's 9 characters, then adding 1 for the 9 makes it 10
    // which makes it 11 chars.
    let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1
    if (byteLen + digits >= Math.pow(10, digits))
      digits += 1
    const len = digits + byteLen
    return len + s
  }
}

Pax.parse = (string, ex, g) => new Pax(merge(parseKV(string), ex), g)

const merge = (a, b) =>
  b ? Object.keys(a).reduce((s, k) => (s[k] = a[k], s), b) : a

const parseKV = string =>
  string
    .replace(/\n$/, '')
    .split('\n')
    .reduce(parseKVLine, Object.create(null))

const parseKVLine = (set, line) => {
  const n = parseInt(line, 10)

  // XXX Values with \n in them will fail this.
  // Refactor to not be a naive line-by-line parse.
  if (n !== Buffer.byteLength(line) + 1)
    return set

  line = line.substr((n + ' ').length)
  const kv = line.split('=')
  const k = kv.shift().replace(/^SCHILY\.(dev|ino|nlink)/, '$1')
  if (!k)
    return set

  const v = kv.join('=')
  set[k] = /^([A-Z]+\.)?([mac]|birth|creation)time$/.test(k)
    ?  new Date(v * 1000)
    : /^[0-9]+$/.test(v) ? +v
    : v
  return set
}

module.exports = Pax


/***/ }),

/***/ "./node_modules/tar/lib/read-entry.js":
/*!********************************************!*\
  !*** ./node_modules/tar/lib/read-entry.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const types = __webpack_require__(/*! ./types.js */ "./node_modules/tar/lib/types.js")
const MiniPass = __webpack_require__(/*! minipass */ "./node_modules/minipass/index.js")

const SLURP = Symbol('slurp')
module.exports = class ReadEntry extends MiniPass {
  constructor (header, ex, gex) {
    super()
    // read entries always start life paused.  this is to avoid the
    // situation where Minipass's auto-ending empty streams results
    // in an entry ending before we're ready for it.
    this.pause()
    this.extended = ex
    this.globalExtended = gex
    this.header = header
    this.startBlockSize = 512 * Math.ceil(header.size / 512)
    this.blockRemain = this.startBlockSize
    this.remain = header.size
    this.type = header.type
    this.meta = false
    this.ignore = false
    switch (this.type) {
      case 'File':
      case 'OldFile':
      case 'Link':
      case 'SymbolicLink':
      case 'CharacterDevice':
      case 'BlockDevice':
      case 'Directory':
      case 'FIFO':
      case 'ContiguousFile':
      case 'GNUDumpDir':
        break

      case 'NextFileHasLongLinkpath':
      case 'NextFileHasLongPath':
      case 'OldGnuLongPath':
      case 'GlobalExtendedHeader':
      case 'ExtendedHeader':
      case 'OldExtendedHeader':
        this.meta = true
        break

      // NOTE: gnutar and bsdtar treat unrecognized types as 'File'
      // it may be worth doing the same, but with a warning.
      default:
        this.ignore = true
    }

    this.path = header.path
    this.mode = header.mode
    if (this.mode)
      this.mode = this.mode & 0o7777
    this.uid = header.uid
    this.gid = header.gid
    this.uname = header.uname
    this.gname = header.gname
    this.size = header.size
    this.mtime = header.mtime
    this.atime = header.atime
    this.ctime = header.ctime
    this.linkpath = header.linkpath
    this.uname = header.uname
    this.gname = header.gname

    if (ex) this[SLURP](ex)
    if (gex) this[SLURP](gex, true)
  }

  write (data) {
    const writeLen = data.length
    if (writeLen > this.blockRemain)
      throw new Error('writing more to entry than is appropriate')

    const r = this.remain
    const br = this.blockRemain
    this.remain = Math.max(0, r - writeLen)
    this.blockRemain = Math.max(0, br - writeLen)
    if (this.ignore)
      return true

    if (r >= writeLen)
      return super.write(data)

    // r < writeLen
    return super.write(data.slice(0, r))
  }

  [SLURP] (ex, global) {
    for (let k in ex) {
      // we slurp in everything except for the path attribute in
      // a global extended header, because that's weird.
      if (ex[k] !== null && ex[k] !== undefined &&
          !(global && k === 'path'))
        this[k] = ex[k]
    }
  }
}


/***/ }),

/***/ "./node_modules/tar/lib/replace.js":
/*!*****************************************!*\
  !*** ./node_modules/tar/lib/replace.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const Buffer = __webpack_require__(/*! ./buffer.js */ "./node_modules/tar/lib/buffer.js")

// tar -r
const hlo = __webpack_require__(/*! ./high-level-opt.js */ "./node_modules/tar/lib/high-level-opt.js")
const Pack = __webpack_require__(/*! ./pack.js */ "./node_modules/tar/lib/pack.js")
const Parse = __webpack_require__(/*! ./parse.js */ "./node_modules/tar/lib/parse.js")
const fs = __webpack_require__(/*! fs */ "fs")
const fsm = __webpack_require__(/*! fs-minipass */ "./node_modules/fs-minipass/index.js")
const t = __webpack_require__(/*! ./list.js */ "./node_modules/tar/lib/list.js")
const path = __webpack_require__(/*! path */ "path")

// starting at the head of the file, read a Header
// If the checksum is invalid, that's our position to start writing
// If it is, jump forward by the specified size (round up to 512)
// and try again.
// Write the new Pack stream starting there.

const Header = __webpack_require__(/*! ./header.js */ "./node_modules/tar/lib/header.js")

const r = module.exports = (opt_, files, cb) => {
  const opt = hlo(opt_)

  if (!opt.file)
    throw new TypeError('file is required')

  if (opt.gzip)
    throw new TypeError('cannot append to compressed archives')

  if (!files || !Array.isArray(files) || !files.length)
    throw new TypeError('no files or directories specified')

  files = Array.from(files)

  return opt.sync ? replaceSync(opt, files)
    : replace(opt, files, cb)
}

const replaceSync = (opt, files) => {
  const p = new Pack.Sync(opt)

  let threw = true
  let fd
  let position

  try {
    try {
      fd = fs.openSync(opt.file, 'r+')
    } catch (er) {
      if (er.code === 'ENOENT')
        fd = fs.openSync(opt.file, 'w+')
      else
        throw er
    }

    const st = fs.fstatSync(fd)
    const headBuf = Buffer.alloc(512)

    POSITION: for (position = 0; position < st.size; position += 512) {
      for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {
        bytes = fs.readSync(
          fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos
        )

        if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b)
          throw new Error('cannot append to compressed archives')

        if (!bytes)
          break POSITION
      }

      let h = new Header(headBuf)
      if (!h.cksumValid)
        break
      let entryBlockSize = 512 * Math.ceil(h.size / 512)
      if (position + entryBlockSize + 512 > st.size)
        break
      // the 512 for the header we just parsed will be added as well
      // also jump ahead all the blocks for the body
      position += entryBlockSize
      if (opt.mtimeCache)
        opt.mtimeCache.set(h.path, h.mtime)
    }
    threw = false

    streamSync(opt, p, position, fd, files)
  } finally {
    if (threw)
      try { fs.closeSync(fd) } catch (er) {}
  }
}

const streamSync = (opt, p, position, fd, files) => {
  const stream = new fsm.WriteStreamSync(opt.file, {
    fd: fd,
    start: position
  })
  p.pipe(stream)
  addFilesSync(p, files)
}

const replace = (opt, files, cb) => {
  files = Array.from(files)
  const p = new Pack(opt)

  const getPos = (fd, size, cb_) => {
    const cb = (er, pos) => {
      if (er)
        fs.close(fd, _ => cb_(er))
      else
        cb_(null, pos)
    }

    let position = 0
    if (size === 0)
      return cb(null, 0)

    let bufPos = 0
    const headBuf = Buffer.alloc(512)
    const onread = (er, bytes) => {
      if (er)
        return cb(er)
      bufPos += bytes
      if (bufPos < 512 && bytes)
        return fs.read(
          fd, headBuf, bufPos, headBuf.length - bufPos,
          position + bufPos, onread
        )

      if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b)
        return cb(new Error('cannot append to compressed archives'))

      // truncated header
      if (bufPos < 512)
        return cb(null, position)

      const h = new Header(headBuf)
      if (!h.cksumValid)
        return cb(null, position)

      const entryBlockSize = 512 * Math.ceil(h.size / 512)
      if (position + entryBlockSize + 512 > size)
        return cb(null, position)

      position += entryBlockSize + 512
      if (position >= size)
        return cb(null, position)

      if (opt.mtimeCache)
        opt.mtimeCache.set(h.path, h.mtime)
      bufPos = 0
      fs.read(fd, headBuf, 0, 512, position, onread)
    }
    fs.read(fd, headBuf, 0, 512, position, onread)
  }

  const promise = new Promise((resolve, reject) => {
    p.on('error', reject)
    let flag = 'r+'
    const onopen = (er, fd) => {
      if (er && er.code === 'ENOENT' && flag === 'r+') {
        flag = 'w+'
        return fs.open(opt.file, flag, onopen)
      }

      if (er)
        return reject(er)

      fs.fstat(fd, (er, st) => {
        if (er)
          return reject(er)
        getPos(fd, st.size, (er, position) => {
          if (er)
            return reject(er)
          const stream = new fsm.WriteStream(opt.file, {
            fd: fd,
            start: position
          })
          p.pipe(stream)
          stream.on('error', reject)
          stream.on('close', resolve)
          addFilesAsync(p, files)
        })
      })
    }
    fs.open(opt.file, flag, onopen)
  })

  return cb ? promise.then(cb, cb) : promise
}

const addFilesSync = (p, files) => {
  files.forEach(file => {
    if (file.charAt(0) === '@')
      t({
        file: path.resolve(p.cwd, file.substr(1)),
        sync: true,
        noResume: true,
        onentry: entry => p.add(entry)
      })
    else
      p.add(file)
  })
  p.end()
}

const addFilesAsync = (p, files) => {
  while (files.length) {
    const file = files.shift()
    if (file.charAt(0) === '@')
      return t({
        file: path.resolve(p.cwd, file.substr(1)),
        noResume: true,
        onentry: entry => p.add(entry)
      }).then(_ => addFilesAsync(p, files))
    else
      p.add(file)
  }
  p.end()
}


/***/ }),

/***/ "./node_modules/tar/lib/types.js":
/*!***************************************!*\
  !*** ./node_modules/tar/lib/types.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// map types from key to human-friendly name
exports.name = new Map([
  ['0', 'File'],
  // same as File
  ['', 'OldFile'],
  ['1', 'Link'],
  ['2', 'SymbolicLink'],
  // Devices and FIFOs aren't fully supported
  // they are parsed, but skipped when unpacking
  ['3', 'CharacterDevice'],
  ['4', 'BlockDevice'],
  ['5', 'Directory'],
  ['6', 'FIFO'],
  // same as File
  ['7', 'ContiguousFile'],
  // pax headers
  ['g', 'GlobalExtendedHeader'],
  ['x', 'ExtendedHeader'],
  // vendor-specific stuff
  // skip
  ['A', 'SolarisACL'],
  // like 5, but with data, which should be skipped
  ['D', 'GNUDumpDir'],
  // metadata only, skip
  ['I', 'Inode'],
  // data = link path of next file
  ['K', 'NextFileHasLongLinkpath'],
  // data = path of next file
  ['L', 'NextFileHasLongPath'],
  // skip
  ['M', 'ContinuationFile'],
  // like L
  ['N', 'OldGnuLongPath'],
  // skip
  ['S', 'SparseFile'],
  // skip
  ['V', 'TapeVolumeHeader'],
  // like x
  ['X', 'OldExtendedHeader']
])

// map the other direction
exports.code = new Map(Array.from(exports.name).map(kv => [kv[1], kv[0]]))


/***/ }),

/***/ "./node_modules/tar/lib/unpack.js":
/*!****************************************!*\
  !*** ./node_modules/tar/lib/unpack.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const assert = __webpack_require__(/*! assert */ "assert")
const EE = __webpack_require__(/*! events */ "events").EventEmitter
const Parser = __webpack_require__(/*! ./parse.js */ "./node_modules/tar/lib/parse.js")
const fs = __webpack_require__(/*! fs */ "fs")
const fsm = __webpack_require__(/*! fs-minipass */ "./node_modules/fs-minipass/index.js")
const path = __webpack_require__(/*! path */ "path")
const mkdir = __webpack_require__(/*! ./mkdir.js */ "./node_modules/tar/lib/mkdir.js")
const mkdirSync = mkdir.sync
const wc = __webpack_require__(/*! ./winchars.js */ "./node_modules/tar/lib/winchars.js")

const ONENTRY = Symbol('onEntry')
const CHECKFS = Symbol('checkFs')
const ISREUSABLE = Symbol('isReusable')
const MAKEFS = Symbol('makeFs')
const FILE = Symbol('file')
const DIRECTORY = Symbol('directory')
const LINK = Symbol('link')
const SYMLINK = Symbol('symlink')
const HARDLINK = Symbol('hardlink')
const UNSUPPORTED = Symbol('unsupported')
const UNKNOWN = Symbol('unknown')
const CHECKPATH = Symbol('checkPath')
const MKDIR = Symbol('mkdir')
const ONERROR = Symbol('onError')
const PENDING = Symbol('pending')
const PEND = Symbol('pend')
const UNPEND = Symbol('unpend')
const ENDED = Symbol('ended')
const MAYBECLOSE = Symbol('maybeClose')
const SKIP = Symbol('skip')
const DOCHOWN = Symbol('doChown')
const UID = Symbol('uid')
const GID = Symbol('gid')
const crypto = __webpack_require__(/*! crypto */ "crypto")

// Unlinks on Windows are not atomic.
//
// This means that if you have a file entry, followed by another
// file entry with an identical name, and you cannot re-use the file
// (because it's a hardlink, or because unlink:true is set, or it's
// Windows, which does not have useful nlink values), then the unlink
// will be committed to the disk AFTER the new file has been written
// over the old one, deleting the new file.
//
// To work around this, on Windows systems, we rename the file and then
// delete the renamed file.  It's a sloppy kludge, but frankly, I do not
// know of a better way to do this, given windows' non-atomic unlink
// semantics.
//
// See: https://github.com/npm/node-tar/issues/183
/* istanbul ignore next */
const unlinkFile = (path, cb) => {
  if (process.platform !== 'win32')
    return fs.unlink(path, cb)

  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')
  fs.rename(path, name, er => {
    if (er)
      return cb(er)
    fs.unlink(name, cb)
  })
}

/* istanbul ignore next */
const unlinkFileSync = path => {
  if (process.platform !== 'win32')
    return fs.unlinkSync(path)

  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')
  fs.renameSync(path, name)
  fs.unlinkSync(name)
}

// this.gid, entry.gid, this.processUid
const uint32 = (a, b, c) =>
  a === a >>> 0 ? a
  : b === b >>> 0 ? b
  : c

class Unpack extends Parser {
  constructor (opt) {
    if (!opt)
      opt = {}

    opt.ondone = _ => {
      this[ENDED] = true
      this[MAYBECLOSE]()
    }

    super(opt)

    this.transform = typeof opt.transform === 'function' ? opt.transform : null

    this.writable = true
    this.readable = false

    this[PENDING] = 0
    this[ENDED] = false

    this.dirCache = opt.dirCache || new Map()

    if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {
      // need both or neither
      if (typeof opt.uid !== 'number' || typeof opt.gid !== 'number')
        throw new TypeError('cannot set owner without number uid and gid')
      if (opt.preserveOwner)
        throw new TypeError(
          'cannot preserve owner in archive and also set owner explicitly')
      this.uid = opt.uid
      this.gid = opt.gid
      this.setOwner = true
    } else {
      this.uid = null
      this.gid = null
      this.setOwner = false
    }

    // default true for root
    if (opt.preserveOwner === undefined && typeof opt.uid !== 'number')
      this.preserveOwner = process.getuid && process.getuid() === 0
    else
      this.preserveOwner = !!opt.preserveOwner

    this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ?
      process.getuid() : null
    this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ?
      process.getgid() : null

    // mostly just for testing, but useful in some cases.
    // Forcibly trigger a chown on every entry, no matter what
    this.forceChown = opt.forceChown === true

    // turn ><?| in filenames into 0xf000-higher encoded forms
    this.win32 = !!opt.win32 || process.platform === 'win32'

    // do not unpack over files that are newer than what's in the archive
    this.newer = !!opt.newer

    // do not unpack over ANY files
    this.keep = !!opt.keep

    // do not set mtime/atime of extracted entries
    this.noMtime = !!opt.noMtime

    // allow .., absolute path entries, and unpacking through symlinks
    // without this, warn and skip .., relativize absolutes, and error
    // on symlinks in extraction path
    this.preservePaths = !!opt.preservePaths

    // unlink files and links before writing. This breaks existing hard
    // links, and removes symlink directories rather than erroring
    this.unlink = !!opt.unlink

    this.cwd = path.resolve(opt.cwd || process.cwd())
    this.strip = +opt.strip || 0
    this.processUmask = process.umask()
    this.umask = typeof opt.umask === 'number' ? opt.umask : this.processUmask
    // default mode for dirs created as parents
    this.dmode = opt.dmode || (0o0777 & (~this.umask))
    this.fmode = opt.fmode || (0o0666 & (~this.umask))
    this.on('entry', entry => this[ONENTRY](entry))
  }

  [MAYBECLOSE] () {
    if (this[ENDED] && this[PENDING] === 0) {
      this.emit('prefinish')
      this.emit('finish')
      this.emit('end')
      this.emit('close')
    }
  }

  [CHECKPATH] (entry) {
    if (this.strip) {
      const parts = entry.path.split(/\/|\\/)
      if (parts.length < this.strip)
        return false
      entry.path = parts.slice(this.strip).join('/')

      if (entry.type === 'Link') {
        const linkparts = entry.linkpath.split(/\/|\\/)
        if (linkparts.length >= this.strip)
          entry.linkpath = linkparts.slice(this.strip).join('/')
      }
    }

    if (!this.preservePaths) {
      const p = entry.path
      if (p.match(/(^|\/|\\)\.\.(\\|\/|$)/)) {
        this.warn('path contains \'..\'', p)
        return false
      }

      // absolutes on posix are also absolutes on win32
      // so we only need to test this one to get both
      if (path.win32.isAbsolute(p)) {
        const parsed = path.win32.parse(p)
        this.warn('stripping ' + parsed.root + ' from absolute path', p)
        entry.path = p.substr(parsed.root.length)
      }
    }

    // only encode : chars that aren't drive letter indicators
    if (this.win32) {
      const parsed = path.win32.parse(entry.path)
      entry.path = parsed.root === '' ? wc.encode(entry.path)
        : parsed.root + wc.encode(entry.path.substr(parsed.root.length))
    }

    if (path.isAbsolute(entry.path))
      entry.absolute = entry.path
    else
      entry.absolute = path.resolve(this.cwd, entry.path)

    return true
  }

  [ONENTRY] (entry) {
    if (!this[CHECKPATH](entry))
      return entry.resume()

    assert.equal(typeof entry.absolute, 'string')

    switch (entry.type) {
      case 'Directory':
      case 'GNUDumpDir':
        if (entry.mode)
          entry.mode = entry.mode | 0o700

      case 'File':
      case 'OldFile':
      case 'ContiguousFile':
      case 'Link':
      case 'SymbolicLink':
        return this[CHECKFS](entry)

      case 'CharacterDevice':
      case 'BlockDevice':
      case 'FIFO':
        return this[UNSUPPORTED](entry)
    }
  }

  [ONERROR] (er, entry) {
    // Cwd has to exist, or else nothing works. That's serious.
    // Other errors are warnings, which raise the error in strict
    // mode, but otherwise continue on.
    if (er.name === 'CwdError')
      this.emit('error', er)
    else {
      this.warn(er.message, er)
      this[UNPEND]()
      entry.resume()
    }
  }

  [MKDIR] (dir, mode, cb) {
    mkdir(dir, {
      uid: this.uid,
      gid: this.gid,
      processUid: this.processUid,
      processGid: this.processGid,
      umask: this.processUmask,
      preserve: this.preservePaths,
      unlink: this.unlink,
      cache: this.dirCache,
      cwd: this.cwd,
      mode: mode
    }, cb)
  }

  [DOCHOWN] (entry) {
    // in preserve owner mode, chown if the entry doesn't match process
    // in set owner mode, chown if setting doesn't match process
    return this.forceChown ||
      this.preserveOwner &&
      ( typeof entry.uid === 'number' && entry.uid !== this.processUid ||
        typeof entry.gid === 'number' && entry.gid !== this.processGid )
      ||
      ( typeof this.uid === 'number' && this.uid !== this.processUid ||
        typeof this.gid === 'number' && this.gid !== this.processGid )
  }

  [UID] (entry) {
    return uint32(this.uid, entry.uid, this.processUid)
  }

  [GID] (entry) {
    return uint32(this.gid, entry.gid, this.processGid)
  }

  [FILE] (entry) {
    const mode = entry.mode & 0o7777 || this.fmode
    const stream = new fsm.WriteStream(entry.absolute, {
      mode: mode,
      autoClose: false
    })
    stream.on('error', er => this[ONERROR](er, entry))

    let actions = 1
    const done = er => {
      if (er)
        return this[ONERROR](er, entry)

      if (--actions === 0)
        fs.close(stream.fd, _ => this[UNPEND]())
    }

    stream.on('finish', _ => {
      // if futimes fails, try utimes
      // if utimes fails, fail with the original error
      // same for fchown/chown
      const abs = entry.absolute
      const fd = stream.fd

      if (entry.mtime && !this.noMtime) {
        actions++
        const atime = entry.atime || new Date()
        const mtime = entry.mtime
        fs.futimes(fd, atime, mtime, er =>
          er ? fs.utimes(abs, atime, mtime, er2 => done(er2 && er))
          : done())
      }

      if (this[DOCHOWN](entry)) {
        actions++
        const uid = this[UID](entry)
        const gid = this[GID](entry)
        fs.fchown(fd, uid, gid, er =>
          er ? fs.chown(abs, uid, gid, er2 => done(er2 && er))
          : done())
      }

      done()
    })

    const tx = this.transform ? this.transform(entry) || entry : entry
    if (tx !== entry) {
      tx.on('error', er => this[ONERROR](er, entry))
      entry.pipe(tx)
    }
    tx.pipe(stream)
  }

  [DIRECTORY] (entry) {
    const mode = entry.mode & 0o7777 || this.dmode
    this[MKDIR](entry.absolute, mode, er => {
      if (er)
        return this[ONERROR](er, entry)

      let actions = 1
      const done = _ => {
        if (--actions === 0) {
          this[UNPEND]()
          entry.resume()
        }
      }

      if (entry.mtime && !this.noMtime) {
        actions++
        fs.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done)
      }

      if (this[DOCHOWN](entry)) {
        actions++
        fs.chown(entry.absolute, this[UID](entry), this[GID](entry), done)
      }

      done()
    })
  }

  [UNSUPPORTED] (entry) {
    this.warn('unsupported entry type: ' + entry.type, entry)
    entry.resume()
  }

  [SYMLINK] (entry) {
    this[LINK](entry, entry.linkpath, 'symlink')
  }

  [HARDLINK] (entry) {
    this[LINK](entry, path.resolve(this.cwd, entry.linkpath), 'link')
  }

  [PEND] () {
    this[PENDING]++
  }

  [UNPEND] () {
    this[PENDING]--
    this[MAYBECLOSE]()
  }

  [SKIP] (entry) {
    this[UNPEND]()
    entry.resume()
  }

  // Check if we can reuse an existing filesystem entry safely and
  // overwrite it, rather than unlinking and recreating
  // Windows doesn't report a useful nlink, so we just never reuse entries
  [ISREUSABLE] (entry, st) {
    return entry.type === 'File' &&
      !this.unlink &&
      st.isFile() &&
      st.nlink <= 1 &&
      process.platform !== 'win32'
  }

  // check if a thing is there, and if so, try to clobber it
  [CHECKFS] (entry) {
    this[PEND]()
    this[MKDIR](path.dirname(entry.absolute), this.dmode, er => {
      if (er)
        return this[ONERROR](er, entry)
      fs.lstat(entry.absolute, (er, st) => {
        if (st && (this.keep || this.newer && st.mtime > entry.mtime))
          this[SKIP](entry)
        else if (er || this[ISREUSABLE](entry, st))
          this[MAKEFS](null, entry)
        else if (st.isDirectory()) {
          if (entry.type === 'Directory') {
            if (!entry.mode || (st.mode & 0o7777) === entry.mode)
              this[MAKEFS](null, entry)
            else
              fs.chmod(entry.absolute, entry.mode, er => this[MAKEFS](er, entry))
          } else
            fs.rmdir(entry.absolute, er => this[MAKEFS](er, entry))
        } else
          unlinkFile(entry.absolute, er => this[MAKEFS](er, entry))
      })
    })
  }

  [MAKEFS] (er, entry) {
    if (er)
      return this[ONERROR](er, entry)

    switch (entry.type) {
      case 'File':
      case 'OldFile':
      case 'ContiguousFile':
        return this[FILE](entry)

      case 'Link':
        return this[HARDLINK](entry)

      case 'SymbolicLink':
        return this[SYMLINK](entry)

      case 'Directory':
      case 'GNUDumpDir':
        return this[DIRECTORY](entry)
    }
  }

  [LINK] (entry, linkpath, link) {
    // XXX: get the type ('file' or 'dir') for windows
    fs[link](linkpath, entry.absolute, er => {
      if (er)
        return this[ONERROR](er, entry)
      this[UNPEND]()
      entry.resume()
    })
  }
}

class UnpackSync extends Unpack {
  constructor (opt) {
    super(opt)
  }

  [CHECKFS] (entry) {
    const er = this[MKDIR](path.dirname(entry.absolute), this.dmode)
    if (er)
      return this[ONERROR](er, entry)
    try {
      const st = fs.lstatSync(entry.absolute)
      if (this.keep || this.newer && st.mtime > entry.mtime)
        return this[SKIP](entry)
      else if (this[ISREUSABLE](entry, st))
        return this[MAKEFS](null, entry)
      else {
        try {
          if (st.isDirectory()) {
            if (entry.type === 'Directory') {
              if (entry.mode && (st.mode & 0o7777) !== entry.mode)
                fs.chmodSync(entry.absolute, entry.mode)
            } else
              fs.rmdirSync(entry.absolute)
          } else
            unlinkFileSync(entry.absolute)
          return this[MAKEFS](null, entry)
        } catch (er) {
          return this[ONERROR](er, entry)
        }
      }
    } catch (er) {
      return this[MAKEFS](null, entry)
    }
  }

  [FILE] (entry) {
    const mode = entry.mode & 0o7777 || this.fmode

    const oner = er => {
      try { fs.closeSync(fd) } catch (_) {}
      if (er)
        this[ONERROR](er, entry)
    }

    let stream
    let fd
    try {
      fd = fs.openSync(entry.absolute, 'w', mode)
    } catch (er) {
      return oner(er)
    }
    const tx = this.transform ? this.transform(entry) || entry : entry
    if (tx !== entry) {
      tx.on('error', er => this[ONERROR](er, entry))
      entry.pipe(tx)
    }

    tx.on('data', chunk => {
      try {
        fs.writeSync(fd, chunk, 0, chunk.length)
      } catch (er) {
        oner(er)
      }
    })

    tx.on('end', _ => {
      let er = null
      // try both, falling futimes back to utimes
      // if either fails, handle the first error
      if (entry.mtime && !this.noMtime) {
        const atime = entry.atime || new Date()
        const mtime = entry.mtime
        try {
          fs.futimesSync(fd, atime, mtime)
        } catch (futimeser) {
          try {
            fs.utimesSync(entry.absolute, atime, mtime)
          } catch (utimeser) {
            er = futimeser
          }
        }
      }

      if (this[DOCHOWN](entry)) {
        const uid = this[UID](entry)
        const gid = this[GID](entry)

        try {
          fs.fchownSync(fd, uid, gid)
        } catch (fchowner) {
          try {
            fs.chownSync(entry.absolute, uid, gid)
          } catch (chowner) {
            er = er || fchowner
          }
        }
      }

      oner(er)
    })
  }

  [DIRECTORY] (entry) {
    const mode = entry.mode & 0o7777 || this.dmode
    const er = this[MKDIR](entry.absolute, mode)
    if (er)
      return this[ONERROR](er, entry)
    if (entry.mtime && !this.noMtime) {
      try {
        fs.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime)
      } catch (er) {}
    }
    if (this[DOCHOWN](entry)) {
      try {
        fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry))
      } catch (er) {}
    }
    entry.resume()
  }

  [MKDIR] (dir, mode) {
    try {
      return mkdir.sync(dir, {
        uid: this.uid,
        gid: this.gid,
        processUid: this.processUid,
        processGid: this.processGid,
        umask: this.processUmask,
        preserve: this.preservePaths,
        unlink: this.unlink,
        cache: this.dirCache,
        cwd: this.cwd,
        mode: mode
      })
    } catch (er) {
      return er
    }
  }

  [LINK] (entry, linkpath, link) {
    try {
      fs[link + 'Sync'](linkpath, entry.absolute)
      entry.resume()
    } catch (er) {
      return this[ONERROR](er, entry)
    }
  }
}

Unpack.Sync = UnpackSync
module.exports = Unpack


/***/ }),

/***/ "./node_modules/tar/lib/update.js":
/*!****************************************!*\
  !*** ./node_modules/tar/lib/update.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// tar -u

const hlo = __webpack_require__(/*! ./high-level-opt.js */ "./node_modules/tar/lib/high-level-opt.js")
const r = __webpack_require__(/*! ./replace.js */ "./node_modules/tar/lib/replace.js")
// just call tar.r with the filter and mtimeCache

const u = module.exports = (opt_, files, cb) => {
  const opt = hlo(opt_)

  if (!opt.file)
    throw new TypeError('file is required')

  if (opt.gzip)
    throw new TypeError('cannot append to compressed archives')

  if (!files || !Array.isArray(files) || !files.length)
    throw new TypeError('no files or directories specified')

  files = Array.from(files)

  mtimeFilter(opt)
  return r(opt, files, cb)
}

const mtimeFilter = opt => {
  const filter = opt.filter

  if (!opt.mtimeCache)
    opt.mtimeCache = new Map()

  opt.filter = filter ? (path, stat) =>
    filter(path, stat) && !(opt.mtimeCache.get(path) > stat.mtime)
    : (path, stat) => !(opt.mtimeCache.get(path) > stat.mtime)
}


/***/ }),

/***/ "./node_modules/tar/lib/warn-mixin.js":
/*!********************************************!*\
  !*** ./node_modules/tar/lib/warn-mixin.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Base => class extends Base {
  warn (msg, data) {
    if (!this.strict)
      this.emit('warn', msg, data)
    else if (data instanceof Error)
      this.emit('error', data)
    else {
      const er = new Error(msg)
      er.data = data
      this.emit('error', er)
    }
  }
}


/***/ }),

/***/ "./node_modules/tar/lib/winchars.js":
/*!******************************************!*\
  !*** ./node_modules/tar/lib/winchars.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// When writing files on Windows, translate the characters to their
// 0xf000 higher-encoded versions.

const raw = [
  '|',
  '<',
  '>',
  '?',
  ':'
]

const win = raw.map(char =>
  String.fromCharCode(0xf000 + char.charCodeAt(0)))

const toWin = new Map(raw.map((char, i) => [char, win[i]]))
const toRaw = new Map(win.map((char, i) => [char, raw[i]]))

module.exports = {
  encode: s => raw.reduce((s, c) => s.split(c).join(toWin.get(c)), s),
  decode: s => win.reduce((s, c) => s.split(c).join(toRaw.get(c)), s)
}


/***/ }),

/***/ "./node_modules/tar/lib/write-entry.js":
/*!*********************************************!*\
  !*** ./node_modules/tar/lib/write-entry.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const Buffer = __webpack_require__(/*! ./buffer.js */ "./node_modules/tar/lib/buffer.js")
const MiniPass = __webpack_require__(/*! minipass */ "./node_modules/minipass/index.js")
const Pax = __webpack_require__(/*! ./pax.js */ "./node_modules/tar/lib/pax.js")
const Header = __webpack_require__(/*! ./header.js */ "./node_modules/tar/lib/header.js")
const ReadEntry = __webpack_require__(/*! ./read-entry.js */ "./node_modules/tar/lib/read-entry.js")
const fs = __webpack_require__(/*! fs */ "fs")
const path = __webpack_require__(/*! path */ "path")

const types = __webpack_require__(/*! ./types.js */ "./node_modules/tar/lib/types.js")
const maxReadSize = 16 * 1024 * 1024
const PROCESS = Symbol('process')
const FILE = Symbol('file')
const DIRECTORY = Symbol('directory')
const SYMLINK = Symbol('symlink')
const HARDLINK = Symbol('hardlink')
const HEADER = Symbol('header')
const READ = Symbol('read')
const LSTAT = Symbol('lstat')
const ONLSTAT = Symbol('onlstat')
const ONREAD = Symbol('onread')
const ONREADLINK = Symbol('onreadlink')
const OPENFILE = Symbol('openfile')
const ONOPENFILE = Symbol('onopenfile')
const CLOSE = Symbol('close')
const MODE = Symbol('mode')
const warner = __webpack_require__(/*! ./warn-mixin.js */ "./node_modules/tar/lib/warn-mixin.js")
const winchars = __webpack_require__(/*! ./winchars.js */ "./node_modules/tar/lib/winchars.js")

const modeFix = __webpack_require__(/*! ./mode-fix.js */ "./node_modules/tar/lib/mode-fix.js")

const WriteEntry = warner(class WriteEntry extends MiniPass {
  constructor (p, opt) {
    opt = opt || {}
    super(opt)
    if (typeof p !== 'string')
      throw new TypeError('path is required')
    this.path = p
    // suppress atime, ctime, uid, gid, uname, gname
    this.portable = !!opt.portable
    // until node has builtin pwnam functions, this'll have to do
    this.myuid = process.getuid && process.getuid()
    this.myuser = process.env.USER || ''
    this.maxReadSize = opt.maxReadSize || maxReadSize
    this.linkCache = opt.linkCache || new Map()
    this.statCache = opt.statCache || new Map()
    this.preservePaths = !!opt.preservePaths
    this.cwd = opt.cwd || process.cwd()
    this.strict = !!opt.strict
    this.noPax = !!opt.noPax
    this.noMtime = !!opt.noMtime
    this.mtime = opt.mtime || null

    if (typeof opt.onwarn === 'function')
      this.on('warn', opt.onwarn)

    if (!this.preservePaths && path.win32.isAbsolute(p)) {
      // absolutes on posix are also absolutes on win32
      // so we only need to test this one to get both
      const parsed = path.win32.parse(p)
      this.warn('stripping ' + parsed.root + ' from absolute path', p)
      this.path = p.substr(parsed.root.length)
    }

    this.win32 = !!opt.win32 || process.platform === 'win32'
    if (this.win32) {
      this.path = winchars.decode(this.path.replace(/\\/g, '/'))
      p = p.replace(/\\/g, '/')
    }

    this.absolute = opt.absolute || path.resolve(this.cwd, p)

    if (this.path === '')
      this.path = './'

    if (this.statCache.has(this.absolute))
      this[ONLSTAT](this.statCache.get(this.absolute))
    else
      this[LSTAT]()
  }

  [LSTAT] () {
    fs.lstat(this.absolute, (er, stat) => {
      if (er)
        return this.emit('error', er)
      this[ONLSTAT](stat)
    })
  }

  [ONLSTAT] (stat) {
    this.statCache.set(this.absolute, stat)
    this.stat = stat
    if (!stat.isFile())
      stat.size = 0
    this.type = getType(stat)
    this.emit('stat', stat)
    this[PROCESS]()
  }

  [PROCESS] () {
    switch (this.type) {
      case 'File': return this[FILE]()
      case 'Directory': return this[DIRECTORY]()
      case 'SymbolicLink': return this[SYMLINK]()
      // unsupported types are ignored.
      default: return this.end()
    }
  }

  [MODE] (mode) {
    return modeFix(mode, this.type === 'Directory')
  }

  [HEADER] () {
    if (this.type === 'Directory' && this.portable)
      this.noMtime = true

    this.header = new Header({
      path: this.path,
      linkpath: this.linkpath,
      // only the permissions and setuid/setgid/sticky bitflags
      // not the higher-order bits that specify file type
      mode: this[MODE](this.stat.mode),
      uid: this.portable ? null : this.stat.uid,
      gid: this.portable ? null : this.stat.gid,
      size: this.stat.size,
      mtime: this.noMtime ? null : this.mtime || this.stat.mtime,
      type: this.type,
      uname: this.portable ? null :
        this.stat.uid === this.myuid ? this.myuser : '',
      atime: this.portable ? null : this.stat.atime,
      ctime: this.portable ? null : this.stat.ctime
    })

    if (this.header.encode() && !this.noPax)
      this.write(new Pax({
        atime: this.portable ? null : this.header.atime,
        ctime: this.portable ? null : this.header.ctime,
        gid: this.portable ? null : this.header.gid,
        mtime: this.noMtime ? null : this.mtime || this.header.mtime,
        path: this.path,
        linkpath: this.linkpath,
        size: this.header.size,
        uid: this.portable ? null : this.header.uid,
        uname: this.portable ? null : this.header.uname,
        dev: this.portable ? null : this.stat.dev,
        ino: this.portable ? null : this.stat.ino,
        nlink: this.portable ? null : this.stat.nlink
      }).encode())
    this.write(this.header.block)
  }

  [DIRECTORY] () {
    if (this.path.substr(-1) !== '/')
      this.path += '/'
    this.stat.size = 0
    this[HEADER]()
    this.end()
  }

  [SYMLINK] () {
    fs.readlink(this.absolute, (er, linkpath) => {
      if (er)
        return this.emit('error', er)
      this[ONREADLINK](linkpath)
    })
  }

  [ONREADLINK] (linkpath) {
    this.linkpath = linkpath
    this[HEADER]()
    this.end()
  }

  [HARDLINK] (linkpath) {
    this.type = 'Link'
    this.linkpath = path.relative(this.cwd, linkpath)
    this.stat.size = 0
    this[HEADER]()
    this.end()
  }

  [FILE] () {
    if (this.stat.nlink > 1) {
      const linkKey = this.stat.dev + ':' + this.stat.ino
      if (this.linkCache.has(linkKey)) {
        const linkpath = this.linkCache.get(linkKey)
        if (linkpath.indexOf(this.cwd) === 0)
          return this[HARDLINK](linkpath)
      }
      this.linkCache.set(linkKey, this.absolute)
    }

    this[HEADER]()
    if (this.stat.size === 0)
      return this.end()

    this[OPENFILE]()
  }

  [OPENFILE] () {
    fs.open(this.absolute, 'r', (er, fd) => {
      if (er)
        return this.emit('error', er)
      this[ONOPENFILE](fd)
    })
  }

  [ONOPENFILE] (fd) {
    const blockLen = 512 * Math.ceil(this.stat.size / 512)
    const bufLen = Math.min(blockLen, this.maxReadSize)
    const buf = Buffer.allocUnsafe(bufLen)
    this[READ](fd, buf, 0, buf.length, 0, this.stat.size, blockLen)
  }

  [READ] (fd, buf, offset, length, pos, remain, blockRemain) {
    fs.read(fd, buf, offset, length, pos, (er, bytesRead) => {
      if (er)
        return this[CLOSE](fd, _ => this.emit('error', er))
      this[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead)
    })
  }

  [CLOSE] (fd, cb) {
    fs.close(fd, cb)
  }

  [ONREAD] (fd, buf, offset, length, pos, remain, blockRemain, bytesRead) {
    if (bytesRead <= 0 && remain > 0) {
      const er = new Error('encountered unexpected EOF')
      er.path = this.absolute
      er.syscall = 'read'
      er.code = 'EOF'
      this[CLOSE](fd, _ => _)
      return this.emit('error', er)
    }

    if (bytesRead > remain) {
      const er = new Error('did not encounter expected EOF')
      er.path = this.absolute
      er.syscall = 'read'
      er.code = 'EOF'
      this[CLOSE](fd, _ => _)
      return this.emit('error', er)
    }

    // null out the rest of the buffer, if we could fit the block padding
    if (bytesRead === remain) {
      for (let i = bytesRead; i < length && bytesRead < blockRemain; i++) {
        buf[i + offset] = 0
        bytesRead ++
        remain ++
      }
    }

    const writeBuf = offset === 0 && bytesRead === buf.length ?
      buf : buf.slice(offset, offset + bytesRead)
    remain -= bytesRead
    blockRemain -= bytesRead
    pos += bytesRead
    offset += bytesRead

    this.write(writeBuf)

    if (!remain) {
      if (blockRemain)
        this.write(Buffer.alloc(blockRemain))
      this.end()
      this[CLOSE](fd, _ => _)
      return
    }

    if (offset >= length) {
      buf = Buffer.allocUnsafe(length)
      offset = 0
    }
    length = buf.length - offset
    this[READ](fd, buf, offset, length, pos, remain, blockRemain)
  }
})

class WriteEntrySync extends WriteEntry {
  constructor (path, opt) {
    super(path, opt)
  }

  [LSTAT] () {
    this[ONLSTAT](fs.lstatSync(this.absolute))
  }

  [SYMLINK] () {
    this[ONREADLINK](fs.readlinkSync(this.absolute))
  }

  [OPENFILE] () {
    this[ONOPENFILE](fs.openSync(this.absolute, 'r'))
  }

  [READ] (fd, buf, offset, length, pos, remain, blockRemain) {
    let threw = true
    try {
      const bytesRead = fs.readSync(fd, buf, offset, length, pos)
      this[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead)
      threw = false
    } finally {
      if (threw)
        try { this[CLOSE](fd) } catch (er) {}
    }
  }

  [CLOSE] (fd) {
    fs.closeSync(fd)
  }
}

const WriteEntryTar = warner(class WriteEntryTar extends MiniPass {
  constructor (readEntry, opt) {
    opt = opt || {}
    super(opt)
    this.preservePaths = !!opt.preservePaths
    this.portable = !!opt.portable
    this.strict = !!opt.strict
    this.noPax = !!opt.noPax
    this.noMtime = !!opt.noMtime

    this.readEntry = readEntry
    this.type = readEntry.type
    if (this.type === 'Directory' && this.portable)
      this.noMtime = true

    this.path = readEntry.path
    this.mode = this[MODE](readEntry.mode)
    this.uid = this.portable ? null : readEntry.uid
    this.gid = this.portable ? null : readEntry.gid
    this.uname = this.portable ? null : readEntry.uname
    this.gname = this.portable ? null : readEntry.gname
    this.size = readEntry.size
    this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime
    this.atime = this.portable ? null : readEntry.atime
    this.ctime = this.portable ? null : readEntry.ctime
    this.linkpath = readEntry.linkpath

    if (typeof opt.onwarn === 'function')
      this.on('warn', opt.onwarn)

    if (path.isAbsolute(this.path) && !this.preservePaths) {
      const parsed = path.parse(this.path)
      this.warn(
        'stripping ' + parsed.root + ' from absolute path',
        this.path
      )
      this.path = this.path.substr(parsed.root.length)
    }

    this.remain = readEntry.size
    this.blockRemain = readEntry.startBlockSize

    this.header = new Header({
      path: this.path,
      linkpath: this.linkpath,
      // only the permissions and setuid/setgid/sticky bitflags
      // not the higher-order bits that specify file type
      mode: this.mode,
      uid: this.portable ? null : this.uid,
      gid: this.portable ? null : this.gid,
      size: this.size,
      mtime: this.noMtime ? null : this.mtime,
      type: this.type,
      uname: this.portable ? null : this.uname,
      atime: this.portable ? null : this.atime,
      ctime: this.portable ? null : this.ctime
    })

    if (this.header.encode() && !this.noPax)
      super.write(new Pax({
        atime: this.portable ? null : this.atime,
        ctime: this.portable ? null : this.ctime,
        gid: this.portable ? null : this.gid,
        mtime: this.noMtime ? null : this.mtime,
        path: this.path,
        linkpath: this.linkpath,
        size: this.size,
        uid: this.portable ? null : this.uid,
        uname: this.portable ? null : this.uname,
        dev: this.portable ? null : this.readEntry.dev,
        ino: this.portable ? null : this.readEntry.ino,
        nlink: this.portable ? null : this.readEntry.nlink
      }).encode())

    super.write(this.header.block)
    readEntry.pipe(this)
  }

  [MODE] (mode) {
    return modeFix(mode, this.type === 'Directory')
  }

  write (data) {
    const writeLen = data.length
    if (writeLen > this.blockRemain)
      throw new Error('writing more to entry than is appropriate')
    this.blockRemain -= writeLen
    return super.write(data)
  }

  end () {
    if (this.blockRemain)
      this.write(Buffer.alloc(this.blockRemain))
    return super.end()
  }
})

WriteEntry.Sync = WriteEntrySync
WriteEntry.Tar = WriteEntryTar

const getType = stat =>
  stat.isFile() ? 'File'
  : stat.isDirectory() ? 'Directory'
  : stat.isSymbolicLink() ? 'SymbolicLink'
  : 'Unsupported'

module.exports = WriteEntry


/***/ }),

/***/ "./node_modules/webpack/hot/log-apply-result.js":
/*!*****************************************!*\
  !*** (webpack)/hot/log-apply-result.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
module.exports = function(updatedModules, renewedModules) {
	var unacceptedModules = updatedModules.filter(function(moduleId) {
		return renewedModules && renewedModules.indexOf(moduleId) < 0;
	});
	var log = __webpack_require__(/*! ./log */ "./node_modules/webpack/hot/log.js");

	if (unacceptedModules.length > 0) {
		log(
			"warning",
			"[HMR] The following modules couldn't be hot updated: (They would need a full reload!)"
		);
		unacceptedModules.forEach(function(moduleId) {
			log("warning", "[HMR]  - " + moduleId);
		});
	}

	if (!renewedModules || renewedModules.length === 0) {
		log("info", "[HMR] Nothing hot updated.");
	} else {
		log("info", "[HMR] Updated modules:");
		renewedModules.forEach(function(moduleId) {
			if (typeof moduleId === "string" && moduleId.indexOf("!") !== -1) {
				var parts = moduleId.split("!");
				log.groupCollapsed("info", "[HMR]  - " + parts.pop());
				log("info", "[HMR]  - " + moduleId);
				log.groupEnd("info");
			} else {
				log("info", "[HMR]  - " + moduleId);
			}
		});
		var numberIds = renewedModules.every(function(moduleId) {
			return typeof moduleId === "number";
		});
		if (numberIds)
			log(
				"info",
				"[HMR] Consider using the NamedModulesPlugin for module names."
			);
	}
};


/***/ }),

/***/ "./node_modules/webpack/hot/log.js":
/*!****************************!*\
  !*** (webpack)/hot/log.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

var logLevel = "info";

function dummy() {}

function shouldLog(level) {
	var shouldLog =
		(logLevel === "info" && level === "info") ||
		(["info", "warning"].indexOf(logLevel) >= 0 && level === "warning") ||
		(["info", "warning", "error"].indexOf(logLevel) >= 0 && level === "error");
	return shouldLog;
}

function logGroup(logFn) {
	return function(level, msg) {
		if (shouldLog(level)) {
			logFn(msg);
		}
	};
}

module.exports = function(level, msg) {
	if (shouldLog(level)) {
		if (level === "info") {
			console.log(msg);
		} else if (level === "warning") {
			console.warn(msg);
		} else if (level === "error") {
			console.error(msg);
		}
	}
};

/* eslint-disable node/no-unsupported-features/node-builtins */
var group = console.group || dummy;
var groupCollapsed = console.groupCollapsed || dummy;
var groupEnd = console.groupEnd || dummy;
/* eslint-enable node/no-unsupported-features/node-builtins */

module.exports.group = logGroup(group);

module.exports.groupCollapsed = logGroup(groupCollapsed);

module.exports.groupEnd = logGroup(groupEnd);

module.exports.setLogLevel = function(level) {
	logLevel = level;
};

module.exports.formatError = function(err) {
	var message = err.message;
	var stack = err.stack;
	if (!stack) {
		return message;
	} else if (stack.indexOf(message) < 0) {
		return message + "\n" + stack;
	} else {
		return stack;
	}
};


/***/ }),

/***/ "./node_modules/webpack/hot/poll.js?1000":
/*!**********************************!*\
  !*** (webpack)/hot/poll.js?1000 ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(__resourceQuery) {/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
/*globals __resourceQuery */
if (true) {
	var hotPollInterval = +__resourceQuery.substr(1) || 10 * 60 * 1000;
	var log = __webpack_require__(/*! ./log */ "./node_modules/webpack/hot/log.js");

	var checkForUpdate = function checkForUpdate(fromUpdate) {
		if (module.hot.status() === "idle") {
			module.hot
				.check(true)
				.then(function(updatedModules) {
					if (!updatedModules) {
						if (fromUpdate) log("info", "[HMR] Update applied.");
						return;
					}
					__webpack_require__(/*! ./log-apply-result */ "./node_modules/webpack/hot/log-apply-result.js")(updatedModules, updatedModules);
					checkForUpdate(true);
				})
				.catch(function(err) {
					var status = module.hot.status();
					if (["abort", "fail"].indexOf(status) >= 0) {
						log("warning", "[HMR] Cannot apply update.");
						log("warning", "[HMR] " + log.formatError(err));
						log("warning", "[HMR] You need to restart the application!");
					} else {
						log("warning", "[HMR] Update failed: " + log.formatError(err));
					}
				});
		}
	};
	setInterval(checkForUpdate, hotPollInterval);
} else {}

/* WEBPACK VAR INJECTION */}.call(this, "?1000"))

/***/ }),

/***/ "./node_modules/wide-align/align.js":
/*!******************************************!*\
  !*** ./node_modules/wide-align/align.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var stringWidth = __webpack_require__(/*! string-width */ "string-width")

exports.center = alignCenter
exports.left = alignLeft
exports.right = alignRight

// lodash's way of generating pad characters.

function createPadding (width) {
  var result = ''
  var string = ' '
  var n = width
  do {
    if (n % 2) {
      result += string;
    }
    n = Math.floor(n / 2);
    string += string;
  } while (n);

  return result;
}

function alignLeft (str, width) {
  var trimmed = str.trimRight()
  if (trimmed.length === 0 && str.length >= width) return str
  var padding = ''
  var strWidth = stringWidth(trimmed)

  if (strWidth < width) {
    padding = createPadding(width - strWidth)
  }

  return trimmed + padding
}

function alignRight (str, width) {
  var trimmed = str.trimLeft()
  if (trimmed.length === 0 && str.length >= width) return str
  var padding = ''
  var strWidth = stringWidth(trimmed)

  if (strWidth < width) {
    padding = createPadding(width - strWidth)
  }

  return padding + trimmed
}

function alignCenter (str, width) {
  var trimmed = str.trim()
  if (trimmed.length === 0 && str.length >= width) return str
  var padLeft = ''
  var padRight = ''
  var strWidth = stringWidth(trimmed)

  if (strWidth < width) {
    var padLeftBy = parseInt((width - strWidth) / 2, 10) 
    padLeft = createPadding(padLeftBy)
    padRight = createPadding(width - (strWidth + padLeftBy))
  }

  return padLeft + trimmed + padRight
}


/***/ }),

/***/ "./src/auth.ts":
/*!*********************!*\
  !*** ./src/auth.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUserFromToken = void 0;
var jsonwebtoken_1 = __importDefault(__webpack_require__(/*! jsonwebtoken */ "jsonwebtoken"));
var user_model_1 = __importDefault(__webpack_require__(/*! ./models/user.model */ "./src/models/user.model.ts"));
var SECRETKEY = process.env.SECRETKEY || 'not safe use env';
exports.getUserFromToken = function (token) {
    try {
        if (!token)
            return null;
        var payload = jsonwebtoken_1.default.verify(token, SECRETKEY);
        return user_model_1.default.findById(payload._id);
    }
    catch (error) {
        return null;
    }
};


/***/ }),

/***/ "./src/connect.ts":
/*!************************!*\
  !*** ./src/connect.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ "mongoose"));
var environment_1 = __webpack_require__(/*! ./environment */ "./src/environment.ts");
mongoose_1.default.connect(environment_1.environment.database.uri, environment_1.environment.database.config);
var db = mongoose_1.default.connection;
db.once('open', function () {
    console.log('MongoDB Atlas connection established!');
});
db.on('error', function () {
    console.error('MongoDB Atlas connection error!');
});
module.exports = db;


/***/ }),

/***/ "./src/directives.ts":
/*!***************************!*\
  !*** ./src/directives.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Authentication = void 0;
var apollo_server_1 = __webpack_require__(/*! apollo-server */ "apollo-server");
var graphql_1 = __webpack_require__(/*! graphql */ "graphql");
var Authentication = (function (_super) {
    __extends(Authentication, _super);
    function Authentication() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Authentication.prototype.visitFieldDefinition = function (field) {
        var _this = this;
        var resolver = field.resolve || graphql_1.defaultFieldResolver;
        field.resolve = function (root, args, ctx, info) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (!ctx.user) {
                    throw new apollo_server_1.AuthenticationError('not auth');
                }
                return [2, resolver(root, args, ctx, info)];
            });
        }); };
    };
    return Authentication;
}(apollo_server_1.SchemaDirectiveVisitor));
exports.Authentication = Authentication;


/***/ }),

/***/ "./src/environment.ts":
/*!****************************!*\
  !*** ./src/environment.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.environment = void 0;
var defaultPort = 4000;
exports.environment = {
    apollo: {
        introspection: process.env.APOLLO_INTROSPECTION === 'true',
        playground: process.env.APOLLO_PLAYGROUND === 'true',
    },
    database: {
        uri: process.env.DB_URI || '',
        config: {
            useNewUrlParser: true,
            useCreateIndex: true,
            useFindAndModify: false,
            useUnifiedTopology: true,
        },
    },
    secret: process.env.SECRETKEY || 'No saved secret!',
    saltRound: parseInt(process.env.SALTROUND || '10'),
    port: process.env.PORT || defaultPort,
};


/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var apollo_server_1 = __webpack_require__(/*! apollo-server */ "apollo-server");
var graphql_scalars_1 = __webpack_require__(/*! graphql-scalars */ "graphql-scalars");
var auth_1 = __webpack_require__(/*! ./auth */ "./src/auth.ts");
var directives_1 = __webpack_require__(/*! ./directives */ "./src/directives.ts");
var environment_1 = __webpack_require__(/*! ./environment */ "./src/environment.ts");
var resolvers_1 = __webpack_require__(/*! ./resolvers */ "./src/resolvers.ts");
var type_defs_graphql_1 = __importDefault(__webpack_require__(/*! ./type-defs.graphql */ "./src/type-defs.graphql"));
__webpack_require__(/*! ./connect */ "./src/connect.ts");
var server = new apollo_server_1.ApolloServer({
    resolvers: resolvers_1.resolvers,
    typeDefs: type_defs_graphql_1.default,
    schemaDirectives: {
        authentication: directives_1.Authentication,
    },
    context: function (_a) {
        var req = _a.req;
        var token = req.headers.authorization;
        var user = auth_1.getUserFromToken(token);
        return { user: user };
    },
    mocks: {
        DateTime: graphql_scalars_1.DateTimeMock,
        EmailAddress: graphql_scalars_1.EmailAddressMock,
        PhoneNumber: graphql_scalars_1.PhoneNumberMock,
        Currency: graphql_scalars_1.CurrencyMock,
        PositiveInt: graphql_scalars_1.PositiveIntMock,
    },
    mockEntireSchema: false,
    introspection: environment_1.environment.apollo.introspection,
    playground: environment_1.environment.apollo.playground,
});
server
    .listen(environment_1.environment.port)
    .then(function (_a) {
    var url = _a.url;
    return console.log("Server ready at " + url + ".");
});
if (true) {
    module.hot.accept();
    module.hot.dispose(function () { return console.log('Module disposed. '); });
}


/***/ }),

/***/ "./src/models/flight.model.ts":
/*!************************************!*\
  !*** ./src/models/flight.model.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var mongoose_1 = __importStar(__webpack_require__(/*! mongoose */ "mongoose"));
var FlightSchema = new mongoose_1.Schema({
    origin: {
        type: mongoose_1.Schema.Types.ObjectId,
        ref: 'Place',
        required: true,
    },
    destination: {
        type: mongoose_1.Schema.Types.ObjectId,
        ref: 'Place',
        required: true,
    },
    departureDate: {
        type: Date,
        required: true,
    },
    arrivalDate: {
        type: Date,
        required: true,
    },
    airline: {
        type: String,
        required: true,
    },
    currency: {
        type: String,
        required: true,
    },
    price: {
        type: Number,
        required: true,
    },
}, { timestamps: true });
exports.default = mongoose_1.default.model('Flight', FlightSchema);


/***/ }),

/***/ "./src/models/place.model.ts":
/*!***********************************!*\
  !*** ./src/models/place.model.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var mongoose_1 = __importStar(__webpack_require__(/*! mongoose */ "mongoose"));
var PlaceSchema = new mongoose_1.Schema({
    airportId: {
        type: String,
    },
    airportName: {
        type: String,
    },
    location: {
        type: String,
    },
    cityId: {
        type: String,
    },
    cityName: {
        type: String,
    },
    countryId: {
        type: String,
    },
    countryName: {
        type: String,
    },
}, { timestamps: true });
exports.default = mongoose_1.default.model('Place', PlaceSchema);


/***/ }),

/***/ "./src/models/trip.model.ts":
/*!**********************************!*\
  !*** ./src/models/trip.model.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var mongoose_1 = __importStar(__webpack_require__(/*! mongoose */ "mongoose"));
var TripSchema = new mongoose_1.Schema({
    creator: {
        type: String,
        required: true,
    },
    booked: {
        type: Boolean,
        required: true,
    },
    startLocation: {
        type: mongoose_1.Schema.Types.ObjectId,
        ref: 'Place',
        required: true,
    },
    endLocation: {
        type: mongoose_1.Schema.Types.ObjectId,
        ref: 'Place',
        required: true,
    },
    startDate: {
        type: Date,
        required: true,
    },
    destinations: [
        {
            type: mongoose_1.Schema.Types.ObjectId,
            ref: 'Place',
        },
    ],
    flights: [
        {
            type: mongoose_1.Schema.Types.ObjectId,
            ref: 'Flight',
        },
    ],
    currency: String,
    price: Number,
}, { timestamps: true });
exports.default = mongoose_1.default.model('Trip', TripSchema);


/***/ }),

/***/ "./src/models/user.model.ts":
/*!**********************************!*\
  !*** ./src/models/user.model.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var mongoose_1 = __importStar(__webpack_require__(/*! mongoose */ "mongoose"));
var UserSchema = new mongoose_1.Schema({
    email: {
        type: String,
        required: true,
        unique: true,
    },
    password: {
        type: String,
        required: true,
    },
    firstName: {
        type: String,
        required: true,
    },
    lastName: {
        type: String,
        required: true,
    },
    phoneNumber: {
        type: String,
    },
    trips: [
        {
            type: mongoose_1.Schema.Types.ObjectId,
            ref: 'Trip',
        },
    ],
}, { timestamps: true });
exports.default = mongoose_1.default.model('User', UserSchema);


/***/ }),

/***/ "./src/resolvers.ts":
/*!**************************!*\
  !*** ./src/resolvers.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolvers = void 0;
var graphql_scalars_1 = __webpack_require__(/*! graphql-scalars */ "graphql-scalars");
var user_model_1 = __importDefault(__webpack_require__(/*! ./models/user.model */ "./src/models/user.model.ts"));
var trip_model_1 = __importDefault(__webpack_require__(/*! ./models/trip.model */ "./src/models/trip.model.ts"));
var place_model_1 = __importDefault(__webpack_require__(/*! ./models/place.model */ "./src/models/place.model.ts"));
var flight_model_1 = __importDefault(__webpack_require__(/*! ./models/flight.model */ "./src/models/flight.model.ts"));
var jsonwebtoken_1 = __importDefault(__webpack_require__(/*! jsonwebtoken */ "jsonwebtoken"));
var bcrypt_1 = __importDefault(__webpack_require__(/*! bcrypt */ "./node_modules/bcrypt/bcrypt.js"));
var environment_1 = __webpack_require__(/*! ./environment */ "./src/environment.ts");
exports.resolvers = {
    Query: {
        login: function (_, _a) {
            var email = _a.email, password = _a.password;
            return __awaiter(this, void 0, void 0, function () {
                var user;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4, user_model_1.default.findOne({ email: email }).populate({
                                path: 'trips',
                                model: trip_model_1.default,
                                populate: [
                                    {
                                        path: 'startLocation endLocation destinations',
                                        model: place_model_1.default,
                                    },
                                    {
                                        path: 'flights',
                                        model: flight_model_1.default,
                                        populate: {
                                            path: 'origin destination',
                                            model: place_model_1.default,
                                        },
                                    },
                                ],
                            })];
                        case 1:
                            user = _b.sent();
                            if (!user)
                                return [2, 'no user'];
                            if (user.password !== password)
                                return [2, 'no user'];
                            user.token = jsonwebtoken_1.default.sign({ _id: user._id }, environment_1.environment.secret);
                            return [2, user];
                    }
                });
            });
        },
    },
    Mutation: {
        registerUser: function (_, _a) {
            var userDetails = _a.userDetails;
            return __awaiter(this, void 0, void 0, function () {
                var _b, user;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            _b = userDetails;
                            return [4, bcrypt_1.default.hash(userDetails.password, environment_1.environment.saltRound)];
                        case 1:
                            _b.password = _c.sent();
                            return [4, user_model_1.default.create(userDetails)];
                        case 2:
                            user = _c.sent();
                            user.token = jsonwebtoken_1.default.sign({ _id: user._id }, environment_1.environment.secret);
                            return [2, user];
                    }
                });
            });
        },
        updateUser: function (_, _a) {
            var userDetails = _a.userDetails;
            return __awaiter(this, void 0, void 0, function () {
                var user;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4, user_model_1.default.findOneAndUpdate({ email: userDetails.email }, userDetails, { new: true }).exec()];
                        case 1:
                            user = _b.sent();
                            return [2, user];
                    }
                });
            });
        },
        createTrip: function (_, _a) {
            var tripInput = _a.tripInput;
            return __awaiter(this, void 0, void 0, function () {
                var flights, i, flightDB, trip;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            flights = __spreadArrays(tripInput.flights);
                            tripInput.flights = [];
                            i = 0;
                            _b.label = 1;
                        case 1:
                            if (!(i < flights.length)) return [3, 4];
                            return [4, flight_model_1.default.create(flights[i])];
                        case 2:
                            flightDB = _b.sent();
                            tripInput.flights.push(flightDB._id);
                            _b.label = 3;
                        case 3:
                            i++;
                            return [3, 1];
                        case 4: return [4, trip_model_1.default.create(tripInput)];
                        case 5:
                            trip = _b.sent();
                            return [4, user_model_1.default.findOneAndUpdate({ _id: trip.creator }, { $push: { trips: trip._id } })];
                        case 6:
                            _b.sent();
                            return [2, trip];
                    }
                });
            });
        },
        updateTrip: function (_, _a) {
            var tripInput = _a.tripInput;
            return __awaiter(this, void 0, void 0, function () {
                var trip, flights, i, flightDB, updateTrip;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4, trip_model_1.default.findById(tripInput._id)];
                        case 1:
                            trip = _b.sent();
                            if (!trip)
                                throw new Error('trip not found');
                            return [4, flight_model_1.default.deleteMany({
                                    _id: {
                                        $in: trip.flights,
                                    },
                                })];
                        case 2:
                            _b.sent();
                            flights = tripInput.flights;
                            tripInput.flights = [];
                            if (!(flights && flights.length > 0)) return [3, 6];
                            i = 0;
                            _b.label = 3;
                        case 3:
                            if (!(i < flights.length)) return [3, 6];
                            return [4, flight_model_1.default.create(flights[i])];
                        case 4:
                            flightDB = _b.sent();
                            tripInput.flights.push(flightDB._id);
                            _b.label = 5;
                        case 5:
                            i++;
                            return [3, 3];
                        case 6:
                            updateTrip = Object.assign(trip, tripInput);
                            return [4, trip_model_1.default.findOneAndUpdate({ _id: tripInput._id }, updateTrip, {
                                    new: true,
                                }).populate([
                                    {
                                        path: 'startLocation endLocation destinations',
                                        model: place_model_1.default,
                                    },
                                    {
                                        path: 'flights',
                                        model: flight_model_1.default,
                                        populate: {
                                            path: 'origin destination',
                                            model: place_model_1.default,
                                        },
                                    },
                                ])];
                        case 7: return [2, _b.sent()];
                    }
                });
            });
        },
        deleteTrip: function (_, _a) {
            var tripid = _a.tripid;
            return __awaiter(this, void 0, void 0, function () {
                var trip, user, i;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4, trip_model_1.default.findById(tripid)];
                        case 1:
                            trip = _b.sent();
                            if (!trip)
                                throw new Error('trip not found');
                            return [4, user_model_1.default.findById(trip.creator)];
                        case 2:
                            user = _b.sent();
                            if (!user)
                                throw new Error('trip has no user smth went really wrong!');
                            if (user.trips && user.trips.length > 0) {
                                for (i = 0; i < user.trips.length; i++) {
                                    if (user.trips[i] === tripid) {
                                        user.trips.splice(i, 1);
                                    }
                                }
                            }
                            return [4, user_model_1.default.findByIdAndUpdate(user.id, user)];
                        case 3:
                            _b.sent();
                            return [4, flight_model_1.default.deleteMany({
                                    _id: {
                                        $in: trip.flights,
                                    },
                                })];
                        case 4:
                            _b.sent();
                            return [4, trip_model_1.default.findByIdAndDelete(tripid)];
                        case 5:
                            _b.sent();
                            return [2, true];
                    }
                });
            });
        },
    },
    DateTime: graphql_scalars_1.DateTimeResolver,
    EmailAddress: graphql_scalars_1.EmailAddressResolver,
    PhoneNumber: graphql_scalars_1.PhoneNumberResolver,
    Currency: graphql_scalars_1.CurrencyResolver,
    PositiveInt: graphql_scalars_1.PositiveIntResolver,
};


/***/ }),

/***/ "./src/type-defs.graphql":
/*!*******************************!*\
  !*** ./src/type-defs.graphql ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var apollo_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! apollo-server */ "apollo-server");
/* harmony import */ var apollo_server__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(apollo_server__WEBPACK_IMPORTED_MODULE_0__);


/* harmony default export */ __webpack_exports__["default"] = (apollo_server__WEBPACK_IMPORTED_MODULE_0__["gql"]`
  schema {
    query: Query
    mutation: Mutation
  }

  directive @authentication on FIELD_DEFINITION

  scalar DateTime
  scalar EmailAddress 
  scalar PhoneNumber
  scalar Currency
  scalar PositiveInt

  type Query {
    login(
      email: EmailAddress!
      password: String!
    ): User!
    logout(
      email: EmailAddress!
      password: String!
    ): User!
    places(
      cityNameSearch: String!
    ): [Place!]!
  }

  type Mutation {
    registerUser(   
      userDetails: UserRegisterInput
    ): User! 
    updateUser(   
      userDetails: UserUpdateInput
    ): User! @authentication
    createTrip(
      tripInput: TripCreateInput
    ): Trip! @authentication
    updateTrip(
      tripInput: TripUpdateInput
    ): Trip! @authentication
    deleteTrip(
      tripid: String!
    ): Boolean! @authentication
  }

  type User {
    _id: ID!
    email: EmailAddress!
    password: String!
    firstName: String
    lastName: String!
    phoneNumber: PhoneNumber
    trips: [Trip]!
    token: String
  }

  type Trip {
    _id: ID!
    creator: ID!
    booked: Boolean!
    startLocation: Place!
    endLocation: Place!
    startDate: DateTime!
    destinations: [Place!]!
    flights: [Flight!]!
    currency: Currency!
    price: PositiveInt!
  }
  
  type Flight {
    _id: ID!
    origin: Place!
    destination: Place!
    departureDate: DateTime!
    arrivalDate: DateTime!
    airline: String!
    currency: Currency!
    price: PositiveInt!
  }

  type Place { 
    _id: ID!
    airportId: String!
    airportName: String!
    location: String!
    cityId: String!
    cityName: String!
    countryId: String!
    countryName: String!
  }
  
  input UserRegisterInput {
    email: EmailAddress!
    password: String!
    firstName: String!
    lastName: String!
    phoneNumber: PhoneNumber
  }

  input UserUpdateInput {
    email: EmailAddress!
    password: String
    firstName: String
    lastName: String
    phoneNumber: PhoneNumber
  }

  input TripCreateInput {
    creator: String!
    booked: Boolean!
    startLocation: String!
    endLocation: String!
    startDate: DateTime!
    destinations: [String!]!
    flights: [FlightInput!]!
    currency: Currency!
    price: PositiveInt!
  }

  input TripUpdateInput {
    _id: ID!
    creator: String!
    booked: Boolean
    startLocation: String
    endLocation: String
    startDate: DateTime
    destinations: [String!]
    flights: [FlightInput!]
    currency: Currency
    price: PositiveInt
  }

  input FlightInput {
    origin: String!
    destination: String!
    departureDate: DateTime!
    arrivalDate: DateTime!
    airline: String!
    currency: Currency!
    price: PositiveInt!
  }
`);

/***/ }),

/***/ 0:
/*!*************************************************!*\
  !*** multi webpack/hot/poll?1000 ./src/main.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! webpack/hot/poll?1000 */"./node_modules/webpack/hot/poll.js?1000");
module.exports = __webpack_require__(/*! /Users/nilswernecke/Documents/webdev/thesisproject/tripwiser/src/main.ts */"./src/main.ts");


/***/ }),

/***/ "apollo-server":
/*!********************************!*\
  !*** external "apollo-server" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("apollo-server");

/***/ }),

/***/ "aproba":
/*!*************************!*\
  !*** external "aproba" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("aproba");

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("assert");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("buffer");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("child_process");

/***/ }),

/***/ "chownr":
/*!*************************!*\
  !*** external "chownr" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("chownr");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("crypto");

/***/ }),

/***/ "debug":
/*!************************!*\
  !*** external "debug" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("debug");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),

/***/ "graphql":
/*!**************************!*\
  !*** external "graphql" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("graphql");

/***/ }),

/***/ "graphql-scalars":
/*!**********************************!*\
  !*** external "graphql-scalars" ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("graphql-scalars");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("https");

/***/ }),

/***/ "iconv-lite":
/*!*****************************!*\
  !*** external "iconv-lite" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("iconv-lite");

/***/ }),

/***/ "ini":
/*!**********************!*\
  !*** external "ini" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("ini");

/***/ }),

/***/ "jsonwebtoken":
/*!*******************************!*\
  !*** external "jsonwebtoken" ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("jsonwebtoken");

/***/ }),

/***/ "minimatch":
/*!****************************!*\
  !*** external "minimatch" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("minimatch");

/***/ }),

/***/ "minimist":
/*!***************************!*\
  !*** external "minimist" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("minimist");

/***/ }),

/***/ "mkdirp":
/*!*************************!*\
  !*** external "mkdirp" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("mkdirp");

/***/ }),

/***/ "mongoose":
/*!***************************!*\
  !*** external "mongoose" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("mongoose");

/***/ }),

/***/ "object-assign":
/*!********************************!*\
  !*** external "object-assign" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("object-assign");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("os");

/***/ }),

/***/ "os-tmpdir":
/*!****************************!*\
  !*** external "os-tmpdir" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("os-tmpdir");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),

/***/ "querystring":
/*!******************************!*\
  !*** external "querystring" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("querystring");

/***/ }),

/***/ "readable-stream":
/*!**********************************!*\
  !*** external "readable-stream" ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("readable-stream");

/***/ }),

/***/ "request":
/*!**************************!*\
  !*** external "request" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("request");

/***/ }),

/***/ "rimraf":
/*!*************************!*\
  !*** external "rimraf" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("rimraf");

/***/ }),

/***/ "safe-buffer":
/*!******************************!*\
  !*** external "safe-buffer" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("safe-buffer");

/***/ }),

/***/ "semver":
/*!*************************!*\
  !*** external "semver" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("semver");

/***/ }),

/***/ "set-blocking":
/*!*******************************!*\
  !*** external "set-blocking" ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("set-blocking");

/***/ }),

/***/ "signal-exit":
/*!******************************!*\
  !*** external "signal-exit" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("signal-exit");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("stream");

/***/ }),

/***/ "string-width":
/*!*******************************!*\
  !*** external "string-width" ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("string-width");

/***/ }),

/***/ "string_decoder":
/*!*********************************!*\
  !*** external "string_decoder" ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("string_decoder");

/***/ }),

/***/ "strip-ansi":
/*!*****************************!*\
  !*** external "strip-ansi" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("strip-ansi");

/***/ }),

/***/ "strip-json-comments":
/*!**************************************!*\
  !*** external "strip-json-comments" ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("strip-json-comments");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("util");

/***/ }),

/***/ "yallist":
/*!**************************!*\
  !*** external "yallist" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("yallist");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("zlib");

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FiYnJldi9hYmJyZXYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FyZS13ZS10aGVyZS15ZXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FyZS13ZS10aGVyZS15ZXQvdHJhY2tlci1iYXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hcmUtd2UtdGhlcmUteWV0L3RyYWNrZXItZ3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FyZS13ZS10aGVyZS15ZXQvdHJhY2tlci1zdHJlYW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FyZS13ZS10aGVyZS15ZXQvdHJhY2tlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmNyeXB0IHN5bmMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JjcnlwdC9iY3J5cHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JjcnlwdC9wcm9taXNlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29uc29sZS1jb250cm9sLXN0cmluZ3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RlZXAtZXh0ZW5kL2xpYi9kZWVwLWV4dGVuZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVsZWdhdGVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZXRlY3QtbGliYy9saWIvZGV0ZWN0LWxpYmMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZzLW1pbmlwYXNzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nYXVnZS9iYXNlLXRoZW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nYXVnZS9lcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2F1Z2UvaGFzLWNvbG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nYXVnZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2F1Z2UvcGx1bWJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dhdWdlL3Byb2Nlc3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dhdWdlL3Byb2dyZXNzLWJhci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2F1Z2UvcmVuZGVyLXRlbXBsYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nYXVnZS9zZXQtaW1tZWRpYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nYXVnZS9zZXQtaW50ZXJ2YWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dhdWdlL3NwaW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dhdWdlL3RlbXBsYXRlLWl0ZW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dhdWdlL3RoZW1lLXNldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2F1Z2UvdGhlbWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nYXVnZS93aWRlLXRydW5jYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXMtdW5pY29kZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaWdub3JlLXdhbGsvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21pbmlwYXNzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9taW5pemxpYi9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21pbml6bGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZWVkbGUvbGliL2F1dGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25lZWRsZS9saWIvY29va2llcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVlZGxlL2xpYi9kZWNvZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZWVkbGUvbGliL211bHRpcGFydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVlZGxlL2xpYi9uZWVkbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25lZWRsZS9saWIvcGFyc2Vycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVlZGxlL2xpYi9xdWVyeXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1wcmUtZ3lwL2xpYiBzeW5jIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ub2RlLXByZS1neXAvbGliIHN5bmMgXlxcLlxcLy4qJCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1wcmUtZ3lwL2xpYi9idWlsZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1wcmUtZ3lwL2xpYi9jbGVhbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1wcmUtZ3lwL2xpYi9jb25maWd1cmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25vZGUtcHJlLWd5cC9saWIvaW5mby5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1wcmUtZ3lwL2xpYi9pbnN0YWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ub2RlLXByZS1neXAvbGliL25vZGUtcHJlLWd5cC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1wcmUtZ3lwL2xpYi9wYWNrYWdlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ub2RlLXByZS1neXAvbGliL3ByZS1iaW5kaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ub2RlLXByZS1neXAvbGliL3B1Ymxpc2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25vZGUtcHJlLWd5cC9saWIvcmVidWlsZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1wcmUtZ3lwL2xpYi9yZWluc3RhbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25vZGUtcHJlLWd5cC9saWIvcmV2ZWFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ub2RlLXByZS1neXAvbGliL3Rlc3RiaW5hcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25vZGUtcHJlLWd5cC9saWIvdGVzdHBhY2thZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25vZGUtcHJlLWd5cC9saWIvdW5wdWJsaXNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ub2RlLXByZS1neXAvbGliL3V0aWwgc3luYyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1wcmUtZ3lwL2xpYi91dGlsL2NvbXBpbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25vZGUtcHJlLWd5cC9saWIvdXRpbC9oYW5kbGVfZ3lwX29wdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25vZGUtcHJlLWd5cC9saWIvdXRpbC9uYXBpLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ub2RlLXByZS1neXAvbGliL3V0aWwvczNfc2V0dXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25vZGUtcHJlLWd5cC9saWIvdXRpbC92ZXJzaW9uaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ub3B0L2xpYi9ub3B0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ucG0tYnVuZGxlZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbnBtLW5vcm1hbGl6ZS1wYWNrYWdlLWJpbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbnBtLXBhY2tsaXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ucG1sb2cvbG9nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vcy1ob21lZGlyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vc2Vudi9vc2Vudi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JjL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2F4L2xpYi9zYXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Rhci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9idWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Rhci9saWIvY3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90YXIvbGliL2V4dHJhY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Rhci9saWIvaGVhZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90YXIvbGliL2hpZ2gtbGV2ZWwtb3B0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90YXIvbGliL2xhcmdlLW51bWJlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Rhci9saWIvbGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9ta2Rpci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9tb2RlLWZpeC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9wYWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90YXIvbGliL3BhcnNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90YXIvbGliL3BheC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9yZWFkLWVudHJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90YXIvbGliL3JlcGxhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Rhci9saWIvdHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Rhci9saWIvdW5wYWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90YXIvbGliL3VwZGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGFyL2xpYi93YXJuLW1peGluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90YXIvbGliL3dpbmNoYXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90YXIvbGliL3dyaXRlLWVudHJ5LmpzIiwid2VicGFjazovLy8od2VicGFjaykvaG90L2xvZy1hcHBseS1yZXN1bHQuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9ob3QvbG9nLmpzIiwid2VicGFjazovLy8od2VicGFjaykvaG90L3BvbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dpZGUtYWxpZ24vYWxpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2F1dGgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Nvbm5lY3QudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RpcmVjdGl2ZXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Vudmlyb25tZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9tYWluLnRzIiwid2VicGFjazovLy8uL3NyYy9tb2RlbHMvZmxpZ2h0Lm1vZGVsLnRzIiwid2VicGFjazovLy8uL3NyYy9tb2RlbHMvcGxhY2UubW9kZWwudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZGVscy90cmlwLm1vZGVsLnRzIiwid2VicGFjazovLy8uL3NyYy9tb2RlbHMvdXNlci5tb2RlbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVzb2x2ZXJzLnRzIiwid2VicGFjazovLy8uL3NyYy90eXBlLWRlZnMuZ3JhcGhxbCIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJhcG9sbG8tc2VydmVyXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiYXByb2JhXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiYXNzZXJ0XCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiYnVmZmVyXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiY2hpbGRfcHJvY2Vzc1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcImNob3duclwiIiwid2VicGFjazovLy9leHRlcm5hbCBcImNyeXB0b1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcImRlYnVnXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZXZlbnRzXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZnNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJncmFwaHFsXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZ3JhcGhxbC1zY2FsYXJzXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiaHR0cFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcImh0dHBzXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiaWNvbnYtbGl0ZVwiIiwid2VicGFjazovLy9leHRlcm5hbCBcImluaVwiIiwid2VicGFjazovLy9leHRlcm5hbCBcImpzb253ZWJ0b2tlblwiIiwid2VicGFjazovLy9leHRlcm5hbCBcIm1pbmltYXRjaFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcIm1pbmltaXN0XCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwibWtkaXJwXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwibW9uZ29vc2VcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJvYmplY3QtYXNzaWduXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwib3NcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJvcy10bXBkaXJcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJwYXRoXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwicXVlcnlzdHJpbmdcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJyZWFkYWJsZS1zdHJlYW1cIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJyZXF1ZXN0XCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwicmltcmFmXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwic2FmZS1idWZmZXJcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJzZW12ZXJcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJzZXQtYmxvY2tpbmdcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJzaWduYWwtZXhpdFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInN0cmVhbVwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInN0cmluZy13aWR0aFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInN0cmluZ19kZWNvZGVyXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwic3RyaXAtYW5zaVwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInN0cmlwLWpzb24tY29tbWVudHNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ1cmxcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ1dGlsXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwieWFsbGlzdFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInpsaWJcIiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLElBQUk7UUFDSjtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLE1BQU07UUFDTjtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSxLQUFLO1FBQ0w7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSxNQUFNO1FBQ047UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLEtBQUs7O1FBRUw7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EsNkJBQTZCO1FBQzdCLDZCQUE2QjtRQUM3QjtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLHFCQUFxQixnQkFBZ0I7UUFDckM7UUFDQTtRQUNBLEtBQUs7UUFDTDtRQUNBO1FBQ0E7UUFDQSxxQkFBcUIsZ0JBQWdCO1FBQ3JDO1FBQ0E7UUFDQSxLQUFLO1FBQ0w7UUFDQTtRQUNBLEtBQUs7UUFDTDtRQUNBO1FBQ0EsS0FBSztRQUNMO1FBQ0E7UUFDQTtRQUNBLEtBQUs7UUFDTDtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLEtBQUs7O1FBRUw7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EsS0FBSztRQUNMO1FBQ0E7UUFDQSxLQUFLO1FBQ0w7UUFDQTtRQUNBO1FBQ0EsS0FBSzs7UUFFTDtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0Esa0JBQWtCLDhCQUE4QjtRQUNoRDtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLEtBQUs7UUFDTDtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EsSUFBSTtRQUNKOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsSUFBSTtRQUNKO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EsTUFBTTtRQUNOO1FBQ0E7UUFDQTtRQUNBLE9BQU87UUFDUDtRQUNBO1FBQ0E7UUFDQTtRQUNBLElBQUk7UUFDSjtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLEtBQUs7UUFDTDtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSxvQkFBb0IsMkJBQTJCO1FBQy9DO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSxPQUFPO1FBQ1A7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBLG1CQUFtQixjQUFjO1FBQ2pDO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSxnQkFBZ0IsS0FBSztRQUNyQjtRQUNBO1FBQ0E7UUFDQSxNQUFNO1FBQ047UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLGdCQUFnQixZQUFZO1FBQzVCO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBO1FBQ0EsY0FBYyw0QkFBNEI7UUFDMUM7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSxNQUFNO1FBQ047UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSxJQUFJOztRQUVKO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTs7UUFFQTtRQUNBO1FBQ0EsZUFBZSw0QkFBNEI7UUFDM0M7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQSxlQUFlLDRCQUE0QjtRQUMzQztRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EsaUJBQWlCLHVDQUF1QztRQUN4RDtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EsaUJBQWlCLHVDQUF1QztRQUN4RDtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLGlCQUFpQixzQkFBc0I7UUFDdkM7UUFDQTtRQUNBO1FBQ0EsUUFBUTtRQUNSO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLFVBQVU7UUFDVjtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxjQUFjLHdDQUF3QztRQUN0RDtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSxLQUFLO1FBQ0w7UUFDQTtRQUNBO1FBQ0EsT0FBTztRQUNQO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLFNBQVM7UUFDVDtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSxNQUFNO1FBQ047UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLFFBQVE7UUFDUjtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EsTUFBTTtRQUNOO1FBQ0EsS0FBSztRQUNMOztRQUVBO1FBQ0E7UUFDQTtRQUNBLElBQUk7UUFDSjs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtR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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYixlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFx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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQywwQkFBMEI7QUFDekU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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RUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsdUJBQXVCLFlBQVk7QUFDdEM7O0FBRUE7QUFDQTs7QUFFQSxvREFBb0Q7O0FBRXBEO0FBQ0E7O0FBRUEsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFD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OztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDeFBBO0FBQ0E7QUFDQSxPQUFPLGVBQWUsR0FBRyxtQkFBTyxDQUFDLGtCQUFNOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUNBQXFDOztBQUVqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsb0JBQW9CO0FBQ3BFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7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QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQy9HWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsbUJBQU8sQ0FBQyxxREFBYTtBQUNwQyxjQUFjLG1CQUFPLENBQUMsbURBQVk7QUFDbEMsbUJBQW1CLG1CQUFPLENBQUMsa0JBQU07QUFDakMsY0FBYyxtQkFBTyxDQUFDLG1FQUFvQjs7QUFFMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBLDJCQUEyQixlQUFlO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0EsMkJBQTJCLGVBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7OztBQzdNWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDYlk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLHFEQUFhOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsbUJBQU8sQ0FBQyxrREFBVTtBQUNuQyxhQUFhLG1CQUFPLENBQUMsa0RBQVU7QUFDL0Isa0JBQWtCLG1CQUFPLENBQUMsNkRBQWlCO0FBQzNDLG1CQUFtQixtQkFBTyxDQUFDLCtEQUFrQjtBQUM3QztBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsd0JBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixlQUFlLG1CQUFPLENBQUMsNkRBQWlCOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDblpZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsbUJBQU8sQ0FBQyw2REFBaUI7QUFDeEMsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGVBQWUsbUJBQU8sQ0FBQyxxREFBYTtBQUNwQyxXQUFXLG1CQUFPLENBQUMsc0JBQVE7QUFDM0IsZ0JBQWdCLG1CQUFPLENBQUMsd0JBQVM7QUFDakM7QUFDQSxjQUFjLG1CQUFPLENBQUMsNkRBQWlCO0FBQ3ZDLFlBQVksbUJBQU8sQ0FBQywrQ0FBVTtBQUM5QixhQUFhLG1CQUFPLENBQUMsa0RBQVU7QUFDL0IsZUFBZSxtQkFBTyxDQUFDLHFEQUFhOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLCtDQUErQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7QUMzYVc7QUFDWixlQUFlLG1CQUFPLENBQUMscURBQWE7QUFDcEMsZUFBZSxtQkFBTyxDQUFDLHFEQUFhO0FBQ3BDLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLCtCQUErQixnQkFBZ0I7QUFDL0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ2pKWTtBQUNaLGNBQWMsbUJBQU8sQ0FBQyxtREFBWTtBQUNsQyxpQkFBaUIsbUJBQU8sQ0FBQyxrREFBVTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QSxXQUFXLG1CQUFPLENBQUMseURBQWU7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsc0JBQVE7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsdUNBQXVDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUNyYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsV0FBVyxtQkFBTyxDQUFDLGdEQUFPOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDM0NBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBVTtBQUNkO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLGdEQUFPOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLG1CQUFPLENBQUMsMEVBQW9CO0FBQ2pDO0FBQ0EsS0FBSztBQUNMO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx1QkFBdUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMVFBO0FBQUE7QUFBQTtBQUFvQzs7QUFFckIsZ0hBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hKQSwwQzs7Ozs7Ozs7Ozs7QUNBQSxtQzs7Ozs7Ozs7Ozs7QUNBQSxtQzs7Ozs7Ozs7Ozs7QUNBQSxtQzs7Ozs7Ozs7Ozs7QUNBQSwwQzs7Ozs7Ozs7Ozs7QUNBQSxtQzs7Ozs7Ozs7Ozs7QUNBQSxtQzs7Ozs7Ozs7Ozs7QUNBQSxrQzs7Ozs7Ozs7Ozs7QUNBQSxtQzs7Ozs7Ozs7Ozs7QUNBQSwrQjs7Ozs7Ozs7Ozs7QUNBQSxvQzs7Ozs7Ozs7Ozs7QUNBQSw0Qzs7Ozs7Ozs7Ozs7QUNBQSxpQzs7Ozs7Ozs7Ozs7QUNBQSxrQzs7Ozs7Ozs7Ozs7QUNBQSx1Qzs7Ozs7Ozs7Ozs7QUNBQSxnQzs7Ozs7Ozs7Ozs7QUNBQSx5Qzs7Ozs7Ozs7Ozs7QUNBQSxzQzs7Ozs7Ozs7Ozs7QUNBQSxxQzs7Ozs7Ozs7Ozs7QUNBQSxtQzs7Ozs7Ozs7Ozs7QUNBQSxxQzs7Ozs7Ozs7Ozs7QUNBQSwwQzs7Ozs7Ozs7Ozs7QUNBQSwrQjs7Ozs7Ozs7Ozs7QUNBQSxzQzs7Ozs7Ozs7Ozs7QUNBQSxpQzs7Ozs7Ozs7Ozs7QUNBQSx3Qzs7Ozs7Ozs7Ozs7QUNBQSw0Qzs7Ozs7Ozs7Ozs7QUNBQSxvQzs7Ozs7Ozs7Ozs7QUNBQSxtQzs7Ozs7Ozs7Ozs7QUNBQSx3Qzs7Ozs7Ozs7Ozs7QUNBQSxtQzs7Ozs7Ozs7Ozs7QUNBQSx5Qzs7Ozs7Ozs7Ozs7QUNBQSx3Qzs7Ozs7Ozs7Ozs7QUNBQSxtQzs7Ozs7Ozs7Ozs7QUNBQSx5Qzs7Ozs7Ozs7Ozs7QUNBQSwyQzs7Ozs7Ozs7Ozs7QUNBQSx1Qzs7Ozs7Ozs7Ozs7QUNBQSxnRDs7Ozs7Ozs7Ozs7QUNBQSxnQzs7Ozs7Ozs7Ozs7QUNBQSxpQzs7Ozs7Ozs7Ozs7QUNBQSxvQzs7Ozs7Ozs7Ozs7QUNBQSxpQyIsImZpbGUiOiJzZXJ2ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiBcdGZ1bmN0aW9uIGhvdERvd25sb2FkVXBkYXRlQ2h1bmsoY2h1bmtJZCkge1xuIFx0XHR2YXIgY2h1bmsgPSByZXF1aXJlKFwiLi9cIiArIFwiXCIgKyBjaHVua0lkICsgXCIuXCIgKyBob3RDdXJyZW50SGFzaCArIFwiLmhvdC11cGRhdGUuanNcIik7XG4gXHRcdGhvdEFkZFVwZGF0ZUNodW5rKGNodW5rLmlkLCBjaHVuay5tb2R1bGVzKTtcbiBcdH1cblxuIFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gXHRmdW5jdGlvbiBob3REb3dubG9hZE1hbmlmZXN0KCkge1xuIFx0XHR0cnkge1xuIFx0XHRcdHZhciB1cGRhdGUgPSByZXF1aXJlKFwiLi9cIiArIFwiXCIgKyBob3RDdXJyZW50SGFzaCArIFwiLmhvdC11cGRhdGUuanNvblwiKTtcbiBcdFx0fSBjYXRjaCAoZSkge1xuIFx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiBcdFx0fVxuIFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHVwZGF0ZSk7XG4gXHR9XG5cbiBcdC8vZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gXHRmdW5jdGlvbiBob3REaXNwb3NlQ2h1bmsoY2h1bmtJZCkge1xuIFx0XHRkZWxldGUgaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdO1xuIFx0fVxuXG4gXHR2YXIgaG90QXBwbHlPblVwZGF0ZSA9IHRydWU7XG4gXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiBcdHZhciBob3RDdXJyZW50SGFzaCA9IFwiZmMxZTY4NWQyN2NhMmYzZWMwZmVcIjtcbiBcdHZhciBob3RSZXF1ZXN0VGltZW91dCA9IDEwMDAwO1xuIFx0dmFyIGhvdEN1cnJlbnRNb2R1bGVEYXRhID0ge307XG4gXHR2YXIgaG90Q3VycmVudENoaWxkTW9kdWxlO1xuIFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gXHR2YXIgaG90Q3VycmVudFBhcmVudHMgPSBbXTtcbiBcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuIFx0dmFyIGhvdEN1cnJlbnRQYXJlbnRzVGVtcCA9IFtdO1xuXG4gXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiBcdGZ1bmN0aW9uIGhvdENyZWF0ZVJlcXVpcmUobW9kdWxlSWQpIHtcbiBcdFx0dmFyIG1lID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XG4gXHRcdGlmICghbWUpIHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fO1xuIFx0XHR2YXIgZm4gPSBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gXHRcdFx0aWYgKG1lLmhvdC5hY3RpdmUpIHtcbiBcdFx0XHRcdGlmIChpbnN0YWxsZWRNb2R1bGVzW3JlcXVlc3RdKSB7XG4gXHRcdFx0XHRcdGlmIChpbnN0YWxsZWRNb2R1bGVzW3JlcXVlc3RdLnBhcmVudHMuaW5kZXhPZihtb2R1bGVJZCkgPT09IC0xKSB7XG4gXHRcdFx0XHRcdFx0aW5zdGFsbGVkTW9kdWxlc1tyZXF1ZXN0XS5wYXJlbnRzLnB1c2gobW9kdWxlSWQpO1xuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHR9IGVsc2Uge1xuIFx0XHRcdFx0XHRob3RDdXJyZW50UGFyZW50cyA9IFttb2R1bGVJZF07XG4gXHRcdFx0XHRcdGhvdEN1cnJlbnRDaGlsZE1vZHVsZSA9IHJlcXVlc3Q7XG4gXHRcdFx0XHR9XG4gXHRcdFx0XHRpZiAobWUuY2hpbGRyZW4uaW5kZXhPZihyZXF1ZXN0KSA9PT0gLTEpIHtcbiBcdFx0XHRcdFx0bWUuY2hpbGRyZW4ucHVzaChyZXF1ZXN0KTtcbiBcdFx0XHRcdH1cbiBcdFx0XHR9IGVsc2Uge1xuIFx0XHRcdFx0Y29uc29sZS53YXJuKFxuIFx0XHRcdFx0XHRcIltITVJdIHVuZXhwZWN0ZWQgcmVxdWlyZShcIiArXG4gXHRcdFx0XHRcdFx0cmVxdWVzdCArXG4gXHRcdFx0XHRcdFx0XCIpIGZyb20gZGlzcG9zZWQgbW9kdWxlIFwiICtcbiBcdFx0XHRcdFx0XHRtb2R1bGVJZFxuIFx0XHRcdFx0KTtcbiBcdFx0XHRcdGhvdEN1cnJlbnRQYXJlbnRzID0gW107XG4gXHRcdFx0fVxuIFx0XHRcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKHJlcXVlc3QpO1xuIFx0XHR9O1xuIFx0XHR2YXIgT2JqZWN0RmFjdG9yeSA9IGZ1bmN0aW9uIE9iamVjdEZhY3RvcnkobmFtZSkge1xuIFx0XHRcdHJldHVybiB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcbiBcdFx0XHRcdFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX19bbmFtZV07XG4gXHRcdFx0XHR9LFxuIFx0XHRcdFx0c2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuIFx0XHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fW25hbWVdID0gdmFsdWU7XG4gXHRcdFx0XHR9XG4gXHRcdFx0fTtcbiBcdFx0fTtcbiBcdFx0Zm9yICh2YXIgbmFtZSBpbiBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gXHRcdFx0aWYgKFxuIFx0XHRcdFx0T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9fd2VicGFja19yZXF1aXJlX18sIG5hbWUpICYmXG4gXHRcdFx0XHRuYW1lICE9PSBcImVcIiAmJlxuIFx0XHRcdFx0bmFtZSAhPT0gXCJ0XCJcbiBcdFx0XHQpIHtcbiBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgbmFtZSwgT2JqZWN0RmFjdG9yeShuYW1lKSk7XG4gXHRcdFx0fVxuIFx0XHR9XG4gXHRcdGZuLmUgPSBmdW5jdGlvbihjaHVua0lkKSB7XG4gXHRcdFx0aWYgKGhvdFN0YXR1cyA9PT0gXCJyZWFkeVwiKSBob3RTZXRTdGF0dXMoXCJwcmVwYXJlXCIpO1xuIFx0XHRcdGhvdENodW5rc0xvYWRpbmcrKztcbiBcdFx0XHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXy5lKGNodW5rSWQpLnRoZW4oZmluaXNoQ2h1bmtMb2FkaW5nLCBmdW5jdGlvbihlcnIpIHtcbiBcdFx0XHRcdGZpbmlzaENodW5rTG9hZGluZygpO1xuIFx0XHRcdFx0dGhyb3cgZXJyO1xuIFx0XHRcdH0pO1xuXG4gXHRcdFx0ZnVuY3Rpb24gZmluaXNoQ2h1bmtMb2FkaW5nKCkge1xuIFx0XHRcdFx0aG90Q2h1bmtzTG9hZGluZy0tO1xuIFx0XHRcdFx0aWYgKGhvdFN0YXR1cyA9PT0gXCJwcmVwYXJlXCIpIHtcbiBcdFx0XHRcdFx0aWYgKCFob3RXYWl0aW5nRmlsZXNNYXBbY2h1bmtJZF0pIHtcbiBcdFx0XHRcdFx0XHRob3RFbnN1cmVVcGRhdGVDaHVuayhjaHVua0lkKTtcbiBcdFx0XHRcdFx0fVxuIFx0XHRcdFx0XHRpZiAoaG90Q2h1bmtzTG9hZGluZyA9PT0gMCAmJiBob3RXYWl0aW5nRmlsZXMgPT09IDApIHtcbiBcdFx0XHRcdFx0XHRob3RVcGRhdGVEb3dubG9hZGVkKCk7XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdH1cbiBcdFx0XHR9XG4gXHRcdH07XG4gXHRcdGZuLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRcdGlmIChtb2RlICYgMSkgdmFsdWUgPSBmbih2YWx1ZSk7XG4gXHRcdFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18udCh2YWx1ZSwgbW9kZSAmIH4xKTtcbiBcdFx0fTtcbiBcdFx0cmV0dXJuIGZuO1xuIFx0fVxuXG4gXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiBcdGZ1bmN0aW9uIGhvdENyZWF0ZU1vZHVsZShtb2R1bGVJZCkge1xuIFx0XHR2YXIgaG90ID0ge1xuIFx0XHRcdC8vIHByaXZhdGUgc3R1ZmZcbiBcdFx0XHRfYWNjZXB0ZWREZXBlbmRlbmNpZXM6IHt9LFxuIFx0XHRcdF9kZWNsaW5lZERlcGVuZGVuY2llczoge30sXG4gXHRcdFx0X3NlbGZBY2NlcHRlZDogZmFsc2UsXG4gXHRcdFx0X3NlbGZEZWNsaW5lZDogZmFsc2UsXG4gXHRcdFx0X3NlbGZJbnZhbGlkYXRlZDogZmFsc2UsXG4gXHRcdFx0X2Rpc3Bvc2VIYW5kbGVyczogW10sXG4gXHRcdFx0X21haW46IGhvdEN1cnJlbnRDaGlsZE1vZHVsZSAhPT0gbW9kdWxlSWQsXG5cbiBcdFx0XHQvLyBNb2R1bGUgQVBJXG4gXHRcdFx0YWN0aXZlOiB0cnVlLFxuIFx0XHRcdGFjY2VwdDogZnVuY3Rpb24oZGVwLCBjYWxsYmFjaykge1xuIFx0XHRcdFx0aWYgKGRlcCA9PT0gdW5kZWZpbmVkKSBob3QuX3NlbGZBY2NlcHRlZCA9IHRydWU7XG4gXHRcdFx0XHRlbHNlIGlmICh0eXBlb2YgZGVwID09PSBcImZ1bmN0aW9uXCIpIGhvdC5fc2VsZkFjY2VwdGVkID0gZGVwO1xuIFx0XHRcdFx0ZWxzZSBpZiAodHlwZW9mIGRlcCA9PT0gXCJvYmplY3RcIilcbiBcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkZXAubGVuZ3RoOyBpKyspXG4gXHRcdFx0XHRcdFx0aG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1tkZXBbaV1dID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcbiBcdFx0XHRcdGVsc2UgaG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1tkZXBdID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcbiBcdFx0XHR9LFxuIFx0XHRcdGRlY2xpbmU6IGZ1bmN0aW9uKGRlcCkge1xuIFx0XHRcdFx0aWYgKGRlcCA9PT0gdW5kZWZpbmVkKSBob3QuX3NlbGZEZWNsaW5lZCA9IHRydWU7XG4gXHRcdFx0XHRlbHNlIGlmICh0eXBlb2YgZGVwID09PSBcIm9iamVjdFwiKVxuIFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRlcC5sZW5ndGg7IGkrKylcbiBcdFx0XHRcdFx0XHRob3QuX2RlY2xpbmVkRGVwZW5kZW5jaWVzW2RlcFtpXV0gPSB0cnVlO1xuIFx0XHRcdFx0ZWxzZSBob3QuX2RlY2xpbmVkRGVwZW5kZW5jaWVzW2RlcF0gPSB0cnVlO1xuIFx0XHRcdH0sXG4gXHRcdFx0ZGlzcG9zZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiBcdFx0XHRcdGhvdC5fZGlzcG9zZUhhbmRsZXJzLnB1c2goY2FsbGJhY2spO1xuIFx0XHRcdH0sXG4gXHRcdFx0YWRkRGlzcG9zZUhhbmRsZXI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gXHRcdFx0XHRob3QuX2Rpc3Bvc2VIYW5kbGVycy5wdXNoKGNhbGxiYWNrKTtcbiBcdFx0XHR9LFxuIFx0XHRcdHJlbW92ZURpc3Bvc2VIYW5kbGVyOiBmdW5jdGlvbihjYWxsYmFjaykge1xuIFx0XHRcdFx0dmFyIGlkeCA9IGhvdC5fZGlzcG9zZUhhbmRsZXJzLmluZGV4T2YoY2FsbGJhY2spO1xuIFx0XHRcdFx0aWYgKGlkeCA+PSAwKSBob3QuX2Rpc3Bvc2VIYW5kbGVycy5zcGxpY2UoaWR4LCAxKTtcbiBcdFx0XHR9LFxuIFx0XHRcdGludmFsaWRhdGU6IGZ1bmN0aW9uKCkge1xuIFx0XHRcdFx0dGhpcy5fc2VsZkludmFsaWRhdGVkID0gdHJ1ZTtcbiBcdFx0XHRcdHN3aXRjaCAoaG90U3RhdHVzKSB7XG4gXHRcdFx0XHRcdGNhc2UgXCJpZGxlXCI6XG4gXHRcdFx0XHRcdFx0aG90VXBkYXRlID0ge307XG4gXHRcdFx0XHRcdFx0aG90VXBkYXRlW21vZHVsZUlkXSA9IG1vZHVsZXNbbW9kdWxlSWRdO1xuIFx0XHRcdFx0XHRcdGhvdFNldFN0YXR1cyhcInJlYWR5XCIpO1xuIFx0XHRcdFx0XHRcdGJyZWFrO1xuIFx0XHRcdFx0XHRjYXNlIFwicmVhZHlcIjpcbiBcdFx0XHRcdFx0XHRob3RBcHBseUludmFsaWRhdGVkTW9kdWxlKG1vZHVsZUlkKTtcbiBcdFx0XHRcdFx0XHRicmVhaztcbiBcdFx0XHRcdFx0Y2FzZSBcInByZXBhcmVcIjpcbiBcdFx0XHRcdFx0Y2FzZSBcImNoZWNrXCI6XG4gXHRcdFx0XHRcdGNhc2UgXCJkaXNwb3NlXCI6XG4gXHRcdFx0XHRcdGNhc2UgXCJhcHBseVwiOlxuIFx0XHRcdFx0XHRcdChob3RRdWV1ZWRJbnZhbGlkYXRlZE1vZHVsZXMgPVxuIFx0XHRcdFx0XHRcdFx0aG90UXVldWVkSW52YWxpZGF0ZWRNb2R1bGVzIHx8IFtdKS5wdXNoKG1vZHVsZUlkKTtcbiBcdFx0XHRcdFx0XHRicmVhaztcbiBcdFx0XHRcdFx0ZGVmYXVsdDpcbiBcdFx0XHRcdFx0XHQvLyBpZ25vcmUgcmVxdWVzdHMgaW4gZXJyb3Igc3RhdGVzXG4gXHRcdFx0XHRcdFx0YnJlYWs7XG4gXHRcdFx0XHR9XG4gXHRcdFx0fSxcblxuIFx0XHRcdC8vIE1hbmFnZW1lbnQgQVBJXG4gXHRcdFx0Y2hlY2s6IGhvdENoZWNrLFxuIFx0XHRcdGFwcGx5OiBob3RBcHBseSxcbiBcdFx0XHRzdGF0dXM6IGZ1bmN0aW9uKGwpIHtcbiBcdFx0XHRcdGlmICghbCkgcmV0dXJuIGhvdFN0YXR1cztcbiBcdFx0XHRcdGhvdFN0YXR1c0hhbmRsZXJzLnB1c2gobCk7XG4gXHRcdFx0fSxcbiBcdFx0XHRhZGRTdGF0dXNIYW5kbGVyOiBmdW5jdGlvbihsKSB7XG4gXHRcdFx0XHRob3RTdGF0dXNIYW5kbGVycy5wdXNoKGwpO1xuIFx0XHRcdH0sXG4gXHRcdFx0cmVtb3ZlU3RhdHVzSGFuZGxlcjogZnVuY3Rpb24obCkge1xuIFx0XHRcdFx0dmFyIGlkeCA9IGhvdFN0YXR1c0hhbmRsZXJzLmluZGV4T2YobCk7XG4gXHRcdFx0XHRpZiAoaWR4ID49IDApIGhvdFN0YXR1c0hhbmRsZXJzLnNwbGljZShpZHgsIDEpO1xuIFx0XHRcdH0sXG5cbiBcdFx0XHQvL2luaGVyaXQgZnJvbSBwcmV2aW91cyBkaXNwb3NlIGNhbGxcbiBcdFx0XHRkYXRhOiBob3RDdXJyZW50TW9kdWxlRGF0YVttb2R1bGVJZF1cbiBcdFx0fTtcbiBcdFx0aG90Q3VycmVudENoaWxkTW9kdWxlID0gdW5kZWZpbmVkO1xuIFx0XHRyZXR1cm4gaG90O1xuIFx0fVxuXG4gXHR2YXIgaG90U3RhdHVzSGFuZGxlcnMgPSBbXTtcbiBcdHZhciBob3RTdGF0dXMgPSBcImlkbGVcIjtcblxuIFx0ZnVuY3Rpb24gaG90U2V0U3RhdHVzKG5ld1N0YXR1cykge1xuIFx0XHRob3RTdGF0dXMgPSBuZXdTdGF0dXM7XG4gXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaG90U3RhdHVzSGFuZGxlcnMubGVuZ3RoOyBpKyspXG4gXHRcdFx0aG90U3RhdHVzSGFuZGxlcnNbaV0uY2FsbChudWxsLCBuZXdTdGF0dXMpO1xuIFx0fVxuXG4gXHQvLyB3aGlsZSBkb3dubG9hZGluZ1xuIFx0dmFyIGhvdFdhaXRpbmdGaWxlcyA9IDA7XG4gXHR2YXIgaG90Q2h1bmtzTG9hZGluZyA9IDA7XG4gXHR2YXIgaG90V2FpdGluZ0ZpbGVzTWFwID0ge307XG4gXHR2YXIgaG90UmVxdWVzdGVkRmlsZXNNYXAgPSB7fTtcbiBcdHZhciBob3RBdmFpbGFibGVGaWxlc01hcCA9IHt9O1xuIFx0dmFyIGhvdERlZmVycmVkO1xuXG4gXHQvLyBUaGUgdXBkYXRlIGluZm9cbiBcdHZhciBob3RVcGRhdGUsIGhvdFVwZGF0ZU5ld0hhc2gsIGhvdFF1ZXVlZEludmFsaWRhdGVkTW9kdWxlcztcblxuIFx0ZnVuY3Rpb24gdG9Nb2R1bGVJZChpZCkge1xuIFx0XHR2YXIgaXNOdW1iZXIgPSAraWQgKyBcIlwiID09PSBpZDtcbiBcdFx0cmV0dXJuIGlzTnVtYmVyID8gK2lkIDogaWQ7XG4gXHR9XG5cbiBcdGZ1bmN0aW9uIGhvdENoZWNrKGFwcGx5KSB7XG4gXHRcdGlmIChob3RTdGF0dXMgIT09IFwiaWRsZVwiKSB7XG4gXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiY2hlY2soKSBpcyBvbmx5IGFsbG93ZWQgaW4gaWRsZSBzdGF0dXNcIik7XG4gXHRcdH1cbiBcdFx0aG90QXBwbHlPblVwZGF0ZSA9IGFwcGx5O1xuIFx0XHRob3RTZXRTdGF0dXMoXCJjaGVja1wiKTtcbiBcdFx0cmV0dXJuIGhvdERvd25sb2FkTWFuaWZlc3QoaG90UmVxdWVzdFRpbWVvdXQpLnRoZW4oZnVuY3Rpb24odXBkYXRlKSB7XG4gXHRcdFx0aWYgKCF1cGRhdGUpIHtcbiBcdFx0XHRcdGhvdFNldFN0YXR1cyhob3RBcHBseUludmFsaWRhdGVkTW9kdWxlcygpID8gXCJyZWFkeVwiIDogXCJpZGxlXCIpO1xuIFx0XHRcdFx0cmV0dXJuIG51bGw7XG4gXHRcdFx0fVxuIFx0XHRcdGhvdFJlcXVlc3RlZEZpbGVzTWFwID0ge307XG4gXHRcdFx0aG90V2FpdGluZ0ZpbGVzTWFwID0ge307XG4gXHRcdFx0aG90QXZhaWxhYmxlRmlsZXNNYXAgPSB1cGRhdGUuYztcbiBcdFx0XHRob3RVcGRhdGVOZXdIYXNoID0gdXBkYXRlLmg7XG5cbiBcdFx0XHRob3RTZXRTdGF0dXMoXCJwcmVwYXJlXCIpO1xuIFx0XHRcdHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gXHRcdFx0XHRob3REZWZlcnJlZCA9IHtcbiBcdFx0XHRcdFx0cmVzb2x2ZTogcmVzb2x2ZSxcbiBcdFx0XHRcdFx0cmVqZWN0OiByZWplY3RcbiBcdFx0XHRcdH07XG4gXHRcdFx0fSk7XG4gXHRcdFx0aG90VXBkYXRlID0ge307XG4gXHRcdFx0dmFyIGNodW5rSWQgPSBcIm1haW5cIjtcbiBcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbiBcdFx0XHR7XG4gXHRcdFx0XHRob3RFbnN1cmVVcGRhdGVDaHVuayhjaHVua0lkKTtcbiBcdFx0XHR9XG4gXHRcdFx0aWYgKFxuIFx0XHRcdFx0aG90U3RhdHVzID09PSBcInByZXBhcmVcIiAmJlxuIFx0XHRcdFx0aG90Q2h1bmtzTG9hZGluZyA9PT0gMCAmJlxuIFx0XHRcdFx0aG90V2FpdGluZ0ZpbGVzID09PSAwXG4gXHRcdFx0KSB7XG4gXHRcdFx0XHRob3RVcGRhdGVEb3dubG9hZGVkKCk7XG4gXHRcdFx0fVxuIFx0XHRcdHJldHVybiBwcm9taXNlO1xuIFx0XHR9KTtcbiBcdH1cblxuIFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gXHRmdW5jdGlvbiBob3RBZGRVcGRhdGVDaHVuayhjaHVua0lkLCBtb3JlTW9kdWxlcykge1xuIFx0XHRpZiAoIWhvdEF2YWlsYWJsZUZpbGVzTWFwW2NodW5rSWRdIHx8ICFob3RSZXF1ZXN0ZWRGaWxlc01hcFtjaHVua0lkXSlcbiBcdFx0XHRyZXR1cm47XG4gXHRcdGhvdFJlcXVlc3RlZEZpbGVzTWFwW2NodW5rSWRdID0gZmFsc2U7XG4gXHRcdGZvciAodmFyIG1vZHVsZUlkIGluIG1vcmVNb2R1bGVzKSB7XG4gXHRcdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3JlTW9kdWxlcywgbW9kdWxlSWQpKSB7XG4gXHRcdFx0XHRob3RVcGRhdGVbbW9kdWxlSWRdID0gbW9yZU1vZHVsZXNbbW9kdWxlSWRdO1xuIFx0XHRcdH1cbiBcdFx0fVxuIFx0XHRpZiAoLS1ob3RXYWl0aW5nRmlsZXMgPT09IDAgJiYgaG90Q2h1bmtzTG9hZGluZyA9PT0gMCkge1xuIFx0XHRcdGhvdFVwZGF0ZURvd25sb2FkZWQoKTtcbiBcdFx0fVxuIFx0fVxuXG4gXHRmdW5jdGlvbiBob3RFbnN1cmVVcGRhdGVDaHVuayhjaHVua0lkKSB7XG4gXHRcdGlmICghaG90QXZhaWxhYmxlRmlsZXNNYXBbY2h1bmtJZF0pIHtcbiBcdFx0XHRob3RXYWl0aW5nRmlsZXNNYXBbY2h1bmtJZF0gPSB0cnVlO1xuIFx0XHR9IGVsc2Uge1xuIFx0XHRcdGhvdFJlcXVlc3RlZEZpbGVzTWFwW2NodW5rSWRdID0gdHJ1ZTtcbiBcdFx0XHRob3RXYWl0aW5nRmlsZXMrKztcbiBcdFx0XHRob3REb3dubG9hZFVwZGF0ZUNodW5rKGNodW5rSWQpO1xuIFx0XHR9XG4gXHR9XG5cbiBcdGZ1bmN0aW9uIGhvdFVwZGF0ZURvd25sb2FkZWQoKSB7XG4gXHRcdGhvdFNldFN0YXR1cyhcInJlYWR5XCIpO1xuIFx0XHR2YXIgZGVmZXJyZWQgPSBob3REZWZlcnJlZDtcbiBcdFx0aG90RGVmZXJyZWQgPSBudWxsO1xuIFx0XHRpZiAoIWRlZmVycmVkKSByZXR1cm47XG4gXHRcdGlmIChob3RBcHBseU9uVXBkYXRlKSB7XG4gXHRcdFx0Ly8gV3JhcCBkZWZlcnJlZCBvYmplY3QgaW4gUHJvbWlzZSB0byBtYXJrIGl0IGFzIGEgd2VsbC1oYW5kbGVkIFByb21pc2UgdG9cbiBcdFx0XHQvLyBhdm9pZCB0cmlnZ2VyaW5nIHVuY2F1Z2h0IGV4Y2VwdGlvbiB3YXJuaW5nIGluIENocm9tZS5cbiBcdFx0XHQvLyBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDY1NjY2XG4gXHRcdFx0UHJvbWlzZS5yZXNvbHZlKClcbiBcdFx0XHRcdC50aGVuKGZ1bmN0aW9uKCkge1xuIFx0XHRcdFx0XHRyZXR1cm4gaG90QXBwbHkoaG90QXBwbHlPblVwZGF0ZSk7XG4gXHRcdFx0XHR9KVxuIFx0XHRcdFx0LnRoZW4oXG4gXHRcdFx0XHRcdGZ1bmN0aW9uKHJlc3VsdCkge1xuIFx0XHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmUocmVzdWx0KTtcbiBcdFx0XHRcdFx0fSxcbiBcdFx0XHRcdFx0ZnVuY3Rpb24oZXJyKSB7XG4gXHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0KGVycik7XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdCk7XG4gXHRcdH0gZWxzZSB7XG4gXHRcdFx0dmFyIG91dGRhdGVkTW9kdWxlcyA9IFtdO1xuIFx0XHRcdGZvciAodmFyIGlkIGluIGhvdFVwZGF0ZSkge1xuIFx0XHRcdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChob3RVcGRhdGUsIGlkKSkge1xuIFx0XHRcdFx0XHRvdXRkYXRlZE1vZHVsZXMucHVzaCh0b01vZHVsZUlkKGlkKSk7XG4gXHRcdFx0XHR9XG4gXHRcdFx0fVxuIFx0XHRcdGRlZmVycmVkLnJlc29sdmUob3V0ZGF0ZWRNb2R1bGVzKTtcbiBcdFx0fVxuIFx0fVxuXG4gXHRmdW5jdGlvbiBob3RBcHBseShvcHRpb25zKSB7XG4gXHRcdGlmIChob3RTdGF0dXMgIT09IFwicmVhZHlcIilcbiBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJhcHBseSgpIGlzIG9ubHkgYWxsb3dlZCBpbiByZWFkeSBzdGF0dXNcIik7XG4gXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuIFx0XHRyZXR1cm4gaG90QXBwbHlJbnRlcm5hbChvcHRpb25zKTtcbiBcdH1cblxuIFx0ZnVuY3Rpb24gaG90QXBwbHlJbnRlcm5hbChvcHRpb25zKSB7XG4gXHRcdGhvdEFwcGx5SW52YWxpZGF0ZWRNb2R1bGVzKCk7XG5cbiBcdFx0dmFyIGNiO1xuIFx0XHR2YXIgaTtcbiBcdFx0dmFyIGo7XG4gXHRcdHZhciBtb2R1bGU7XG4gXHRcdHZhciBtb2R1bGVJZDtcblxuIFx0XHRmdW5jdGlvbiBnZXRBZmZlY3RlZFN0dWZmKHVwZGF0ZU1vZHVsZUlkKSB7XG4gXHRcdFx0dmFyIG91dGRhdGVkTW9kdWxlcyA9IFt1cGRhdGVNb2R1bGVJZF07XG4gXHRcdFx0dmFyIG91dGRhdGVkRGVwZW5kZW5jaWVzID0ge307XG5cbiBcdFx0XHR2YXIgcXVldWUgPSBvdXRkYXRlZE1vZHVsZXMubWFwKGZ1bmN0aW9uKGlkKSB7XG4gXHRcdFx0XHRyZXR1cm4ge1xuIFx0XHRcdFx0XHRjaGFpbjogW2lkXSxcbiBcdFx0XHRcdFx0aWQ6IGlkXG4gXHRcdFx0XHR9O1xuIFx0XHRcdH0pO1xuIFx0XHRcdHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gXHRcdFx0XHR2YXIgcXVldWVJdGVtID0gcXVldWUucG9wKCk7XG4gXHRcdFx0XHR2YXIgbW9kdWxlSWQgPSBxdWV1ZUl0ZW0uaWQ7XG4gXHRcdFx0XHR2YXIgY2hhaW4gPSBxdWV1ZUl0ZW0uY2hhaW47XG4gXHRcdFx0XHRtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcbiBcdFx0XHRcdGlmIChcbiBcdFx0XHRcdFx0IW1vZHVsZSB8fFxuIFx0XHRcdFx0XHQobW9kdWxlLmhvdC5fc2VsZkFjY2VwdGVkICYmICFtb2R1bGUuaG90Ll9zZWxmSW52YWxpZGF0ZWQpXG4gXHRcdFx0XHQpXG4gXHRcdFx0XHRcdGNvbnRpbnVlO1xuIFx0XHRcdFx0aWYgKG1vZHVsZS5ob3QuX3NlbGZEZWNsaW5lZCkge1xuIFx0XHRcdFx0XHRyZXR1cm4ge1xuIFx0XHRcdFx0XHRcdHR5cGU6IFwic2VsZi1kZWNsaW5lZFwiLFxuIFx0XHRcdFx0XHRcdGNoYWluOiBjaGFpbixcbiBcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWRcbiBcdFx0XHRcdFx0fTtcbiBcdFx0XHRcdH1cbiBcdFx0XHRcdGlmIChtb2R1bGUuaG90Ll9tYWluKSB7XG4gXHRcdFx0XHRcdHJldHVybiB7XG4gXHRcdFx0XHRcdFx0dHlwZTogXCJ1bmFjY2VwdGVkXCIsXG4gXHRcdFx0XHRcdFx0Y2hhaW46IGNoYWluLFxuIFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZFxuIFx0XHRcdFx0XHR9O1xuIFx0XHRcdFx0fVxuIFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtb2R1bGUucGFyZW50cy5sZW5ndGg7IGkrKykge1xuIFx0XHRcdFx0XHR2YXIgcGFyZW50SWQgPSBtb2R1bGUucGFyZW50c1tpXTtcbiBcdFx0XHRcdFx0dmFyIHBhcmVudCA9IGluc3RhbGxlZE1vZHVsZXNbcGFyZW50SWRdO1xuIFx0XHRcdFx0XHRpZiAoIXBhcmVudCkgY29udGludWU7XG4gXHRcdFx0XHRcdGlmIChwYXJlbnQuaG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRcdFx0XHRyZXR1cm4ge1xuIFx0XHRcdFx0XHRcdFx0dHlwZTogXCJkZWNsaW5lZFwiLFxuIFx0XHRcdFx0XHRcdFx0Y2hhaW46IGNoYWluLmNvbmNhdChbcGFyZW50SWRdKSxcbiBcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZCxcbiBcdFx0XHRcdFx0XHRcdHBhcmVudElkOiBwYXJlbnRJZFxuIFx0XHRcdFx0XHRcdH07XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdFx0aWYgKG91dGRhdGVkTW9kdWxlcy5pbmRleE9mKHBhcmVudElkKSAhPT0gLTEpIGNvbnRpbnVlO1xuIFx0XHRcdFx0XHRpZiAocGFyZW50LmhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0XHRcdFx0aWYgKCFvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0pXG4gXHRcdFx0XHRcdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0gPSBbXTtcbiBcdFx0XHRcdFx0XHRhZGRBbGxUb1NldChvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0sIFttb2R1bGVJZF0pO1xuIFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdGRlbGV0ZSBvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF07XG4gXHRcdFx0XHRcdG91dGRhdGVkTW9kdWxlcy5wdXNoKHBhcmVudElkKTtcbiBcdFx0XHRcdFx0cXVldWUucHVzaCh7XG4gXHRcdFx0XHRcdFx0Y2hhaW46IGNoYWluLmNvbmNhdChbcGFyZW50SWRdKSxcbiBcdFx0XHRcdFx0XHRpZDogcGFyZW50SWRcbiBcdFx0XHRcdFx0fSk7XG4gXHRcdFx0XHR9XG4gXHRcdFx0fVxuXG4gXHRcdFx0cmV0dXJuIHtcbiBcdFx0XHRcdHR5cGU6IFwiYWNjZXB0ZWRcIixcbiBcdFx0XHRcdG1vZHVsZUlkOiB1cGRhdGVNb2R1bGVJZCxcbiBcdFx0XHRcdG91dGRhdGVkTW9kdWxlczogb3V0ZGF0ZWRNb2R1bGVzLFxuIFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXM6IG91dGRhdGVkRGVwZW5kZW5jaWVzXG4gXHRcdFx0fTtcbiBcdFx0fVxuXG4gXHRcdGZ1bmN0aW9uIGFkZEFsbFRvU2V0KGEsIGIpIHtcbiBcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiBcdFx0XHRcdHZhciBpdGVtID0gYltpXTtcbiBcdFx0XHRcdGlmIChhLmluZGV4T2YoaXRlbSkgPT09IC0xKSBhLnB1c2goaXRlbSk7XG4gXHRcdFx0fVxuIFx0XHR9XG5cbiBcdFx0Ly8gYXQgYmVnaW4gYWxsIHVwZGF0ZXMgbW9kdWxlcyBhcmUgb3V0ZGF0ZWRcbiBcdFx0Ly8gdGhlIFwib3V0ZGF0ZWRcIiBzdGF0dXMgY2FuIHByb3BhZ2F0ZSB0byBwYXJlbnRzIGlmIHRoZXkgZG9uJ3QgYWNjZXB0IHRoZSBjaGlsZHJlblxuIFx0XHR2YXIgb3V0ZGF0ZWREZXBlbmRlbmNpZXMgPSB7fTtcbiBcdFx0dmFyIG91dGRhdGVkTW9kdWxlcyA9IFtdO1xuIFx0XHR2YXIgYXBwbGllZFVwZGF0ZSA9IHt9O1xuXG4gXHRcdHZhciB3YXJuVW5leHBlY3RlZFJlcXVpcmUgPSBmdW5jdGlvbiB3YXJuVW5leHBlY3RlZFJlcXVpcmUoKSB7XG4gXHRcdFx0Y29uc29sZS53YXJuKFxuIFx0XHRcdFx0XCJbSE1SXSB1bmV4cGVjdGVkIHJlcXVpcmUoXCIgKyByZXN1bHQubW9kdWxlSWQgKyBcIikgdG8gZGlzcG9zZWQgbW9kdWxlXCJcbiBcdFx0XHQpO1xuIFx0XHR9O1xuXG4gXHRcdGZvciAodmFyIGlkIGluIGhvdFVwZGF0ZSkge1xuIFx0XHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaG90VXBkYXRlLCBpZCkpIHtcbiBcdFx0XHRcdG1vZHVsZUlkID0gdG9Nb2R1bGVJZChpZCk7XG4gXHRcdFx0XHQvKiogQHR5cGUge1RPRE99ICovXG4gXHRcdFx0XHR2YXIgcmVzdWx0O1xuIFx0XHRcdFx0aWYgKGhvdFVwZGF0ZVtpZF0pIHtcbiBcdFx0XHRcdFx0cmVzdWx0ID0gZ2V0QWZmZWN0ZWRTdHVmZihtb2R1bGVJZCk7XG4gXHRcdFx0XHR9IGVsc2Uge1xuIFx0XHRcdFx0XHRyZXN1bHQgPSB7XG4gXHRcdFx0XHRcdFx0dHlwZTogXCJkaXNwb3NlZFwiLFxuIFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBpZFxuIFx0XHRcdFx0XHR9O1xuIFx0XHRcdFx0fVxuIFx0XHRcdFx0LyoqIEB0eXBlIHtFcnJvcnxmYWxzZX0gKi9cbiBcdFx0XHRcdHZhciBhYm9ydEVycm9yID0gZmFsc2U7XG4gXHRcdFx0XHR2YXIgZG9BcHBseSA9IGZhbHNlO1xuIFx0XHRcdFx0dmFyIGRvRGlzcG9zZSA9IGZhbHNlO1xuIFx0XHRcdFx0dmFyIGNoYWluSW5mbyA9IFwiXCI7XG4gXHRcdFx0XHRpZiAocmVzdWx0LmNoYWluKSB7XG4gXHRcdFx0XHRcdGNoYWluSW5mbyA9IFwiXFxuVXBkYXRlIHByb3BhZ2F0aW9uOiBcIiArIHJlc3VsdC5jaGFpbi5qb2luKFwiIC0+IFwiKTtcbiBcdFx0XHRcdH1cbiBcdFx0XHRcdHN3aXRjaCAocmVzdWx0LnR5cGUpIHtcbiBcdFx0XHRcdFx0Y2FzZSBcInNlbGYtZGVjbGluZWRcIjpcbiBcdFx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkRlY2xpbmVkKSBvcHRpb25zLm9uRGVjbGluZWQocmVzdWx0KTtcbiBcdFx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlRGVjbGluZWQpXG4gXHRcdFx0XHRcdFx0XHRhYm9ydEVycm9yID0gbmV3IEVycm9yKFxuIFx0XHRcdFx0XHRcdFx0XHRcIkFib3J0ZWQgYmVjYXVzZSBvZiBzZWxmIGRlY2xpbmU6IFwiICtcbiBcdFx0XHRcdFx0XHRcdFx0XHRyZXN1bHQubW9kdWxlSWQgK1xuIFx0XHRcdFx0XHRcdFx0XHRcdGNoYWluSW5mb1xuIFx0XHRcdFx0XHRcdFx0KTtcbiBcdFx0XHRcdFx0XHRicmVhaztcbiBcdFx0XHRcdFx0Y2FzZSBcImRlY2xpbmVkXCI6XG4gXHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMub25EZWNsaW5lZCkgb3B0aW9ucy5vbkRlY2xpbmVkKHJlc3VsdCk7XG4gXHRcdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZURlY2xpbmVkKVxuIFx0XHRcdFx0XHRcdFx0YWJvcnRFcnJvciA9IG5ldyBFcnJvcihcbiBcdFx0XHRcdFx0XHRcdFx0XCJBYm9ydGVkIGJlY2F1c2Ugb2YgZGVjbGluZWQgZGVwZW5kZW5jeTogXCIgK1xuIFx0XHRcdFx0XHRcdFx0XHRcdHJlc3VsdC5tb2R1bGVJZCArXG4gXHRcdFx0XHRcdFx0XHRcdFx0XCIgaW4gXCIgK1xuIFx0XHRcdFx0XHRcdFx0XHRcdHJlc3VsdC5wYXJlbnRJZCArXG4gXHRcdFx0XHRcdFx0XHRcdFx0Y2hhaW5JbmZvXG4gXHRcdFx0XHRcdFx0XHQpO1xuIFx0XHRcdFx0XHRcdGJyZWFrO1xuIFx0XHRcdFx0XHRjYXNlIFwidW5hY2NlcHRlZFwiOlxuIFx0XHRcdFx0XHRcdGlmIChvcHRpb25zLm9uVW5hY2NlcHRlZCkgb3B0aW9ucy5vblVuYWNjZXB0ZWQocmVzdWx0KTtcbiBcdFx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlVW5hY2NlcHRlZClcbiBcdFx0XHRcdFx0XHRcdGFib3J0RXJyb3IgPSBuZXcgRXJyb3IoXG4gXHRcdFx0XHRcdFx0XHRcdFwiQWJvcnRlZCBiZWNhdXNlIFwiICsgbW9kdWxlSWQgKyBcIiBpcyBub3QgYWNjZXB0ZWRcIiArIGNoYWluSW5mb1xuIFx0XHRcdFx0XHRcdFx0KTtcbiBcdFx0XHRcdFx0XHRicmVhaztcbiBcdFx0XHRcdFx0Y2FzZSBcImFjY2VwdGVkXCI6XG4gXHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMub25BY2NlcHRlZCkgb3B0aW9ucy5vbkFjY2VwdGVkKHJlc3VsdCk7XG4gXHRcdFx0XHRcdFx0ZG9BcHBseSA9IHRydWU7XG4gXHRcdFx0XHRcdFx0YnJlYWs7XG4gXHRcdFx0XHRcdGNhc2UgXCJkaXNwb3NlZFwiOlxuIFx0XHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRGlzcG9zZWQpIG9wdGlvbnMub25EaXNwb3NlZChyZXN1bHQpO1xuIFx0XHRcdFx0XHRcdGRvRGlzcG9zZSA9IHRydWU7XG4gXHRcdFx0XHRcdFx0YnJlYWs7XG4gXHRcdFx0XHRcdGRlZmF1bHQ6XG4gXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5leGNlcHRpb24gdHlwZSBcIiArIHJlc3VsdC50eXBlKTtcbiBcdFx0XHRcdH1cbiBcdFx0XHRcdGlmIChhYm9ydEVycm9yKSB7XG4gXHRcdFx0XHRcdGhvdFNldFN0YXR1cyhcImFib3J0XCIpO1xuIFx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QoYWJvcnRFcnJvcik7XG4gXHRcdFx0XHR9XG4gXHRcdFx0XHRpZiAoZG9BcHBseSkge1xuIFx0XHRcdFx0XHRhcHBsaWVkVXBkYXRlW21vZHVsZUlkXSA9IGhvdFVwZGF0ZVttb2R1bGVJZF07XG4gXHRcdFx0XHRcdGFkZEFsbFRvU2V0KG91dGRhdGVkTW9kdWxlcywgcmVzdWx0Lm91dGRhdGVkTW9kdWxlcyk7XG4gXHRcdFx0XHRcdGZvciAobW9kdWxlSWQgaW4gcmVzdWx0Lm91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XG4gXHRcdFx0XHRcdFx0aWYgKFxuIFx0XHRcdFx0XHRcdFx0T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKFxuIFx0XHRcdFx0XHRcdFx0XHRyZXN1bHQub3V0ZGF0ZWREZXBlbmRlbmNpZXMsXG4gXHRcdFx0XHRcdFx0XHRcdG1vZHVsZUlkXG4gXHRcdFx0XHRcdFx0XHQpXG4gXHRcdFx0XHRcdFx0KSB7XG4gXHRcdFx0XHRcdFx0XHRpZiAoIW91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSlcbiBcdFx0XHRcdFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdID0gW107XG4gXHRcdFx0XHRcdFx0XHRhZGRBbGxUb1NldChcbiBcdFx0XHRcdFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdLFxuIFx0XHRcdFx0XHRcdFx0XHRyZXN1bHQub3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdXG4gXHRcdFx0XHRcdFx0XHQpO1xuIFx0XHRcdFx0XHRcdH1cbiBcdFx0XHRcdFx0fVxuIFx0XHRcdFx0fVxuIFx0XHRcdFx0aWYgKGRvRGlzcG9zZSkge1xuIFx0XHRcdFx0XHRhZGRBbGxUb1NldChvdXRkYXRlZE1vZHVsZXMsIFtyZXN1bHQubW9kdWxlSWRdKTtcbiBcdFx0XHRcdFx0YXBwbGllZFVwZGF0ZVttb2R1bGVJZF0gPSB3YXJuVW5leHBlY3RlZFJlcXVpcmU7XG4gXHRcdFx0XHR9XG4gXHRcdFx0fVxuIFx0XHR9XG5cbiBcdFx0Ly8gU3RvcmUgc2VsZiBhY2NlcHRlZCBvdXRkYXRlZCBtb2R1bGVzIHRvIHJlcXVpcmUgdGhlbSBsYXRlciBieSB0aGUgbW9kdWxlIHN5c3RlbVxuIFx0XHR2YXIgb3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzID0gW107XG4gXHRcdGZvciAoaSA9IDA7IGkgPCBvdXRkYXRlZE1vZHVsZXMubGVuZ3RoOyBpKyspIHtcbiBcdFx0XHRtb2R1bGVJZCA9IG91dGRhdGVkTW9kdWxlc1tpXTtcbiBcdFx0XHRpZiAoXG4gXHRcdFx0XHRpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSAmJlxuIFx0XHRcdFx0aW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uaG90Ll9zZWxmQWNjZXB0ZWQgJiZcbiBcdFx0XHRcdC8vIHJlbW92ZWQgc2VsZi1hY2NlcHRlZCBtb2R1bGVzIHNob3VsZCBub3QgYmUgcmVxdWlyZWRcbiBcdFx0XHRcdGFwcGxpZWRVcGRhdGVbbW9kdWxlSWRdICE9PSB3YXJuVW5leHBlY3RlZFJlcXVpcmUgJiZcbiBcdFx0XHRcdC8vIHdoZW4gY2FsbGVkIGludmFsaWRhdGUgc2VsZi1hY2NlcHRpbmcgaXMgbm90IHBvc3NpYmxlXG4gXHRcdFx0XHQhaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uaG90Ll9zZWxmSW52YWxpZGF0ZWRcbiBcdFx0XHQpIHtcbiBcdFx0XHRcdG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcy5wdXNoKHtcbiBcdFx0XHRcdFx0bW9kdWxlOiBtb2R1bGVJZCxcbiBcdFx0XHRcdFx0cGFyZW50czogaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0ucGFyZW50cy5zbGljZSgpLFxuIFx0XHRcdFx0XHRlcnJvckhhbmRsZXI6IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmhvdC5fc2VsZkFjY2VwdGVkXG4gXHRcdFx0XHR9KTtcbiBcdFx0XHR9XG4gXHRcdH1cblxuIFx0XHQvLyBOb3cgaW4gXCJkaXNwb3NlXCIgcGhhc2VcbiBcdFx0aG90U2V0U3RhdHVzKFwiZGlzcG9zZVwiKTtcbiBcdFx0T2JqZWN0LmtleXMoaG90QXZhaWxhYmxlRmlsZXNNYXApLmZvckVhY2goZnVuY3Rpb24oY2h1bmtJZCkge1xuIFx0XHRcdGlmIChob3RBdmFpbGFibGVGaWxlc01hcFtjaHVua0lkXSA9PT0gZmFsc2UpIHtcbiBcdFx0XHRcdGhvdERpc3Bvc2VDaHVuayhjaHVua0lkKTtcbiBcdFx0XHR9XG4gXHRcdH0pO1xuXG4gXHRcdHZhciBpZHg7XG4gXHRcdHZhciBxdWV1ZSA9IG91dGRhdGVkTW9kdWxlcy5zbGljZSgpO1xuIFx0XHR3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuIFx0XHRcdG1vZHVsZUlkID0gcXVldWUucG9wKCk7XG4gXHRcdFx0bW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XG4gXHRcdFx0aWYgKCFtb2R1bGUpIGNvbnRpbnVlO1xuXG4gXHRcdFx0dmFyIGRhdGEgPSB7fTtcblxuIFx0XHRcdC8vIENhbGwgZGlzcG9zZSBoYW5kbGVyc1xuIFx0XHRcdHZhciBkaXNwb3NlSGFuZGxlcnMgPSBtb2R1bGUuaG90Ll9kaXNwb3NlSGFuZGxlcnM7XG4gXHRcdFx0Zm9yIChqID0gMDsgaiA8IGRpc3Bvc2VIYW5kbGVycy5sZW5ndGg7IGorKykge1xuIFx0XHRcdFx0Y2IgPSBkaXNwb3NlSGFuZGxlcnNbal07XG4gXHRcdFx0XHRjYihkYXRhKTtcbiBcdFx0XHR9XG4gXHRcdFx0aG90Q3VycmVudE1vZHVsZURhdGFbbW9kdWxlSWRdID0gZGF0YTtcblxuIFx0XHRcdC8vIGRpc2FibGUgbW9kdWxlICh0aGlzIGRpc2FibGVzIHJlcXVpcmVzIGZyb20gdGhpcyBtb2R1bGUpXG4gXHRcdFx0bW9kdWxlLmhvdC5hY3RpdmUgPSBmYWxzZTtcblxuIFx0XHRcdC8vIHJlbW92ZSBtb2R1bGUgZnJvbSBjYWNoZVxuIFx0XHRcdGRlbGV0ZSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcblxuIFx0XHRcdC8vIHdoZW4gZGlzcG9zaW5nIHRoZXJlIGlzIG5vIG5lZWQgdG8gY2FsbCBkaXNwb3NlIGhhbmRsZXJcbiBcdFx0XHRkZWxldGUgb3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdO1xuXG4gXHRcdFx0Ly8gcmVtb3ZlIFwicGFyZW50c1wiIHJlZmVyZW5jZXMgZnJvbSBhbGwgY2hpbGRyZW5cbiBcdFx0XHRmb3IgKGogPSAwOyBqIDwgbW9kdWxlLmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gXHRcdFx0XHR2YXIgY2hpbGQgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZS5jaGlsZHJlbltqXV07XG4gXHRcdFx0XHRpZiAoIWNoaWxkKSBjb250aW51ZTtcbiBcdFx0XHRcdGlkeCA9IGNoaWxkLnBhcmVudHMuaW5kZXhPZihtb2R1bGVJZCk7XG4gXHRcdFx0XHRpZiAoaWR4ID49IDApIHtcbiBcdFx0XHRcdFx0Y2hpbGQucGFyZW50cy5zcGxpY2UoaWR4LCAxKTtcbiBcdFx0XHRcdH1cbiBcdFx0XHR9XG4gXHRcdH1cblxuIFx0XHQvLyByZW1vdmUgb3V0ZGF0ZWQgZGVwZW5kZW5jeSBmcm9tIG1vZHVsZSBjaGlsZHJlblxuIFx0XHR2YXIgZGVwZW5kZW5jeTtcbiBcdFx0dmFyIG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzO1xuIFx0XHRmb3IgKG1vZHVsZUlkIGluIG91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XG4gXHRcdFx0aWYgKFxuIFx0XHRcdFx0T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG91dGRhdGVkRGVwZW5kZW5jaWVzLCBtb2R1bGVJZClcbiBcdFx0XHQpIHtcbiBcdFx0XHRcdG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xuIFx0XHRcdFx0aWYgKG1vZHVsZSkge1xuIFx0XHRcdFx0XHRtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcyA9IG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXTtcbiBcdFx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzLmxlbmd0aDsgaisrKSB7XG4gXHRcdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzW2pdO1xuIFx0XHRcdFx0XHRcdGlkeCA9IG1vZHVsZS5jaGlsZHJlbi5pbmRleE9mKGRlcGVuZGVuY3kpO1xuIFx0XHRcdFx0XHRcdGlmIChpZHggPj0gMCkgbW9kdWxlLmNoaWxkcmVuLnNwbGljZShpZHgsIDEpO1xuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHR9XG4gXHRcdFx0fVxuIFx0XHR9XG5cbiBcdFx0Ly8gTm93IGluIFwiYXBwbHlcIiBwaGFzZVxuIFx0XHRob3RTZXRTdGF0dXMoXCJhcHBseVwiKTtcblxuIFx0XHRpZiAoaG90VXBkYXRlTmV3SGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gXHRcdFx0aG90Q3VycmVudEhhc2ggPSBob3RVcGRhdGVOZXdIYXNoO1xuIFx0XHRcdGhvdFVwZGF0ZU5ld0hhc2ggPSB1bmRlZmluZWQ7XG4gXHRcdH1cbiBcdFx0aG90VXBkYXRlID0gdW5kZWZpbmVkO1xuXG4gXHRcdC8vIGluc2VydCBuZXcgY29kZVxuIFx0XHRmb3IgKG1vZHVsZUlkIGluIGFwcGxpZWRVcGRhdGUpIHtcbiBcdFx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcGxpZWRVcGRhdGUsIG1vZHVsZUlkKSkge1xuIFx0XHRcdFx0bW9kdWxlc1ttb2R1bGVJZF0gPSBhcHBsaWVkVXBkYXRlW21vZHVsZUlkXTtcbiBcdFx0XHR9XG4gXHRcdH1cblxuIFx0XHQvLyBjYWxsIGFjY2VwdCBoYW5kbGVyc1xuIFx0XHR2YXIgZXJyb3IgPSBudWxsO1xuIFx0XHRmb3IgKG1vZHVsZUlkIGluIG91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XG4gXHRcdFx0aWYgKFxuIFx0XHRcdFx0T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG91dGRhdGVkRGVwZW5kZW5jaWVzLCBtb2R1bGVJZClcbiBcdFx0XHQpIHtcbiBcdFx0XHRcdG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xuIFx0XHRcdFx0aWYgKG1vZHVsZSkge1xuIFx0XHRcdFx0XHRtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcyA9IG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXTtcbiBcdFx0XHRcdFx0dmFyIGNhbGxiYWNrcyA9IFtdO1xuIFx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiBcdFx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXNbaV07XG4gXHRcdFx0XHRcdFx0Y2IgPSBtb2R1bGUuaG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1tkZXBlbmRlbmN5XTtcbiBcdFx0XHRcdFx0XHRpZiAoY2IpIHtcbiBcdFx0XHRcdFx0XHRcdGlmIChjYWxsYmFja3MuaW5kZXhPZihjYikgIT09IC0xKSBjb250aW51ZTtcbiBcdFx0XHRcdFx0XHRcdGNhbGxiYWNrcy5wdXNoKGNiKTtcbiBcdFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuIFx0XHRcdFx0XHRcdGNiID0gY2FsbGJhY2tzW2ldO1xuIFx0XHRcdFx0XHRcdHRyeSB7XG4gXHRcdFx0XHRcdFx0XHRjYihtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcyk7XG4gXHRcdFx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG4gXHRcdFx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkVycm9yZWQpIHtcbiBcdFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkVycm9yZWQoe1xuIFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYWNjZXB0LWVycm9yZWRcIixcbiBcdFx0XHRcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWQsXG4gXHRcdFx0XHRcdFx0XHRcdFx0ZGVwZW5kZW5jeUlkOiBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llc1tpXSxcbiBcdFx0XHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyXG4gXHRcdFx0XHRcdFx0XHRcdH0pO1xuIFx0XHRcdFx0XHRcdFx0fVxuIFx0XHRcdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZUVycm9yZWQpIHtcbiBcdFx0XHRcdFx0XHRcdFx0aWYgKCFlcnJvcikgZXJyb3IgPSBlcnI7XG4gXHRcdFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdFx0fVxuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHR9XG4gXHRcdFx0fVxuIFx0XHR9XG5cbiBcdFx0Ly8gTG9hZCBzZWxmIGFjY2VwdGVkIG1vZHVsZXNcbiBcdFx0Zm9yIChpID0gMDsgaSA8IG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcy5sZW5ndGg7IGkrKykge1xuIFx0XHRcdHZhciBpdGVtID0gb3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzW2ldO1xuIFx0XHRcdG1vZHVsZUlkID0gaXRlbS5tb2R1bGU7XG4gXHRcdFx0aG90Q3VycmVudFBhcmVudHMgPSBpdGVtLnBhcmVudHM7XG4gXHRcdFx0aG90Q3VycmVudENoaWxkTW9kdWxlID0gbW9kdWxlSWQ7XG4gXHRcdFx0dHJ5IHtcbiBcdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpO1xuIFx0XHRcdH0gY2F0Y2ggKGVycikge1xuIFx0XHRcdFx0aWYgKHR5cGVvZiBpdGVtLmVycm9ySGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gXHRcdFx0XHRcdHRyeSB7XG4gXHRcdFx0XHRcdFx0aXRlbS5lcnJvckhhbmRsZXIoZXJyKTtcbiBcdFx0XHRcdFx0fSBjYXRjaCAoZXJyMikge1xuIFx0XHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRXJyb3JlZCkge1xuIFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkVycm9yZWQoe1xuIFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInNlbGYtYWNjZXB0LWVycm9yLWhhbmRsZXItZXJyb3JlZFwiLFxuIFx0XHRcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWQsXG4gXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBlcnIyLFxuIFx0XHRcdFx0XHRcdFx0XHRvcmlnaW5hbEVycm9yOiBlcnJcbiBcdFx0XHRcdFx0XHRcdH0pO1xuIFx0XHRcdFx0XHRcdH1cbiBcdFx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlRXJyb3JlZCkge1xuIFx0XHRcdFx0XHRcdFx0aWYgKCFlcnJvcikgZXJyb3IgPSBlcnIyO1xuIFx0XHRcdFx0XHRcdH1cbiBcdFx0XHRcdFx0XHRpZiAoIWVycm9yKSBlcnJvciA9IGVycjtcbiBcdFx0XHRcdFx0fVxuIFx0XHRcdFx0fSBlbHNlIHtcbiBcdFx0XHRcdFx0aWYgKG9wdGlvbnMub25FcnJvcmVkKSB7XG4gXHRcdFx0XHRcdFx0b3B0aW9ucy5vbkVycm9yZWQoe1xuIFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzZWxmLWFjY2VwdC1lcnJvcmVkXCIsXG4gXHRcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWQsXG4gXHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyXG4gXHRcdFx0XHRcdFx0fSk7XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZUVycm9yZWQpIHtcbiBcdFx0XHRcdFx0XHRpZiAoIWVycm9yKSBlcnJvciA9IGVycjtcbiBcdFx0XHRcdFx0fVxuIFx0XHRcdFx0fVxuIFx0XHRcdH1cbiBcdFx0fVxuXG4gXHRcdC8vIGhhbmRsZSBlcnJvcnMgaW4gYWNjZXB0IGhhbmRsZXJzIGFuZCBzZWxmIGFjY2VwdGVkIG1vZHVsZSBsb2FkXG4gXHRcdGlmIChlcnJvcikge1xuIFx0XHRcdGhvdFNldFN0YXR1cyhcImZhaWxcIik7XG4gXHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiBcdFx0fVxuXG4gXHRcdGlmIChob3RRdWV1ZWRJbnZhbGlkYXRlZE1vZHVsZXMpIHtcbiBcdFx0XHRyZXR1cm4gaG90QXBwbHlJbnRlcm5hbChvcHRpb25zKS50aGVuKGZ1bmN0aW9uKGxpc3QpIHtcbiBcdFx0XHRcdG91dGRhdGVkTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uKG1vZHVsZUlkKSB7XG4gXHRcdFx0XHRcdGlmIChsaXN0LmluZGV4T2YobW9kdWxlSWQpIDwgMCkgbGlzdC5wdXNoKG1vZHVsZUlkKTtcbiBcdFx0XHRcdH0pO1xuIFx0XHRcdFx0cmV0dXJuIGxpc3Q7XG4gXHRcdFx0fSk7XG4gXHRcdH1cblxuIFx0XHRob3RTZXRTdGF0dXMoXCJpZGxlXCIpO1xuIFx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuIFx0XHRcdHJlc29sdmUob3V0ZGF0ZWRNb2R1bGVzKTtcbiBcdFx0fSk7XG4gXHR9XG5cbiBcdGZ1bmN0aW9uIGhvdEFwcGx5SW52YWxpZGF0ZWRNb2R1bGVzKCkge1xuIFx0XHRpZiAoaG90UXVldWVkSW52YWxpZGF0ZWRNb2R1bGVzKSB7XG4gXHRcdFx0aWYgKCFob3RVcGRhdGUpIGhvdFVwZGF0ZSA9IHt9O1xuIFx0XHRcdGhvdFF1ZXVlZEludmFsaWRhdGVkTW9kdWxlcy5mb3JFYWNoKGhvdEFwcGx5SW52YWxpZGF0ZWRNb2R1bGUpO1xuIFx0XHRcdGhvdFF1ZXVlZEludmFsaWRhdGVkTW9kdWxlcyA9IHVuZGVmaW5lZDtcbiBcdFx0XHRyZXR1cm4gdHJ1ZTtcbiBcdFx0fVxuIFx0fVxuXG4gXHRmdW5jdGlvbiBob3RBcHBseUludmFsaWRhdGVkTW9kdWxlKG1vZHVsZUlkKSB7XG4gXHRcdGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhvdFVwZGF0ZSwgbW9kdWxlSWQpKVxuIFx0XHRcdGhvdFVwZGF0ZVttb2R1bGVJZF0gPSBtb2R1bGVzW21vZHVsZUlkXTtcbiBcdH1cblxuIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aG90OiBob3RDcmVhdGVNb2R1bGUobW9kdWxlSWQpLFxuIFx0XHRcdHBhcmVudHM6IChob3RDdXJyZW50UGFyZW50c1RlbXAgPSBob3RDdXJyZW50UGFyZW50cywgaG90Q3VycmVudFBhcmVudHMgPSBbXSwgaG90Q3VycmVudFBhcmVudHNUZW1wKSxcbiBcdFx0XHRjaGlsZHJlbjogW11cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgaG90Q3JlYXRlUmVxdWlyZShtb2R1bGVJZCkpO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIF9fd2VicGFja19oYXNoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18uaCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaG90Q3VycmVudEhhc2g7IH07XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gaG90Q3JlYXRlUmVxdWlyZSgwKShfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAwKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGFiYnJldi5hYmJyZXYgPSBhYmJyZXZcblxuYWJicmV2Lm1vbmtleVBhdGNoID0gbW9ua2V5UGF0Y2hcblxuZnVuY3Rpb24gbW9ua2V5UGF0Y2ggKCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXJyYXkucHJvdG90eXBlLCAnYWJicmV2Jywge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBhYmJyZXYodGhpcykgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZVxuICB9KVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3QucHJvdG90eXBlLCAnYWJicmV2Jywge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBhYmJyZXYoT2JqZWN0LmtleXModGhpcykpIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWVcbiAgfSlcbn1cblxuZnVuY3Rpb24gYWJicmV2IChsaXN0KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAxIHx8ICFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgbGlzdCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMClcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoLCBhcmdzID0gW10gOyBpIDwgbCA7IGkgKyspIHtcbiAgICBhcmdzW2ldID0gdHlwZW9mIGxpc3RbaV0gPT09IFwic3RyaW5nXCIgPyBsaXN0W2ldIDogU3RyaW5nKGxpc3RbaV0pXG4gIH1cblxuICAvLyBzb3J0IHRoZW0gbGV4aWNvZ3JhcGhpY2FsbHksIHNvIHRoYXQgdGhleSdyZSBuZXh0IHRvIHRoZWlyIG5lYXJlc3Qga2luXG4gIGFyZ3MgPSBhcmdzLnNvcnQobGV4U29ydClcblxuICAvLyB3YWxrIHRocm91Z2ggZWFjaCwgc2VlaW5nIGhvdyBtdWNoIGl0IGhhcyBpbiBjb21tb24gd2l0aCB0aGUgbmV4dCBhbmQgcHJldmlvdXNcbiAgdmFyIGFiYnJldnMgPSB7fVxuICAgICwgcHJldiA9IFwiXCJcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmdzLmxlbmd0aCA7IGkgPCBsIDsgaSArKykge1xuICAgIHZhciBjdXJyZW50ID0gYXJnc1tpXVxuICAgICAgLCBuZXh0ID0gYXJnc1tpICsgMV0gfHwgXCJcIlxuICAgICAgLCBuZXh0TWF0Y2hlcyA9IHRydWVcbiAgICAgICwgcHJldk1hdGNoZXMgPSB0cnVlXG4gICAgaWYgKGN1cnJlbnQgPT09IG5leHQpIGNvbnRpbnVlXG4gICAgZm9yICh2YXIgaiA9IDAsIGNsID0gY3VycmVudC5sZW5ndGggOyBqIDwgY2wgOyBqICsrKSB7XG4gICAgICB2YXIgY3VyQ2hhciA9IGN1cnJlbnQuY2hhckF0KGopXG4gICAgICBuZXh0TWF0Y2hlcyA9IG5leHRNYXRjaGVzICYmIGN1ckNoYXIgPT09IG5leHQuY2hhckF0KGopXG4gICAgICBwcmV2TWF0Y2hlcyA9IHByZXZNYXRjaGVzICYmIGN1ckNoYXIgPT09IHByZXYuY2hhckF0KGopXG4gICAgICBpZiAoIW5leHRNYXRjaGVzICYmICFwcmV2TWF0Y2hlcykge1xuICAgICAgICBqICsrXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHByZXYgPSBjdXJyZW50XG4gICAgaWYgKGogPT09IGNsKSB7XG4gICAgICBhYmJyZXZzW2N1cnJlbnRdID0gY3VycmVudFxuICAgICAgY29udGludWVcbiAgICB9XG4gICAgZm9yICh2YXIgYSA9IGN1cnJlbnQuc3Vic3RyKDAsIGopIDsgaiA8PSBjbCA7IGogKyspIHtcbiAgICAgIGFiYnJldnNbYV0gPSBjdXJyZW50XG4gICAgICBhICs9IGN1cnJlbnQuY2hhckF0KGopXG4gICAgfVxuICB9XG4gIHJldHVybiBhYmJyZXZzXG59XG5cbmZ1bmN0aW9uIGxleFNvcnQgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGIgPyAwIDogYSA+IGIgPyAxIDogLTFcbn1cbiIsIid1c2Ugc3RyaWN0J1xuZXhwb3J0cy5UcmFja2VyR3JvdXAgPSByZXF1aXJlKCcuL3RyYWNrZXItZ3JvdXAuanMnKVxuZXhwb3J0cy5UcmFja2VyID0gcmVxdWlyZSgnLi90cmFja2VyLmpzJylcbmV4cG9ydHMuVHJhY2tlclN0cmVhbSA9IHJlcXVpcmUoJy4vdHJhY2tlci1zdHJlYW0uanMnKVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxuXG52YXIgdHJhY2tlcklkID0gMFxudmFyIFRyYWNrZXJCYXNlID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKVxuICB0aGlzLmlkID0gKyt0cmFja2VySWRcbiAgdGhpcy5uYW1lID0gbmFtZVxufVxudXRpbC5pbmhlcml0cyhUcmFja2VyQmFzZSwgRXZlbnRFbWl0dGVyKVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxudmFyIFRyYWNrZXJCYXNlID0gcmVxdWlyZSgnLi90cmFja2VyLWJhc2UuanMnKVxudmFyIFRyYWNrZXIgPSByZXF1aXJlKCcuL3RyYWNrZXIuanMnKVxudmFyIFRyYWNrZXJTdHJlYW0gPSByZXF1aXJlKCcuL3RyYWNrZXItc3RyZWFtLmpzJylcblxudmFyIFRyYWNrZXJHcm91cCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgVHJhY2tlckJhc2UuY2FsbCh0aGlzLCBuYW1lKVxuICB0aGlzLnBhcmVudEdyb3VwID0gbnVsbFxuICB0aGlzLnRyYWNrZXJzID0gW11cbiAgdGhpcy5jb21wbGV0aW9uID0ge31cbiAgdGhpcy53ZWlnaHQgPSB7fVxuICB0aGlzLnRvdGFsV2VpZ2h0ID0gMFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2VcbiAgdGhpcy5idWJibGVDaGFuZ2UgPSBidWJibGVDaGFuZ2UodGhpcylcbn1cbnV0aWwuaW5oZXJpdHMoVHJhY2tlckdyb3VwLCBUcmFja2VyQmFzZSlcblxuZnVuY3Rpb24gYnViYmxlQ2hhbmdlICh0cmFja2VyR3JvdXApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lLCBjb21wbGV0ZWQsIHRyYWNrZXIpIHtcbiAgICB0cmFja2VyR3JvdXAuY29tcGxldGlvblt0cmFja2VyLmlkXSA9IGNvbXBsZXRlZFxuICAgIGlmICh0cmFja2VyR3JvdXAuZmluaXNoZWQpIHJldHVyblxuICAgIHRyYWNrZXJHcm91cC5lbWl0KCdjaGFuZ2UnLCBuYW1lIHx8IHRyYWNrZXJHcm91cC5uYW1lLCB0cmFja2VyR3JvdXAuY29tcGxldGVkKCksIHRyYWNrZXJHcm91cClcbiAgfVxufVxuXG5UcmFja2VyR3JvdXAucHJvdG90eXBlLm5hbWVJblRyZWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBuYW1lcyA9IFtdXG4gIHZhciBmcm9tID0gdGhpc1xuICB3aGlsZSAoZnJvbSkge1xuICAgIG5hbWVzLnVuc2hpZnQoZnJvbS5uYW1lKVxuICAgIGZyb20gPSBmcm9tLnBhcmVudEdyb3VwXG4gIH1cbiAgcmV0dXJuIG5hbWVzLmpvaW4oJy8nKVxufVxuXG5UcmFja2VyR3JvdXAucHJvdG90eXBlLmFkZFVuaXQgPSBmdW5jdGlvbiAodW5pdCwgd2VpZ2h0KSB7XG4gIGlmICh1bml0LmFkZFVuaXQpIHtcbiAgICB2YXIgdG9UZXN0ID0gdGhpc1xuICAgIHdoaWxlICh0b1Rlc3QpIHtcbiAgICAgIGlmICh1bml0ID09PSB0b1Rlc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdBdHRlbXB0ZWQgdG8gYWRkIHRyYWNrZXIgZ3JvdXAgJyArXG4gICAgICAgICAgdW5pdC5uYW1lICsgJyB0byB0cmVlIHRoYXQgYWxyZWFkeSBpbmNsdWRlcyBpdCAnICtcbiAgICAgICAgICB0aGlzLm5hbWVJblRyZWUodGhpcykpXG4gICAgICB9XG4gICAgICB0b1Rlc3QgPSB0b1Rlc3QucGFyZW50R3JvdXBcbiAgICB9XG4gICAgdW5pdC5wYXJlbnRHcm91cCA9IHRoaXNcbiAgfVxuICB0aGlzLndlaWdodFt1bml0LmlkXSA9IHdlaWdodCB8fCAxXG4gIHRoaXMudG90YWxXZWlnaHQgKz0gdGhpcy53ZWlnaHRbdW5pdC5pZF1cbiAgdGhpcy50cmFja2Vycy5wdXNoKHVuaXQpXG4gIHRoaXMuY29tcGxldGlvblt1bml0LmlkXSA9IHVuaXQuY29tcGxldGVkKClcbiAgdW5pdC5vbignY2hhbmdlJywgdGhpcy5idWJibGVDaGFuZ2UpXG4gIGlmICghdGhpcy5maW5pc2hlZCkgdGhpcy5lbWl0KCdjaGFuZ2UnLCB1bml0Lm5hbWUsIHRoaXMuY29tcGxldGlvblt1bml0LmlkXSwgdW5pdClcbiAgcmV0dXJuIHVuaXRcbn1cblxuVHJhY2tlckdyb3VwLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnRyYWNrZXJzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcbiAgdmFyIHZhbFBlcldlaWdodCA9IDEgLyB0aGlzLnRvdGFsV2VpZ2h0XG4gIHZhciBjb21wbGV0ZWQgPSAwXG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCB0aGlzLnRyYWNrZXJzLmxlbmd0aDsgaWkrKykge1xuICAgIHZhciB0cmFja2VySWQgPSB0aGlzLnRyYWNrZXJzW2lpXS5pZFxuICAgIGNvbXBsZXRlZCArPSB2YWxQZXJXZWlnaHQgKiB0aGlzLndlaWdodFt0cmFja2VySWRdICogdGhpcy5jb21wbGV0aW9uW3RyYWNrZXJJZF1cbiAgfVxuICByZXR1cm4gY29tcGxldGVkXG59XG5cblRyYWNrZXJHcm91cC5wcm90b3R5cGUubmV3R3JvdXAgPSBmdW5jdGlvbiAobmFtZSwgd2VpZ2h0KSB7XG4gIHJldHVybiB0aGlzLmFkZFVuaXQobmV3IFRyYWNrZXJHcm91cChuYW1lKSwgd2VpZ2h0KVxufVxuXG5UcmFja2VyR3JvdXAucHJvdG90eXBlLm5ld0l0ZW0gPSBmdW5jdGlvbiAobmFtZSwgdG9kbywgd2VpZ2h0KSB7XG4gIHJldHVybiB0aGlzLmFkZFVuaXQobmV3IFRyYWNrZXIobmFtZSwgdG9kbyksIHdlaWdodClcbn1cblxuVHJhY2tlckdyb3VwLnByb3RvdHlwZS5uZXdTdHJlYW0gPSBmdW5jdGlvbiAobmFtZSwgdG9kbywgd2VpZ2h0KSB7XG4gIHJldHVybiB0aGlzLmFkZFVuaXQobmV3IFRyYWNrZXJTdHJlYW0obmFtZSwgdG9kbyksIHdlaWdodClcbn1cblxuVHJhY2tlckdyb3VwLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZmluaXNoZWQgPSB0cnVlXG4gIGlmICghdGhpcy50cmFja2Vycy5sZW5ndGgpIHRoaXMuYWRkVW5pdChuZXcgVHJhY2tlcigpLCAxLCB0cnVlKVxuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgdGhpcy50cmFja2Vycy5sZW5ndGg7IGlpKyspIHtcbiAgICB2YXIgdHJhY2tlciA9IHRoaXMudHJhY2tlcnNbaWldXG4gICAgdHJhY2tlci5maW5pc2goKVxuICAgIHRyYWNrZXIucmVtb3ZlTGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuYnViYmxlQ2hhbmdlKVxuICB9XG4gIHRoaXMuZW1pdCgnY2hhbmdlJywgdGhpcy5uYW1lLCAxLCB0aGlzKVxufVxuXG52YXIgYnVmZmVyID0gJyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXG5UcmFja2VyR3JvdXAucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24gKGRlcHRoKSB7XG4gIGRlcHRoID0gZGVwdGggfHwgMFxuICB2YXIgaW5kZW50ID0gZGVwdGggPyBidWZmZXIuc3Vic3RyKDAsIGRlcHRoKSA6ICcnXG4gIHZhciBvdXRwdXQgPSBpbmRlbnQgKyAodGhpcy5uYW1lIHx8ICd0b3AnKSArICc6ICcgKyB0aGlzLmNvbXBsZXRlZCgpICsgJ1xcbidcbiAgdGhpcy50cmFja2Vycy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFja2VyKSB7XG4gICAgaWYgKHRyYWNrZXIgaW5zdGFuY2VvZiBUcmFja2VyR3JvdXApIHtcbiAgICAgIG91dHB1dCArPSB0cmFja2VyLmRlYnVnKGRlcHRoICsgMSlcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0ICs9IGluZGVudCArICcgJyArIHRyYWNrZXIubmFtZSArICc6ICcgKyB0cmFja2VyLmNvbXBsZXRlZCgpICsgJ1xcbidcbiAgICB9XG4gIH0pXG4gIHJldHVybiBvdXRwdXRcbn1cbiIsIid1c2Ugc3RyaWN0J1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJylcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxudmFyIGRlbGVnYXRlID0gcmVxdWlyZSgnZGVsZWdhdGVzJylcbnZhciBUcmFja2VyID0gcmVxdWlyZSgnLi90cmFja2VyLmpzJylcblxudmFyIFRyYWNrZXJTdHJlYW0gPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lLCBzaXplLCBvcHRpb25zKSB7XG4gIHN0cmVhbS5UcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKVxuICB0aGlzLnRyYWNrZXIgPSBuZXcgVHJhY2tlcihuYW1lLCBzaXplKVxuICB0aGlzLm5hbWUgPSBuYW1lXG4gIHRoaXMuaWQgPSB0aGlzLnRyYWNrZXIuaWRcbiAgdGhpcy50cmFja2VyLm9uKCdjaGFuZ2UnLCBkZWxlZ2F0ZUNoYW5nZSh0aGlzKSlcbn1cbnV0aWwuaW5oZXJpdHMoVHJhY2tlclN0cmVhbSwgc3RyZWFtLlRyYW5zZm9ybSlcblxuZnVuY3Rpb24gZGVsZWdhdGVDaGFuZ2UgKHRyYWNrZXJTdHJlYW0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lLCBjb21wbGV0aW9uLCB0cmFja2VyKSB7XG4gICAgdHJhY2tlclN0cmVhbS5lbWl0KCdjaGFuZ2UnLCBuYW1lLCBjb21wbGV0aW9uLCB0cmFja2VyU3RyZWFtKVxuICB9XG59XG5cblRyYWNrZXJTdHJlYW0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoZGF0YSwgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMudHJhY2tlci5jb21wbGV0ZVdvcmsoZGF0YS5sZW5ndGggPyBkYXRhLmxlbmd0aCA6IDEpXG4gIHRoaXMucHVzaChkYXRhKVxuICBjYigpXG59XG5cblRyYWNrZXJTdHJlYW0ucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uIChjYikge1xuICB0aGlzLnRyYWNrZXIuZmluaXNoKClcbiAgY2IoKVxufVxuXG5kZWxlZ2F0ZShUcmFja2VyU3RyZWFtLnByb3RvdHlwZSwgJ3RyYWNrZXInKVxuICAubWV0aG9kKCdjb21wbGV0ZWQnKVxuICAubWV0aG9kKCdhZGRXb3JrJylcbiAgLm1ldGhvZCgnZmluaXNoJylcbiIsIid1c2Ugc3RyaWN0J1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJylcbnZhciBUcmFja2VyQmFzZSA9IHJlcXVpcmUoJy4vdHJhY2tlci1iYXNlLmpzJylcblxudmFyIFRyYWNrZXIgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lLCB0b2RvKSB7XG4gIFRyYWNrZXJCYXNlLmNhbGwodGhpcywgbmFtZSlcbiAgdGhpcy53b3JrRG9uZSA9IDBcbiAgdGhpcy53b3JrVG9kbyA9IHRvZG8gfHwgMFxufVxudXRpbC5pbmhlcml0cyhUcmFja2VyLCBUcmFja2VyQmFzZSlcblxuVHJhY2tlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy53b3JrVG9kbyA9PT0gMCA/IDAgOiB0aGlzLndvcmtEb25lIC8gdGhpcy53b3JrVG9kb1xufVxuXG5UcmFja2VyLnByb3RvdHlwZS5hZGRXb3JrID0gZnVuY3Rpb24gKHdvcmspIHtcbiAgdGhpcy53b3JrVG9kbyArPSB3b3JrXG4gIHRoaXMuZW1pdCgnY2hhbmdlJywgdGhpcy5uYW1lLCB0aGlzLmNvbXBsZXRlZCgpLCB0aGlzKVxufVxuXG5UcmFja2VyLnByb3RvdHlwZS5jb21wbGV0ZVdvcmsgPSBmdW5jdGlvbiAod29yaykge1xuICB0aGlzLndvcmtEb25lICs9IHdvcmtcbiAgaWYgKHRoaXMud29ya0RvbmUgPiB0aGlzLndvcmtUb2RvKSB0aGlzLndvcmtEb25lID0gdGhpcy53b3JrVG9kb1xuICB0aGlzLmVtaXQoJ2NoYW5nZScsIHRoaXMubmFtZSwgdGhpcy5jb21wbGV0ZWQoKSwgdGhpcylcbn1cblxuVHJhY2tlci5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLndvcmtUb2RvID0gdGhpcy53b3JrRG9uZSA9IDFcbiAgdGhpcy5lbWl0KCdjaGFuZ2UnLCB0aGlzLm5hbWUsIDEsIHRoaXMpXG59XG4iLCJmdW5jdGlvbiB3ZWJwYWNrRW1wdHlDb250ZXh0KHJlcSkge1xuXHR2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIidcIik7XG5cdGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJztcblx0dGhyb3cgZTtcbn1cbndlYnBhY2tFbXB0eUNvbnRleHQua2V5cyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gW107IH07XG53ZWJwYWNrRW1wdHlDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrRW1wdHlDb250ZXh0O1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrRW1wdHlDb250ZXh0O1xud2VicGFja0VtcHR5Q29udGV4dC5pZCA9IFwiLi9ub2RlX21vZHVsZXMvYmNyeXB0IHN5bmMgcmVjdXJzaXZlXCI7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluYXJ5ID0gcmVxdWlyZSgnbm9kZS1wcmUtZ3lwJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciBiaW5kaW5nX3BhdGggPSBiaW5hcnkuZmluZChwYXRoLnJlc29sdmUocGF0aC5qb2luKF9fZGlybmFtZSwgJy4vcGFja2FnZS5qc29uJykpKTtcbnZhciBiaW5kaW5ncyA9IHJlcXVpcmUoYmluZGluZ19wYXRoKTtcblxudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG52YXIgcHJvbWlzZXMgPSByZXF1aXJlKCcuL3Byb21pc2VzJyk7XG5cbi8vLyBnZW5lcmF0ZSBhIHNhbHQgKHN5bmMpXG4vLy8gQHBhcmFtIHtOdW1iZXJ9IFtyb3VuZHNdIG51bWJlciBvZiByb3VuZHMgKGRlZmF1bHQgMTApXG4vLy8gQHJldHVybiB7U3RyaW5nfSBzYWx0XG5tb2R1bGUuZXhwb3J0cy5nZW5TYWx0U3luYyA9IGZ1bmN0aW9uIGdlblNhbHRTeW5jKHJvdW5kcywgbWlub3IpIHtcbiAgICAvLyBkZWZhdWx0IDEwIHJvdW5kc1xuICAgIGlmICghcm91bmRzKSB7XG4gICAgICAgIHJvdW5kcyA9IDEwO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJvdW5kcyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyb3VuZHMgbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIH1cblxuICAgIGlmKCFtaW5vcikge1xuICAgICAgICBtaW5vciA9ICdiJztcbiAgICB9IGVsc2UgaWYobWlub3IgIT09ICdiJyAmJiBtaW5vciAhPT0gJ2EnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlub3IgbXVzdCBiZSBlaXRoZXIgXCJhXCIgb3IgXCJiXCInKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmluZGluZ3MuZ2VuX3NhbHRfc3luYyhtaW5vciwgcm91bmRzLCBjcnlwdG8ucmFuZG9tQnl0ZXMoMTYpKTtcbn07XG5cbi8vLyBnZW5lcmF0ZSBhIHNhbHRcbi8vLyBAcGFyYW0ge051bWJlcn0gW3JvdW5kc10gbnVtYmVyIG9mIHJvdW5kcyAoZGVmYXVsdCAxMClcbi8vLyBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBjYWxsYmFjayhlcnIsIHNhbHQpXG5tb2R1bGUuZXhwb3J0cy5nZW5TYWx0ID0gZnVuY3Rpb24gZ2VuU2FsdChyb3VuZHMsIG1pbm9yLCBjYikge1xuICAgIHZhciBlcnJvcjtcblxuICAgIC8vIGlmIGNhbGxiYWNrIGlzIGZpcnN0IGFyZ3VtZW50LCB0aGVuIHVzZSBkZWZhdWx0cyBmb3Igb3RoZXJzXG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gaGF2ZSB0byBzZXQgY2FsbGJhY2sgZmlyc3Qgb3RoZXJ3aXNlIGFyZ3VtZW50cyBhcmUgb3ZlcnJpZGVuXG4gICAgICAgIGNiID0gYXJndW1lbnRzWzBdO1xuICAgICAgICByb3VuZHMgPSAxMDtcbiAgICAgICAgbWlub3IgPSAnYic7XG4gICAgLy8gY2FsbGJhY2sgaXMgc2Vjb25kIGFyZ3VtZW50XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIGhhdmUgdG8gc2V0IGNhbGxiYWNrIGZpcnN0IG90aGVyd2lzZSBhcmd1bWVudHMgYXJlIG92ZXJyaWRlblxuICAgICAgICBjYiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgbWlub3IgPSAnYic7XG4gICAgfVxuXG4gICAgaWYgKCFjYikge1xuICAgICAgICByZXR1cm4gcHJvbWlzZXMucHJvbWlzZShnZW5TYWx0LCB0aGlzLCBbcm91bmRzLCBtaW5vcl0pO1xuICAgIH1cblxuICAgIC8vIGRlZmF1bHQgMTAgcm91bmRzXG4gICAgaWYgKCFyb3VuZHMpIHtcbiAgICAgICAgcm91bmRzID0gMTA7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygcm91bmRzICE9PSAnbnVtYmVyJykge1xuICAgICAgICAvLyBjYWxsYmFjayBlcnJvciBhc3luY2hyb25vdXNseVxuICAgICAgICBlcnJvciA9IG5ldyBFcnJvcigncm91bmRzIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmKCFtaW5vcikge1xuICAgICAgICBtaW5vciA9ICdiJ1xuICAgIH0gZWxzZSBpZihtaW5vciAhPT0gJ2InICYmIG1pbm9yICE9PSAnYScpIHtcbiAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ21pbm9yIG11c3QgYmUgZWl0aGVyIFwiYVwiIG9yIFwiYlwiJyk7XG4gICAgICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjcnlwdG8ucmFuZG9tQnl0ZXMoMTYsIGZ1bmN0aW9uKGVycm9yLCByYW5kb21CeXRlcykge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJpbmRpbmdzLmdlbl9zYWx0KG1pbm9yLCByb3VuZHMsIHJhbmRvbUJ5dGVzLCBjYik7XG4gICAgfSk7XG59O1xuXG4vLy8gaGFzaCBkYXRhIHVzaW5nIGEgc2FsdFxuLy8vIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRoZSBkYXRhIHRvIGVuY3J5cHRcbi8vLyBAcGFyYW0ge1N0cmluZ30gc2FsdCB0aGUgc2FsdCB0byB1c2Ugd2hlbiBoYXNoaW5nXG4vLy8gQHJldHVybiB7U3RyaW5nfSBoYXNoXG5tb2R1bGUuZXhwb3J0cy5oYXNoU3luYyA9IGZ1bmN0aW9uIGhhc2hTeW5jKGRhdGEsIHNhbHQpIHtcbiAgICBpZiAoZGF0YSA9PSBudWxsIHx8IHNhbHQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RhdGEgYW5kIHNhbHQgYXJndW1lbnRzIHJlcXVpcmVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJyB8fCAodHlwZW9mIHNhbHQgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBzYWx0ICE9PSAnbnVtYmVyJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkYXRhIG11c3QgYmUgYSBzdHJpbmcgYW5kIHNhbHQgbXVzdCBlaXRoZXIgYmUgYSBzYWx0IHN0cmluZyBvciBhIG51bWJlciBvZiByb3VuZHMnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNhbHQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHNhbHQgPSBtb2R1bGUuZXhwb3J0cy5nZW5TYWx0U3luYyhzYWx0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmluZGluZ3MuZW5jcnlwdF9zeW5jKGRhdGEsIHNhbHQpO1xufTtcblxuLy8vIGhhc2ggZGF0YSB1c2luZyBhIHNhbHRcbi8vLyBAcGFyYW0ge1N0cmluZ30gZGF0YSB0aGUgZGF0YSB0byBlbmNyeXB0XG4vLy8gQHBhcmFtIHtTdHJpbmd9IHNhbHQgdGhlIHNhbHQgdG8gdXNlIHdoZW4gaGFzaGluZ1xuLy8vIEBwYXJhbSB7RnVuY3Rpb259IGNiIGNhbGxiYWNrKGVyciwgaGFzaClcbm1vZHVsZS5leHBvcnRzLmhhc2ggPSBmdW5jdGlvbiBoYXNoKGRhdGEsIHNhbHQsIGNiKSB7XG4gICAgdmFyIGVycm9yO1xuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdkYXRhIG11c3QgYmUgYSBzdHJpbmcgYW5kIHNhbHQgbXVzdCBlaXRoZXIgYmUgYSBzYWx0IHN0cmluZyBvciBhIG51bWJlciBvZiByb3VuZHMnKTtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkYXRhKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzYWx0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdkYXRhIG11c3QgYmUgYSBzdHJpbmcgYW5kIHNhbHQgbXVzdCBlaXRoZXIgYmUgYSBzYWx0IHN0cmluZyBvciBhIG51bWJlciBvZiByb3VuZHMnKTtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzYWx0KGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gY2IgZXhpc3RzIGJ1dCBpcyBub3QgYSBmdW5jdGlvblxuICAgIC8vIHJldHVybiBhIHJlamVjdGluZyBwcm9taXNlXG4gICAgaWYgKGNiICYmIHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gcHJvbWlzZXMucmVqZWN0KG5ldyBFcnJvcignY2IgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIG51bGwgdG8gcmV0dXJuIGEgUHJvbWlzZScpKTtcbiAgICB9XG5cbiAgICBpZiAoIWNiKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlcy5wcm9taXNlKGhhc2gsIHRoaXMsIFtkYXRhLCBzYWx0XSk7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEgPT0gbnVsbCB8fCBzYWx0ID09IG51bGwpIHtcbiAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ2RhdGEgYW5kIHNhbHQgYXJndW1lbnRzIHJlcXVpcmVkJyk7XG4gICAgICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnIHx8ICh0eXBlb2Ygc2FsdCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHNhbHQgIT09ICdudW1iZXInKSkge1xuICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignZGF0YSBtdXN0IGJlIGEgc3RyaW5nIGFuZCBzYWx0IG11c3QgZWl0aGVyIGJlIGEgc2FsdCBzdHJpbmcgb3IgYSBudW1iZXIgb2Ygcm91bmRzJyk7XG4gICAgICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIGlmICh0eXBlb2Ygc2FsdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzLmdlblNhbHQoc2FsdCwgZnVuY3Rpb24oZXJyLCBzYWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZGluZ3MuZW5jcnlwdChkYXRhLCBzYWx0LCBjYik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBiaW5kaW5ncy5lbmNyeXB0KGRhdGEsIHNhbHQsIGNiKTtcbn07XG5cbi8vLyBjb21wYXJlIHJhdyBkYXRhIHRvIGhhc2hcbi8vLyBAcGFyYW0ge1N0cmluZ30gZGF0YSB0aGUgZGF0YSB0byBoYXNoIGFuZCBjb21wYXJlXG4vLy8gQHBhcmFtIHtTdHJpbmd9IGhhc2ggZXhwZWN0ZWQgaGFzaFxuLy8vIEByZXR1cm4ge2Jvb2x9IHRydWUgaWYgaGFzaGVkIGRhdGEgbWF0Y2hlcyBoYXNoXG5tb2R1bGUuZXhwb3J0cy5jb21wYXJlU3luYyA9IGZ1bmN0aW9uIGNvbXBhcmVTeW5jKGRhdGEsIGhhc2gpIHtcbiAgICBpZiAoZGF0YSA9PSBudWxsIHx8IGhhc2ggPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RhdGEgYW5kIGhhc2ggYXJndW1lbnRzIHJlcXVpcmVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgaGFzaCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkYXRhIGFuZCBoYXNoIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH1cblxuICAgIHJldHVybiBiaW5kaW5ncy5jb21wYXJlX3N5bmMoZGF0YSwgaGFzaCk7XG59O1xuXG4vLy8gY29tcGFyZSByYXcgZGF0YSB0byBoYXNoXG4vLy8gQHBhcmFtIHtTdHJpbmd9IGRhdGEgdGhlIGRhdGEgdG8gaGFzaCBhbmQgY29tcGFyZVxuLy8vIEBwYXJhbSB7U3RyaW5nfSBoYXNoIGV4cGVjdGVkIGhhc2hcbi8vLyBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBjYWxsYmFjayhlcnIsIG1hdGNoZWQpIC0gbWF0Y2hlZCBpcyB0cnVlIGlmIGhhc2hlZCBkYXRhIG1hdGNoZXMgaGFzaFxubW9kdWxlLmV4cG9ydHMuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUoZGF0YSwgaGFzaCwgY2IpIHtcbiAgICB2YXIgZXJyb3I7XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ2RhdGEgYW5kIGhhc2ggYXJndW1lbnRzIHJlcXVpcmVkJyk7XG4gICAgICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZGF0YShlcnJvcik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaGFzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignZGF0YSBhbmQgaGFzaCBhcmd1bWVudHMgcmVxdWlyZWQnKTtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBoYXNoKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gY2IgZXhpc3RzIGJ1dCBpcyBub3QgYSBmdW5jdGlvblxuICAgIC8vIHJldHVybiBhIHJlamVjdGluZyBwcm9taXNlXG4gICAgaWYgKGNiICYmIHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gcHJvbWlzZXMucmVqZWN0KG5ldyBFcnJvcignY2IgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIG51bGwgdG8gcmV0dXJuIGEgUHJvbWlzZScpKTtcbiAgICB9XG5cbiAgICBpZiAoIWNiKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlcy5wcm9taXNlKGNvbXBhcmUsIHRoaXMsIFtkYXRhLCBoYXNoXSk7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEgPT0gbnVsbCB8fCBoYXNoID09IG51bGwpIHtcbiAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ2RhdGEgYW5kIGhhc2ggYXJndW1lbnRzIHJlcXVpcmVkJyk7XG4gICAgICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBoYXNoICE9PSAnc3RyaW5nJykge1xuICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignZGF0YSBhbmQgaGFzaCBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBiaW5kaW5ncy5jb21wYXJlKGRhdGEsIGhhc2gsIGNiKTtcbn07XG5cbi8vLyBAcGFyYW0ge1N0cmluZ30gaGFzaCBleHRyYWN0IHJvdW5kcyBmcm9tIHRoaXMgaGFzaFxuLy8vIEByZXR1cm4ge051bWJlcn0gdGhlIG51bWJlciBvZiByb3VuZHMgdXNlZCB0byBlbmNyeXB0IGEgZ2l2ZW4gaGFzaFxubW9kdWxlLmV4cG9ydHMuZ2V0Um91bmRzID0gZnVuY3Rpb24gZ2V0Um91bmRzKGhhc2gpIHtcbiAgICBpZiAoaGFzaCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGFzaCBhcmd1bWVudCByZXF1aXJlZCcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaGFzaCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmluZGluZ3MuZ2V0X3JvdW5kcyhoYXNoKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQcm9taXNlID0gZ2xvYmFsLlByb21pc2U7XG5cbi8vLyBlbmNhcHN1bGF0ZSBhIG1ldGhvZCB3aXRoIGEgbm9kZS1zdHlsZSBjYWxsYmFjayBpbiBhIFByb21pc2Vcbi8vLyBAcGFyYW0ge29iamVjdH0gJ3RoaXMnIG9mIHRoZSBlbmNhcHN1bGF0ZWQgZnVuY3Rpb25cbi8vLyBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jdGlvbiB0byBiZSBlbmNhcHN1bGF0ZWRcbi8vLyBAcGFyYW0ge0FycmF5LWxpa2V9IGFyZ3MgdG8gYmUgcGFzc2VkIHRvIHRoZSBjYWxsZWQgZnVuY3Rpb25cbi8vLyBAcmV0dXJuIHtQcm9taXNlfSBhIFByb21pc2UgZW5jYXBzdWxhdGluZyB0aGUgZnVuY3Rpb25cbm1vZHVsZS5leHBvcnRzLnByb21pc2UgPSBmdW5jdGlvbiAoZm4sIGNvbnRleHQsIGFyZ3MpIHtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShhcmdzKSkge1xuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdmbiBtdXN0IGJlIGEgZnVuY3Rpb24nKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBhcmdzLnB1c2goZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH0pO1xufTtcblxuLy8vIEBwYXJhbSB7ZXJyfSB0aGUgZXJyb3IgdG8gYmUgdGhyb3duXG5tb2R1bGUuZXhwb3J0cy5yZWplY3QgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG59O1xuXG4vLy8gY2hhbmdlcyB0aGUgcHJvbWlzZSBpbXBsZW1lbnRhdGlvbiB0aGF0IGJjcnlwdCB1c2VzXG4vLy8gQHBhcmFtIHtQcm9taXNlfSB0aGUgaW1wbGVtZW50YXRpb24gdG8gdXNlXG5tb2R1bGUuZXhwb3J0cy51c2UgPSBmdW5jdGlvbihwcm9taXNlKSB7XG4gIFByb21pc2UgPSBwcm9taXNlO1xufTtcbiIsIid1c2Ugc3RyaWN0J1xuXG4vLyBUaGVzZSB0YWJsZXMgYm9ycm93ZWQgZnJvbSBgYW5zaWBcblxudmFyIHByZWZpeCA9ICdcXHgxYlsnXG5cbmV4cG9ydHMudXAgPSBmdW5jdGlvbiB1cCAobnVtKSB7XG4gIHJldHVybiBwcmVmaXggKyAobnVtIHx8ICcnKSArICdBJ1xufVxuXG5leHBvcnRzLmRvd24gPSBmdW5jdGlvbiBkb3duIChudW0pIHtcbiAgcmV0dXJuIHByZWZpeCArIChudW0gfHwgJycpICsgJ0InXG59XG5cbmV4cG9ydHMuZm9yd2FyZCA9IGZ1bmN0aW9uIGZvcndhcmQgKG51bSkge1xuICByZXR1cm4gcHJlZml4ICsgKG51bSB8fCAnJykgKyAnQydcbn1cblxuZXhwb3J0cy5iYWNrID0gZnVuY3Rpb24gYmFjayAobnVtKSB7XG4gIHJldHVybiBwcmVmaXggKyAobnVtIHx8ICcnKSArICdEJ1xufVxuXG5leHBvcnRzLm5leHRMaW5lID0gZnVuY3Rpb24gbmV4dExpbmUgKG51bSkge1xuICByZXR1cm4gcHJlZml4ICsgKG51bSB8fCAnJykgKyAnRSdcbn1cblxuZXhwb3J0cy5wcmV2aW91c0xpbmUgPSBmdW5jdGlvbiBwcmV2aW91c0xpbmUgKG51bSkge1xuICByZXR1cm4gcHJlZml4ICsgKG51bSB8fCAnJykgKyAnRidcbn1cblxuZXhwb3J0cy5ob3Jpem9udGFsQWJzb2x1dGUgPSBmdW5jdGlvbiBob3Jpem9udGFsQWJzb2x1dGUgKG51bSkge1xuICBpZiAobnVtID09IG51bGwpIHRocm93IG5ldyBFcnJvcignaG9yaXpvbnRhbEFib3NsdXRlIHJlcXVpcmVzIGEgY29sdW1uIHRvIHBvc2l0aW9uIHRvJylcbiAgcmV0dXJuIHByZWZpeCArIG51bSArICdHJ1xufVxuXG5leHBvcnRzLmVyYXNlRGF0YSA9IGZ1bmN0aW9uIGVyYXNlRGF0YSAoKSB7XG4gIHJldHVybiBwcmVmaXggKyAnSidcbn1cblxuZXhwb3J0cy5lcmFzZUxpbmUgPSBmdW5jdGlvbiBlcmFzZUxpbmUgKCkge1xuICByZXR1cm4gcHJlZml4ICsgJ0snXG59XG5cbmV4cG9ydHMuZ290byA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gIHJldHVybiBwcmVmaXggKyB5ICsgJzsnICsgeCArICdIJ1xufVxuXG5leHBvcnRzLmdvdG9TT0wgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAnXFxyJ1xufVxuXG5leHBvcnRzLmJlZXAgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAnXFx4MDcnXG59XG5cbmV4cG9ydHMuaGlkZUN1cnNvciA9IGZ1bmN0aW9uIGhpZGVDdXJzb3IgKCkge1xuICByZXR1cm4gcHJlZml4ICsgJz8yNWwnXG59XG5cbmV4cG9ydHMuc2hvd0N1cnNvciA9IGZ1bmN0aW9uIHNob3dDdXJzb3IgKCkge1xuICByZXR1cm4gcHJlZml4ICsgJz8yNWgnXG59XG5cbnZhciBjb2xvcnMgPSB7XG4gIHJlc2V0OiAwLFxuLy8gc3R5bGVzXG4gIGJvbGQ6IDEsXG4gIGl0YWxpYzogMyxcbiAgdW5kZXJsaW5lOiA0LFxuICBpbnZlcnNlOiA3LFxuLy8gcmVzZXRzXG4gIHN0b3BCb2xkOiAyMixcbiAgc3RvcEl0YWxpYzogMjMsXG4gIHN0b3BVbmRlcmxpbmU6IDI0LFxuICBzdG9wSW52ZXJzZTogMjcsXG4vLyBjb2xvcnNcbiAgd2hpdGU6IDM3LFxuICBibGFjazogMzAsXG4gIGJsdWU6IDM0LFxuICBjeWFuOiAzNixcbiAgZ3JlZW46IDMyLFxuICBtYWdlbnRhOiAzNSxcbiAgcmVkOiAzMSxcbiAgeWVsbG93OiAzMyxcbiAgYmdXaGl0ZTogNDcsXG4gIGJnQmxhY2s6IDQwLFxuICBiZ0JsdWU6IDQ0LFxuICBiZ0N5YW46IDQ2LFxuICBiZ0dyZWVuOiA0MixcbiAgYmdNYWdlbnRhOiA0NSxcbiAgYmdSZWQ6IDQxLFxuICBiZ1llbGxvdzogNDMsXG5cbiAgZ3JleTogOTAsXG4gIGJyaWdodEJsYWNrOiA5MCxcbiAgYnJpZ2h0UmVkOiA5MSxcbiAgYnJpZ2h0R3JlZW46IDkyLFxuICBicmlnaHRZZWxsb3c6IDkzLFxuICBicmlnaHRCbHVlOiA5NCxcbiAgYnJpZ2h0TWFnZW50YTogOTUsXG4gIGJyaWdodEN5YW46IDk2LFxuICBicmlnaHRXaGl0ZTogOTcsXG5cbiAgYmdHcmV5OiAxMDAsXG4gIGJnQnJpZ2h0QmxhY2s6IDEwMCxcbiAgYmdCcmlnaHRSZWQ6IDEwMSxcbiAgYmdCcmlnaHRHcmVlbjogMTAyLFxuICBiZ0JyaWdodFllbGxvdzogMTAzLFxuICBiZ0JyaWdodEJsdWU6IDEwNCxcbiAgYmdCcmlnaHRNYWdlbnRhOiAxMDUsXG4gIGJnQnJpZ2h0Q3lhbjogMTA2LFxuICBiZ0JyaWdodFdoaXRlOiAxMDdcbn1cblxuZXhwb3J0cy5jb2xvciA9IGZ1bmN0aW9uIGNvbG9yIChjb2xvcldpdGgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDEgfHwgIUFycmF5LmlzQXJyYXkoY29sb3JXaXRoKSkge1xuICAgIGNvbG9yV2l0aCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgfVxuICByZXR1cm4gcHJlZml4ICsgY29sb3JXaXRoLm1hcChjb2xvck5hbWVUb0NvZGUpLmpvaW4oJzsnKSArICdtJ1xufVxuXG5mdW5jdGlvbiBjb2xvck5hbWVUb0NvZGUgKGNvbG9yKSB7XG4gIGlmIChjb2xvcnNbY29sb3JdICE9IG51bGwpIHJldHVybiBjb2xvcnNbY29sb3JdXG4gIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjb2xvciBvciBzdHlsZSBuYW1lOiAnICsgY29sb3IpXG59XG4iLCIvKiFcbiAqIEBkZXNjcmlwdGlvbiBSZWN1cnNpdmUgb2JqZWN0IGV4dGVuZGluZ1xuICogQGF1dGhvciBWaWFjaGVzbGF2IExvdHNtYW5vdiA8bG90c21hbm92ODlAZ21haWwuY29tPlxuICogQGxpY2Vuc2UgTUlUXG4gKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTggVmlhY2hlc2xhdiBMb3RzbWFub3ZcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZlxuICogdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICogc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTXG4gKiBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1JcbiAqIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUlxuICogSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAqIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBpc1NwZWNpZmljVmFsdWUodmFsKSB7XG5cdHJldHVybiAoXG5cdFx0dmFsIGluc3RhbmNlb2YgQnVmZmVyXG5cdFx0fHwgdmFsIGluc3RhbmNlb2YgRGF0ZVxuXHRcdHx8IHZhbCBpbnN0YW5jZW9mIFJlZ0V4cFxuXHQpID8gdHJ1ZSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjbG9uZVNwZWNpZmljVmFsdWUodmFsKSB7XG5cdGlmICh2YWwgaW5zdGFuY2VvZiBCdWZmZXIpIHtcblx0XHR2YXIgeCA9IEJ1ZmZlci5hbGxvY1xuXHRcdFx0PyBCdWZmZXIuYWxsb2ModmFsLmxlbmd0aClcblx0XHRcdDogbmV3IEJ1ZmZlcih2YWwubGVuZ3RoKTtcblx0XHR2YWwuY29weSh4KTtcblx0XHRyZXR1cm4geDtcblx0fSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBEYXRlKSB7XG5cdFx0cmV0dXJuIG5ldyBEYXRlKHZhbC5nZXRUaW1lKCkpO1xuXHR9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuXHRcdHJldHVybiBuZXcgUmVnRXhwKHZhbCk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHNpdHVhdGlvbicpO1xuXHR9XG59XG5cbi8qKlxuICogUmVjdXJzaXZlIGNsb25pbmcgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGRlZXBDbG9uZUFycmF5KGFycikge1xuXHR2YXIgY2xvbmUgPSBbXTtcblx0YXJyLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG5cdFx0aWYgKHR5cGVvZiBpdGVtID09PSAnb2JqZWN0JyAmJiBpdGVtICE9PSBudWxsKSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuXHRcdFx0XHRjbG9uZVtpbmRleF0gPSBkZWVwQ2xvbmVBcnJheShpdGVtKTtcblx0XHRcdH0gZWxzZSBpZiAoaXNTcGVjaWZpY1ZhbHVlKGl0ZW0pKSB7XG5cdFx0XHRcdGNsb25lW2luZGV4XSA9IGNsb25lU3BlY2lmaWNWYWx1ZShpdGVtKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lW2luZGV4XSA9IGRlZXBFeHRlbmQoe30sIGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjbG9uZVtpbmRleF0gPSBpdGVtO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBjbG9uZTtcbn1cblxuZnVuY3Rpb24gc2FmZUdldFByb3BlcnR5KG9iamVjdCwgcHJvcGVydHkpIHtcblx0cmV0dXJuIHByb3BlcnR5ID09PSAnX19wcm90b19fJyA/IHVuZGVmaW5lZCA6IG9iamVjdFtwcm9wZXJ0eV07XG59XG5cbi8qKlxuICogRXh0ZW5pbmcgb2JqZWN0IHRoYXQgZW50ZXJlZCBpbiBmaXJzdCBhcmd1bWVudC5cbiAqXG4gKiBSZXR1cm5zIGV4dGVuZGVkIG9iamVjdCBvciBmYWxzZSBpZiBoYXZlIG5vIHRhcmdldCBvYmplY3Qgb3IgaW5jb3JyZWN0IHR5cGUuXG4gKlxuICogSWYgeW91IHdpc2ggdG8gY2xvbmUgc291cmNlIG9iamVjdCAod2l0aG91dCBtb2RpZnkgaXQpLCBqdXN0IHVzZSBlbXB0eSBuZXdcbiAqIG9iamVjdCBhcyBmaXJzdCBhcmd1bWVudCwgbGlrZSB0aGlzOlxuICogICBkZWVwRXh0ZW5kKHt9LCB5b3VyT2JqXzEsIFt5b3VyT2JqX05dKTtcbiAqL1xudmFyIGRlZXBFeHRlbmQgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgvKm9ial8xLCBbb2JqXzJdLCBbb2JqX05dKi8pIHtcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxIHx8IHR5cGVvZiBhcmd1bWVudHNbMF0gIT09ICdvYmplY3QnKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50c1swXTtcblx0fVxuXG5cdHZhciB0YXJnZXQgPSBhcmd1bWVudHNbMF07XG5cblx0Ly8gY29udmVydCBhcmd1bWVudHMgdG8gYXJyYXkgYW5kIGN1dCBvZmYgdGFyZ2V0IG9iamVjdFxuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cblx0dmFyIHZhbCwgc3JjLCBjbG9uZTtcblxuXHRhcmdzLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuXHRcdC8vIHNraXAgYXJndW1lbnQgaWYgaXNuJ3QgYW4gb2JqZWN0LCBpcyBudWxsLCBvciBpcyBhbiBhcnJheVxuXHRcdGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwgfHwgQXJyYXkuaXNBcnJheShvYmopKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0T2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdHNyYyA9IHNhZmVHZXRQcm9wZXJ0eSh0YXJnZXQsIGtleSk7IC8vIHNvdXJjZSB2YWx1ZVxuXHRcdFx0dmFsID0gc2FmZUdldFByb3BlcnR5KG9iaiwga2V5KTsgLy8gbmV3IHZhbHVlXG5cblx0XHRcdC8vIHJlY3Vyc2lvbiBwcmV2ZW50aW9uXG5cdFx0XHRpZiAodmFsID09PSB0YXJnZXQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIGlmIG5ldyB2YWx1ZSBpc24ndCBvYmplY3QgdGhlbiBqdXN0IG92ZXJ3cml0ZSBieSBuZXcgdmFsdWVcblx0XHRcdCAqIGluc3RlYWQgb2YgZXh0ZW5kaW5nLlxuXHRcdFx0ICovXG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWwgIT09ICdvYmplY3QnIHx8IHZhbCA9PT0gbnVsbCkge1xuXHRcdFx0XHR0YXJnZXRba2V5XSA9IHZhbDtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHQvLyBqdXN0IGNsb25lIGFycmF5cyAoYW5kIHJlY3Vyc2l2ZSBjbG9uZSBvYmplY3RzIGluc2lkZSlcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG5cdFx0XHRcdHRhcmdldFtrZXldID0gZGVlcENsb25lQXJyYXkodmFsKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHQvLyBjdXN0b20gY2xvbmluZyBhbmQgb3ZlcndyaXRlIGZvciBzcGVjaWZpYyBvYmplY3RzXG5cdFx0XHR9IGVsc2UgaWYgKGlzU3BlY2lmaWNWYWx1ZSh2YWwpKSB7XG5cdFx0XHRcdHRhcmdldFtrZXldID0gY2xvbmVTcGVjaWZpY1ZhbHVlKHZhbCk7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0Ly8gb3ZlcndyaXRlIGJ5IG5ldyB2YWx1ZSBpZiBzb3VyY2UgaXNuJ3Qgb2JqZWN0IG9yIGFycmF5XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBzcmMgIT09ICdvYmplY3QnIHx8IHNyYyA9PT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KHNyYykpIHtcblx0XHRcdFx0dGFyZ2V0W2tleV0gPSBkZWVwRXh0ZW5kKHt9LCB2YWwpO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdC8vIHNvdXJjZSB2YWx1ZSBhbmQgbmV3IHZhbHVlIGlzIG9iamVjdHMgYm90aCwgZXh0ZW5kaW5nLi4uXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0YXJnZXRba2V5XSA9IGRlZXBFeHRlbmQoc3JjLCB2YWwpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXG5cdHJldHVybiB0YXJnZXQ7XG59O1xuIiwiXG4vKipcbiAqIEV4cG9zZSBgRGVsZWdhdG9yYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IERlbGVnYXRvcjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgZGVsZWdhdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b1xuICogQHBhcmFtIHtTdHJpbmd9IHRhcmdldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBEZWxlZ2F0b3IocHJvdG8sIHRhcmdldCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVsZWdhdG9yKSkgcmV0dXJuIG5ldyBEZWxlZ2F0b3IocHJvdG8sIHRhcmdldCk7XG4gIHRoaXMucHJvdG8gPSBwcm90bztcbiAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gIHRoaXMubWV0aG9kcyA9IFtdO1xuICB0aGlzLmdldHRlcnMgPSBbXTtcbiAgdGhpcy5zZXR0ZXJzID0gW107XG4gIHRoaXMuZmx1ZW50cyA9IFtdO1xufVxuXG4vKipcbiAqIERlbGVnYXRlIG1ldGhvZCBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0RlbGVnYXRvcn0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5EZWxlZ2F0b3IucHJvdG90eXBlLm1ldGhvZCA9IGZ1bmN0aW9uKG5hbWUpe1xuICB2YXIgcHJvdG8gPSB0aGlzLnByb3RvO1xuICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG4gIHRoaXMubWV0aG9kcy5wdXNoKG5hbWUpO1xuXG4gIHByb3RvW25hbWVdID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpc1t0YXJnZXRdW25hbWVdLmFwcGx5KHRoaXNbdGFyZ2V0XSwgYXJndW1lbnRzKTtcbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGVsZWdhdG9yIGFjY2Vzc29yIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7RGVsZWdhdG9yfSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRlbGVnYXRvci5wcm90b3R5cGUuYWNjZXNzID0gZnVuY3Rpb24obmFtZSl7XG4gIHJldHVybiB0aGlzLmdldHRlcihuYW1lKS5zZXR0ZXIobmFtZSk7XG59O1xuXG4vKipcbiAqIERlbGVnYXRvciBnZXR0ZXIgYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtEZWxlZ2F0b3J9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRGVsZWdhdG9yLnByb3RvdHlwZS5nZXR0ZXIgPSBmdW5jdGlvbihuYW1lKXtcbiAgdmFyIHByb3RvID0gdGhpcy5wcm90bztcbiAgdmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuICB0aGlzLmdldHRlcnMucHVzaChuYW1lKTtcblxuICBwcm90by5fX2RlZmluZUdldHRlcl9fKG5hbWUsIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXNbdGFyZ2V0XVtuYW1lXTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERlbGVnYXRvciBzZXR0ZXIgYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtEZWxlZ2F0b3J9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRGVsZWdhdG9yLnByb3RvdHlwZS5zZXR0ZXIgPSBmdW5jdGlvbihuYW1lKXtcbiAgdmFyIHByb3RvID0gdGhpcy5wcm90bztcbiAgdmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuICB0aGlzLnNldHRlcnMucHVzaChuYW1lKTtcblxuICBwcm90by5fX2RlZmluZVNldHRlcl9fKG5hbWUsIGZ1bmN0aW9uKHZhbCl7XG4gICAgcmV0dXJuIHRoaXNbdGFyZ2V0XVtuYW1lXSA9IHZhbDtcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERlbGVnYXRvciBmbHVlbnQgYWNjZXNzb3JcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7RGVsZWdhdG9yfSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRlbGVnYXRvci5wcm90b3R5cGUuZmx1ZW50ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIHByb3RvID0gdGhpcy5wcm90bztcbiAgdmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuICB0aGlzLmZsdWVudHMucHVzaChuYW1lKTtcblxuICBwcm90b1tuYW1lXSA9IGZ1bmN0aW9uKHZhbCl7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZiB2YWwpIHtcbiAgICAgIHRoaXNbdGFyZ2V0XVtuYW1lXSA9IHZhbDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpc1t0YXJnZXRdW25hbWVdO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBwbGF0Zm9ybSA9IHJlcXVpcmUoJ29zJykucGxhdGZvcm0oKTtcbnZhciBzcGF3blN5bmMgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuc3Bhd25TeW5jO1xudmFyIHJlYWRkaXJTeW5jID0gcmVxdWlyZSgnZnMnKS5yZWFkZGlyU3luYztcblxudmFyIEdMSUJDID0gJ2dsaWJjJztcbnZhciBNVVNMID0gJ211c2wnO1xuXG52YXIgc3Bhd25PcHRpb25zID0ge1xuICBlbmNvZGluZzogJ3V0ZjgnLFxuICBlbnY6IHByb2Nlc3MuZW52XG59O1xuXG5pZiAoIXNwYXduU3luYykge1xuICBzcGF3blN5bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHsgc3RhdHVzOiAxMjYsIHN0ZG91dDogJycsIHN0ZGVycjogJycgfTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnMgKG5lZWRsZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGhheXN0YWNrKSB7XG4gICAgcmV0dXJuIGhheXN0YWNrLmluZGV4T2YobmVlZGxlKSAhPT0gLTE7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHZlcnNpb25Gcm9tTXVzbExkZCAob3V0KSB7XG4gIHJldHVybiBvdXQuc3BsaXQoL1tcXHJcXG5dKy8pWzFdLnRyaW0oKS5zcGxpdCgvXFxzLylbMV07XG59XG5cbmZ1bmN0aW9uIHNhZmVSZWFkZGlyU3luYyAocGF0aCkge1xuICB0cnkge1xuICAgIHJldHVybiByZWFkZGlyU3luYyhwYXRoKTtcbiAgfSBjYXRjaCAoZSkge31cbiAgcmV0dXJuIFtdO1xufVxuXG52YXIgZmFtaWx5ID0gJyc7XG52YXIgdmVyc2lvbiA9ICcnO1xudmFyIG1ldGhvZCA9ICcnO1xuXG5pZiAocGxhdGZvcm0gPT09ICdsaW51eCcpIHtcbiAgLy8gVHJ5IGdldGNvbmZcbiAgdmFyIGdsaWJjID0gc3Bhd25TeW5jKCdnZXRjb25mJywgWydHTlVfTElCQ19WRVJTSU9OJ10sIHNwYXduT3B0aW9ucyk7XG4gIGlmIChnbGliYy5zdGF0dXMgPT09IDApIHtcbiAgICBmYW1pbHkgPSBHTElCQztcbiAgICB2ZXJzaW9uID0gZ2xpYmMuc3Rkb3V0LnRyaW0oKS5zcGxpdCgnICcpWzFdO1xuICAgIG1ldGhvZCA9ICdnZXRjb25mJztcbiAgfSBlbHNlIHtcbiAgICAvLyBUcnkgbGRkXG4gICAgdmFyIGxkZCA9IHNwYXduU3luYygnbGRkJywgWyctLXZlcnNpb24nXSwgc3Bhd25PcHRpb25zKTtcbiAgICBpZiAobGRkLnN0YXR1cyA9PT0gMCAmJiBsZGQuc3Rkb3V0LmluZGV4T2YoTVVTTCkgIT09IC0xKSB7XG4gICAgICBmYW1pbHkgPSBNVVNMO1xuICAgICAgdmVyc2lvbiA9IHZlcnNpb25Gcm9tTXVzbExkZChsZGQuc3Rkb3V0KTtcbiAgICAgIG1ldGhvZCA9ICdsZGQnO1xuICAgIH0gZWxzZSBpZiAobGRkLnN0YXR1cyA9PT0gMSAmJiBsZGQuc3RkZXJyLmluZGV4T2YoTVVTTCkgIT09IC0xKSB7XG4gICAgICBmYW1pbHkgPSBNVVNMO1xuICAgICAgdmVyc2lvbiA9IHZlcnNpb25Gcm9tTXVzbExkZChsZGQuc3RkZXJyKTtcbiAgICAgIG1ldGhvZCA9ICdsZGQnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUcnkgZmlsZXN5c3RlbSAoZmFtaWx5IG9ubHkpXG4gICAgICB2YXIgbGliID0gc2FmZVJlYWRkaXJTeW5jKCcvbGliJyk7XG4gICAgICBpZiAobGliLnNvbWUoY29udGFpbnMoJy1saW51eC1nbnUnKSkpIHtcbiAgICAgICAgZmFtaWx5ID0gR0xJQkM7XG4gICAgICAgIG1ldGhvZCA9ICdmaWxlc3lzdGVtJztcbiAgICAgIH0gZWxzZSBpZiAobGliLnNvbWUoY29udGFpbnMoJ2xpYmMubXVzbC0nKSkpIHtcbiAgICAgICAgZmFtaWx5ID0gTVVTTDtcbiAgICAgICAgbWV0aG9kID0gJ2ZpbGVzeXN0ZW0nO1xuICAgICAgfSBlbHNlIGlmIChsaWIuc29tZShjb250YWlucygnbGQtbXVzbC0nKSkpIHtcbiAgICAgICAgZmFtaWx5ID0gTVVTTDtcbiAgICAgICAgbWV0aG9kID0gJ2ZpbGVzeXN0ZW0nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHVzclNiaW4gPSBzYWZlUmVhZGRpclN5bmMoJy91c3Ivc2JpbicpO1xuICAgICAgICBpZiAodXNyU2Jpbi5zb21lKGNvbnRhaW5zKCdnbGliYycpKSkge1xuICAgICAgICAgIGZhbWlseSA9IEdMSUJDO1xuICAgICAgICAgIG1ldGhvZCA9ICdmaWxlc3lzdGVtJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgaXNOb25HbGliY0xpbnV4ID0gKGZhbWlseSAhPT0gJycgJiYgZmFtaWx5ICE9PSBHTElCQyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTElCQzogR0xJQkMsXG4gIE1VU0w6IE1VU0wsXG4gIGZhbWlseTogZmFtaWx5LFxuICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICBtZXRob2Q6IG1ldGhvZCxcbiAgaXNOb25HbGliY0xpbnV4OiBpc05vbkdsaWJjTGludXhcbn07XG4iLCIndXNlIHN0cmljdCdcbmNvbnN0IE1pbmlQYXNzID0gcmVxdWlyZSgnbWluaXBhc3MnKVxuY29uc3QgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKVxuXG4vLyBmb3Igd3JpdGV2XG5jb25zdCBiaW5kaW5nID0gcHJvY2Vzcy5iaW5kaW5nKCdmcycpXG5jb25zdCB3cml0ZUJ1ZmZlcnMgPSBiaW5kaW5nLndyaXRlQnVmZmVyc1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IEZTUmVxV3JhcCA9IGJpbmRpbmcuRlNSZXFXcmFwIHx8IGJpbmRpbmcuRlNSZXFDYWxsYmFja1xuXG5jb25zdCBfYXV0b0Nsb3NlID0gU3ltYm9sKCdfYXV0b0Nsb3NlJylcbmNvbnN0IF9jbG9zZSA9IFN5bWJvbCgnX2Nsb3NlJylcbmNvbnN0IF9lbmRlZCA9IFN5bWJvbCgnX2VuZGVkJylcbmNvbnN0IF9mZCA9IFN5bWJvbCgnX2ZkJylcbmNvbnN0IF9maW5pc2hlZCA9IFN5bWJvbCgnX2ZpbmlzaGVkJylcbmNvbnN0IF9mbGFncyA9IFN5bWJvbCgnX2ZsYWdzJylcbmNvbnN0IF9mbHVzaCA9IFN5bWJvbCgnX2ZsdXNoJylcbmNvbnN0IF9oYW5kbGVDaHVuayA9IFN5bWJvbCgnX2hhbmRsZUNodW5rJylcbmNvbnN0IF9tYWtlQnVmID0gU3ltYm9sKCdfbWFrZUJ1ZicpXG5jb25zdCBfbW9kZSA9IFN5bWJvbCgnX21vZGUnKVxuY29uc3QgX25lZWREcmFpbiA9IFN5bWJvbCgnX25lZWREcmFpbicpXG5jb25zdCBfb25lcnJvciA9IFN5bWJvbCgnX29uZXJyb3InKVxuY29uc3QgX29ub3BlbiA9IFN5bWJvbCgnX29ub3BlbicpXG5jb25zdCBfb25yZWFkID0gU3ltYm9sKCdfb25yZWFkJylcbmNvbnN0IF9vbndyaXRlID0gU3ltYm9sKCdfb253cml0ZScpXG5jb25zdCBfb3BlbiA9IFN5bWJvbCgnX29wZW4nKVxuY29uc3QgX3BhdGggPSBTeW1ib2woJ19wYXRoJylcbmNvbnN0IF9wb3MgPSBTeW1ib2woJ19wb3MnKVxuY29uc3QgX3F1ZXVlID0gU3ltYm9sKCdfcXVldWUnKVxuY29uc3QgX3JlYWQgPSBTeW1ib2woJ19yZWFkJylcbmNvbnN0IF9yZWFkU2l6ZSA9IFN5bWJvbCgnX3JlYWRTaXplJylcbmNvbnN0IF9yZWFkaW5nID0gU3ltYm9sKCdfcmVhZGluZycpXG5jb25zdCBfcmVtYWluID0gU3ltYm9sKCdfcmVtYWluJylcbmNvbnN0IF9zaXplID0gU3ltYm9sKCdfc2l6ZScpXG5jb25zdCBfd3JpdGUgPSBTeW1ib2woJ193cml0ZScpXG5jb25zdCBfd3JpdGluZyA9IFN5bWJvbCgnX3dyaXRpbmcnKVxuY29uc3QgX2RlZmF1bHRGbGFnID0gU3ltYm9sKCdfZGVmYXVsdEZsYWcnKVxuXG5jbGFzcyBSZWFkU3RyZWFtIGV4dGVuZHMgTWluaVBhc3Mge1xuICBjb25zdHJ1Y3RvciAocGF0aCwgb3B0KSB7XG4gICAgb3B0ID0gb3B0IHx8IHt9XG4gICAgc3VwZXIob3B0KVxuXG4gICAgdGhpcy53cml0YWJsZSA9IGZhbHNlXG5cbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGF0aCBtdXN0IGJlIGEgc3RyaW5nJylcblxuICAgIHRoaXNbX2ZkXSA9IHR5cGVvZiBvcHQuZmQgPT09ICdudW1iZXInID8gb3B0LmZkIDogbnVsbFxuICAgIHRoaXNbX3BhdGhdID0gcGF0aFxuICAgIHRoaXNbX3JlYWRTaXplXSA9IG9wdC5yZWFkU2l6ZSB8fCAxNioxMDI0KjEwMjRcbiAgICB0aGlzW19yZWFkaW5nXSA9IGZhbHNlXG4gICAgdGhpc1tfc2l6ZV0gPSB0eXBlb2Ygb3B0LnNpemUgPT09ICdudW1iZXInID8gb3B0LnNpemUgOiBJbmZpbml0eVxuICAgIHRoaXNbX3JlbWFpbl0gPSB0aGlzW19zaXplXVxuICAgIHRoaXNbX2F1dG9DbG9zZV0gPSB0eXBlb2Ygb3B0LmF1dG9DbG9zZSA9PT0gJ2Jvb2xlYW4nID9cbiAgICAgIG9wdC5hdXRvQ2xvc2UgOiB0cnVlXG5cbiAgICBpZiAodHlwZW9mIHRoaXNbX2ZkXSA9PT0gJ251bWJlcicpXG4gICAgICB0aGlzW19yZWFkXSgpXG4gICAgZWxzZVxuICAgICAgdGhpc1tfb3Blbl0oKVxuICB9XG5cbiAgZ2V0IGZkICgpIHsgcmV0dXJuIHRoaXNbX2ZkXSB9XG4gIGdldCBwYXRoICgpIHsgcmV0dXJuIHRoaXNbX3BhdGhdIH1cblxuICB3cml0ZSAoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBpcyBhIHJlYWRhYmxlIHN0cmVhbScpXG4gIH1cblxuICBlbmQgKCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RoaXMgaXMgYSByZWFkYWJsZSBzdHJlYW0nKVxuICB9XG5cbiAgW19vcGVuXSAoKSB7XG4gICAgZnMub3Blbih0aGlzW19wYXRoXSwgJ3InLCAoZXIsIGZkKSA9PiB0aGlzW19vbm9wZW5dKGVyLCBmZCkpXG4gIH1cblxuICBbX29ub3Blbl0gKGVyLCBmZCkge1xuICAgIGlmIChlcilcbiAgICAgIHRoaXNbX29uZXJyb3JdKGVyKVxuICAgIGVsc2Uge1xuICAgICAgdGhpc1tfZmRdID0gZmRcbiAgICAgIHRoaXMuZW1pdCgnb3BlbicsIGZkKVxuICAgICAgdGhpc1tfcmVhZF0oKVxuICAgIH1cbiAgfVxuXG4gIFtfbWFrZUJ1Zl0gKCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoTWF0aC5taW4odGhpc1tfcmVhZFNpemVdLCB0aGlzW19yZW1haW5dKSlcbiAgfVxuXG4gIFtfcmVhZF0gKCkge1xuICAgIGlmICghdGhpc1tfcmVhZGluZ10pIHtcbiAgICAgIHRoaXNbX3JlYWRpbmddID0gdHJ1ZVxuICAgICAgY29uc3QgYnVmID0gdGhpc1tfbWFrZUJ1Zl0oKVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soKCkgPT4gdGhpc1tfb25yZWFkXShudWxsLCAwLCBidWYpKVxuICAgICAgZnMucmVhZCh0aGlzW19mZF0sIGJ1ZiwgMCwgYnVmLmxlbmd0aCwgbnVsbCwgKGVyLCBiciwgYnVmKSA9PlxuICAgICAgICB0aGlzW19vbnJlYWRdKGVyLCBiciwgYnVmKSlcbiAgICB9XG4gIH1cblxuICBbX29ucmVhZF0gKGVyLCBiciwgYnVmKSB7XG4gICAgdGhpc1tfcmVhZGluZ10gPSBmYWxzZVxuICAgIGlmIChlcilcbiAgICAgIHRoaXNbX29uZXJyb3JdKGVyKVxuICAgIGVsc2UgaWYgKHRoaXNbX2hhbmRsZUNodW5rXShiciwgYnVmKSlcbiAgICAgIHRoaXNbX3JlYWRdKClcbiAgfVxuXG4gIFtfY2xvc2VdICgpIHtcbiAgICBpZiAodGhpc1tfYXV0b0Nsb3NlXSAmJiB0eXBlb2YgdGhpc1tfZmRdID09PSAnbnVtYmVyJykge1xuICAgICAgZnMuY2xvc2UodGhpc1tfZmRdLCBfID0+IHRoaXMuZW1pdCgnY2xvc2UnKSlcbiAgICAgIHRoaXNbX2ZkXSA9IG51bGxcbiAgICB9XG4gIH1cblxuICBbX29uZXJyb3JdIChlcikge1xuICAgIHRoaXNbX3JlYWRpbmddID0gdHJ1ZVxuICAgIHRoaXNbX2Nsb3NlXSgpXG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKVxuICB9XG5cbiAgW19oYW5kbGVDaHVua10gKGJyLCBidWYpIHtcbiAgICBsZXQgcmV0ID0gZmFsc2VcbiAgICAvLyBubyBlZmZlY3QgaWYgaW5maW5pdGVcbiAgICB0aGlzW19yZW1haW5dIC09IGJyXG4gICAgaWYgKGJyID4gMClcbiAgICAgIHJldCA9IHN1cGVyLndyaXRlKGJyIDwgYnVmLmxlbmd0aCA/IGJ1Zi5zbGljZSgwLCBicikgOiBidWYpXG5cbiAgICBpZiAoYnIgPT09IDAgfHwgdGhpc1tfcmVtYWluXSA8PSAwKSB7XG4gICAgICByZXQgPSBmYWxzZVxuICAgICAgdGhpc1tfY2xvc2VdKClcbiAgICAgIHN1cGVyLmVuZCgpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgZW1pdCAoZXYsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKGV2KSB7XG4gICAgICBjYXNlICdwcmVmaW5pc2gnOlxuICAgICAgY2FzZSAnZmluaXNoJzpcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAnZHJhaW4nOlxuICAgICAgICBpZiAodHlwZW9mIHRoaXNbX2ZkXSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgdGhpc1tfcmVhZF0oKVxuICAgICAgICBicmVha1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gc3VwZXIuZW1pdChldiwgZGF0YSlcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgUmVhZFN0cmVhbVN5bmMgZXh0ZW5kcyBSZWFkU3RyZWFtIHtcbiAgW19vcGVuXSAoKSB7XG4gICAgbGV0IHRocmV3ID0gdHJ1ZVxuICAgIHRyeSB7XG4gICAgICB0aGlzW19vbm9wZW5dKG51bGwsIGZzLm9wZW5TeW5jKHRoaXNbX3BhdGhdLCAncicpKVxuICAgICAgdGhyZXcgPSBmYWxzZVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodGhyZXcpXG4gICAgICAgIHRoaXNbX2Nsb3NlXSgpXG4gICAgfVxuICB9XG5cbiAgW19yZWFkXSAoKSB7XG4gICAgbGV0IHRocmV3ID0gdHJ1ZVxuICAgIHRyeSB7XG4gICAgICBpZiAoIXRoaXNbX3JlYWRpbmddKSB7XG4gICAgICAgIHRoaXNbX3JlYWRpbmddID0gdHJ1ZVxuICAgICAgICBkbyB7XG4gICAgICAgICAgY29uc3QgYnVmID0gdGhpc1tfbWFrZUJ1Zl0oKVxuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgY29uc3QgYnIgPSBidWYubGVuZ3RoID09PSAwID8gMCA6IGZzLnJlYWRTeW5jKHRoaXNbX2ZkXSwgYnVmLCAwLCBidWYubGVuZ3RoLCBudWxsKVxuICAgICAgICAgIGlmICghdGhpc1tfaGFuZGxlQ2h1bmtdKGJyLCBidWYpKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgfSB3aGlsZSAodHJ1ZSlcbiAgICAgICAgdGhpc1tfcmVhZGluZ10gPSBmYWxzZVxuICAgICAgfVxuICAgICAgdGhyZXcgPSBmYWxzZVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodGhyZXcpXG4gICAgICAgIHRoaXNbX2Nsb3NlXSgpXG4gICAgfVxuICB9XG5cbiAgW19jbG9zZV0gKCkge1xuICAgIGlmICh0aGlzW19hdXRvQ2xvc2VdICYmIHR5cGVvZiB0aGlzW19mZF0gPT09ICdudW1iZXInKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmcy5jbG9zZVN5bmModGhpc1tfZmRdKVxuICAgICAgfSBjYXRjaCAoZXIpIHt9XG4gICAgICB0aGlzW19mZF0gPSBudWxsXG4gICAgICB0aGlzLmVtaXQoJ2Nsb3NlJylcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgV3JpdGVTdHJlYW0gZXh0ZW5kcyBFRSB7XG4gIGNvbnN0cnVjdG9yIChwYXRoLCBvcHQpIHtcbiAgICBvcHQgPSBvcHQgfHwge31cbiAgICBzdXBlcihvcHQpXG4gICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlXG4gICAgdGhpc1tfd3JpdGluZ10gPSBmYWxzZVxuICAgIHRoaXNbX2VuZGVkXSA9IGZhbHNlXG4gICAgdGhpc1tfbmVlZERyYWluXSA9IGZhbHNlXG4gICAgdGhpc1tfcXVldWVdID0gW11cbiAgICB0aGlzW19wYXRoXSA9IHBhdGhcbiAgICB0aGlzW19mZF0gPSB0eXBlb2Ygb3B0LmZkID09PSAnbnVtYmVyJyA/IG9wdC5mZCA6IG51bGxcbiAgICB0aGlzW19tb2RlXSA9IG9wdC5tb2RlID09PSB1bmRlZmluZWQgPyAwbzY2NiA6IG9wdC5tb2RlXG4gICAgdGhpc1tfcG9zXSA9IHR5cGVvZiBvcHQuc3RhcnQgPT09ICdudW1iZXInID8gb3B0LnN0YXJ0IDogbnVsbFxuICAgIHRoaXNbX2F1dG9DbG9zZV0gPSB0eXBlb2Ygb3B0LmF1dG9DbG9zZSA9PT0gJ2Jvb2xlYW4nID9cbiAgICAgIG9wdC5hdXRvQ2xvc2UgOiB0cnVlXG5cbiAgICAvLyB0cnVuY2F0aW5nIG1ha2VzIG5vIHNlbnNlIHdoZW4gd3JpdGluZyBpbnRvIHRoZSBtaWRkbGVcbiAgICBjb25zdCBkZWZhdWx0RmxhZyA9IHRoaXNbX3Bvc10gIT09IG51bGwgPyAncisnIDogJ3cnXG4gICAgdGhpc1tfZGVmYXVsdEZsYWddID0gb3B0LmZsYWdzID09PSB1bmRlZmluZWRcbiAgICB0aGlzW19mbGFnc10gPSB0aGlzW19kZWZhdWx0RmxhZ10gPyBkZWZhdWx0RmxhZyA6IG9wdC5mbGFnc1xuXG4gICAgaWYgKHRoaXNbX2ZkXSA9PT0gbnVsbClcbiAgICAgIHRoaXNbX29wZW5dKClcbiAgfVxuXG4gIGdldCBmZCAoKSB7IHJldHVybiB0aGlzW19mZF0gfVxuICBnZXQgcGF0aCAoKSB7IHJldHVybiB0aGlzW19wYXRoXSB9XG5cbiAgW19vbmVycm9yXSAoZXIpIHtcbiAgICB0aGlzW19jbG9zZV0oKVxuICAgIHRoaXNbX3dyaXRpbmddID0gdHJ1ZVxuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcilcbiAgfVxuXG4gIFtfb3Blbl0gKCkge1xuICAgIGZzLm9wZW4odGhpc1tfcGF0aF0sIHRoaXNbX2ZsYWdzXSwgdGhpc1tfbW9kZV0sXG4gICAgICAoZXIsIGZkKSA9PiB0aGlzW19vbm9wZW5dKGVyLCBmZCkpXG4gIH1cblxuICBbX29ub3Blbl0gKGVyLCBmZCkge1xuICAgIGlmICh0aGlzW19kZWZhdWx0RmxhZ10gJiZcbiAgICAgICAgdGhpc1tfZmxhZ3NdID09PSAncisnICYmXG4gICAgICAgIGVyICYmIGVyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICB0aGlzW19mbGFnc10gPSAndydcbiAgICAgIHRoaXNbX29wZW5dKClcbiAgICB9IGVsc2UgaWYgKGVyKVxuICAgICAgdGhpc1tfb25lcnJvcl0oZXIpXG4gICAgZWxzZSB7XG4gICAgICB0aGlzW19mZF0gPSBmZFxuICAgICAgdGhpcy5lbWl0KCdvcGVuJywgZmQpXG4gICAgICB0aGlzW19mbHVzaF0oKVxuICAgIH1cbiAgfVxuXG4gIGVuZCAoYnVmLCBlbmMpIHtcbiAgICBpZiAoYnVmKVxuICAgICAgdGhpcy53cml0ZShidWYsIGVuYylcblxuICAgIHRoaXNbX2VuZGVkXSA9IHRydWVcblxuICAgIC8vIHN5bnRoZXRpYyBhZnRlci13cml0ZSBsb2dpYywgd2hlcmUgZHJhaW4vZmluaXNoIGxpdmVcbiAgICBpZiAoIXRoaXNbX3dyaXRpbmddICYmICF0aGlzW19xdWV1ZV0ubGVuZ3RoICYmXG4gICAgICAgIHR5cGVvZiB0aGlzW19mZF0gPT09ICdudW1iZXInKVxuICAgICAgdGhpc1tfb253cml0ZV0obnVsbCwgMClcbiAgfVxuXG4gIHdyaXRlIChidWYsIGVuYykge1xuICAgIGlmICh0eXBlb2YgYnVmID09PSAnc3RyaW5nJylcbiAgICAgIGJ1ZiA9IG5ldyBCdWZmZXIoYnVmLCBlbmMpXG5cbiAgICBpZiAodGhpc1tfZW5kZWRdKSB7XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCd3cml0ZSgpIGFmdGVyIGVuZCgpJykpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAodGhpc1tfZmRdID09PSBudWxsIHx8IHRoaXNbX3dyaXRpbmddIHx8IHRoaXNbX3F1ZXVlXS5sZW5ndGgpIHtcbiAgICAgIHRoaXNbX3F1ZXVlXS5wdXNoKGJ1ZilcbiAgICAgIHRoaXNbX25lZWREcmFpbl0gPSB0cnVlXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICB0aGlzW193cml0aW5nXSA9IHRydWVcbiAgICB0aGlzW193cml0ZV0oYnVmKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBbX3dyaXRlXSAoYnVmKSB7XG4gICAgZnMud3JpdGUodGhpc1tfZmRdLCBidWYsIDAsIGJ1Zi5sZW5ndGgsIHRoaXNbX3Bvc10sIChlciwgYncpID0+XG4gICAgICB0aGlzW19vbndyaXRlXShlciwgYncpKVxuICB9XG5cbiAgW19vbndyaXRlXSAoZXIsIGJ3KSB7XG4gICAgaWYgKGVyKVxuICAgICAgdGhpc1tfb25lcnJvcl0oZXIpXG4gICAgZWxzZSB7XG4gICAgICBpZiAodGhpc1tfcG9zXSAhPT0gbnVsbClcbiAgICAgICAgdGhpc1tfcG9zXSArPSBid1xuICAgICAgaWYgKHRoaXNbX3F1ZXVlXS5sZW5ndGgpXG4gICAgICAgIHRoaXNbX2ZsdXNoXSgpXG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpc1tfd3JpdGluZ10gPSBmYWxzZVxuXG4gICAgICAgIGlmICh0aGlzW19lbmRlZF0gJiYgIXRoaXNbX2ZpbmlzaGVkXSkge1xuICAgICAgICAgIHRoaXNbX2ZpbmlzaGVkXSA9IHRydWVcbiAgICAgICAgICB0aGlzW19jbG9zZV0oKVxuICAgICAgICAgIHRoaXMuZW1pdCgnZmluaXNoJylcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzW19uZWVkRHJhaW5dKSB7XG4gICAgICAgICAgdGhpc1tfbmVlZERyYWluXSA9IGZhbHNlXG4gICAgICAgICAgdGhpcy5lbWl0KCdkcmFpbicpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBbX2ZsdXNoXSAoKSB7XG4gICAgaWYgKHRoaXNbX3F1ZXVlXS5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmICh0aGlzW19lbmRlZF0pXG4gICAgICAgIHRoaXNbX29ud3JpdGVdKG51bGwsIDApXG4gICAgfSBlbHNlIGlmICh0aGlzW19xdWV1ZV0ubGVuZ3RoID09PSAxKVxuICAgICAgdGhpc1tfd3JpdGVdKHRoaXNbX3F1ZXVlXS5wb3AoKSlcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IGlvdmVjID0gdGhpc1tfcXVldWVdXG4gICAgICB0aGlzW19xdWV1ZV0gPSBbXVxuICAgICAgd3JpdGV2KHRoaXNbX2ZkXSwgaW92ZWMsIHRoaXNbX3Bvc10sXG4gICAgICAgIChlciwgYncpID0+IHRoaXNbX29ud3JpdGVdKGVyLCBidykpXG4gICAgfVxuICB9XG5cbiAgW19jbG9zZV0gKCkge1xuICAgIGlmICh0aGlzW19hdXRvQ2xvc2VdICYmIHR5cGVvZiB0aGlzW19mZF0gPT09ICdudW1iZXInKSB7XG4gICAgICBmcy5jbG9zZSh0aGlzW19mZF0sIF8gPT4gdGhpcy5lbWl0KCdjbG9zZScpKVxuICAgICAgdGhpc1tfZmRdID0gbnVsbFxuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBXcml0ZVN0cmVhbVN5bmMgZXh0ZW5kcyBXcml0ZVN0cmVhbSB7XG4gIFtfb3Blbl0gKCkge1xuICAgIGxldCBmZFxuICAgIHRyeSB7XG4gICAgICBmZCA9IGZzLm9wZW5TeW5jKHRoaXNbX3BhdGhdLCB0aGlzW19mbGFnc10sIHRoaXNbX21vZGVdKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICBpZiAodGhpc1tfZGVmYXVsdEZsYWddICYmXG4gICAgICAgICAgdGhpc1tfZmxhZ3NdID09PSAncisnICYmXG4gICAgICAgICAgZXIgJiYgZXIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgdGhpc1tfZmxhZ3NdID0gJ3cnXG4gICAgICAgIHJldHVybiB0aGlzW19vcGVuXSgpXG4gICAgICB9IGVsc2VcbiAgICAgICAgdGhyb3cgZXJcbiAgICB9XG4gICAgdGhpc1tfb25vcGVuXShudWxsLCBmZClcbiAgfVxuXG4gIFtfY2xvc2VdICgpIHtcbiAgICBpZiAodGhpc1tfYXV0b0Nsb3NlXSAmJiB0eXBlb2YgdGhpc1tfZmRdID09PSAnbnVtYmVyJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZnMuY2xvc2VTeW5jKHRoaXNbX2ZkXSlcbiAgICAgIH0gY2F0Y2ggKGVyKSB7fVxuICAgICAgdGhpc1tfZmRdID0gbnVsbFxuICAgICAgdGhpcy5lbWl0KCdjbG9zZScpXG4gICAgfVxuICB9XG5cbiAgW193cml0ZV0gKGJ1Zikge1xuICAgIHRyeSB7XG4gICAgICB0aGlzW19vbndyaXRlXShudWxsLFxuICAgICAgICBmcy53cml0ZVN5bmModGhpc1tfZmRdLCBidWYsIDAsIGJ1Zi5sZW5ndGgsIHRoaXNbX3Bvc10pKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICB0aGlzW19vbndyaXRlXShlciwgMClcbiAgICB9XG4gIH1cbn1cblxuY29uc3Qgd3JpdGV2ID0gKGZkLCBpb3ZlYywgcG9zLCBjYikgPT4ge1xuICBjb25zdCBkb25lID0gKGVyLCBidykgPT4gY2IoZXIsIGJ3LCBpb3ZlYylcbiAgY29uc3QgcmVxID0gbmV3IEZTUmVxV3JhcCgpXG4gIHJlcS5vbmNvbXBsZXRlID0gZG9uZVxuICBiaW5kaW5nLndyaXRlQnVmZmVycyhmZCwgaW92ZWMsIHBvcywgcmVxKVxufVxuXG5leHBvcnRzLlJlYWRTdHJlYW0gPSBSZWFkU3RyZWFtXG5leHBvcnRzLlJlYWRTdHJlYW1TeW5jID0gUmVhZFN0cmVhbVN5bmNcblxuZXhwb3J0cy5Xcml0ZVN0cmVhbSA9IFdyaXRlU3RyZWFtXG5leHBvcnRzLldyaXRlU3RyZWFtU3luYyA9IFdyaXRlU3RyZWFtU3luY1xuIiwiJ3VzZSBzdHJpY3QnXG52YXIgc3BpbiA9IHJlcXVpcmUoJy4vc3Bpbi5qcycpXG52YXIgcHJvZ3Jlc3NCYXIgPSByZXF1aXJlKCcuL3Byb2dyZXNzLWJhci5qcycpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhY3Rpdml0eUluZGljYXRvcjogZnVuY3Rpb24gKHZhbHVlcywgdGhlbWUsIHdpZHRoKSB7XG4gICAgaWYgKHZhbHVlcy5zcHVuID09IG51bGwpIHJldHVyblxuICAgIHJldHVybiBzcGluKHRoZW1lLCB2YWx1ZXMuc3B1bilcbiAgfSxcbiAgcHJvZ3Jlc3NiYXI6IGZ1bmN0aW9uICh2YWx1ZXMsIHRoZW1lLCB3aWR0aCkge1xuICAgIGlmICh2YWx1ZXMuY29tcGxldGVkID09IG51bGwpIHJldHVyblxuICAgIHJldHVybiBwcm9ncmVzc0Jhcih0aGVtZSwgd2lkdGgsIHZhbHVlcy5jb21wbGV0ZWQpXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJylcblxudmFyIFVzZXIgPSBleHBvcnRzLlVzZXIgPSBmdW5jdGlvbiBVc2VyIChtc2cpIHtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcihtc2cpXG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgVXNlcilcbiAgZXJyLmNvZGUgPSAnRUdBVUdFJ1xuICByZXR1cm4gZXJyXG59XG5cbmV4cG9ydHMuTWlzc2luZ1RlbXBsYXRlVmFsdWUgPSBmdW5jdGlvbiBNaXNzaW5nVGVtcGxhdGVWYWx1ZSAoaXRlbSwgdmFsdWVzKSB7XG4gIHZhciBlcnIgPSBuZXcgVXNlcih1dGlsLmZvcm1hdCgnTWlzc2luZyB0ZW1wbGF0ZSB2YWx1ZSBcIiVzXCInLCBpdGVtLnR5cGUpKVxuICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIsIE1pc3NpbmdUZW1wbGF0ZVZhbHVlKVxuICBlcnIudGVtcGxhdGUgPSBpdGVtXG4gIGVyci52YWx1ZXMgPSB2YWx1ZXNcbiAgcmV0dXJuIGVyclxufVxuXG5leHBvcnRzLkludGVybmFsID0gZnVuY3Rpb24gSW50ZXJuYWwgKG1zZykge1xuICB2YXIgZXJyID0gbmV3IEVycm9yKG1zZylcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBJbnRlcm5hbClcbiAgZXJyLmNvZGUgPSAnRUdBVUdFSU5URVJOQUwnXG4gIHJldHVybiBlcnJcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzV2luMzIoKSB8fCBpc0NvbG9yVGVybSgpXG5cbmZ1bmN0aW9uIGlzV2luMzIgKCkge1xuICByZXR1cm4gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJ1xufVxuXG5mdW5jdGlvbiBpc0NvbG9yVGVybSAoKSB7XG4gIHZhciB0ZXJtSGFzQ29sb3IgPSAvXnNjcmVlbnxeeHRlcm18XnZ0MTAwfGNvbG9yfGFuc2l8Y3lnd2lufGxpbnV4L2lcbiAgcmV0dXJuICEhcHJvY2Vzcy5lbnYuQ09MT1JURVJNIHx8IHRlcm1IYXNDb2xvci50ZXN0KHByb2Nlc3MuZW52LlRFUk0pXG59XG4iLCIndXNlIHN0cmljdCdcbnZhciBQbHVtYmluZyA9IHJlcXVpcmUoJy4vcGx1bWJpbmcuanMnKVxudmFyIGhhc1VuaWNvZGUgPSByZXF1aXJlKCdoYXMtdW5pY29kZScpXG52YXIgaGFzQ29sb3IgPSByZXF1aXJlKCcuL2hhcy1jb2xvci5qcycpXG52YXIgb25FeGl0ID0gcmVxdWlyZSgnc2lnbmFsLWV4aXQnKVxudmFyIGRlZmF1bHRUaGVtZXMgPSByZXF1aXJlKCcuL3RoZW1lcycpXG52YXIgc2V0SW50ZXJ2YWwgPSByZXF1aXJlKCcuL3NldC1pbnRlcnZhbC5qcycpXG52YXIgcHJvY2VzcyA9IHJlcXVpcmUoJy4vcHJvY2Vzcy5qcycpXG52YXIgc2V0SW1tZWRpYXRlID0gcmVxdWlyZSgnLi9zZXQtaW1tZWRpYXRlJylcblxubW9kdWxlLmV4cG9ydHMgPSBHYXVnZVxuXG5mdW5jdGlvbiBjYWxsV2l0aCAob2JqLCBtZXRob2QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbWV0aG9kLmNhbGwob2JqKVxuICB9XG59XG5cbmZ1bmN0aW9uIEdhdWdlIChhcmcxLCBhcmcyKSB7XG4gIHZhciBvcHRpb25zLCB3cml0ZVRvXG4gIGlmIChhcmcxICYmIGFyZzEud3JpdGUpIHtcbiAgICB3cml0ZVRvID0gYXJnMVxuICAgIG9wdGlvbnMgPSBhcmcyIHx8IHt9XG4gIH0gZWxzZSBpZiAoYXJnMiAmJiBhcmcyLndyaXRlKSB7XG4gICAgd3JpdGVUbyA9IGFyZzJcbiAgICBvcHRpb25zID0gYXJnMSB8fCB7fVxuICB9IGVsc2Uge1xuICAgIHdyaXRlVG8gPSBwcm9jZXNzLnN0ZGVyclxuICAgIG9wdGlvbnMgPSBhcmcxIHx8IGFyZzIgfHwge31cbiAgfVxuXG4gIHRoaXMuX3N0YXR1cyA9IHtcbiAgICBzcHVuOiAwLFxuICAgIHNlY3Rpb246ICcnLFxuICAgIHN1YnNlY3Rpb246ICcnXG4gIH1cbiAgdGhpcy5fcGF1c2VkID0gZmFsc2UgLy8gYXJlIHdlIHBhdXNlZCBmb3IgYmFjayBwcmVzc3VyZT9cbiAgdGhpcy5fZGlzYWJsZWQgPSB0cnVlIC8vIGFyZSBhbGwgcHJvZ3Jlc3MgYmFyIHVwZGF0ZXMgZGlzYWJsZWQ/XG4gIHRoaXMuX3Nob3dpbmcgPSBmYWxzZSAvLyBkbyB3ZSBXQU5UIHRoZSBwcm9ncmVzcyBiYXIgb24gc2NyZWVuXG4gIHRoaXMuX29uU2NyZWVuID0gZmFsc2UgLy8gSVMgdGhlIHByb2dyZXNzIGJhciBvbiBzY3JlZW5cbiAgdGhpcy5fbmVlZHNSZWRyYXcgPSBmYWxzZSAvLyBzaG91bGQgd2UgcHJpbnQgc29tZXRoaW5nIGF0IG5leHQgdGljaz9cbiAgdGhpcy5faGlkZUN1cnNvciA9IG9wdGlvbnMuaGlkZUN1cnNvciA9PSBudWxsID8gdHJ1ZSA6IG9wdGlvbnMuaGlkZUN1cnNvclxuICB0aGlzLl9maXhlZEZyYW1lcmF0ZSA9IG9wdGlvbnMuZml4ZWRGcmFtZXJhdGUgPT0gbnVsbFxuICAgID8gISgvXnYwXFwuOFxcLi8udGVzdChwcm9jZXNzLnZlcnNpb24pKVxuICAgIDogb3B0aW9ucy5maXhlZEZyYW1lcmF0ZVxuICB0aGlzLl9sYXN0VXBkYXRlQXQgPSBudWxsXG4gIHRoaXMuX3VwZGF0ZUludGVydmFsID0gb3B0aW9ucy51cGRhdGVJbnRlcnZhbCA9PSBudWxsID8gNTAgOiBvcHRpb25zLnVwZGF0ZUludGVydmFsXG5cbiAgdGhpcy5fdGhlbWVzID0gb3B0aW9ucy50aGVtZXMgfHwgZGVmYXVsdFRoZW1lc1xuICB0aGlzLl90aGVtZSA9IG9wdGlvbnMudGhlbWVcbiAgdmFyIHRoZW1lID0gdGhpcy5fY29tcHV0ZVRoZW1lKG9wdGlvbnMudGhlbWUpXG4gIHZhciB0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGUgfHwgW1xuICAgIHt0eXBlOiAncHJvZ3Jlc3NiYXInLCBsZW5ndGg6IDIwfSxcbiAgICB7dHlwZTogJ2FjdGl2aXR5SW5kaWNhdG9yJywga2VybmluZzogMSwgbGVuZ3RoOiAxfSxcbiAgICB7dHlwZTogJ3NlY3Rpb24nLCBrZXJuaW5nOiAxLCBkZWZhdWx0OiAnJ30sXG4gICAge3R5cGU6ICdzdWJzZWN0aW9uJywga2VybmluZzogMSwgZGVmYXVsdDogJyd9XG4gIF1cbiAgdGhpcy5zZXRXcml0ZVRvKHdyaXRlVG8sIG9wdGlvbnMudHR5KVxuICB2YXIgUGx1bWJpbmdDbGFzcyA9IG9wdGlvbnMuUGx1bWJpbmcgfHwgUGx1bWJpbmdcbiAgdGhpcy5fZ2F1Z2UgPSBuZXcgUGx1bWJpbmdDbGFzcyh0aGVtZSwgdGVtcGxhdGUsIHRoaXMuZ2V0V2lkdGgoKSlcblxuICB0aGlzLl8kJGRvUmVkcmF3ID0gY2FsbFdpdGgodGhpcywgdGhpcy5fZG9SZWRyYXcpXG4gIHRoaXMuXyQkaGFuZGxlU2l6ZUNoYW5nZSA9IGNhbGxXaXRoKHRoaXMsIHRoaXMuX2hhbmRsZVNpemVDaGFuZ2UpXG5cbiAgdGhpcy5fY2xlYW51cE9uRXhpdCA9IG9wdGlvbnMuY2xlYW51cE9uRXhpdCA9PSBudWxsIHx8IG9wdGlvbnMuY2xlYW51cE9uRXhpdFxuICB0aGlzLl9yZW1vdmVPbkV4aXQgPSBudWxsXG5cbiAgaWYgKG9wdGlvbnMuZW5hYmxlZCB8fCAob3B0aW9ucy5lbmFibGVkID09IG51bGwgJiYgdGhpcy5fdHR5ICYmIHRoaXMuX3R0eS5pc1RUWSkpIHtcbiAgICB0aGlzLmVuYWJsZSgpXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5kaXNhYmxlKClcbiAgfVxufVxuR2F1Z2UucHJvdG90eXBlID0ge31cblxuR2F1Z2UucHJvdG90eXBlLmlzRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICF0aGlzLl9kaXNhYmxlZFxufVxuXG5HYXVnZS5wcm90b3R5cGUuc2V0VGVtcGxhdGUgPSBmdW5jdGlvbiAodGVtcGxhdGUpIHtcbiAgdGhpcy5fZ2F1Z2Uuc2V0VGVtcGxhdGUodGVtcGxhdGUpXG4gIGlmICh0aGlzLl9zaG93aW5nKSB0aGlzLl9yZXF1ZXN0UmVkcmF3KClcbn1cblxuR2F1Z2UucHJvdG90eXBlLl9jb21wdXRlVGhlbWUgPSBmdW5jdGlvbiAodGhlbWUpIHtcbiAgaWYgKCF0aGVtZSkgdGhlbWUgPSB7fVxuICBpZiAodHlwZW9mIHRoZW1lID09PSAnc3RyaW5nJykge1xuICAgIHRoZW1lID0gdGhpcy5fdGhlbWVzLmdldFRoZW1lKHRoZW1lKVxuICB9IGVsc2UgaWYgKHRoZW1lICYmIChPYmplY3Qua2V5cyh0aGVtZSkubGVuZ3RoID09PSAwIHx8IHRoZW1lLmhhc1VuaWNvZGUgIT0gbnVsbCB8fCB0aGVtZS5oYXNDb2xvciAhPSBudWxsKSkge1xuICAgIHZhciB1c2VVbmljb2RlID0gdGhlbWUuaGFzVW5pY29kZSA9PSBudWxsID8gaGFzVW5pY29kZSgpIDogdGhlbWUuaGFzVW5pY29kZVxuICAgIHZhciB1c2VDb2xvciA9IHRoZW1lLmhhc0NvbG9yID09IG51bGwgPyBoYXNDb2xvciA6IHRoZW1lLmhhc0NvbG9yXG4gICAgdGhlbWUgPSB0aGlzLl90aGVtZXMuZ2V0RGVmYXVsdCh7aGFzVW5pY29kZTogdXNlVW5pY29kZSwgaGFzQ29sb3I6IHVzZUNvbG9yLCBwbGF0Zm9ybTogdGhlbWUucGxhdGZvcm19KVxuICB9XG4gIHJldHVybiB0aGVtZVxufVxuXG5HYXVnZS5wcm90b3R5cGUuc2V0VGhlbWVzZXQgPSBmdW5jdGlvbiAodGhlbWVzKSB7XG4gIHRoaXMuX3RoZW1lcyA9IHRoZW1lc1xuICB0aGlzLnNldFRoZW1lKHRoaXMuX3RoZW1lKVxufVxuXG5HYXVnZS5wcm90b3R5cGUuc2V0VGhlbWUgPSBmdW5jdGlvbiAodGhlbWUpIHtcbiAgdGhpcy5fZ2F1Z2Uuc2V0VGhlbWUodGhpcy5fY29tcHV0ZVRoZW1lKHRoZW1lKSlcbiAgaWYgKHRoaXMuX3Nob3dpbmcpIHRoaXMuX3JlcXVlc3RSZWRyYXcoKVxuICB0aGlzLl90aGVtZSA9IHRoZW1lXG59XG5cbkdhdWdlLnByb3RvdHlwZS5fcmVxdWVzdFJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fbmVlZHNSZWRyYXcgPSB0cnVlXG4gIGlmICghdGhpcy5fZml4ZWRGcmFtZXJhdGUpIHRoaXMuX2RvUmVkcmF3KClcbn1cblxuR2F1Z2UucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKCh0aGlzLl90dHkgJiYgdGhpcy5fdHR5LmNvbHVtbnMpIHx8IDgwKSAtIDFcbn1cblxuR2F1Z2UucHJvdG90eXBlLnNldFdyaXRlVG8gPSBmdW5jdGlvbiAod3JpdGVUbywgdHR5KSB7XG4gIHZhciBlbmFibGVkID0gIXRoaXMuX2Rpc2FibGVkXG4gIGlmIChlbmFibGVkKSB0aGlzLmRpc2FibGUoKVxuICB0aGlzLl93cml0ZVRvID0gd3JpdGVUb1xuICB0aGlzLl90dHkgPSB0dHkgfHxcbiAgICAod3JpdGVUbyA9PT0gcHJvY2Vzcy5zdGRlcnIgJiYgcHJvY2Vzcy5zdGRvdXQuaXNUVFkgJiYgcHJvY2Vzcy5zdGRvdXQpIHx8XG4gICAgKHdyaXRlVG8uaXNUVFkgJiYgd3JpdGVUbykgfHxcbiAgICB0aGlzLl90dHlcbiAgaWYgKHRoaXMuX2dhdWdlKSB0aGlzLl9nYXVnZS5zZXRXaWR0aCh0aGlzLmdldFdpZHRoKCkpXG4gIGlmIChlbmFibGVkKSB0aGlzLmVuYWJsZSgpXG59XG5cbkdhdWdlLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5fZGlzYWJsZWQpIHJldHVyblxuICB0aGlzLl9kaXNhYmxlZCA9IGZhbHNlXG4gIGlmICh0aGlzLl90dHkpIHRoaXMuX2VuYWJsZUV2ZW50cygpXG4gIGlmICh0aGlzLl9zaG93aW5nKSB0aGlzLnNob3coKVxufVxuXG5HYXVnZS5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2Rpc2FibGVkKSByZXR1cm5cbiAgaWYgKHRoaXMuX3Nob3dpbmcpIHtcbiAgICB0aGlzLl9sYXN0VXBkYXRlQXQgPSBudWxsXG4gICAgdGhpcy5fc2hvd2luZyA9IGZhbHNlXG4gICAgdGhpcy5fZG9SZWRyYXcoKVxuICAgIHRoaXMuX3Nob3dpbmcgPSB0cnVlXG4gIH1cbiAgdGhpcy5fZGlzYWJsZWQgPSB0cnVlXG4gIGlmICh0aGlzLl90dHkpIHRoaXMuX2Rpc2FibGVFdmVudHMoKVxufVxuXG5HYXVnZS5wcm90b3R5cGUuX2VuYWJsZUV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2NsZWFudXBPbkV4aXQpIHtcbiAgICB0aGlzLl9yZW1vdmVPbkV4aXQgPSBvbkV4aXQoY2FsbFdpdGgodGhpcywgdGhpcy5kaXNhYmxlKSlcbiAgfVxuICB0aGlzLl90dHkub24oJ3Jlc2l6ZScsIHRoaXMuXyQkaGFuZGxlU2l6ZUNoYW5nZSlcbiAgaWYgKHRoaXMuX2ZpeGVkRnJhbWVyYXRlKSB7XG4gICAgdGhpcy5yZWRyYXdUcmFja2VyID0gc2V0SW50ZXJ2YWwodGhpcy5fJCRkb1JlZHJhdywgdGhpcy5fdXBkYXRlSW50ZXJ2YWwpXG4gICAgaWYgKHRoaXMucmVkcmF3VHJhY2tlci51bnJlZikgdGhpcy5yZWRyYXdUcmFja2VyLnVucmVmKClcbiAgfVxufVxuXG5HYXVnZS5wcm90b3R5cGUuX2Rpc2FibGVFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX3R0eS5yZW1vdmVMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fJCRoYW5kbGVTaXplQ2hhbmdlKVxuICBpZiAodGhpcy5fZml4ZWRGcmFtZXJhdGUpIGNsZWFySW50ZXJ2YWwodGhpcy5yZWRyYXdUcmFja2VyKVxuICBpZiAodGhpcy5fcmVtb3ZlT25FeGl0KSB0aGlzLl9yZW1vdmVPbkV4aXQoKVxufVxuXG5HYXVnZS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uIChjYikge1xuICBpZiAodGhpcy5fZGlzYWJsZWQpIHJldHVybiBjYiAmJiBwcm9jZXNzLm5leHRUaWNrKGNiKVxuICBpZiAoIXRoaXMuX3Nob3dpbmcpIHJldHVybiBjYiAmJiBwcm9jZXNzLm5leHRUaWNrKGNiKVxuICB0aGlzLl9zaG93aW5nID0gZmFsc2VcbiAgdGhpcy5fZG9SZWRyYXcoKVxuICBjYiAmJiBzZXRJbW1lZGlhdGUoY2IpXG59XG5cbkdhdWdlLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKHNlY3Rpb24sIGNvbXBsZXRlZCkge1xuICB0aGlzLl9zaG93aW5nID0gdHJ1ZVxuICBpZiAodHlwZW9mIHNlY3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy5fc3RhdHVzLnNlY3Rpb24gPSBzZWN0aW9uXG4gIH0gZWxzZSBpZiAodHlwZW9mIHNlY3Rpb24gPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHNlY3Rpb25LZXlzID0gT2JqZWN0LmtleXMoc2VjdGlvbilcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgc2VjdGlvbktleXMubGVuZ3RoOyArK2lpKSB7XG4gICAgICB2YXIga2V5ID0gc2VjdGlvbktleXNbaWldXG4gICAgICB0aGlzLl9zdGF0dXNba2V5XSA9IHNlY3Rpb25ba2V5XVxuICAgIH1cbiAgfVxuICBpZiAoY29tcGxldGVkICE9IG51bGwpIHRoaXMuX3N0YXR1cy5jb21wbGV0ZWQgPSBjb21wbGV0ZWRcbiAgaWYgKHRoaXMuX2Rpc2FibGVkKSByZXR1cm5cbiAgdGhpcy5fcmVxdWVzdFJlZHJhdygpXG59XG5cbkdhdWdlLnByb3RvdHlwZS5wdWxzZSA9IGZ1bmN0aW9uIChzdWJzZWN0aW9uKSB7XG4gIHRoaXMuX3N0YXR1cy5zdWJzZWN0aW9uID0gc3Vic2VjdGlvbiB8fCAnJ1xuICB0aGlzLl9zdGF0dXMuc3B1biArK1xuICBpZiAodGhpcy5fZGlzYWJsZWQpIHJldHVyblxuICBpZiAoIXRoaXMuX3Nob3dpbmcpIHJldHVyblxuICB0aGlzLl9yZXF1ZXN0UmVkcmF3KClcbn1cblxuR2F1Z2UucHJvdG90eXBlLl9oYW5kbGVTaXplQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9nYXVnZS5zZXRXaWR0aCh0aGlzLl90dHkuY29sdW1ucyAtIDEpXG4gIHRoaXMuX3JlcXVlc3RSZWRyYXcoKVxufVxuXG5HYXVnZS5wcm90b3R5cGUuX2RvUmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fZGlzYWJsZWQgfHwgdGhpcy5fcGF1c2VkKSByZXR1cm5cbiAgaWYgKCF0aGlzLl9maXhlZEZyYW1lcmF0ZSkge1xuICAgIHZhciBub3cgPSBEYXRlLm5vdygpXG4gICAgaWYgKHRoaXMuX2xhc3RVcGRhdGVBdCAmJiBub3cgLSB0aGlzLl9sYXN0VXBkYXRlQXQgPCB0aGlzLl91cGRhdGVJbnRlcnZhbCkgcmV0dXJuXG4gICAgdGhpcy5fbGFzdFVwZGF0ZUF0ID0gbm93XG4gIH1cbiAgaWYgKCF0aGlzLl9zaG93aW5nICYmIHRoaXMuX29uU2NyZWVuKSB7XG4gICAgdGhpcy5fb25TY3JlZW4gPSBmYWxzZVxuICAgIHZhciByZXN1bHQgPSB0aGlzLl9nYXVnZS5oaWRlKClcbiAgICBpZiAodGhpcy5faGlkZUN1cnNvcikge1xuICAgICAgcmVzdWx0ICs9IHRoaXMuX2dhdWdlLnNob3dDdXJzb3IoKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd3JpdGVUby53cml0ZShyZXN1bHQpXG4gIH1cbiAgaWYgKCF0aGlzLl9zaG93aW5nICYmICF0aGlzLl9vblNjcmVlbikgcmV0dXJuXG4gIGlmICh0aGlzLl9zaG93aW5nICYmICF0aGlzLl9vblNjcmVlbikge1xuICAgIHRoaXMuX29uU2NyZWVuID0gdHJ1ZVxuICAgIHRoaXMuX25lZWRzUmVkcmF3ID0gdHJ1ZVxuICAgIGlmICh0aGlzLl9oaWRlQ3Vyc29yKSB7XG4gICAgICB0aGlzLl93cml0ZVRvLndyaXRlKHRoaXMuX2dhdWdlLmhpZGVDdXJzb3IoKSlcbiAgICB9XG4gIH1cbiAgaWYgKCF0aGlzLl9uZWVkc1JlZHJhdykgcmV0dXJuXG4gIGlmICghdGhpcy5fd3JpdGVUby53cml0ZSh0aGlzLl9nYXVnZS5zaG93KHRoaXMuX3N0YXR1cykpKSB7XG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZVxuICAgIHRoaXMuX3dyaXRlVG8ub24oJ2RyYWluJywgY2FsbFdpdGgodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fcGF1c2VkID0gZmFsc2VcbiAgICAgIHRoaXMuX2RvUmVkcmF3KClcbiAgICB9KSlcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgY29uc29sZUNvbnRyb2wgPSByZXF1aXJlKCdjb25zb2xlLWNvbnRyb2wtc3RyaW5ncycpXG52YXIgcmVuZGVyVGVtcGxhdGUgPSByZXF1aXJlKCcuL3JlbmRlci10ZW1wbGF0ZS5qcycpXG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCdhcHJvYmEnKVxuXG52YXIgUGx1bWJpbmcgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGVtZSwgdGVtcGxhdGUsIHdpZHRoKSB7XG4gIGlmICghd2lkdGgpIHdpZHRoID0gODBcbiAgdmFsaWRhdGUoJ09BTicsIFt0aGVtZSwgdGVtcGxhdGUsIHdpZHRoXSlcbiAgdGhpcy5zaG93aW5nID0gZmFsc2VcbiAgdGhpcy50aGVtZSA9IHRoZW1lXG4gIHRoaXMud2lkdGggPSB3aWR0aFxuICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGVcbn1cblBsdW1iaW5nLnByb3RvdHlwZSA9IHt9XG5cblBsdW1iaW5nLnByb3RvdHlwZS5zZXRUaGVtZSA9IGZ1bmN0aW9uICh0aGVtZSkge1xuICB2YWxpZGF0ZSgnTycsIFt0aGVtZV0pXG4gIHRoaXMudGhlbWUgPSB0aGVtZVxufVxuXG5QbHVtYmluZy5wcm90b3R5cGUuc2V0VGVtcGxhdGUgPSBmdW5jdGlvbiAodGVtcGxhdGUpIHtcbiAgdmFsaWRhdGUoJ0EnLCBbdGVtcGxhdGVdKVxuICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGVcbn1cblxuUGx1bWJpbmcucHJvdG90eXBlLnNldFdpZHRoID0gZnVuY3Rpb24gKHdpZHRoKSB7XG4gIHZhbGlkYXRlKCdOJywgW3dpZHRoXSlcbiAgdGhpcy53aWR0aCA9IHdpZHRoXG59XG5cblBsdW1iaW5nLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY29uc29sZUNvbnRyb2wuZ290b1NPTCgpICsgY29uc29sZUNvbnRyb2wuZXJhc2VMaW5lKClcbn1cblxuUGx1bWJpbmcucHJvdG90eXBlLmhpZGVDdXJzb3IgPSBjb25zb2xlQ29udHJvbC5oaWRlQ3Vyc29yXG5cblBsdW1iaW5nLnByb3RvdHlwZS5zaG93Q3Vyc29yID0gY29uc29sZUNvbnRyb2wuc2hvd0N1cnNvclxuXG5QbHVtYmluZy5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgdmFyIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUodGhpcy50aGVtZSlcbiAgZm9yICh2YXIga2V5IGluIHN0YXR1cykge1xuICAgIHZhbHVlc1trZXldID0gc3RhdHVzW2tleV1cbiAgfVxuXG4gIHJldHVybiByZW5kZXJUZW1wbGF0ZSh0aGlzLndpZHRoLCB0aGlzLnRlbXBsYXRlLCB2YWx1ZXMpLnRyaW0oKSArXG4gICAgICAgICBjb25zb2xlQ29udHJvbC5jb2xvcigncmVzZXQnKSArXG4gICAgICAgICBjb25zb2xlQ29udHJvbC5lcmFzZUxpbmUoKSArIGNvbnNvbGVDb250cm9sLmdvdG9TT0woKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG4vLyB0aGlzIGV4aXN0cyBzbyB3ZSBjYW4gcmVwbGFjZSBpdCBkdXJpbmcgdGVzdGluZ1xubW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzXG4iLCIndXNlIHN0cmljdCdcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJ2Fwcm9iYScpXG52YXIgcmVuZGVyVGVtcGxhdGUgPSByZXF1aXJlKCcuL3JlbmRlci10ZW1wbGF0ZS5qcycpXG52YXIgd2lkZVRydW5jYXRlID0gcmVxdWlyZSgnLi93aWRlLXRydW5jYXRlJylcbnZhciBzdHJpbmdXaWR0aCA9IHJlcXVpcmUoJ3N0cmluZy13aWR0aCcpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoZW1lLCB3aWR0aCwgY29tcGxldGVkKSB7XG4gIHZhbGlkYXRlKCdPTk4nLCBbdGhlbWUsIHdpZHRoLCBjb21wbGV0ZWRdKVxuICBpZiAoY29tcGxldGVkIDwgMCkgY29tcGxldGVkID0gMFxuICBpZiAoY29tcGxldGVkID4gMSkgY29tcGxldGVkID0gMVxuICBpZiAod2lkdGggPD0gMCkgcmV0dXJuICcnXG4gIHZhciBzb2ZhciA9IE1hdGgucm91bmQod2lkdGggKiBjb21wbGV0ZWQpXG4gIHZhciByZXN0ID0gd2lkdGggLSBzb2ZhclxuICB2YXIgdGVtcGxhdGUgPSBbXG4gICAge3R5cGU6ICdjb21wbGV0ZScsIHZhbHVlOiByZXBlYXQodGhlbWUuY29tcGxldGUsIHNvZmFyKSwgbGVuZ3RoOiBzb2Zhcn0sXG4gICAge3R5cGU6ICdyZW1haW5pbmcnLCB2YWx1ZTogcmVwZWF0KHRoZW1lLnJlbWFpbmluZywgcmVzdCksIGxlbmd0aDogcmVzdH1cbiAgXVxuICByZXR1cm4gcmVuZGVyVGVtcGxhdGUod2lkdGgsIHRlbXBsYXRlLCB0aGVtZSlcbn1cblxuLy8gbG9kYXNoJ3Mgd2F5IG9mIHJlcGVhdGluZ1xuZnVuY3Rpb24gcmVwZWF0IChzdHJpbmcsIHdpZHRoKSB7XG4gIHZhciByZXN1bHQgPSAnJ1xuICB2YXIgbiA9IHdpZHRoXG4gIGRvIHtcbiAgICBpZiAobiAlIDIpIHtcbiAgICAgIHJlc3VsdCArPSBzdHJpbmdcbiAgICB9XG4gICAgbiA9IE1hdGguZmxvb3IobiAvIDIpXG4gICAgLyplc2xpbnQgbm8tc2VsZi1hc3NpZ246IDAqL1xuICAgIHN0cmluZyArPSBzdHJpbmdcbiAgfSB3aGlsZSAobiAmJiBzdHJpbmdXaWR0aChyZXN1bHQpIDwgd2lkdGgpXG5cbiAgcmV0dXJuIHdpZGVUcnVuY2F0ZShyZXN1bHQsIHdpZHRoKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgYWxpZ24gPSByZXF1aXJlKCd3aWRlLWFsaWduJylcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJ2Fwcm9iYScpXG52YXIgb2JqZWN0QXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpXG52YXIgd2lkZVRydW5jYXRlID0gcmVxdWlyZSgnLi93aWRlLXRydW5jYXRlJylcbnZhciBlcnJvciA9IHJlcXVpcmUoJy4vZXJyb3InKVxudmFyIFRlbXBsYXRlSXRlbSA9IHJlcXVpcmUoJy4vdGVtcGxhdGUtaXRlbScpXG5cbmZ1bmN0aW9uIHJlbmRlclZhbHVlV2l0aFZhbHVlcyAodmFsdWVzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXRlbSkge1xuICAgIHJldHVybiByZW5kZXJWYWx1ZShpdGVtLCB2YWx1ZXMpXG4gIH1cbn1cblxudmFyIHJlbmRlclRlbXBsYXRlID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAod2lkdGgsIHRlbXBsYXRlLCB2YWx1ZXMpIHtcbiAgdmFyIGl0ZW1zID0gcHJlcGFyZUl0ZW1zKHdpZHRoLCB0ZW1wbGF0ZSwgdmFsdWVzKVxuICB2YXIgcmVuZGVyZWQgPSBpdGVtcy5tYXAocmVuZGVyVmFsdWVXaXRoVmFsdWVzKHZhbHVlcykpLmpvaW4oJycpXG4gIHJldHVybiBhbGlnbi5sZWZ0KHdpZGVUcnVuY2F0ZShyZW5kZXJlZCwgd2lkdGgpLCB3aWR0aClcbn1cblxuZnVuY3Rpb24gcHJlVHlwZSAoaXRlbSkge1xuICB2YXIgY2FwcGVkVHlwZU5hbWUgPSBpdGVtLnR5cGVbMF0udG9VcHBlckNhc2UoKSArIGl0ZW0udHlwZS5zbGljZSgxKVxuICByZXR1cm4gJ3ByZScgKyBjYXBwZWRUeXBlTmFtZVxufVxuXG5mdW5jdGlvbiBwb3N0VHlwZSAoaXRlbSkge1xuICB2YXIgY2FwcGVkVHlwZU5hbWUgPSBpdGVtLnR5cGVbMF0udG9VcHBlckNhc2UoKSArIGl0ZW0udHlwZS5zbGljZSgxKVxuICByZXR1cm4gJ3Bvc3QnICsgY2FwcGVkVHlwZU5hbWVcbn1cblxuZnVuY3Rpb24gaGFzUHJlT3JQb3N0IChpdGVtLCB2YWx1ZXMpIHtcbiAgaWYgKCFpdGVtLnR5cGUpIHJldHVyblxuICByZXR1cm4gdmFsdWVzW3ByZVR5cGUoaXRlbSldIHx8IHZhbHVlc1twb3N0VHlwZShpdGVtKV1cbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVQcmVBbmRQb3N0IChiYXNlSXRlbSwgcGFyZW50VmFsdWVzKSB7XG4gIHZhciBpdGVtID0gb2JqZWN0QXNzaWduKHt9LCBiYXNlSXRlbSlcbiAgdmFyIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50VmFsdWVzKVxuICB2YXIgdGVtcGxhdGUgPSBbXVxuICB2YXIgcHJlID0gcHJlVHlwZShpdGVtKVxuICB2YXIgcG9zdCA9IHBvc3RUeXBlKGl0ZW0pXG4gIGlmICh2YWx1ZXNbcHJlXSkge1xuICAgIHRlbXBsYXRlLnB1c2goe3ZhbHVlOiB2YWx1ZXNbcHJlXX0pXG4gICAgdmFsdWVzW3ByZV0gPSBudWxsXG4gIH1cbiAgaXRlbS5taW5MZW5ndGggPSBudWxsXG4gIGl0ZW0ubGVuZ3RoID0gbnVsbFxuICBpdGVtLm1heExlbmd0aCA9IG51bGxcbiAgdGVtcGxhdGUucHVzaChpdGVtKVxuICB2YWx1ZXNbaXRlbS50eXBlXSA9IHZhbHVlc1tpdGVtLnR5cGVdXG4gIGlmICh2YWx1ZXNbcG9zdF0pIHtcbiAgICB0ZW1wbGF0ZS5wdXNoKHt2YWx1ZTogdmFsdWVzW3Bvc3RdfSlcbiAgICB2YWx1ZXNbcG9zdF0gPSBudWxsXG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgkMSwgJDIsIGxlbmd0aCkge1xuICAgIHJldHVybiByZW5kZXJUZW1wbGF0ZShsZW5ndGgsIHRlbXBsYXRlLCB2YWx1ZXMpXG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlcGFyZUl0ZW1zICh3aWR0aCwgdGVtcGxhdGUsIHZhbHVlcykge1xuICBmdW5jdGlvbiBjbG9uZUFuZE9iamVjdGlmeSAoaXRlbSwgaW5kZXgsIGFycikge1xuICAgIHZhciBjbG9uZWQgPSBuZXcgVGVtcGxhdGVJdGVtKGl0ZW0sIHdpZHRoKVxuICAgIHZhciB0eXBlID0gY2xvbmVkLnR5cGVcbiAgICBpZiAoY2xvbmVkLnZhbHVlID09IG51bGwpIHtcbiAgICAgIGlmICghKHR5cGUgaW4gdmFsdWVzKSkge1xuICAgICAgICBpZiAoY2xvbmVkLmRlZmF1bHQgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBlcnJvci5NaXNzaW5nVGVtcGxhdGVWYWx1ZShjbG9uZWQsIHZhbHVlcylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbG9uZWQudmFsdWUgPSBjbG9uZWQuZGVmYXVsdFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbG9uZWQudmFsdWUgPSB2YWx1ZXNbdHlwZV1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNsb25lZC52YWx1ZSA9PSBudWxsIHx8IGNsb25lZC52YWx1ZSA9PT0gJycpIHJldHVybiBudWxsXG4gICAgY2xvbmVkLmluZGV4ID0gaW5kZXhcbiAgICBjbG9uZWQuZmlyc3QgPSBpbmRleCA9PT0gMFxuICAgIGNsb25lZC5sYXN0ID0gaW5kZXggPT09IGFyci5sZW5ndGggLSAxXG4gICAgaWYgKGhhc1ByZU9yUG9zdChjbG9uZWQsIHZhbHVlcykpIGNsb25lZC52YWx1ZSA9IGdlbmVyYXRlUHJlQW5kUG9zdChjbG9uZWQsIHZhbHVlcylcbiAgICByZXR1cm4gY2xvbmVkXG4gIH1cblxuICB2YXIgb3V0cHV0ID0gdGVtcGxhdGUubWFwKGNsb25lQW5kT2JqZWN0aWZ5KS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0gIT0gbnVsbCB9KVxuXG4gIHZhciBvdXRwdXRMZW5ndGggPSAwXG4gIHZhciByZW1haW5pbmdTcGFjZSA9IHdpZHRoXG4gIHZhciB2YXJpYWJsZUNvdW50ID0gb3V0cHV0Lmxlbmd0aFxuXG4gIGZ1bmN0aW9uIGNvbnN1bWVTcGFjZSAobGVuZ3RoKSB7XG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZ1NwYWNlKSBsZW5ndGggPSByZW1haW5pbmdTcGFjZVxuICAgIG91dHB1dExlbmd0aCArPSBsZW5ndGhcbiAgICByZW1haW5pbmdTcGFjZSAtPSBsZW5ndGhcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaFNpemluZyAoaXRlbSwgbGVuZ3RoKSB7XG4gICAgaWYgKGl0ZW0uZmluaXNoZWQpIHRocm93IG5ldyBlcnJvci5JbnRlcm5hbCgnVHJpZWQgdG8gZmluaXNoIHRlbXBsYXRlIGl0ZW0gdGhhdCB3YXMgYWxyZWFkeSBmaW5pc2hlZCcpXG4gICAgaWYgKGxlbmd0aCA9PT0gSW5maW5pdHkpIHRocm93IG5ldyBlcnJvci5JbnRlcm5hbCgnTGVuZ3RoIG9mIHRlbXBsYXRlIGl0ZW0gY2Fubm90IGJlIGluZmluaXR5JylcbiAgICBpZiAobGVuZ3RoICE9IG51bGwpIGl0ZW0ubGVuZ3RoID0gbGVuZ3RoXG4gICAgaXRlbS5taW5MZW5ndGggPSBudWxsXG4gICAgaXRlbS5tYXhMZW5ndGggPSBudWxsXG4gICAgLS12YXJpYWJsZUNvdW50XG4gICAgaXRlbS5maW5pc2hlZCA9IHRydWVcbiAgICBpZiAoaXRlbS5sZW5ndGggPT0gbnVsbCkgaXRlbS5sZW5ndGggPSBpdGVtLmdldEJhc2VMZW5ndGgoKVxuICAgIGlmIChpdGVtLmxlbmd0aCA9PSBudWxsKSB0aHJvdyBuZXcgZXJyb3IuSW50ZXJuYWwoJ0ZpbmlzaGVkIHRlbXBsYXRlIGl0ZW1zIG11c3QgaGF2ZSBhIGxlbmd0aCcpXG4gICAgY29uc3VtZVNwYWNlKGl0ZW0uZ2V0TGVuZ3RoKCkpXG4gIH1cblxuICBvdXRwdXQuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmICghaXRlbS5rZXJuaW5nKSByZXR1cm5cbiAgICB2YXIgcHJldlBhZFJpZ2h0ID0gaXRlbS5maXJzdCA/IDAgOiBvdXRwdXRbaXRlbS5pbmRleCAtIDFdLnBhZFJpZ2h0XG4gICAgaWYgKCFpdGVtLmZpcnN0ICYmIHByZXZQYWRSaWdodCA8IGl0ZW0ua2VybmluZykgaXRlbS5wYWRMZWZ0ID0gaXRlbS5rZXJuaW5nIC0gcHJldlBhZFJpZ2h0XG4gICAgaWYgKCFpdGVtLmxhc3QpIGl0ZW0ucGFkUmlnaHQgPSBpdGVtLmtlcm5pbmdcbiAgfSlcblxuICAvLyBGaW5pc2ggYW55IHRoYXQgaGF2ZSBhIGZpeGVkIChsaXRlcmFsIG9yIGludHVpdGVkKSBsZW5ndGhcbiAgb3V0cHV0LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoaXRlbS5nZXRCYXNlTGVuZ3RoKCkgPT0gbnVsbCkgcmV0dXJuXG4gICAgZmluaXNoU2l6aW5nKGl0ZW0pXG4gIH0pXG5cbiAgdmFyIHJlc2l6ZWQgPSAwXG4gIHZhciByZXNpemluZ1xuICB2YXIgaHVua1NpemVcbiAgZG8ge1xuICAgIHJlc2l6aW5nID0gZmFsc2VcbiAgICBodW5rU2l6ZSA9IE1hdGgucm91bmQocmVtYWluaW5nU3BhY2UgLyB2YXJpYWJsZUNvdW50KVxuICAgIG91dHB1dC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBpZiAoaXRlbS5maW5pc2hlZCkgcmV0dXJuXG4gICAgICBpZiAoIWl0ZW0ubWF4TGVuZ3RoKSByZXR1cm5cbiAgICAgIGlmIChpdGVtLmdldE1heExlbmd0aCgpIDwgaHVua1NpemUpIHtcbiAgICAgICAgZmluaXNoU2l6aW5nKGl0ZW0sIGl0ZW0ubWF4TGVuZ3RoKVxuICAgICAgICByZXNpemluZyA9IHRydWVcbiAgICAgIH1cbiAgICB9KVxuICB9IHdoaWxlIChyZXNpemluZyAmJiByZXNpemVkKysgPCBvdXRwdXQubGVuZ3RoKVxuICBpZiAocmVzaXppbmcpIHRocm93IG5ldyBlcnJvci5JbnRlcm5hbCgnUmVzaXplIGxvb3AgaXRlcmF0ZWQgdG9vIG1hbnkgdGltZXMgd2hpbGUgZGV0ZXJtaW5pbmcgbWF4TGVuZ3RoJylcblxuICByZXNpemVkID0gMFxuICBkbyB7XG4gICAgcmVzaXppbmcgPSBmYWxzZVxuICAgIGh1bmtTaXplID0gTWF0aC5yb3VuZChyZW1haW5pbmdTcGFjZSAvIHZhcmlhYmxlQ291bnQpXG4gICAgb3V0cHV0LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIGlmIChpdGVtLmZpbmlzaGVkKSByZXR1cm5cbiAgICAgIGlmICghaXRlbS5taW5MZW5ndGgpIHJldHVyblxuICAgICAgaWYgKGl0ZW0uZ2V0TWluTGVuZ3RoKCkgPj0gaHVua1NpemUpIHtcbiAgICAgICAgZmluaXNoU2l6aW5nKGl0ZW0sIGl0ZW0ubWluTGVuZ3RoKVxuICAgICAgICByZXNpemluZyA9IHRydWVcbiAgICAgIH1cbiAgICB9KVxuICB9IHdoaWxlIChyZXNpemluZyAmJiByZXNpemVkKysgPCBvdXRwdXQubGVuZ3RoKVxuICBpZiAocmVzaXppbmcpIHRocm93IG5ldyBlcnJvci5JbnRlcm5hbCgnUmVzaXplIGxvb3AgaXRlcmF0ZWQgdG9vIG1hbnkgdGltZXMgd2hpbGUgZGV0ZXJtaW5pbmcgbWluTGVuZ3RoJylcblxuICBodW5rU2l6ZSA9IE1hdGgucm91bmQocmVtYWluaW5nU3BhY2UgLyB2YXJpYWJsZUNvdW50KVxuICBvdXRwdXQuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmIChpdGVtLmZpbmlzaGVkKSByZXR1cm5cbiAgICBmaW5pc2hTaXppbmcoaXRlbSwgaHVua1NpemUpXG4gIH0pXG5cbiAgcmV0dXJuIG91dHB1dFxufVxuXG5mdW5jdGlvbiByZW5kZXJGdW5jdGlvbiAoaXRlbSwgdmFsdWVzLCBsZW5ndGgpIHtcbiAgdmFsaWRhdGUoJ09PTicsIGFyZ3VtZW50cylcbiAgaWYgKGl0ZW0udHlwZSkge1xuICAgIHJldHVybiBpdGVtLnZhbHVlKHZhbHVlcywgdmFsdWVzW2l0ZW0udHlwZSArICdUaGVtZSddIHx8IHt9LCBsZW5ndGgpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGl0ZW0udmFsdWUodmFsdWVzLCB7fSwgbGVuZ3RoKVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlclZhbHVlIChpdGVtLCB2YWx1ZXMpIHtcbiAgdmFyIGxlbmd0aCA9IGl0ZW0uZ2V0QmFzZUxlbmd0aCgpXG4gIHZhciB2YWx1ZSA9IHR5cGVvZiBpdGVtLnZhbHVlID09PSAnZnVuY3Rpb24nID8gcmVuZGVyRnVuY3Rpb24oaXRlbSwgdmFsdWVzLCBsZW5ndGgpIDogaXRlbS52YWx1ZVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSA9PT0gJycpIHJldHVybiAnJ1xuICB2YXIgYWxpZ25XaXRoID0gYWxpZ25baXRlbS5hbGlnbl0gfHwgYWxpZ24ubGVmdFxuICB2YXIgbGVmdFBhZGRpbmcgPSBpdGVtLnBhZExlZnQgPyBhbGlnbi5sZWZ0KCcnLCBpdGVtLnBhZExlZnQpIDogJydcbiAgdmFyIHJpZ2h0UGFkZGluZyA9IGl0ZW0ucGFkUmlnaHQgPyBhbGlnbi5yaWdodCgnJywgaXRlbS5wYWRSaWdodCkgOiAnJ1xuICB2YXIgdHJ1bmNhdGVkID0gd2lkZVRydW5jYXRlKFN0cmluZyh2YWx1ZSksIGxlbmd0aClcbiAgdmFyIGFsaWduZWQgPSBhbGlnbldpdGgodHJ1bmNhdGVkLCBsZW5ndGgpXG4gIHJldHVybiBsZWZ0UGFkZGluZyArIGFsaWduZWQgKyByaWdodFBhZGRpbmdcbn1cbiIsIid1c2Ugc3RyaWN0J1xudmFyIHByb2Nlc3MgPSByZXF1aXJlKCcuL3Byb2Nlc3MnKVxudHJ5IHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBzZXRJbW1lZGlhdGVcbn0gY2F0Y2ggKGV4KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcHJvY2Vzcy5uZXh0VGlja1xufVxuIiwiJ3VzZSBzdHJpY3QnXG4vLyB0aGlzIGV4aXN0cyBzbyB3ZSBjYW4gcmVwbGFjZSBpdCBkdXJpbmcgdGVzdGluZ1xubW9kdWxlLmV4cG9ydHMgPSBzZXRJbnRlcnZhbFxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3BpbiAoc3BpbnN0ciwgc3B1bikge1xuICByZXR1cm4gc3BpbnN0cltzcHVuICUgc3BpbnN0ci5sZW5ndGhdXG59XG4iLCIndXNlIHN0cmljdCdcbnZhciBzdHJpbmdXaWR0aCA9IHJlcXVpcmUoJ3N0cmluZy13aWR0aCcpXG5cbm1vZHVsZS5leHBvcnRzID0gVGVtcGxhdGVJdGVtXG5cbmZ1bmN0aW9uIGlzUGVyY2VudCAobnVtKSB7XG4gIGlmICh0eXBlb2YgbnVtICE9PSAnc3RyaW5nJykgcmV0dXJuIGZhbHNlXG4gIHJldHVybiBudW0uc2xpY2UoLTEpID09PSAnJSdcbn1cblxuZnVuY3Rpb24gcGVyY2VudCAobnVtKSB7XG4gIHJldHVybiBOdW1iZXIobnVtLnNsaWNlKDAsIC0xKSkgLyAxMDBcbn1cblxuZnVuY3Rpb24gVGVtcGxhdGVJdGVtICh2YWx1ZXMsIG91dHB1dExlbmd0aCkge1xuICB0aGlzLm92ZXJhbGxPdXRwdXRMZW5ndGggPSBvdXRwdXRMZW5ndGhcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlXG4gIHRoaXMudHlwZSA9IG51bGxcbiAgdGhpcy52YWx1ZSA9IG51bGxcbiAgdGhpcy5sZW5ndGggPSBudWxsXG4gIHRoaXMubWF4TGVuZ3RoID0gbnVsbFxuICB0aGlzLm1pbkxlbmd0aCA9IG51bGxcbiAgdGhpcy5rZXJuaW5nID0gbnVsbFxuICB0aGlzLmFsaWduID0gJ2xlZnQnXG4gIHRoaXMucGFkTGVmdCA9IDBcbiAgdGhpcy5wYWRSaWdodCA9IDBcbiAgdGhpcy5pbmRleCA9IG51bGxcbiAgdGhpcy5maXJzdCA9IG51bGxcbiAgdGhpcy5sYXN0ID0gbnVsbFxuICBpZiAodHlwZW9mIHZhbHVlcyA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWVzXG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiB2YWx1ZXMpIHRoaXNbcHJvcF0gPSB2YWx1ZXNbcHJvcF1cbiAgfVxuICAvLyBSZWFsaXplIHBlcmNlbnRzXG4gIGlmIChpc1BlcmNlbnQodGhpcy5sZW5ndGgpKSB7XG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLnJvdW5kKHRoaXMub3ZlcmFsbE91dHB1dExlbmd0aCAqIHBlcmNlbnQodGhpcy5sZW5ndGgpKVxuICB9XG4gIGlmIChpc1BlcmNlbnQodGhpcy5taW5MZW5ndGgpKSB7XG4gICAgdGhpcy5taW5MZW5ndGggPSBNYXRoLnJvdW5kKHRoaXMub3ZlcmFsbE91dHB1dExlbmd0aCAqIHBlcmNlbnQodGhpcy5taW5MZW5ndGgpKVxuICB9XG4gIGlmIChpc1BlcmNlbnQodGhpcy5tYXhMZW5ndGgpKSB7XG4gICAgdGhpcy5tYXhMZW5ndGggPSBNYXRoLnJvdW5kKHRoaXMub3ZlcmFsbE91dHB1dExlbmd0aCAqIHBlcmNlbnQodGhpcy5tYXhMZW5ndGgpKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cblRlbXBsYXRlSXRlbS5wcm90b3R5cGUgPSB7fVxuXG5UZW1wbGF0ZUl0ZW0ucHJvdG90eXBlLmdldEJhc2VMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09IG51bGwgJiYgdHlwZW9mIHRoaXMudmFsdWUgPT09ICdzdHJpbmcnICYmIHRoaXMubWF4TGVuZ3RoID09IG51bGwgJiYgdGhpcy5taW5MZW5ndGggPT0gbnVsbCkge1xuICAgIGxlbmd0aCA9IHN0cmluZ1dpZHRoKHRoaXMudmFsdWUpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aFxufVxuXG5UZW1wbGF0ZUl0ZW0ucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMuZ2V0QmFzZUxlbmd0aCgpXG4gIGlmIChsZW5ndGggPT0gbnVsbCkgcmV0dXJuIG51bGxcbiAgcmV0dXJuIGxlbmd0aCArIHRoaXMucGFkTGVmdCArIHRoaXMucGFkUmlnaHRcbn1cblxuVGVtcGxhdGVJdGVtLnByb3RvdHlwZS5nZXRNYXhMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLm1heExlbmd0aCA9PSBudWxsKSByZXR1cm4gbnVsbFxuICByZXR1cm4gdGhpcy5tYXhMZW5ndGggKyB0aGlzLnBhZExlZnQgKyB0aGlzLnBhZFJpZ2h0XG59XG5cblRlbXBsYXRlSXRlbS5wcm90b3R5cGUuZ2V0TWluTGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5taW5MZW5ndGggPT0gbnVsbCkgcmV0dXJuIG51bGxcbiAgcmV0dXJuIHRoaXMubWluTGVuZ3RoICsgdGhpcy5wYWRMZWZ0ICsgdGhpcy5wYWRSaWdodFxufVxuXG4iLCIndXNlIHN0cmljdCdcbnZhciBvYmplY3RBc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBUaGVtZVNldFByb3RvLm5ld1RoZW1lU2V0KClcbn1cblxudmFyIFRoZW1lU2V0UHJvdG8gPSB7fVxuXG5UaGVtZVNldFByb3RvLmJhc2VUaGVtZSA9IHJlcXVpcmUoJy4vYmFzZS10aGVtZS5qcycpXG5cblRoZW1lU2V0UHJvdG8ubmV3VGhlbWUgPSBmdW5jdGlvbiAocGFyZW50LCB0aGVtZSkge1xuICBpZiAoIXRoZW1lKSB7XG4gICAgdGhlbWUgPSBwYXJlbnRcbiAgICBwYXJlbnQgPSB0aGlzLmJhc2VUaGVtZVxuICB9XG4gIHJldHVybiBvYmplY3RBc3NpZ24oe30sIHBhcmVudCwgdGhlbWUpXG59XG5cblRoZW1lU2V0UHJvdG8uZ2V0VGhlbWVOYW1lcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMudGhlbWVzKVxufVxuXG5UaGVtZVNldFByb3RvLmFkZFRoZW1lID0gZnVuY3Rpb24gKG5hbWUsIHBhcmVudCwgdGhlbWUpIHtcbiAgdGhpcy50aGVtZXNbbmFtZV0gPSB0aGlzLm5ld1RoZW1lKHBhcmVudCwgdGhlbWUpXG59XG5cblRoZW1lU2V0UHJvdG8uYWRkVG9BbGxUaGVtZXMgPSBmdW5jdGlvbiAodGhlbWUpIHtcbiAgdmFyIHRoZW1lcyA9IHRoaXMudGhlbWVzXG4gIE9iamVjdC5rZXlzKHRoZW1lcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIG9iamVjdEFzc2lnbih0aGVtZXNbbmFtZV0sIHRoZW1lKVxuICB9KVxuICBvYmplY3RBc3NpZ24odGhpcy5iYXNlVGhlbWUsIHRoZW1lKVxufVxuXG5UaGVtZVNldFByb3RvLmdldFRoZW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgaWYgKCF0aGlzLnRoZW1lc1tuYW1lXSkgdGhyb3cgdGhpcy5uZXdNaXNzaW5nVGhlbWVFcnJvcihuYW1lKVxuICByZXR1cm4gdGhpcy50aGVtZXNbbmFtZV1cbn1cblxuVGhlbWVTZXRQcm90by5zZXREZWZhdWx0ID0gZnVuY3Rpb24gKG9wdHMsIG5hbWUpIHtcbiAgaWYgKG5hbWUgPT0gbnVsbCkge1xuICAgIG5hbWUgPSBvcHRzXG4gICAgb3B0cyA9IHt9XG4gIH1cbiAgdmFyIHBsYXRmb3JtID0gb3B0cy5wbGF0Zm9ybSA9PSBudWxsID8gJ2ZhbGxiYWNrJyA6IG9wdHMucGxhdGZvcm1cbiAgdmFyIGhhc1VuaWNvZGUgPSAhIW9wdHMuaGFzVW5pY29kZVxuICB2YXIgaGFzQ29sb3IgPSAhIW9wdHMuaGFzQ29sb3JcbiAgaWYgKCF0aGlzLmRlZmF1bHRzW3BsYXRmb3JtXSkgdGhpcy5kZWZhdWx0c1twbGF0Zm9ybV0gPSB7dHJ1ZToge30sIGZhbHNlOiB7fX1cbiAgdGhpcy5kZWZhdWx0c1twbGF0Zm9ybV1baGFzVW5pY29kZV1baGFzQ29sb3JdID0gbmFtZVxufVxuXG5UaGVtZVNldFByb3RvLmdldERlZmF1bHQgPSBmdW5jdGlvbiAob3B0cykge1xuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuICB2YXIgcGxhdGZvcm1OYW1lID0gb3B0cy5wbGF0Zm9ybSB8fCBwcm9jZXNzLnBsYXRmb3JtXG4gIHZhciBwbGF0Zm9ybSA9IHRoaXMuZGVmYXVsdHNbcGxhdGZvcm1OYW1lXSB8fCB0aGlzLmRlZmF1bHRzLmZhbGxiYWNrXG4gIHZhciBoYXNVbmljb2RlID0gISFvcHRzLmhhc1VuaWNvZGVcbiAgdmFyIGhhc0NvbG9yID0gISFvcHRzLmhhc0NvbG9yXG4gIGlmICghcGxhdGZvcm0pIHRocm93IHRoaXMubmV3TWlzc2luZ0RlZmF1bHRUaGVtZUVycm9yKHBsYXRmb3JtTmFtZSwgaGFzVW5pY29kZSwgaGFzQ29sb3IpXG4gIGlmICghcGxhdGZvcm1baGFzVW5pY29kZV1baGFzQ29sb3JdKSB7XG4gICAgaWYgKGhhc1VuaWNvZGUgJiYgaGFzQ29sb3IgJiYgcGxhdGZvcm1bIWhhc1VuaWNvZGVdW2hhc0NvbG9yXSkge1xuICAgICAgaGFzVW5pY29kZSA9IGZhbHNlXG4gICAgfSBlbHNlIGlmIChoYXNVbmljb2RlICYmIGhhc0NvbG9yICYmIHBsYXRmb3JtW2hhc1VuaWNvZGVdWyFoYXNDb2xvcl0pIHtcbiAgICAgIGhhc0NvbG9yID0gZmFsc2VcbiAgICB9IGVsc2UgaWYgKGhhc1VuaWNvZGUgJiYgaGFzQ29sb3IgJiYgcGxhdGZvcm1bIWhhc1VuaWNvZGVdWyFoYXNDb2xvcl0pIHtcbiAgICAgIGhhc1VuaWNvZGUgPSBmYWxzZVxuICAgICAgaGFzQ29sb3IgPSBmYWxzZVxuICAgIH0gZWxzZSBpZiAoaGFzVW5pY29kZSAmJiAhaGFzQ29sb3IgJiYgcGxhdGZvcm1bIWhhc1VuaWNvZGVdW2hhc0NvbG9yXSkge1xuICAgICAgaGFzVW5pY29kZSA9IGZhbHNlXG4gICAgfSBlbHNlIGlmICghaGFzVW5pY29kZSAmJiBoYXNDb2xvciAmJiBwbGF0Zm9ybVtoYXNVbmljb2RlXVshaGFzQ29sb3JdKSB7XG4gICAgICBoYXNDb2xvciA9IGZhbHNlXG4gICAgfSBlbHNlIGlmIChwbGF0Zm9ybSA9PT0gdGhpcy5kZWZhdWx0cy5mYWxsYmFjaykge1xuICAgICAgdGhyb3cgdGhpcy5uZXdNaXNzaW5nRGVmYXVsdFRoZW1lRXJyb3IocGxhdGZvcm1OYW1lLCBoYXNVbmljb2RlLCBoYXNDb2xvcilcbiAgICB9XG4gIH1cbiAgaWYgKHBsYXRmb3JtW2hhc1VuaWNvZGVdW2hhc0NvbG9yXSkge1xuICAgIHJldHVybiB0aGlzLmdldFRoZW1lKHBsYXRmb3JtW2hhc1VuaWNvZGVdW2hhc0NvbG9yXSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5nZXREZWZhdWx0KG9iamVjdEFzc2lnbih7fSwgb3B0cywge3BsYXRmb3JtOiAnZmFsbGJhY2snfSkpXG4gIH1cbn1cblxuVGhlbWVTZXRQcm90by5uZXdNaXNzaW5nVGhlbWVFcnJvciA9IGZ1bmN0aW9uIG5ld01pc3NpbmdUaGVtZUVycm9yIChuYW1lKSB7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGEgZ2F1Z2UgdGhlbWUgbmFtZWQgXCInICsgbmFtZSArICdcIicpXG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlLmNhbGwoZXJyLCBuZXdNaXNzaW5nVGhlbWVFcnJvcilcbiAgZXJyLnRoZW1lID0gbmFtZVxuICBlcnIuY29kZSA9ICdFTUlTU0lOR1RIRU1FJ1xuICByZXR1cm4gZXJyXG59XG5cblRoZW1lU2V0UHJvdG8ubmV3TWlzc2luZ0RlZmF1bHRUaGVtZUVycm9yID0gZnVuY3Rpb24gbmV3TWlzc2luZ0RlZmF1bHRUaGVtZUVycm9yIChwbGF0Zm9ybU5hbWUsIGhhc1VuaWNvZGUsIGhhc0NvbG9yKSB7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gICAgJ0NvdWxkIG5vdCBmaW5kIGEgZ2F1Z2UgdGhlbWUgZm9yIHlvdXIgcGxhdGZvcm0vdW5pY29kZS9jb2xvciB1c2UgY29tYm86XFxuJyArXG4gICAgJyAgICBwbGF0Zm9ybSA9ICcgKyBwbGF0Zm9ybU5hbWUgKyAnXFxuJyArXG4gICAgJyAgICBoYXNVbmljb2RlID0gJyArIGhhc1VuaWNvZGUgKyAnXFxuJyArXG4gICAgJyAgICBoYXNDb2xvciA9ICcgKyBoYXNDb2xvcilcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UuY2FsbChlcnIsIG5ld01pc3NpbmdEZWZhdWx0VGhlbWVFcnJvcilcbiAgZXJyLnBsYXRmb3JtID0gcGxhdGZvcm1OYW1lXG4gIGVyci5oYXNVbmljb2RlID0gaGFzVW5pY29kZVxuICBlcnIuaGFzQ29sb3IgPSBoYXNDb2xvclxuICBlcnIuY29kZSA9ICdFTUlTU0lOR1RIRU1FJ1xuICByZXR1cm4gZXJyXG59XG5cblRoZW1lU2V0UHJvdG8ubmV3VGhlbWVTZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGVtZXNldCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgcmV0dXJuIHRoZW1lc2V0LmdldERlZmF1bHQob3B0cylcbiAgfVxuICByZXR1cm4gb2JqZWN0QXNzaWduKHRoZW1lc2V0LCBUaGVtZVNldFByb3RvLCB7XG4gICAgdGhlbWVzOiBvYmplY3RBc3NpZ24oe30sIHRoaXMudGhlbWVzKSxcbiAgICBiYXNlVGhlbWU6IG9iamVjdEFzc2lnbih7fSwgdGhpcy5iYXNlVGhlbWUpLFxuICAgIGRlZmF1bHRzOiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuZGVmYXVsdHMgfHwge30pKVxuICB9KVxufVxuXG4iLCIndXNlIHN0cmljdCdcbnZhciBjb25zb2xlQ29udHJvbCA9IHJlcXVpcmUoJ2NvbnNvbGUtY29udHJvbC1zdHJpbmdzJylcbnZhciBUaGVtZVNldCA9IHJlcXVpcmUoJy4vdGhlbWUtc2V0LmpzJylcblxudmFyIHRoZW1lcyA9IG1vZHVsZS5leHBvcnRzID0gbmV3IFRoZW1lU2V0KClcblxudGhlbWVzLmFkZFRoZW1lKCdBU0NJSScsIHtcbiAgcHJlUHJvZ3Jlc3NiYXI6ICdbJyxcbiAgcG9zdFByb2dyZXNzYmFyOiAnXScsXG4gIHByb2dyZXNzYmFyVGhlbWU6IHtcbiAgICBjb21wbGV0ZTogJyMnLFxuICAgIHJlbWFpbmluZzogJy4nXG4gIH0sXG4gIGFjdGl2aXR5SW5kaWNhdG9yVGhlbWU6ICctXFxcXHwvJyxcbiAgcHJlU3Vic2VjdGlvbjogJz4nXG59KVxuXG50aGVtZXMuYWRkVGhlbWUoJ2NvbG9yQVNDSUknLCB0aGVtZXMuZ2V0VGhlbWUoJ0FTQ0lJJyksIHtcbiAgcHJvZ3Jlc3NiYXJUaGVtZToge1xuICAgIHByZUNvbXBsZXRlOiBjb25zb2xlQ29udHJvbC5jb2xvcignaW52ZXJzZScpLFxuICAgIGNvbXBsZXRlOiAnICcsXG4gICAgcG9zdENvbXBsZXRlOiBjb25zb2xlQ29udHJvbC5jb2xvcignc3RvcEludmVyc2UnKSxcbiAgICBwcmVSZW1haW5pbmc6IGNvbnNvbGVDb250cm9sLmNvbG9yKCdicmlnaHRCbGFjaycpLFxuICAgIHJlbWFpbmluZzogJy4nLFxuICAgIHBvc3RSZW1haW5pbmc6IGNvbnNvbGVDb250cm9sLmNvbG9yKCdyZXNldCcpXG4gIH1cbn0pXG5cbnRoZW1lcy5hZGRUaGVtZSgnYnJhaWxsZVNwaW5uZXInLCB7XG4gIHByZVByb2dyZXNzYmFyOiAn4rioJyxcbiAgcG9zdFByb2dyZXNzYmFyOiAn4ripJyxcbiAgcHJvZ3Jlc3NiYXJUaGVtZToge1xuICAgIGNvbXBsZXRlOiAn4paRJyxcbiAgICByZW1haW5pbmc6ICfioIInXG4gIH0sXG4gIGFjdGl2aXR5SW5kaWNhdG9yVGhlbWU6ICfioIvioJnioLnioLjioLzioLTioKbioKfioIfioI8nLFxuICBwcmVTdWJzZWN0aW9uOiAnPidcbn0pXG5cbnRoZW1lcy5hZGRUaGVtZSgnY29sb3JCcmFpbGxlU3Bpbm5lcicsIHRoZW1lcy5nZXRUaGVtZSgnYnJhaWxsZVNwaW5uZXInKSwge1xuICBwcm9ncmVzc2JhclRoZW1lOiB7XG4gICAgcHJlQ29tcGxldGU6IGNvbnNvbGVDb250cm9sLmNvbG9yKCdpbnZlcnNlJyksXG4gICAgY29tcGxldGU6ICcgJyxcbiAgICBwb3N0Q29tcGxldGU6IGNvbnNvbGVDb250cm9sLmNvbG9yKCdzdG9wSW52ZXJzZScpLFxuICAgIHByZVJlbWFpbmluZzogY29uc29sZUNvbnRyb2wuY29sb3IoJ2JyaWdodEJsYWNrJyksXG4gICAgcmVtYWluaW5nOiAn4paRJyxcbiAgICBwb3N0UmVtYWluaW5nOiBjb25zb2xlQ29udHJvbC5jb2xvcigncmVzZXQnKVxuICB9XG59KVxuXG50aGVtZXMuc2V0RGVmYXVsdCh7fSwgJ0FTQ0lJJylcbnRoZW1lcy5zZXREZWZhdWx0KHtoYXNDb2xvcjogdHJ1ZX0sICdjb2xvckFTQ0lJJylcbnRoZW1lcy5zZXREZWZhdWx0KHtwbGF0Zm9ybTogJ2RhcndpbicsIGhhc1VuaWNvZGU6IHRydWV9LCAnYnJhaWxsZVNwaW5uZXInKVxudGhlbWVzLnNldERlZmF1bHQoe3BsYXRmb3JtOiAnZGFyd2luJywgaGFzVW5pY29kZTogdHJ1ZSwgaGFzQ29sb3I6IHRydWV9LCAnY29sb3JCcmFpbGxlU3Bpbm5lcicpXG4iLCIndXNlIHN0cmljdCdcbnZhciBzdHJpbmdXaWR0aCA9IHJlcXVpcmUoJ3N0cmluZy13aWR0aCcpXG52YXIgc3RyaXBBbnNpID0gcmVxdWlyZSgnc3RyaXAtYW5zaScpXG5cbm1vZHVsZS5leHBvcnRzID0gd2lkZVRydW5jYXRlXG5cbmZ1bmN0aW9uIHdpZGVUcnVuY2F0ZSAoc3RyLCB0YXJnZXQpIHtcbiAgaWYgKHN0cmluZ1dpZHRoKHN0cikgPT09IDApIHJldHVybiBzdHJcbiAgaWYgKHRhcmdldCA8PSAwKSByZXR1cm4gJydcbiAgaWYgKHN0cmluZ1dpZHRoKHN0cikgPD0gdGFyZ2V0KSByZXR1cm4gc3RyXG5cbiAgLy8gV2UgY29tcHV0ZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIG9mIGFuc2kgc2VxdWVuY2VzIGhlcmUgYW5kIGFkZFxuICAvLyB0aGF0IHRvIG91ciBpbml0aWFsIHRydW5jYXRpb24gdG8gZW5zdXJlIHRoYXQgd2UgZG9uJ3Qgc2xpY2Ugb25lXG4gIC8vIHRoYXQgd2Ugd2FudCB0byBrZWVwIGluIGhhbGYuXG4gIHZhciBub0Fuc2kgPSBzdHJpcEFuc2koc3RyKVxuICB2YXIgYW5zaVNpemUgPSBzdHIubGVuZ3RoICsgbm9BbnNpLmxlbmd0aFxuICB2YXIgdHJ1bmNhdGVkID0gc3RyLnNsaWNlKDAsIHRhcmdldCArIGFuc2lTaXplKVxuXG4gIC8vIHdlIGhhdmUgdG8gc2hyaW5rIHRoZSByZXN1bHQgdG8gYWNjb3VudCBmb3Igb3VyIGFuc2kgc2VxdWVuY2UgYnVmZmVyXG4gIC8vIChpZiBhbiBhbnNpIHNlcXVlbmNlIHdhcyB0cnVuY2F0ZWQpIGFuZCBkb3VibGUgd2lkdGggY2hhcmFjdGVycy5cbiAgd2hpbGUgKHN0cmluZ1dpZHRoKHRydW5jYXRlZCkgPiB0YXJnZXQpIHtcbiAgICB0cnVuY2F0ZWQgPSB0cnVuY2F0ZWQuc2xpY2UoMCwgLTEpXG4gIH1cbiAgcmV0dXJuIHRydW5jYXRlZFxufVxuIiwiXCJ1c2Ugc3RyaWN0XCJcbnZhciBvcyA9IHJlcXVpcmUoXCJvc1wiKVxuXG52YXIgaGFzVW5pY29kZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICAvLyBSZWNlbnQgV2luMzIgcGxhdGZvcm1zICg+WFApIENBTiBzdXBwb3J0IHVuaWNvZGUgaW4gdGhlIGNvbnNvbGUgYnV0XG4gIC8vIGRvbid0IGhhdmUgdG8sIGFuZCBpbiBub24tZW5nbGlzaCBsb2NhbGVzIG9mdGVuIHVzZSB0cmFkaXRpb25hbCBsb2NhbFxuICAvLyBjb2RlIHBhZ2VzLiBUaGVyZSdzIG5vIHdheSwgc2hvcnQgb2Ygd2luZG93cyBzeXN0ZW0gY2FsbHMgb3IgZXhlY2luZ1xuICAvLyB0aGUgY2hjcCBjb21tYW5kIGxpbmUgcHJvZ3JhbSB0byBmaWd1cmUgdGhpcyBvdXQuIEFzIHN1Y2gsIHdlIGRlZmF1bHRcbiAgLy8gdGhpcyB0byBmYWxzZSBhbmQgZW5jb3VyYWdlIHlvdXIgdXNlcnMgdG8gb3ZlcnJpZGUgaXQgdmlhIGNvbmZpZyBpZlxuICAvLyBhcHByb3ByaWF0ZS5cbiAgaWYgKG9zLnR5cGUoKSA9PSBcIldpbmRvd3NfTlRcIikgeyByZXR1cm4gZmFsc2UgfVxuXG4gIHZhciBpc1VURjggPSAvVVRGLT84JC9pXG4gIHZhciBjdHlwZSA9IHByb2Nlc3MuZW52LkxDX0FMTCB8fCBwcm9jZXNzLmVudi5MQ19DVFlQRSB8fCBwcm9jZXNzLmVudi5MQU5HXG4gIHJldHVybiBpc1VURjgudGVzdChjdHlwZSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG5jb25zdCBNaW5pbWF0Y2ggPSByZXF1aXJlKCdtaW5pbWF0Y2gnKS5NaW5pbWF0Y2hcblxuY2xhc3MgV2Fsa2VyIGV4dGVuZHMgRUUge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9XG4gICAgc3VwZXIob3B0cylcbiAgICB0aGlzLnBhdGggPSBvcHRzLnBhdGggfHwgcHJvY2Vzcy5jd2QoKVxuICAgIHRoaXMuYmFzZW5hbWUgPSBwYXRoLmJhc2VuYW1lKHRoaXMucGF0aClcbiAgICB0aGlzLmlnbm9yZUZpbGVzID0gb3B0cy5pZ25vcmVGaWxlcyB8fCBbICcuaWdub3JlJyBdXG4gICAgdGhpcy5pZ25vcmVSdWxlcyA9IHt9XG4gICAgdGhpcy5wYXJlbnQgPSBvcHRzLnBhcmVudCB8fCBudWxsXG4gICAgdGhpcy5pbmNsdWRlRW1wdHkgPSAhIW9wdHMuaW5jbHVkZUVtcHR5XG4gICAgdGhpcy5yb290ID0gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5yb290IDogdGhpcy5wYXRoXG4gICAgdGhpcy5mb2xsb3cgPSAhIW9wdHMuZm9sbG93XG4gICAgdGhpcy5yZXN1bHQgPSB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LnJlc3VsdCA6IG5ldyBTZXQoKVxuICAgIHRoaXMuZW50cmllcyA9IG51bGxcbiAgICB0aGlzLnNhd0Vycm9yID0gZmFsc2VcbiAgfVxuXG4gIHNvcnQgKGEsIGIpIHtcbiAgICByZXR1cm4gYS5sb2NhbGVDb21wYXJlKGIpXG4gIH1cblxuICBlbWl0IChldiwgZGF0YSkge1xuICAgIGxldCByZXQgPSBmYWxzZVxuICAgIGlmICghKHRoaXMuc2F3RXJyb3IgJiYgZXYgPT09ICdlcnJvcicpKSB7XG4gICAgICBpZiAoZXYgPT09ICdlcnJvcicpXG4gICAgICAgIHRoaXMuc2F3RXJyb3IgPSB0cnVlXG4gICAgICBlbHNlIGlmIChldiA9PT0gJ2RvbmUnICYmICF0aGlzLnBhcmVudCkge1xuICAgICAgICBkYXRhID0gQXJyYXkuZnJvbShkYXRhKVxuICAgICAgICAgIC5tYXAoZSA9PiAvXkAvLnRlc3QoZSkgPyBgLi8ke2V9YCA6IGUpLnNvcnQodGhpcy5zb3J0KVxuICAgICAgICB0aGlzLnJlc3VsdCA9IGRhdGFcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ID09PSAnZXJyb3InICYmIHRoaXMucGFyZW50KVxuICAgICAgICByZXQgPSB0aGlzLnBhcmVudC5lbWl0KCdlcnJvcicsIGRhdGEpXG4gICAgICBlbHNlXG4gICAgICAgIHJldCA9IHN1cGVyLmVtaXQoZXYsIGRhdGEpXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIHN0YXJ0ICgpIHtcbiAgICBmcy5yZWFkZGlyKHRoaXMucGF0aCwgKGVyLCBlbnRyaWVzKSA9PlxuICAgICAgZXIgPyB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpIDogdGhpcy5vblJlYWRkaXIoZW50cmllcykpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGlzSWdub3JlRmlsZSAoZSkge1xuICAgIHJldHVybiBlICE9PSBcIi5cIiAmJlxuICAgICAgZSAhPT0gXCIuLlwiICYmXG4gICAgICAtMSAhPT0gdGhpcy5pZ25vcmVGaWxlcy5pbmRleE9mKGUpXG4gIH1cblxuICBvblJlYWRkaXIgKGVudHJpZXMpIHtcbiAgICB0aGlzLmVudHJpZXMgPSBlbnRyaWVzXG4gICAgaWYgKGVudHJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAodGhpcy5pbmNsdWRlRW1wdHkpXG4gICAgICAgIHRoaXMucmVzdWx0LmFkZCh0aGlzLnBhdGguc3Vic3RyKHRoaXMucm9vdC5sZW5ndGggKyAxKSlcbiAgICAgIHRoaXMuZW1pdCgnZG9uZScsIHRoaXMucmVzdWx0KVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoYXNJZyA9IHRoaXMuZW50cmllcy5zb21lKGUgPT5cbiAgICAgICAgdGhpcy5pc0lnbm9yZUZpbGUoZSkpXG5cbiAgICAgIGlmIChoYXNJZylcbiAgICAgICAgdGhpcy5hZGRJZ25vcmVGaWxlcygpXG4gICAgICBlbHNlXG4gICAgICAgIHRoaXMuZmlsdGVyRW50cmllcygpXG4gICAgfVxuICB9XG5cbiAgYWRkSWdub3JlRmlsZXMgKCkge1xuICAgIGNvbnN0IG5ld0lnID0gdGhpcy5lbnRyaWVzXG4gICAgICAuZmlsdGVyKGUgPT4gdGhpcy5pc0lnbm9yZUZpbGUoZSkpXG5cbiAgICBsZXQgaWdDb3VudCA9IG5ld0lnLmxlbmd0aFxuICAgIGNvbnN0IHRoZW4gPSBfID0+IHtcbiAgICAgIGlmICgtLWlnQ291bnQgPT09IDApXG4gICAgICAgIHRoaXMuZmlsdGVyRW50cmllcygpXG4gICAgfVxuXG4gICAgbmV3SWcuZm9yRWFjaChlID0+IHRoaXMuYWRkSWdub3JlRmlsZShlLCB0aGVuKSlcbiAgfVxuXG4gIGFkZElnbm9yZUZpbGUgKGZpbGUsIHRoZW4pIHtcbiAgICBjb25zdCBpZyA9IHBhdGgucmVzb2x2ZSh0aGlzLnBhdGgsIGZpbGUpXG4gICAgZnMucmVhZEZpbGUoaWcsICd1dGY4JywgKGVyLCBkYXRhKSA9PlxuICAgICAgZXIgPyB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpIDogdGhpcy5vblJlYWRJZ25vcmVGaWxlKGZpbGUsIGRhdGEsIHRoZW4pKVxuICB9XG5cbiAgb25SZWFkSWdub3JlRmlsZSAoZmlsZSwgZGF0YSwgdGhlbikge1xuICAgIGNvbnN0IG1tb3B0ID0ge1xuICAgICAgbWF0Y2hCYXNlOiB0cnVlLFxuICAgICAgZG90OiB0cnVlLFxuICAgICAgZmxpcE5lZ2F0ZTogdHJ1ZSxcbiAgICAgIG5vY2FzZTogdHJ1ZVxuICAgIH1cbiAgICBjb25zdCBydWxlcyA9IGRhdGEuc3BsaXQoL1xccj9cXG4vKVxuICAgICAgLmZpbHRlcihsaW5lID0+ICEvXiN8XiQvLnRlc3QobGluZS50cmltKCkpKVxuICAgICAgLm1hcChyID0+IG5ldyBNaW5pbWF0Y2gociwgbW1vcHQpKVxuXG4gICAgdGhpcy5pZ25vcmVSdWxlc1tmaWxlXSA9IHJ1bGVzXG5cbiAgICB0aGVuKClcbiAgfVxuXG4gIGZpbHRlckVudHJpZXMgKCkge1xuICAgIC8vIGF0IHRoaXMgcG9pbnQgd2UgZWl0aGVyIGhhdmUgaWdub3JlIHJ1bGVzLCBvciBqdXN0IGluaGVyaXRpbmdcbiAgICAvLyB0aGlzIGV4Y2x1c2lvbiBpcyBhdCB0aGUgcG9pbnQgd2hlcmUgd2Uga25vdyB0aGUgbGlzdCBvZlxuICAgIC8vIGVudHJpZXMgaW4gdGhlIGRpciwgYnV0IGRvbid0IGtub3cgd2hhdCB0aGV5IGFyZS4gIHNpbmNlXG4gICAgLy8gc29tZSBvZiB0aGVtICptaWdodCogYmUgZGlyZWN0b3JpZXMsIHdlIGhhdmUgdG8gcnVuIHRoZVxuICAgIC8vIG1hdGNoIGluIGRpci1tb2RlIGFzIHdlbGwsIHNvIHRoYXQgd2UnbGwgcGljayB1cCBwYXJ0aWFsc1xuICAgIC8vIG9mIGZpbGVzIHRoYXQgd2lsbCBiZSBpbmNsdWRlZCBsYXRlci4gIEFueXRoaW5nIGluY2x1ZGVkXG4gICAgLy8gYXQgdGhpcyBwb2ludCB3aWxsIGJlIGNoZWNrZWQgYWdhaW4gbGF0ZXIgb25jZSB3ZSBrbm93XG4gICAgLy8gd2hhdCBpdCBpcy5cbiAgICBjb25zdCBmaWx0ZXJlZCA9IHRoaXMuZW50cmllcy5tYXAoZW50cnkgPT4ge1xuICAgICAgLy8gYXQgdGhpcyBwb2ludCwgd2UgZG9uJ3Qga25vdyBpZiBpdCdzIGEgZGlyIG9yIG5vdC5cbiAgICAgIGNvbnN0IHBhc3NGaWxlID0gdGhpcy5maWx0ZXJFbnRyeShlbnRyeSlcbiAgICAgIGNvbnN0IHBhc3NEaXIgPSB0aGlzLmZpbHRlckVudHJ5KGVudHJ5LCB0cnVlKVxuICAgICAgcmV0dXJuIChwYXNzRmlsZSB8fCBwYXNzRGlyKSA/IFtlbnRyeSwgcGFzc0ZpbGUsIHBhc3NEaXJdIDogZmFsc2VcbiAgICB9KS5maWx0ZXIoZSA9PiBlKVxuXG4gICAgLy8gbm93IHdlIHN0YXQgdGhlbSBhbGxcbiAgICAvLyBpZiBpdCdzIGEgZGlyLCBhbmQgcGFzc2VzIGFzIGEgZGlyLCB0aGVuIHJlY3Vyc2VcbiAgICAvLyBpZiBpdCdzIG5vdCBhIGRpciwgYnV0IHBhc3NlcyBhcyBhIGZpbGUsIGFkZCB0byBzZXRcbiAgICBsZXQgZW50cnlDb3VudCA9IGZpbHRlcmVkLmxlbmd0aFxuICAgIGlmIChlbnRyeUNvdW50ID09PSAwKSB7XG4gICAgICB0aGlzLmVtaXQoJ2RvbmUnLCB0aGlzLnJlc3VsdClcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGhlbiA9IF8gPT4ge1xuICAgICAgICBpZiAoLS0gZW50cnlDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLmVtaXQoJ2RvbmUnLCB0aGlzLnJlc3VsdClcbiAgICAgIH1cbiAgICAgIGZpbHRlcmVkLmZvckVhY2goZmlsdCA9PiB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gZmlsdFswXVxuICAgICAgICBjb25zdCBmaWxlID0gZmlsdFsxXVxuICAgICAgICBjb25zdCBkaXIgPSBmaWx0WzJdXG4gICAgICAgIHRoaXMuc3RhdChlbnRyeSwgZmlsZSwgZGlyLCB0aGVuKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBvbnN0YXQgKHN0LCBlbnRyeSwgZmlsZSwgZGlyLCB0aGVuKSB7XG4gICAgY29uc3QgYWJzID0gdGhpcy5wYXRoICsgJy8nICsgZW50cnlcbiAgICBpZiAoIXN0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIGlmIChmaWxlKVxuICAgICAgICB0aGlzLnJlc3VsdC5hZGQoYWJzLnN1YnN0cih0aGlzLnJvb3QubGVuZ3RoICsgMSkpXG4gICAgICB0aGVuKClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaXMgYSBkaXJlY3RvcnlcbiAgICAgIGlmIChkaXIpXG4gICAgICAgIHRoaXMud2Fsa2VyKGVudHJ5LCB0aGVuKVxuICAgICAgZWxzZVxuICAgICAgICB0aGVuKClcbiAgICB9XG4gIH1cblxuICBzdGF0IChlbnRyeSwgZmlsZSwgZGlyLCB0aGVuKSB7XG4gICAgY29uc3QgYWJzID0gdGhpcy5wYXRoICsgJy8nICsgZW50cnlcbiAgICBmc1t0aGlzLmZvbGxvdyA/ICdzdGF0JyA6ICdsc3RhdCddKGFicywgKGVyLCBzdCkgPT4ge1xuICAgICAgaWYgKGVyKVxuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgICBlbHNlXG4gICAgICAgIHRoaXMub25zdGF0KHN0LCBlbnRyeSwgZmlsZSwgZGlyLCB0aGVuKVxuICAgIH0pXG4gIH1cblxuICB3YWxrZXJPcHQgKGVudHJ5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHRoaXMucGF0aCArICcvJyArIGVudHJ5LFxuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgaWdub3JlRmlsZXM6IHRoaXMuaWdub3JlRmlsZXMsXG4gICAgICBmb2xsb3c6IHRoaXMuZm9sbG93LFxuICAgICAgaW5jbHVkZUVtcHR5OiB0aGlzLmluY2x1ZGVFbXB0eVxuICAgIH1cbiAgfVxuXG4gIHdhbGtlciAoZW50cnksIHRoZW4pIHtcbiAgICBuZXcgV2Fsa2VyKHRoaXMud2Fsa2VyT3B0KGVudHJ5KSkub24oJ2RvbmUnLCB0aGVuKS5zdGFydCgpXG4gIH1cblxuICBmaWx0ZXJFbnRyeSAoZW50cnksIHBhcnRpYWwpIHtcbiAgICBsZXQgaW5jbHVkZWQgPSB0cnVlXG5cbiAgICAvLyB0aGlzID0gL2EvYi9jXG4gICAgLy8gZW50cnkgPSBkXG4gICAgLy8gcGFyZW50IC9hL2Igc2VlcyBjL2RcbiAgICBpZiAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuZmlsdGVyRW50cnkpIHtcbiAgICAgIHZhciBwdCA9IHRoaXMuYmFzZW5hbWUgKyBcIi9cIiArIGVudHJ5XG4gICAgICBpbmNsdWRlZCA9IHRoaXMucGFyZW50LmZpbHRlckVudHJ5KHB0LCBwYXJ0aWFsKVxuICAgIH1cblxuICAgIHRoaXMuaWdub3JlRmlsZXMuZm9yRWFjaChmID0+IHtcbiAgICAgIGlmICh0aGlzLmlnbm9yZVJ1bGVzW2ZdKSB7XG4gICAgICAgIHRoaXMuaWdub3JlUnVsZXNbZl0uZm9yRWFjaChydWxlID0+IHtcbiAgICAgICAgICAvLyBuZWdhdGlvbiBtZWFucyBpbmNsdXNpb25cbiAgICAgICAgICAvLyBzbyBpZiBpdCdzIG5lZ2F0ZWQsIGFuZCBhbHJlYWR5IGluY2x1ZGVkLCBubyBuZWVkIHRvIGNoZWNrXG4gICAgICAgICAgLy8gbGlrZXdpc2UgaWYgaXQncyBuZWl0aGVyIG5lZ2F0ZWQgbm9yIGluY2x1ZGVkXG4gICAgICAgICAgaWYgKHJ1bGUubmVnYXRlICE9PSBpbmNsdWRlZCkge1xuICAgICAgICAgICAgLy8gZmlyc3QsIG1hdGNoIGFnYWluc3QgL2Zvby9iYXJcbiAgICAgICAgICAgIC8vIHRoZW4sIGFnYWluc3QgZm9vL2JhclxuICAgICAgICAgICAgLy8gdGhlbiwgaW4gdGhlIGNhc2Ugb2YgcGFydGlhbHMsIG1hdGNoIHdpdGggYSAvXG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IHJ1bGUubWF0Y2goJy8nICsgZW50cnkpIHx8XG4gICAgICAgICAgICAgIHJ1bGUubWF0Y2goZW50cnkpIHx8XG4gICAgICAgICAgICAgICghIXBhcnRpYWwgJiYgKFxuICAgICAgICAgICAgICAgIHJ1bGUubWF0Y2goJy8nICsgZW50cnkgKyAnLycpIHx8XG4gICAgICAgICAgICAgICAgcnVsZS5tYXRjaChlbnRyeSArICcvJykpKSB8fFxuICAgICAgICAgICAgICAoISFwYXJ0aWFsICYmIHJ1bGUubmVnYXRlICYmIChcbiAgICAgICAgICAgICAgICBydWxlLm1hdGNoKCcvJyArIGVudHJ5LCB0cnVlKSB8fFxuICAgICAgICAgICAgICAgIHJ1bGUubWF0Y2goZW50cnksIHRydWUpKSlcblxuICAgICAgICAgICAgaWYgKG1hdGNoKVxuICAgICAgICAgICAgICBpbmNsdWRlZCA9IHJ1bGUubmVnYXRlXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gaW5jbHVkZWRcbiAgfVxufVxuXG5jbGFzcyBXYWxrZXJTeW5jIGV4dGVuZHMgV2Fsa2VyIHtcbiAgY29uc3RydWN0b3IgKG9wdCkge1xuICAgIHN1cGVyKG9wdClcbiAgfVxuXG4gIHN0YXJ0ICgpIHtcbiAgICB0aGlzLm9uUmVhZGRpcihmcy5yZWFkZGlyU3luYyh0aGlzLnBhdGgpKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBhZGRJZ25vcmVGaWxlIChmaWxlLCB0aGVuKSB7XG4gICAgY29uc3QgaWcgPSBwYXRoLnJlc29sdmUodGhpcy5wYXRoLCBmaWxlKVxuICAgIHRoaXMub25SZWFkSWdub3JlRmlsZShmaWxlLCBmcy5yZWFkRmlsZVN5bmMoaWcsICd1dGY4JyksIHRoZW4pXG4gIH1cblxuICBzdGF0IChlbnRyeSwgZmlsZSwgZGlyLCB0aGVuKSB7XG4gICAgY29uc3QgYWJzID0gdGhpcy5wYXRoICsgJy8nICsgZW50cnlcbiAgICBjb25zdCBzdCA9IGZzW3RoaXMuZm9sbG93ID8gJ3N0YXRTeW5jJyA6ICdsc3RhdFN5bmMnXShhYnMpXG4gICAgdGhpcy5vbnN0YXQoc3QsIGVudHJ5LCBmaWxlLCBkaXIsIHRoZW4pXG4gIH1cblxuICB3YWxrZXIgKGVudHJ5LCB0aGVuKSB7XG4gICAgbmV3IFdhbGtlclN5bmModGhpcy53YWxrZXJPcHQoZW50cnkpKS5zdGFydCgpXG4gICAgdGhlbigpXG4gIH1cbn1cblxuY29uc3Qgd2FsayA9IChvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICBjb25zdCBwID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIG5ldyBXYWxrZXIob3B0aW9ucykub24oJ2RvbmUnLCByZXNvbHZlKS5vbignZXJyb3InLCByZWplY3QpLnN0YXJ0KClcbiAgfSlcbiAgcmV0dXJuIGNhbGxiYWNrID8gcC50aGVuKHJlcyA9PiBjYWxsYmFjayhudWxsLCByZXMpLCBjYWxsYmFjaykgOiBwXG59XG5cbmNvbnN0IHdhbGtTeW5jID0gb3B0aW9ucyA9PiB7XG4gIHJldHVybiBuZXcgV2Fsa2VyU3luYyhvcHRpb25zKS5zdGFydCgpLnJlc3VsdFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhbGtcbndhbGsuc3luYyA9IHdhbGtTeW5jXG53YWxrLldhbGtlciA9IFdhbGtlclxud2Fsay5XYWxrZXJTeW5jID0gV2Fsa2VyU3luY1xuIiwiJ3VzZSBzdHJpY3QnXG5jb25zdCBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpXG5jb25zdCBZYWxsaXN0ID0gcmVxdWlyZSgneWFsbGlzdCcpXG5jb25zdCBTRCA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJykuU3RyaW5nRGVjb2RlclxuXG5jb25zdCBFT0YgPSBTeW1ib2woJ0VPRicpXG5jb25zdCBNQVlCRV9FTUlUX0VORCA9IFN5bWJvbCgnbWF5YmVFbWl0RW5kJylcbmNvbnN0IEVNSVRURURfRU5EID0gU3ltYm9sKCdlbWl0dGVkRW5kJylcbmNvbnN0IEVNSVRUSU5HX0VORCA9IFN5bWJvbCgnZW1pdHRpbmdFbmQnKVxuY29uc3QgQ0xPU0VEID0gU3ltYm9sKCdjbG9zZWQnKVxuY29uc3QgUkVBRCA9IFN5bWJvbCgncmVhZCcpXG5jb25zdCBGTFVTSCA9IFN5bWJvbCgnZmx1c2gnKVxuY29uc3QgRkxVU0hDSFVOSyA9IFN5bWJvbCgnZmx1c2hDaHVuaycpXG5jb25zdCBFTkNPRElORyA9IFN5bWJvbCgnZW5jb2RpbmcnKVxuY29uc3QgREVDT0RFUiA9IFN5bWJvbCgnZGVjb2RlcicpXG5jb25zdCBGTE9XSU5HID0gU3ltYm9sKCdmbG93aW5nJylcbmNvbnN0IFBBVVNFRCA9IFN5bWJvbCgncGF1c2VkJylcbmNvbnN0IFJFU1VNRSA9IFN5bWJvbCgncmVzdW1lJylcbmNvbnN0IEJVRkZFUkxFTkdUSCA9IFN5bWJvbCgnYnVmZmVyTGVuZ3RoJylcbmNvbnN0IEJVRkZFUlBVU0ggPSBTeW1ib2woJ2J1ZmZlclB1c2gnKVxuY29uc3QgQlVGRkVSU0hJRlQgPSBTeW1ib2woJ2J1ZmZlclNoaWZ0JylcbmNvbnN0IE9CSkVDVE1PREUgPSBTeW1ib2woJ29iamVjdE1vZGUnKVxuY29uc3QgREVTVFJPWUVEID0gU3ltYm9sKCdkZXN0cm95ZWQnKVxuXG4vLyBUT0RPIHJlbW92ZSB3aGVuIE5vZGUgdjggc3VwcG9ydCBkcm9wc1xuY29uc3QgZG9JdGVyID0gZ2xvYmFsLl9NUF9OT19JVEVSQVRPUl9TWU1CT0xTXyAgIT09ICcxJ1xuY29uc3QgQVNZTkNJVEVSQVRPUiA9IGRvSXRlciAmJiBTeW1ib2wuYXN5bmNJdGVyYXRvclxuICB8fCBTeW1ib2woJ2FzeW5jSXRlcmF0b3Igbm90IGltcGxlbWVudGVkJylcbmNvbnN0IElURVJBVE9SID0gZG9JdGVyICYmIFN5bWJvbC5pdGVyYXRvclxuICB8fCBTeW1ib2woJ2l0ZXJhdG9yIG5vdCBpbXBsZW1lbnRlZCcpXG5cbi8vIEJ1ZmZlciBpbiBub2RlIDQueCA8IDQuNS4wIGRvZXNuJ3QgaGF2ZSB3b3JraW5nIEJ1ZmZlci5mcm9tXG4vLyBvciBCdWZmZXIuYWxsb2MsIGFuZCBCdWZmZXIgaW4gbm9kZSAxMCBkZXByZWNhdGVkIHRoZSBjdG9yLlxuLy8gLk0sIHRoaXMgaXMgZmluZSAuXFxeL00uLlxuY29uc3QgQiA9IEJ1ZmZlci5hbGxvYyA/IEJ1ZmZlclxuICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbi8vIGV2ZW50cyB0aGF0IG1lYW4gJ3RoZSBzdHJlYW0gaXMgb3Zlcidcbi8vIHRoZXNlIGFyZSB0cmVhdGVkIHNwZWNpYWxseSwgYW5kIHJlLWVtaXR0ZWRcbi8vIGlmIHRoZXkgYXJlIGxpc3RlbmVkIGZvciBhZnRlciBlbWl0dGluZy5cbmNvbnN0IGlzRW5kaXNoID0gZXYgPT5cbiAgZXYgPT09ICdlbmQnIHx8XG4gIGV2ID09PSAnZmluaXNoJyB8fFxuICBldiA9PT0gJ3ByZWZpbmlzaCdcblxuY29uc3QgaXNBcnJheUJ1ZmZlciA9IGIgPT4gYiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XG4gIHR5cGVvZiBiID09PSAnb2JqZWN0JyAmJlxuICBiLmNvbnN0cnVjdG9yICYmXG4gIGIuY29uc3RydWN0b3IubmFtZSA9PT0gJ0FycmF5QnVmZmVyJyAmJlxuICBiLmJ5dGVMZW5ndGggPj0gMFxuXG5jb25zdCBpc0FycmF5QnVmZmVyVmlldyA9IGIgPT4gIUIuaXNCdWZmZXIoYikgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KGIpXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgTWluaXBhc3MgZXh0ZW5kcyBFRSB7XG4gIGNvbnN0cnVjdG9yIChvcHRpb25zKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXNbRkxPV0lOR10gPSBmYWxzZVxuICAgIC8vIHdoZXRoZXIgd2UncmUgZXhwbGljaXRseSBwYXVzZWRcbiAgICB0aGlzW1BBVVNFRF0gPSBmYWxzZVxuICAgIHRoaXMucGlwZXMgPSBuZXcgWWFsbGlzdCgpXG4gICAgdGhpcy5idWZmZXIgPSBuZXcgWWFsbGlzdCgpXG4gICAgdGhpc1tPQkpFQ1RNT0RFXSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5vYmplY3RNb2RlIHx8IGZhbHNlXG4gICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pXG4gICAgICB0aGlzW0VOQ09ESU5HXSA9IG51bGxcbiAgICBlbHNlXG4gICAgICB0aGlzW0VOQ09ESU5HXSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5lbmNvZGluZyB8fCBudWxsXG4gICAgaWYgKHRoaXNbRU5DT0RJTkddID09PSAnYnVmZmVyJylcbiAgICAgIHRoaXNbRU5DT0RJTkddID0gbnVsbFxuICAgIHRoaXNbREVDT0RFUl0gPSB0aGlzW0VOQ09ESU5HXSA/IG5ldyBTRCh0aGlzW0VOQ09ESU5HXSkgOiBudWxsXG4gICAgdGhpc1tFT0ZdID0gZmFsc2VcbiAgICB0aGlzW0VNSVRURURfRU5EXSA9IGZhbHNlXG4gICAgdGhpc1tFTUlUVElOR19FTkRdID0gZmFsc2VcbiAgICB0aGlzW0NMT1NFRF0gPSBmYWxzZVxuICAgIHRoaXMud3JpdGFibGUgPSB0cnVlXG4gICAgdGhpcy5yZWFkYWJsZSA9IHRydWVcbiAgICB0aGlzW0JVRkZFUkxFTkdUSF0gPSAwXG4gICAgdGhpc1tERVNUUk9ZRURdID0gZmFsc2VcbiAgfVxuXG4gIGdldCBidWZmZXJMZW5ndGggKCkgeyByZXR1cm4gdGhpc1tCVUZGRVJMRU5HVEhdIH1cblxuICBnZXQgZW5jb2RpbmcgKCkgeyByZXR1cm4gdGhpc1tFTkNPRElOR10gfVxuICBzZXQgZW5jb2RpbmcgKGVuYykge1xuICAgIGlmICh0aGlzW09CSkVDVE1PREVdKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3Qgc2V0IGVuY29kaW5nIGluIG9iamVjdE1vZGUnKVxuXG4gICAgaWYgKHRoaXNbRU5DT0RJTkddICYmIGVuYyAhPT0gdGhpc1tFTkNPRElOR10gJiZcbiAgICAgICAgKHRoaXNbREVDT0RFUl0gJiYgdGhpc1tERUNPREVSXS5sYXN0TmVlZCB8fCB0aGlzW0JVRkZFUkxFTkdUSF0pKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgY2hhbmdlIGVuY29kaW5nJylcblxuICAgIGlmICh0aGlzW0VOQ09ESU5HXSAhPT0gZW5jKSB7XG4gICAgICB0aGlzW0RFQ09ERVJdID0gZW5jID8gbmV3IFNEKGVuYykgOiBudWxsXG4gICAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoKVxuICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuYnVmZmVyLm1hcChjaHVuayA9PiB0aGlzW0RFQ09ERVJdLndyaXRlKGNodW5rKSlcbiAgICB9XG5cbiAgICB0aGlzW0VOQ09ESU5HXSA9IGVuY1xuICB9XG5cbiAgc2V0RW5jb2RpbmcgKGVuYykge1xuICAgIHRoaXMuZW5jb2RpbmcgPSBlbmNcbiAgfVxuXG4gIGdldCBvYmplY3RNb2RlICgpIHsgcmV0dXJuIHRoaXNbT0JKRUNUTU9ERV0gfVxuICBzZXQgb2JqZWN0TW9kZSAo4KWQICkgeyB0aGlzW09CSkVDVE1PREVdID0gdGhpc1tPQkpFQ1RNT0RFXSB8fCAhIeClkCAgfVxuXG4gIHdyaXRlIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgaWYgKHRoaXNbRU9GXSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJylcblxuICAgIGlmICh0aGlzW0RFU1RST1lFRF0pIHtcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBPYmplY3QuYXNzaWduKFxuICAgICAgICBuZXcgRXJyb3IoJ0Nhbm5vdCBjYWxsIHdyaXRlIGFmdGVyIGEgc3RyZWFtIHdhcyBkZXN0cm95ZWQnKSxcbiAgICAgICAgeyBjb2RlOiAnRVJSX1NUUkVBTV9ERVNUUk9ZRUQnIH1cbiAgICAgICkpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYiA9IGVuY29kaW5nLCBlbmNvZGluZyA9ICd1dGY4J1xuXG4gICAgaWYgKCFlbmNvZGluZylcbiAgICAgIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgICAvLyBjb252ZXJ0IGFycmF5IGJ1ZmZlcnMgYW5kIHR5cGVkIGFycmF5IHZpZXdzIGludG8gYnVmZmVyc1xuICAgIC8vIGF0IHNvbWUgcG9pbnQgaW4gdGhlIGZ1dHVyZSwgd2UgbWF5IHdhbnQgdG8gZG8gdGhlIG9wcG9zaXRlIVxuICAgIC8vIGxlYXZlIHN0cmluZ3MgYW5kIGJ1ZmZlcnMgYXMtaXNcbiAgICAvLyBhbnl0aGluZyBlbHNlIHN3aXRjaGVzIHVzIGludG8gb2JqZWN0IG1vZGVcbiAgICBpZiAoIXRoaXNbT0JKRUNUTU9ERV0gJiYgIUIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgICBpZiAoaXNBcnJheUJ1ZmZlclZpZXcoY2h1bmspKVxuICAgICAgICBjaHVuayA9IEIuZnJvbShjaHVuay5idWZmZXIsIGNodW5rLmJ5dGVPZmZzZXQsIGNodW5rLmJ5dGVMZW5ndGgpXG4gICAgICBlbHNlIGlmIChpc0FycmF5QnVmZmVyKGNodW5rKSlcbiAgICAgICAgY2h1bmsgPSBCLmZyb20oY2h1bmspXG4gICAgICBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnKVxuICAgICAgICAvLyB1c2UgdGhlIHNldHRlciBzbyB3ZSB0aHJvdyBpZiB3ZSBoYXZlIGVuY29kaW5nIHNldFxuICAgICAgICB0aGlzLm9iamVjdE1vZGUgPSB0cnVlXG4gICAgfVxuXG4gICAgLy8gdGhpcyBlbnN1cmVzIGF0IHRoaXMgcG9pbnQgdGhhdCB0aGUgY2h1bmsgaXMgYSBidWZmZXIgb3Igc3RyaW5nXG4gICAgLy8gZG9uJ3QgYnVmZmVyIGl0IHVwIG9yIHNlbmQgaXQgdG8gdGhlIGRlY29kZXJcbiAgICBpZiAoIXRoaXMub2JqZWN0TW9kZSAmJiAhY2h1bmsubGVuZ3RoKSB7XG4gICAgICBjb25zdCByZXQgPSB0aGlzLmZsb3dpbmdcbiAgICAgIGlmICh0aGlzW0JVRkZFUkxFTkdUSF0gIT09IDApXG4gICAgICAgIHRoaXMuZW1pdCgncmVhZGFibGUnKVxuICAgICAgaWYgKGNiKVxuICAgICAgICBjYigpXG4gICAgICByZXR1cm4gcmV0XG4gICAgfVxuXG4gICAgLy8gZmFzdC1wYXRoIHdyaXRpbmcgc3RyaW5ncyBvZiBzYW1lIGVuY29kaW5nIHRvIGEgc3RyZWFtIHdpdGhcbiAgICAvLyBhbiBlbXB0eSBidWZmZXIsIHNraXBwaW5nIHRoZSBidWZmZXIvZGVjb2RlciBkYW5jZVxuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnICYmICF0aGlzW09CSkVDVE1PREVdICYmXG4gICAgICAgIC8vIHVubGVzcyBpdCBpcyBhIHN0cmluZyBhbHJlYWR5IHJlYWR5IGZvciB1cyB0byB1c2VcbiAgICAgICAgIShlbmNvZGluZyA9PT0gdGhpc1tFTkNPRElOR10gJiYgIXRoaXNbREVDT0RFUl0ubGFzdE5lZWQpKSB7XG4gICAgICBjaHVuayA9IEIuZnJvbShjaHVuaywgZW5jb2RpbmcpXG4gICAgfVxuXG4gICAgaWYgKEIuaXNCdWZmZXIoY2h1bmspICYmIHRoaXNbRU5DT0RJTkddKVxuICAgICAgY2h1bmsgPSB0aGlzW0RFQ09ERVJdLndyaXRlKGNodW5rKVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dpbmdcbiAgICAgICAgPyAodGhpcy5lbWl0KCdkYXRhJywgY2h1bmspLCB0aGlzLmZsb3dpbmcpXG4gICAgICAgIDogKHRoaXNbQlVGRkVSUFVTSF0oY2h1bmspLCBmYWxzZSlcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHRoaXNbQlVGRkVSTEVOR1RIXSAhPT0gMClcbiAgICAgICAgdGhpcy5lbWl0KCdyZWFkYWJsZScpXG4gICAgICBpZiAoY2IpXG4gICAgICAgIGNiKClcbiAgICB9XG4gIH1cblxuICByZWFkIChuKSB7XG4gICAgaWYgKHRoaXNbREVTVFJPWUVEXSlcbiAgICAgIHJldHVybiBudWxsXG5cbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXNbQlVGRkVSTEVOR1RIXSA9PT0gMCB8fCBuID09PSAwIHx8IG4gPiB0aGlzW0JVRkZFUkxFTkdUSF0pXG4gICAgICAgIHJldHVybiBudWxsXG5cbiAgICAgIGlmICh0aGlzW09CSkVDVE1PREVdKVxuICAgICAgICBuID0gbnVsbFxuXG4gICAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoID4gMSAmJiAhdGhpc1tPQkpFQ1RNT0RFXSkge1xuICAgICAgICBpZiAodGhpcy5lbmNvZGluZylcbiAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBZYWxsaXN0KFtcbiAgICAgICAgICAgIEFycmF5LmZyb20odGhpcy5idWZmZXIpLmpvaW4oJycpXG4gICAgICAgICAgXSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFlhbGxpc3QoW1xuICAgICAgICAgICAgQi5jb25jYXQoQXJyYXkuZnJvbSh0aGlzLmJ1ZmZlciksIHRoaXNbQlVGRkVSTEVOR1RIXSlcbiAgICAgICAgICBdKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpc1tSRUFEXShuIHx8IG51bGwsIHRoaXMuYnVmZmVyLmhlYWQudmFsdWUpXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKClcbiAgICB9XG4gIH1cblxuICBbUkVBRF0gKG4sIGNodW5rKSB7XG4gICAgaWYgKG4gPT09IGNodW5rLmxlbmd0aCB8fCBuID09PSBudWxsKVxuICAgICAgdGhpc1tCVUZGRVJTSElGVF0oKVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5idWZmZXIuaGVhZC52YWx1ZSA9IGNodW5rLnNsaWNlKG4pXG4gICAgICBjaHVuayA9IGNodW5rLnNsaWNlKDAsIG4pXG4gICAgICB0aGlzW0JVRkZFUkxFTkdUSF0gLT0gblxuICAgIH1cblxuICAgIHRoaXMuZW1pdCgnZGF0YScsIGNodW5rKVxuXG4gICAgaWYgKCF0aGlzLmJ1ZmZlci5sZW5ndGggJiYgIXRoaXNbRU9GXSlcbiAgICAgIHRoaXMuZW1pdCgnZHJhaW4nKVxuXG4gICAgcmV0dXJuIGNodW5rXG4gIH1cblxuICBlbmQgKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBjaHVuaywgY2h1bmsgPSBudWxsXG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiID0gZW5jb2RpbmcsIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgaWYgKGNodW5rKVxuICAgICAgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpXG4gICAgaWYgKGNiKVxuICAgICAgdGhpcy5vbmNlKCdlbmQnLCBjYilcbiAgICB0aGlzW0VPRl0gPSB0cnVlXG4gICAgdGhpcy53cml0YWJsZSA9IGZhbHNlXG5cbiAgICAvLyBpZiB3ZSBoYXZlbid0IHdyaXR0ZW4gYW55dGhpbmcsIHRoZW4gZ28gYWhlYWQgYW5kIGVtaXQsXG4gICAgLy8gZXZlbiBpZiB3ZSdyZSBub3QgcmVhZGluZy5cbiAgICAvLyB3ZSdsbCByZS1lbWl0IGlmIGEgbmV3ICdlbmQnIGxpc3RlbmVyIGlzIGFkZGVkIGFueXdheS5cbiAgICAvLyBUaGlzIG1ha2VzIE1QIG1vcmUgc3VpdGFibGUgdG8gd3JpdGUtb25seSB1c2UgY2FzZXMuXG4gICAgaWYgKHRoaXMuZmxvd2luZyB8fCAhdGhpc1tQQVVTRURdKVxuICAgICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBkb24ndCBsZXQgdGhlIGludGVybmFsIHJlc3VtZSBiZSBvdmVyd3JpdHRlblxuICBbUkVTVU1FXSAoKSB7XG4gICAgaWYgKHRoaXNbREVTVFJPWUVEXSlcbiAgICAgIHJldHVyblxuXG4gICAgdGhpc1tQQVVTRURdID0gZmFsc2VcbiAgICB0aGlzW0ZMT1dJTkddID0gdHJ1ZVxuICAgIHRoaXMuZW1pdCgncmVzdW1lJylcbiAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoKVxuICAgICAgdGhpc1tGTFVTSF0oKVxuICAgIGVsc2UgaWYgKHRoaXNbRU9GXSlcbiAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKClcbiAgICBlbHNlXG4gICAgICB0aGlzLmVtaXQoJ2RyYWluJylcbiAgfVxuXG4gIHJlc3VtZSAoKSB7XG4gICAgcmV0dXJuIHRoaXNbUkVTVU1FXSgpXG4gIH1cblxuICBwYXVzZSAoKSB7XG4gICAgdGhpc1tGTE9XSU5HXSA9IGZhbHNlXG4gICAgdGhpc1tQQVVTRURdID0gdHJ1ZVxuICB9XG5cbiAgZ2V0IGRlc3Ryb3llZCAoKSB7XG4gICAgcmV0dXJuIHRoaXNbREVTVFJPWUVEXVxuICB9XG5cbiAgZ2V0IGZsb3dpbmcgKCkge1xuICAgIHJldHVybiB0aGlzW0ZMT1dJTkddXG4gIH1cblxuICBnZXQgcGF1c2VkICgpIHtcbiAgICByZXR1cm4gdGhpc1tQQVVTRURdXG4gIH1cblxuICBbQlVGRkVSUFVTSF0gKGNodW5rKSB7XG4gICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pXG4gICAgICB0aGlzW0JVRkZFUkxFTkdUSF0gKz0gMVxuICAgIGVsc2VcbiAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSArPSBjaHVuay5sZW5ndGhcbiAgICByZXR1cm4gdGhpcy5idWZmZXIucHVzaChjaHVuaylcbiAgfVxuXG4gIFtCVUZGRVJTSElGVF0gKCkge1xuICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzW09CSkVDVE1PREVdKVxuICAgICAgICB0aGlzW0JVRkZFUkxFTkdUSF0gLT0gMVxuICAgICAgZWxzZVxuICAgICAgICB0aGlzW0JVRkZFUkxFTkdUSF0gLT0gdGhpcy5idWZmZXIuaGVhZC52YWx1ZS5sZW5ndGhcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyLnNoaWZ0KClcbiAgfVxuXG4gIFtGTFVTSF0gKCkge1xuICAgIGRvIHt9IHdoaWxlICh0aGlzW0ZMVVNIQ0hVTktdKHRoaXNbQlVGRkVSU0hJRlRdKCkpKVxuXG4gICAgaWYgKCF0aGlzLmJ1ZmZlci5sZW5ndGggJiYgIXRoaXNbRU9GXSlcbiAgICAgIHRoaXMuZW1pdCgnZHJhaW4nKVxuICB9XG5cbiAgW0ZMVVNIQ0hVTktdIChjaHVuaykge1xuICAgIHJldHVybiBjaHVuayA/ICh0aGlzLmVtaXQoJ2RhdGEnLCBjaHVuayksIHRoaXMuZmxvd2luZykgOiBmYWxzZVxuICB9XG5cbiAgcGlwZSAoZGVzdCwgb3B0cykge1xuICAgIGlmICh0aGlzW0RFU1RST1lFRF0pXG4gICAgICByZXR1cm5cblxuICAgIGNvbnN0IGVuZGVkID0gdGhpc1tFTUlUVEVEX0VORF1cbiAgICBvcHRzID0gb3B0cyB8fCB7fVxuICAgIGlmIChkZXN0ID09PSBwcm9jZXNzLnN0ZG91dCB8fCBkZXN0ID09PSBwcm9jZXNzLnN0ZGVycilcbiAgICAgIG9wdHMuZW5kID0gZmFsc2VcbiAgICBlbHNlXG4gICAgICBvcHRzLmVuZCA9IG9wdHMuZW5kICE9PSBmYWxzZVxuXG4gICAgY29uc3QgcCA9IHsgZGVzdDogZGVzdCwgb3B0czogb3B0cywgb25kcmFpbjogXyA9PiB0aGlzW1JFU1VNRV0oKSB9XG4gICAgdGhpcy5waXBlcy5wdXNoKHApXG5cbiAgICBkZXN0Lm9uKCdkcmFpbicsIHAub25kcmFpbilcbiAgICB0aGlzW1JFU1VNRV0oKVxuICAgIC8vIHBpcGluZyBhbiBlbmRlZCBzdHJlYW0gZW5kcyBpbW1lZGlhdGVseVxuICAgIGlmIChlbmRlZCAmJiBwLm9wdHMuZW5kKVxuICAgICAgcC5kZXN0LmVuZCgpXG4gICAgcmV0dXJuIGRlc3RcbiAgfVxuXG4gIGFkZExpc3RlbmVyIChldiwgZm4pIHtcbiAgICByZXR1cm4gdGhpcy5vbihldiwgZm4pXG4gIH1cblxuICBvbiAoZXYsIGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBzdXBlci5vbihldiwgZm4pXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChldiA9PT0gJ2RhdGEnICYmICF0aGlzLnBpcGVzLmxlbmd0aCAmJiAhdGhpcy5mbG93aW5nKVxuICAgICAgICB0aGlzW1JFU1VNRV0oKVxuICAgICAgZWxzZSBpZiAoaXNFbmRpc2goZXYpICYmIHRoaXNbRU1JVFRFRF9FTkRdKSB7XG4gICAgICAgIHN1cGVyLmVtaXQoZXYpXG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGV2KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldCBlbWl0dGVkRW5kICgpIHtcbiAgICByZXR1cm4gdGhpc1tFTUlUVEVEX0VORF1cbiAgfVxuXG4gIFtNQVlCRV9FTUlUX0VORF0gKCkge1xuICAgIGlmICghdGhpc1tFTUlUVElOR19FTkRdICYmXG4gICAgICAgICF0aGlzW0VNSVRURURfRU5EXSAmJlxuICAgICAgICAhdGhpc1tERVNUUk9ZRURdICYmXG4gICAgICAgIHRoaXMuYnVmZmVyLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICB0aGlzW0VPRl0pIHtcbiAgICAgIHRoaXNbRU1JVFRJTkdfRU5EXSA9IHRydWVcbiAgICAgIHRoaXMuZW1pdCgnZW5kJylcbiAgICAgIHRoaXMuZW1pdCgncHJlZmluaXNoJylcbiAgICAgIHRoaXMuZW1pdCgnZmluaXNoJylcbiAgICAgIGlmICh0aGlzW0NMT1NFRF0pXG4gICAgICAgIHRoaXMuZW1pdCgnY2xvc2UnKVxuICAgICAgdGhpc1tFTUlUVElOR19FTkRdID0gZmFsc2VcbiAgICB9XG4gIH1cblxuICBlbWl0IChldiwgZGF0YSkge1xuICAgIC8vIGVycm9yIGFuZCBjbG9zZSBhcmUgb25seSBldmVudHMgYWxsb3dlZCBhZnRlciBjYWxsaW5nIGRlc3Ryb3koKVxuICAgIGlmIChldiAhPT0gJ2Vycm9yJyAmJiBldiAhPT0gJ2Nsb3NlJyAmJiBldiAhPT0gREVTVFJPWUVEICYmIHRoaXNbREVTVFJPWUVEXSlcbiAgICAgIHJldHVyblxuICAgIGVsc2UgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAgIGlmICghZGF0YSlcbiAgICAgICAgcmV0dXJuXG5cbiAgICAgIGlmICh0aGlzLnBpcGVzLmxlbmd0aClcbiAgICAgICAgdGhpcy5waXBlcy5mb3JFYWNoKHAgPT5cbiAgICAgICAgICBwLmRlc3Qud3JpdGUoZGF0YSkgPT09IGZhbHNlICYmIHRoaXMucGF1c2UoKSlcbiAgICB9IGVsc2UgaWYgKGV2ID09PSAnZW5kJykge1xuICAgICAgLy8gb25seSBhY3R1YWwgZW5kIGdldHMgdGhpcyB0cmVhdG1lbnRcbiAgICAgIGlmICh0aGlzW0VNSVRURURfRU5EXSA9PT0gdHJ1ZSlcbiAgICAgICAgcmV0dXJuXG5cbiAgICAgIHRoaXNbRU1JVFRFRF9FTkRdID0gdHJ1ZVxuICAgICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlXG5cbiAgICAgIGlmICh0aGlzW0RFQ09ERVJdKSB7XG4gICAgICAgIGRhdGEgPSB0aGlzW0RFQ09ERVJdLmVuZCgpXG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgdGhpcy5waXBlcy5mb3JFYWNoKHAgPT4gcC5kZXN0LndyaXRlKGRhdGEpKVxuICAgICAgICAgIHN1cGVyLmVtaXQoJ2RhdGEnLCBkYXRhKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGlwZXMuZm9yRWFjaChwID0+IHtcbiAgICAgICAgcC5kZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIHAub25kcmFpbilcbiAgICAgICAgaWYgKHAub3B0cy5lbmQpXG4gICAgICAgICAgcC5kZXN0LmVuZCgpXG4gICAgICB9KVxuICAgIH0gZWxzZSBpZiAoZXYgPT09ICdjbG9zZScpIHtcbiAgICAgIHRoaXNbQ0xPU0VEXSA9IHRydWVcbiAgICAgIC8vIGRvbid0IGVtaXQgY2xvc2UgYmVmb3JlICdlbmQnIGFuZCAnZmluaXNoJ1xuICAgICAgaWYgKCF0aGlzW0VNSVRURURfRU5EXSAmJiAhdGhpc1tERVNUUk9ZRURdKVxuICAgICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBUT0RPOiByZXBsYWNlIHdpdGggYSBzcHJlYWQgb3BlcmF0b3Igd2hlbiBOb2RlIHY0IHN1cHBvcnQgZHJvcHNcbiAgICBjb25zdCBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgYXJnc1swXSA9IGV2XG4gICAgYXJnc1sxXSA9IGRhdGFcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGZvciAobGV0IGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHN1cGVyLmVtaXQuYXBwbHkodGhpcywgYXJncylcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKCFpc0VuZGlzaChldikpXG4gICAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKClcbiAgICAgIGVsc2VcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoZXYpXG4gICAgfVxuICB9XG5cbiAgLy8gY29uc3QgYWxsID0gYXdhaXQgc3RyZWFtLmNvbGxlY3QoKVxuICBjb2xsZWN0ICgpIHtcbiAgICBjb25zdCBidWYgPSBbXVxuICAgIGJ1Zi5kYXRhTGVuZ3RoID0gMFxuICAgIHRoaXMub24oJ2RhdGEnLCBjID0+IHtcbiAgICAgIGJ1Zi5wdXNoKGMpXG4gICAgICBidWYuZGF0YUxlbmd0aCArPSBjLmxlbmd0aFxuICAgIH0pXG4gICAgcmV0dXJuIHRoaXMucHJvbWlzZSgpLnRoZW4oKCkgPT4gYnVmKVxuICB9XG5cbiAgLy8gY29uc3QgZGF0YSA9IGF3YWl0IHN0cmVhbS5jb25jYXQoKVxuICBjb25jYXQgKCkge1xuICAgIHJldHVybiB0aGlzW09CSkVDVE1PREVdXG4gICAgICA/IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignY2Fubm90IGNvbmNhdCBpbiBvYmplY3RNb2RlJykpXG4gICAgICA6IHRoaXMuY29sbGVjdCgpLnRoZW4oYnVmID0+XG4gICAgICAgICAgdGhpc1tPQkpFQ1RNT0RFXVxuICAgICAgICAgICAgPyBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ2Nhbm5vdCBjb25jYXQgaW4gb2JqZWN0TW9kZScpKVxuICAgICAgICAgICAgOiB0aGlzW0VOQ09ESU5HXSA/IGJ1Zi5qb2luKCcnKSA6IEIuY29uY2F0KGJ1ZiwgYnVmLmRhdGFMZW5ndGgpKVxuICB9XG5cbiAgLy8gc3RyZWFtLnByb21pc2UoKS50aGVuKCgpID0+IGRvbmUsIGVyID0+IGVtaXR0ZWQgZXJyb3IpXG4gIHByb21pc2UgKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLm9uKERFU1RST1lFRCwgKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignc3RyZWFtIGRlc3Ryb3llZCcpKSlcbiAgICAgIHRoaXMub24oJ2VuZCcsICgpID0+IHJlc29sdmUoKSlcbiAgICAgIHRoaXMub24oJ2Vycm9yJywgZXIgPT4gcmVqZWN0KGVyKSlcbiAgICB9KVxuICB9XG5cbiAgLy8gZm9yIGF3YWl0IChsZXQgY2h1bmsgb2Ygc3RyZWFtKVxuICBbQVNZTkNJVEVSQVRPUl0gKCkge1xuICAgIGNvbnN0IG5leHQgPSAoKSA9PiB7XG4gICAgICBjb25zdCByZXMgPSB0aGlzLnJlYWQoKVxuICAgICAgaWYgKHJlcyAhPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGRvbmU6IGZhbHNlLCB2YWx1ZTogcmVzIH0pXG5cbiAgICAgIGlmICh0aGlzW0VPRl0pXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBkb25lOiB0cnVlIH0pXG5cbiAgICAgIGxldCByZXNvbHZlID0gbnVsbFxuICAgICAgbGV0IHJlamVjdCA9IG51bGxcbiAgICAgIGNvbnN0IG9uZXJyID0gZXIgPT4ge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKVxuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZClcbiAgICAgICAgcmVqZWN0KGVyKVxuICAgICAgfVxuICAgICAgY29uc3Qgb25kYXRhID0gdmFsdWUgPT4ge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyKVxuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZClcbiAgICAgICAgdGhpcy5wYXVzZSgpXG4gICAgICAgIHJlc29sdmUoeyB2YWx1ZTogdmFsdWUsIGRvbmU6ICEhdGhpc1tFT0ZdIH0pXG4gICAgICB9XG4gICAgICBjb25zdCBvbmVuZCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycilcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSlcbiAgICAgICAgcmVzb2x2ZSh7IGRvbmU6IHRydWUgfSlcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9uZGVzdHJveSA9ICgpID0+IG9uZXJyKG5ldyBFcnJvcignc3RyZWFtIGRlc3Ryb3llZCcpKVxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICByZWplY3QgPSByZWpcbiAgICAgICAgcmVzb2x2ZSA9IHJlc1xuICAgICAgICB0aGlzLm9uY2UoREVTVFJPWUVELCBvbmRlc3Ryb3kpXG4gICAgICAgIHRoaXMub25jZSgnZXJyb3InLCBvbmVycilcbiAgICAgICAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZClcbiAgICAgICAgdGhpcy5vbmNlKCdkYXRhJywgb25kYXRhKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4geyBuZXh0IH1cbiAgfVxuXG4gIC8vIGZvciAobGV0IGNodW5rIG9mIHN0cmVhbSlcbiAgW0lURVJBVE9SXSAoKSB7XG4gICAgY29uc3QgbmV4dCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5yZWFkKClcbiAgICAgIGNvbnN0IGRvbmUgPSB2YWx1ZSA9PT0gbnVsbFxuICAgICAgcmV0dXJuIHsgdmFsdWUsIGRvbmUgfVxuICAgIH1cbiAgICByZXR1cm4geyBuZXh0IH1cbiAgfVxuXG4gIGRlc3Ryb3kgKGVyKSB7XG4gICAgaWYgKHRoaXNbREVTVFJPWUVEXSkge1xuICAgICAgaWYgKGVyKVxuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgICBlbHNlXG4gICAgICAgIHRoaXMuZW1pdChERVNUUk9ZRUQpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHRoaXNbREVTVFJPWUVEXSA9IHRydWVcblxuICAgIC8vIHRocm93IGF3YXkgYWxsIGJ1ZmZlcmVkIGRhdGEsIGl0J3MgbmV2ZXIgY29taW5nIG91dFxuICAgIHRoaXMuYnVmZmVyID0gbmV3IFlhbGxpc3QoKVxuICAgIHRoaXNbQlVGRkVSTEVOR1RIXSA9IDBcblxuICAgIGlmICh0eXBlb2YgdGhpcy5jbG9zZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhdGhpc1tDTE9TRURdKVxuICAgICAgdGhpcy5jbG9zZSgpXG5cbiAgICBpZiAoZXIpXG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgZWxzZSAvLyBpZiBubyBlcnJvciB0byBlbWl0LCBzdGlsbCByZWplY3QgcGVuZGluZyBwcm9taXNlc1xuICAgICAgdGhpcy5lbWl0KERFU1RST1lFRClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGF0aWMgaXNTdHJlYW0gKHMpIHtcbiAgICByZXR1cm4gISFzICYmIChzIGluc3RhbmNlb2YgTWluaXBhc3MgfHwgcyBpbnN0YW5jZW9mIEVFICYmIChcbiAgICAgIHR5cGVvZiBzLnBpcGUgPT09ICdmdW5jdGlvbicgfHwgLy8gcmVhZGFibGVcbiAgICAgICh0eXBlb2Ygcy53cml0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygcy5lbmQgPT09ICdmdW5jdGlvbicpIC8vIHdyaXRhYmxlXG4gICAgKSlcbiAgfVxufVxuIiwiLy8gVXBkYXRlIHdpdGggYW55IHpsaWIgY29uc3RhbnRzIHRoYXQgYXJlIGFkZGVkIG9yIGNoYW5nZWQgaW4gdGhlIGZ1dHVyZS5cbi8vIE5vZGUgdjYgZGlkbid0IGV4cG9ydCB0aGlzLCBzbyB3ZSBqdXN0IGhhcmQgY29kZSB0aGUgdmVyc2lvbiBhbmQgcmVseVxuLy8gb24gYWxsIHRoZSBvdGhlciBoYXJkLWNvZGVkIHZhbHVlcyBmcm9tIHpsaWIgdjQ3MzYuICBXaGVuIG5vZGUgdjZcbi8vIHN1cHBvcnQgZHJvcHMsIHdlIGNhbiBqdXN0IGV4cG9ydCB0aGUgcmVhbFpsaWJDb25zdGFudHMgb2JqZWN0LlxuY29uc3QgcmVhbFpsaWJDb25zdGFudHMgPSByZXF1aXJlKCd6bGliJykuY29uc3RhbnRzIHx8XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHsgWkxJQl9WRVJOVU06IDQ3MzYgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5mcmVlemUoT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gIFpfTk9fRkxVU0g6IDAsXG4gIFpfUEFSVElBTF9GTFVTSDogMSxcbiAgWl9TWU5DX0ZMVVNIOiAyLFxuICBaX0ZVTExfRkxVU0g6IDMsXG4gIFpfRklOSVNIOiA0LFxuICBaX0JMT0NLOiA1LFxuICBaX09LOiAwLFxuICBaX1NUUkVBTV9FTkQ6IDEsXG4gIFpfTkVFRF9ESUNUOiAyLFxuICBaX0VSUk5POiAtMSxcbiAgWl9TVFJFQU1fRVJST1I6IC0yLFxuICBaX0RBVEFfRVJST1I6IC0zLFxuICBaX01FTV9FUlJPUjogLTQsXG4gIFpfQlVGX0VSUk9SOiAtNSxcbiAgWl9WRVJTSU9OX0VSUk9SOiAtNixcbiAgWl9OT19DT01QUkVTU0lPTjogMCxcbiAgWl9CRVNUX1NQRUVEOiAxLFxuICBaX0JFU1RfQ09NUFJFU1NJT046IDksXG4gIFpfREVGQVVMVF9DT01QUkVTU0lPTjogLTEsXG4gIFpfRklMVEVSRUQ6IDEsXG4gIFpfSFVGRk1BTl9PTkxZOiAyLFxuICBaX1JMRTogMyxcbiAgWl9GSVhFRDogNCxcbiAgWl9ERUZBVUxUX1NUUkFURUdZOiAwLFxuICBERUZMQVRFOiAxLFxuICBJTkZMQVRFOiAyLFxuICBHWklQOiAzLFxuICBHVU5aSVA6IDQsXG4gIERFRkxBVEVSQVc6IDUsXG4gIElORkxBVEVSQVc6IDYsXG4gIFVOWklQOiA3LFxuICBCUk9UTElfREVDT0RFOiA4LFxuICBCUk9UTElfRU5DT0RFOiA5LFxuICBaX01JTl9XSU5ET1dCSVRTOiA4LFxuICBaX01BWF9XSU5ET1dCSVRTOiAxNSxcbiAgWl9ERUZBVUxUX1dJTkRPV0JJVFM6IDE1LFxuICBaX01JTl9DSFVOSzogNjQsXG4gIFpfTUFYX0NIVU5LOiBJbmZpbml0eSxcbiAgWl9ERUZBVUxUX0NIVU5LOiAxNjM4NCxcbiAgWl9NSU5fTUVNTEVWRUw6IDEsXG4gIFpfTUFYX01FTUxFVkVMOiA5LFxuICBaX0RFRkFVTFRfTUVNTEVWRUw6IDgsXG4gIFpfTUlOX0xFVkVMOiAtMSxcbiAgWl9NQVhfTEVWRUw6IDksXG4gIFpfREVGQVVMVF9MRVZFTDogLTEsXG4gIEJST1RMSV9PUEVSQVRJT05fUFJPQ0VTUzogMCxcbiAgQlJPVExJX09QRVJBVElPTl9GTFVTSDogMSxcbiAgQlJPVExJX09QRVJBVElPTl9GSU5JU0g6IDIsXG4gIEJST1RMSV9PUEVSQVRJT05fRU1JVF9NRVRBREFUQTogMyxcbiAgQlJPVExJX01PREVfR0VORVJJQzogMCxcbiAgQlJPVExJX01PREVfVEVYVDogMSxcbiAgQlJPVExJX01PREVfRk9OVDogMixcbiAgQlJPVExJX0RFRkFVTFRfTU9ERTogMCxcbiAgQlJPVExJX01JTl9RVUFMSVRZOiAwLFxuICBCUk9UTElfTUFYX1FVQUxJVFk6IDExLFxuICBCUk9UTElfREVGQVVMVF9RVUFMSVRZOiAxMSxcbiAgQlJPVExJX01JTl9XSU5ET1dfQklUUzogMTAsXG4gIEJST1RMSV9NQVhfV0lORE9XX0JJVFM6IDI0LFxuICBCUk9UTElfTEFSR0VfTUFYX1dJTkRPV19CSVRTOiAzMCxcbiAgQlJPVExJX0RFRkFVTFRfV0lORE9XOiAyMixcbiAgQlJPVExJX01JTl9JTlBVVF9CTE9DS19CSVRTOiAxNixcbiAgQlJPVExJX01BWF9JTlBVVF9CTE9DS19CSVRTOiAyNCxcbiAgQlJPVExJX1BBUkFNX01PREU6IDAsXG4gIEJST1RMSV9QQVJBTV9RVUFMSVRZOiAxLFxuICBCUk9UTElfUEFSQU1fTEdXSU46IDIsXG4gIEJST1RMSV9QQVJBTV9MR0JMT0NLOiAzLFxuICBCUk9UTElfUEFSQU1fRElTQUJMRV9MSVRFUkFMX0NPTlRFWFRfTU9ERUxJTkc6IDQsXG4gIEJST1RMSV9QQVJBTV9TSVpFX0hJTlQ6IDUsXG4gIEJST1RMSV9QQVJBTV9MQVJHRV9XSU5ET1c6IDYsXG4gIEJST1RMSV9QQVJBTV9OUE9TVEZJWDogNyxcbiAgQlJPVExJX1BBUkFNX05ESVJFQ1Q6IDgsXG4gIEJST1RMSV9ERUNPREVSX1JFU1VMVF9FUlJPUjogMCxcbiAgQlJPVExJX0RFQ09ERVJfUkVTVUxUX1NVQ0NFU1M6IDEsXG4gIEJST1RMSV9ERUNPREVSX1JFU1VMVF9ORUVEU19NT1JFX0lOUFVUOiAyLFxuICBCUk9UTElfREVDT0RFUl9SRVNVTFRfTkVFRFNfTU9SRV9PVVRQVVQ6IDMsXG4gIEJST1RMSV9ERUNPREVSX1BBUkFNX0RJU0FCTEVfUklOR19CVUZGRVJfUkVBTExPQ0FUSU9OOiAwLFxuICBCUk9UTElfREVDT0RFUl9QQVJBTV9MQVJHRV9XSU5ET1c6IDEsXG4gIEJST1RMSV9ERUNPREVSX05PX0VSUk9SOiAwLFxuICBCUk9UTElfREVDT0RFUl9TVUNDRVNTOiAxLFxuICBCUk9UTElfREVDT0RFUl9ORUVEU19NT1JFX0lOUFVUOiAyLFxuICBCUk9UTElfREVDT0RFUl9ORUVEU19NT1JFX09VVFBVVDogMyxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX0VYVUJFUkFOVF9OSUJCTEU6IC0xLFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfUkVTRVJWRUQ6IC0yLFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfRVhVQkVSQU5UX01FVEFfTklCQkxFOiAtMyxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX1NJTVBMRV9IVUZGTUFOX0FMUEhBQkVUOiAtNCxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX1NJTVBMRV9IVUZGTUFOX1NBTUU6IC01LFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfQ0xfU1BBQ0U6IC02LFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfSFVGRk1BTl9TUEFDRTogLTcsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9DT05URVhUX01BUF9SRVBFQVQ6IC04LFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfQkxPQ0tfTEVOR1RIXzE6IC05LFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfQkxPQ0tfTEVOR1RIXzI6IC0xMCxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX1RSQU5TRk9STTogLTExLFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfRElDVElPTkFSWTogLTEyLFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfV0lORE9XX0JJVFM6IC0xMyxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX1BBRERJTkdfMTogLTE0LFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfUEFERElOR18yOiAtMTUsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9ESVNUQU5DRTogLTE2LFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9ESUNUSU9OQVJZX05PVF9TRVQ6IC0xOSxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfSU5WQUxJRF9BUkdVTUVOVFM6IC0yMCxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfQUxMT0NfQ09OVEVYVF9NT0RFUzogLTIxLFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9BTExPQ19UUkVFX0dST1VQUzogLTIyLFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9BTExPQ19DT05URVhUX01BUDogLTI1LFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9BTExPQ19SSU5HX0JVRkZFUl8xOiAtMjYsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0FMTE9DX1JJTkdfQlVGRkVSXzI6IC0yNyxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfQUxMT0NfQkxPQ0tfVFlQRV9UUkVFUzogLTMwLFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9VTlJFQUNIQUJMRTogLTMxLFxufSwgcmVhbFpsaWJDb25zdGFudHMpKVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXJcbmNvbnN0IHJlYWxabGliID0gcmVxdWlyZSgnemxpYicpXG5cbmNvbnN0IGNvbnN0YW50cyA9IGV4cG9ydHMuY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMuanMnKVxuY29uc3QgTWluaXBhc3MgPSByZXF1aXJlKCdtaW5pcGFzcycpXG5cbmNvbnN0IE9yaWdpbmFsQnVmZmVyQ29uY2F0ID0gQnVmZmVyLmNvbmNhdFxuXG5jbGFzcyBabGliRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChlcnIpIHtcbiAgICBzdXBlcignemxpYjogJyArIGVyci5tZXNzYWdlKVxuICAgIHRoaXMuY29kZSA9IGVyci5jb2RlXG4gICAgdGhpcy5lcnJubyA9IGVyci5lcnJub1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghdGhpcy5jb2RlKVxuICAgICAgdGhpcy5jb2RlID0gJ1pMSUJfRVJST1InXG5cbiAgICB0aGlzLm1lc3NhZ2UgPSAnemxpYjogJyArIGVyci5tZXNzYWdlXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3RvcilcbiAgfVxuXG4gIGdldCBuYW1lICgpIHtcbiAgICByZXR1cm4gJ1psaWJFcnJvcidcbiAgfVxufVxuXG4vLyB0aGUgWmxpYiBjbGFzcyB0aGV5IGFsbCBpbmhlcml0IGZyb21cbi8vIFRoaXMgdGhpbmcgbWFuYWdlcyB0aGUgcXVldWUgb2YgcmVxdWVzdHMsIGFuZCByZXR1cm5zXG4vLyB0cnVlIG9yIGZhbHNlIGlmIHRoZXJlIGlzIGFueXRoaW5nIGluIHRoZSBxdWV1ZSB3aGVuXG4vLyB5b3UgY2FsbCB0aGUgLndyaXRlKCkgbWV0aG9kLlxuY29uc3QgX29wdHMgPSBTeW1ib2woJ29wdHMnKVxuY29uc3QgX2ZsdXNoRmxhZyA9IFN5bWJvbCgnZmx1c2hGbGFnJylcbmNvbnN0IF9maW5pc2hGbHVzaEZsYWcgPSBTeW1ib2woJ2ZpbmlzaEZsdXNoRmxhZycpXG5jb25zdCBfZnVsbEZsdXNoRmxhZyA9IFN5bWJvbCgnZnVsbEZsdXNoRmxhZycpXG5jb25zdCBfaGFuZGxlID0gU3ltYm9sKCdoYW5kbGUnKVxuY29uc3QgX29uRXJyb3IgPSBTeW1ib2woJ29uRXJyb3InKVxuY29uc3QgX3Nhd0Vycm9yID0gU3ltYm9sKCdzYXdFcnJvcicpXG5jb25zdCBfbGV2ZWwgPSBTeW1ib2woJ2xldmVsJylcbmNvbnN0IF9zdHJhdGVneSA9IFN5bWJvbCgnc3RyYXRlZ3knKVxuY29uc3QgX2VuZGVkID0gU3ltYm9sKCdlbmRlZCcpXG5jb25zdCBfZGVmYXVsdEZ1bGxGbHVzaCA9IFN5bWJvbCgnX2RlZmF1bHRGdWxsRmx1c2gnKVxuXG5jbGFzcyBabGliQmFzZSBleHRlbmRzIE1pbmlwYXNzIHtcbiAgY29uc3RydWN0b3IgKG9wdHMsIG1vZGUpIHtcbiAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBvcHRpb25zIGZvciBabGliQmFzZSBjb25zdHJ1Y3RvcicpXG5cbiAgICBzdXBlcihvcHRzKVxuICAgIHRoaXNbX2VuZGVkXSA9IGZhbHNlXG4gICAgdGhpc1tfb3B0c10gPSBvcHRzXG5cbiAgICB0aGlzW19mbHVzaEZsYWddID0gb3B0cy5mbHVzaFxuICAgIHRoaXNbX2ZpbmlzaEZsdXNoRmxhZ10gPSBvcHRzLmZpbmlzaEZsdXNoXG4gICAgLy8gdGhpcyB3aWxsIHRocm93IGlmIGFueSBvcHRpb25zIGFyZSBpbnZhbGlkIGZvciB0aGUgY2xhc3Mgc2VsZWN0ZWRcbiAgICB0cnkge1xuICAgICAgdGhpc1tfaGFuZGxlXSA9IG5ldyByZWFsWmxpYlttb2RlXShvcHRzKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgdGhhdCBhbGwgZXJyb3JzIGdldCBkZWNvcmF0ZWQgcHJvcGVybHlcbiAgICAgIHRocm93IG5ldyBabGliRXJyb3IoZXIpXG4gICAgfVxuXG4gICAgdGhpc1tfb25FcnJvcl0gPSAoZXJyKSA9PiB7XG4gICAgICB0aGlzW19zYXdFcnJvcl0gPSB0cnVlXG4gICAgICAvLyB0aGVyZSBpcyBubyB3YXkgdG8gY2xlYW5seSByZWNvdmVyLlxuICAgICAgLy8gY29udGludWluZyBvbmx5IG9ic2N1cmVzIHByb2JsZW1zLlxuICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgIH1cblxuICAgIHRoaXNbX2hhbmRsZV0ub24oJ2Vycm9yJywgZXIgPT4gdGhpc1tfb25FcnJvcl0obmV3IFpsaWJFcnJvcihlcikpKVxuICAgIHRoaXMub25jZSgnZW5kJywgKCkgPT4gdGhpcy5jbG9zZSlcbiAgfVxuXG4gIGNsb3NlICgpIHtcbiAgICBpZiAodGhpc1tfaGFuZGxlXSkge1xuICAgICAgdGhpc1tfaGFuZGxlXS5jbG9zZSgpXG4gICAgICB0aGlzW19oYW5kbGVdID0gbnVsbFxuICAgICAgdGhpcy5lbWl0KCdjbG9zZScpXG4gICAgfVxuICB9XG5cbiAgcmVzZXQgKCkge1xuICAgIGlmICghdGhpc1tfc2F3RXJyb3JdKSB7XG4gICAgICBhc3NlcnQodGhpc1tfaGFuZGxlXSwgJ3psaWIgYmluZGluZyBjbG9zZWQnKVxuICAgICAgcmV0dXJuIHRoaXNbX2hhbmRsZV0ucmVzZXQoKVxuICAgIH1cbiAgfVxuXG4gIGZsdXNoIChmbHVzaEZsYWcpIHtcbiAgICBpZiAodGhpcy5lbmRlZClcbiAgICAgIHJldHVyblxuXG4gICAgaWYgKHR5cGVvZiBmbHVzaEZsYWcgIT09ICdudW1iZXInKVxuICAgICAgZmx1c2hGbGFnID0gdGhpc1tfZnVsbEZsdXNoRmxhZ11cbiAgICB0aGlzLndyaXRlKE9iamVjdC5hc3NpZ24oQnVmZmVyLmFsbG9jKDApLCB7IFtfZmx1c2hGbGFnXTogZmx1c2hGbGFnIH0pKVxuICB9XG5cbiAgZW5kIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgaWYgKGNodW5rKVxuICAgICAgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpXG4gICAgdGhpcy5mbHVzaCh0aGlzW19maW5pc2hGbHVzaEZsYWddKVxuICAgIHRoaXNbX2VuZGVkXSA9IHRydWVcbiAgICByZXR1cm4gc3VwZXIuZW5kKG51bGwsIG51bGwsIGNiKVxuICB9XG5cbiAgZ2V0IGVuZGVkICgpIHtcbiAgICByZXR1cm4gdGhpc1tfZW5kZWRdXG4gIH1cblxuICB3cml0ZSAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIC8vIHByb2Nlc3MgdGhlIGNodW5rIHVzaW5nIHRoZSBzeW5jIHByb2Nlc3NcbiAgICAvLyB0aGVuIHN1cGVyLndyaXRlKCkgYWxsIHRoZSBvdXRwdXR0ZWQgY2h1bmtzXG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiID0gZW5jb2RpbmcsIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJylcbiAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKVxuXG4gICAgaWYgKHRoaXNbX3Nhd0Vycm9yXSlcbiAgICAgIHJldHVyblxuICAgIGFzc2VydCh0aGlzW19oYW5kbGVdLCAnemxpYiBiaW5kaW5nIGNsb3NlZCcpXG5cbiAgICAvLyBfcHJvY2Vzc0NodW5rIHRyaWVzIHRvIC5jbG9zZSgpIHRoZSBuYXRpdmUgaGFuZGxlIGFmdGVyIGl0J3MgZG9uZSwgc28gd2VcbiAgICAvLyBpbnRlcmNlcHQgdGhhdCBieSB0ZW1wb3JhcmlseSBtYWtpbmcgaXQgYSBuby1vcC5cbiAgICBjb25zdCBuYXRpdmVIYW5kbGUgPSB0aGlzW19oYW5kbGVdLl9oYW5kbGVcbiAgICBjb25zdCBvcmlnaW5hbE5hdGl2ZUNsb3NlID0gbmF0aXZlSGFuZGxlLmNsb3NlXG4gICAgbmF0aXZlSGFuZGxlLmNsb3NlID0gKCkgPT4ge31cbiAgICBjb25zdCBvcmlnaW5hbENsb3NlID0gdGhpc1tfaGFuZGxlXS5jbG9zZVxuICAgIHRoaXNbX2hhbmRsZV0uY2xvc2UgPSAoKSA9PiB7fVxuICAgIC8vIEl0IGFsc28gY2FsbHMgYEJ1ZmZlci5jb25jYXQoKWAgYXQgdGhlIGVuZCwgd2hpY2ggbWF5IGJlIGNvbnZlbmllbnRcbiAgICAvLyBmb3Igc29tZSwgYnV0IHdoaWNoIHdlIGFyZSBub3QgaW50ZXJlc3RlZCBpbiBhcyBpdCBzbG93cyB1cyBkb3duLlxuICAgIEJ1ZmZlci5jb25jYXQgPSAoYXJncykgPT4gYXJnc1xuICAgIGxldCByZXN1bHRcbiAgICB0cnkge1xuICAgICAgY29uc3QgZmx1c2hGbGFnID0gdHlwZW9mIGNodW5rW19mbHVzaEZsYWddID09PSAnbnVtYmVyJ1xuICAgICAgICA/IGNodW5rW19mbHVzaEZsYWddIDogdGhpc1tfZmx1c2hGbGFnXVxuICAgICAgcmVzdWx0ID0gdGhpc1tfaGFuZGxlXS5fcHJvY2Vzc0NodW5rKGNodW5rLCBmbHVzaEZsYWcpXG4gICAgICAvLyBpZiB3ZSBkb24ndCB0aHJvdywgcmVzZXQgaXQgYmFjayBob3cgaXQgd2FzXG4gICAgICBCdWZmZXIuY29uY2F0ID0gT3JpZ2luYWxCdWZmZXJDb25jYXRcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIG9yIGlmIHdlIGRvLCBwdXQgQnVmZmVyLmNvbmNhdCgpIGJhY2sgYmVmb3JlIHdlIGVtaXQgZXJyb3JcbiAgICAgIC8vIEVycm9yIGV2ZW50cyBjYWxsIGludG8gdXNlciBjb2RlLCB3aGljaCBtYXkgY2FsbCBCdWZmZXIuY29uY2F0KClcbiAgICAgIEJ1ZmZlci5jb25jYXQgPSBPcmlnaW5hbEJ1ZmZlckNvbmNhdFxuICAgICAgdGhpc1tfb25FcnJvcl0obmV3IFpsaWJFcnJvcihlcnIpKVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodGhpc1tfaGFuZGxlXSkge1xuICAgICAgICAvLyBDb3JlIHpsaWIgcmVzZXRzIGBfaGFuZGxlYCB0byBudWxsIGFmdGVyIGF0dGVtcHRpbmcgdG8gY2xvc2UgdGhlXG4gICAgICAgIC8vIG5hdGl2ZSBoYW5kbGUuIE91ciBuby1vcCBoYW5kbGVyIHByZXZlbnRlZCBhY3R1YWwgY2xvc3VyZSwgYnV0IHdlXG4gICAgICAgIC8vIG5lZWQgdG8gcmVzdG9yZSB0aGUgYC5faGFuZGxlYCBwcm9wZXJ0eS5cbiAgICAgICAgdGhpc1tfaGFuZGxlXS5faGFuZGxlID0gbmF0aXZlSGFuZGxlXG4gICAgICAgIG5hdGl2ZUhhbmRsZS5jbG9zZSA9IG9yaWdpbmFsTmF0aXZlQ2xvc2VcbiAgICAgICAgdGhpc1tfaGFuZGxlXS5jbG9zZSA9IG9yaWdpbmFsQ2xvc2VcbiAgICAgICAgLy8gYF9wcm9jZXNzQ2h1bmsoKWAgYWRkcyBhbiAnZXJyb3InIGxpc3RlbmVyLiBJZiB3ZSBkb24ndCByZW1vdmUgaXRcbiAgICAgICAgLy8gYWZ0ZXIgZWFjaCBjYWxsLCB0aGVzZSBoYW5kbGVycyBzdGFydCBwaWxpbmcgdXAuXG4gICAgICAgIHRoaXNbX2hhbmRsZV0ucmVtb3ZlQWxsTGlzdGVuZXJzKCdlcnJvcicpXG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHdyaXRlUmV0dXJuXG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSAmJiByZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBUaGUgZmlyc3QgYnVmZmVyIGlzIGFsd2F5cyBgaGFuZGxlLl9vdXRCdWZmZXJgLCB3aGljaCB3b3VsZCBiZVxuICAgICAgICAvLyByZS11c2VkIGZvciBsYXRlciBpbnZvY2F0aW9uczsgc28sIHdlIGFsd2F5cyBoYXZlIHRvIGNvcHkgdGhhdCBvbmUuXG4gICAgICAgIHdyaXRlUmV0dXJuID0gc3VwZXIud3JpdGUoQnVmZmVyLmZyb20ocmVzdWx0WzBdKSlcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB3cml0ZVJldHVybiA9IHN1cGVyLndyaXRlKHJlc3VsdFtpXSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVSZXR1cm4gPSBzdXBlci53cml0ZShCdWZmZXIuZnJvbShyZXN1bHQpKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjYilcbiAgICAgIGNiKClcbiAgICByZXR1cm4gd3JpdGVSZXR1cm5cbiAgfVxufVxuXG5jbGFzcyBabGliIGV4dGVuZHMgWmxpYkJhc2Uge1xuICBjb25zdHJ1Y3RvciAob3B0cywgbW9kZSkge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICBvcHRzLmZsdXNoID0gb3B0cy5mbHVzaCB8fCBjb25zdGFudHMuWl9OT19GTFVTSFxuICAgIG9wdHMuZmluaXNoRmx1c2ggPSBvcHRzLmZpbmlzaEZsdXNoIHx8IGNvbnN0YW50cy5aX0ZJTklTSFxuICAgIHN1cGVyKG9wdHMsIG1vZGUpXG5cbiAgICB0aGlzW19mdWxsRmx1c2hGbGFnXSA9IGNvbnN0YW50cy5aX0ZVTExfRkxVU0hcbiAgICB0aGlzW19sZXZlbF0gPSBvcHRzLmxldmVsXG4gICAgdGhpc1tfc3RyYXRlZ3ldID0gb3B0cy5zdHJhdGVneVxuICB9XG5cbiAgcGFyYW1zIChsZXZlbCwgc3RyYXRlZ3kpIHtcbiAgICBpZiAodGhpc1tfc2F3RXJyb3JdKVxuICAgICAgcmV0dXJuXG5cbiAgICBpZiAoIXRoaXNbX2hhbmRsZV0pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBzd2l0Y2ggcGFyYW1zIHdoZW4gYmluZGluZyBpcyBjbG9zZWQnKVxuXG4gICAgLy8gbm8gd2F5IHRvIHRlc3QgdGhpcyB3aXRob3V0IGFsc28gbm90IHN1cHBvcnRpbmcgcGFyYW1zIGF0IGFsbFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghdGhpc1tfaGFuZGxlXS5wYXJhbXMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBzdXBwb3J0ZWQgaW4gdGhpcyBpbXBsZW1lbnRhdGlvbicpXG5cbiAgICBpZiAodGhpc1tfbGV2ZWxdICE9PSBsZXZlbCB8fCB0aGlzW19zdHJhdGVneV0gIT09IHN0cmF0ZWd5KSB7XG4gICAgICB0aGlzLmZsdXNoKGNvbnN0YW50cy5aX1NZTkNfRkxVU0gpXG4gICAgICBhc3NlcnQodGhpc1tfaGFuZGxlXSwgJ3psaWIgYmluZGluZyBjbG9zZWQnKVxuICAgICAgLy8gLnBhcmFtcygpIGNhbGxzIC5mbHVzaCgpLCBidXQgdGhlIGxhdHRlciBpcyBhbHdheXMgYXN5bmMgaW4gdGhlXG4gICAgICAvLyBjb3JlIHpsaWIuIFdlIG92ZXJyaWRlIC5mbHVzaCgpIHRlbXBvcmFyaWx5IHRvIGludGVyY2VwdCB0aGF0IGFuZFxuICAgICAgLy8gZmx1c2ggc3luY2hyb25vdXNseS5cbiAgICAgIGNvbnN0IG9yaWdGbHVzaCA9IHRoaXNbX2hhbmRsZV0uZmx1c2hcbiAgICAgIHRoaXNbX2hhbmRsZV0uZmx1c2ggPSAoZmx1c2hGbGFnLCBjYikgPT4ge1xuICAgICAgICB0aGlzLmZsdXNoKGZsdXNoRmxhZylcbiAgICAgICAgY2IoKVxuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpc1tfaGFuZGxlXS5wYXJhbXMobGV2ZWwsIHN0cmF0ZWd5KVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpc1tfaGFuZGxlXS5mbHVzaCA9IG9yaWdGbHVzaFxuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmICh0aGlzW19oYW5kbGVdKSB7XG4gICAgICAgIHRoaXNbX2xldmVsXSA9IGxldmVsXG4gICAgICAgIHRoaXNbX3N0cmF0ZWd5XSA9IHN0cmF0ZWd5XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIG1pbmltYWwgMi1ieXRlIGhlYWRlclxuY2xhc3MgRGVmbGF0ZSBleHRlbmRzIFpsaWIge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMsICdEZWZsYXRlJylcbiAgfVxufVxuXG5jbGFzcyBJbmZsYXRlIGV4dGVuZHMgWmxpYiB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIob3B0cywgJ0luZmxhdGUnKVxuICB9XG59XG5cbi8vIGd6aXAgLSBiaWdnZXIgaGVhZGVyLCBzYW1lIGRlZmxhdGUgY29tcHJlc3Npb25cbmNsYXNzIEd6aXAgZXh0ZW5kcyBabGliIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzLCAnR3ppcCcpXG4gIH1cbn1cblxuY2xhc3MgR3VuemlwIGV4dGVuZHMgWmxpYiB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIob3B0cywgJ0d1bnppcCcpXG4gIH1cbn1cblxuLy8gcmF3IC0gbm8gaGVhZGVyXG5jbGFzcyBEZWZsYXRlUmF3IGV4dGVuZHMgWmxpYiB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIob3B0cywgJ0RlZmxhdGVSYXcnKVxuICB9XG59XG5cbmNsYXNzIEluZmxhdGVSYXcgZXh0ZW5kcyBabGliIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzLCAnSW5mbGF0ZVJhdycpXG4gIH1cbn1cblxuLy8gYXV0by1kZXRlY3QgaGVhZGVyLlxuY2xhc3MgVW56aXAgZXh0ZW5kcyBabGliIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzLCAnVW56aXAnKVxuICB9XG59XG5cbmNsYXNzIEJyb3RsaSBleHRlbmRzIFpsaWJCYXNlIHtcbiAgY29uc3RydWN0b3IgKG9wdHMsIG1vZGUpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgb3B0cy5mbHVzaCA9IG9wdHMuZmx1c2ggfHwgY29uc3RhbnRzLkJST1RMSV9PUEVSQVRJT05fUFJPQ0VTU1xuICAgIG9wdHMuZmluaXNoRmx1c2ggPSBvcHRzLmZpbmlzaEZsdXNoIHx8IGNvbnN0YW50cy5CUk9UTElfT1BFUkFUSU9OX0ZJTklTSFxuXG4gICAgc3VwZXIob3B0cywgbW9kZSlcblxuICAgIHRoaXNbX2Z1bGxGbHVzaEZsYWddID0gY29uc3RhbnRzLkJST1RMSV9PUEVSQVRJT05fRkxVU0hcbiAgfVxufVxuXG5jbGFzcyBCcm90bGlDb21wcmVzcyBleHRlbmRzIEJyb3RsaSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIob3B0cywgJ0Jyb3RsaUNvbXByZXNzJylcbiAgfVxufVxuXG5jbGFzcyBCcm90bGlEZWNvbXByZXNzIGV4dGVuZHMgQnJvdGxpIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzLCAnQnJvdGxpRGVjb21wcmVzcycpXG4gIH1cbn1cblxuZXhwb3J0cy5EZWZsYXRlID0gRGVmbGF0ZVxuZXhwb3J0cy5JbmZsYXRlID0gSW5mbGF0ZVxuZXhwb3J0cy5HemlwID0gR3ppcFxuZXhwb3J0cy5HdW56aXAgPSBHdW56aXBcbmV4cG9ydHMuRGVmbGF0ZVJhdyA9IERlZmxhdGVSYXdcbmV4cG9ydHMuSW5mbGF0ZVJhdyA9IEluZmxhdGVSYXdcbmV4cG9ydHMuVW56aXAgPSBVbnppcFxuLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbmlmICh0eXBlb2YgcmVhbFpsaWIuQnJvdGxpQ29tcHJlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgZXhwb3J0cy5Ccm90bGlDb21wcmVzcyA9IEJyb3RsaUNvbXByZXNzXG4gIGV4cG9ydHMuQnJvdGxpRGVjb21wcmVzcyA9IEJyb3RsaURlY29tcHJlc3Ncbn0gZWxzZSB7XG4gIGV4cG9ydHMuQnJvdGxpQ29tcHJlc3MgPSBleHBvcnRzLkJyb3RsaURlY29tcHJlc3MgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IgKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCcm90bGkgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIHZlcnNpb24gb2YgTm9kZS5qcycpXG4gICAgfVxuICB9XG59XG4iLCJ2YXIgY3JlYXRlSGFzaCA9IHJlcXVpcmUoJ2NyeXB0bycpLmNyZWF0ZUhhc2g7XG5cbmZ1bmN0aW9uIGdldF9oZWFkZXIoaGVhZGVyLCBjcmVkZW50aWFscywgb3B0cykge1xuICB2YXIgdHlwZSA9IGhlYWRlci5zcGxpdCgnICcpWzBdLFxuICAgICAgdXNlciA9IGNyZWRlbnRpYWxzWzBdLFxuICAgICAgcGFzcyA9IGNyZWRlbnRpYWxzWzFdO1xuXG4gIGlmICh0eXBlID09ICdEaWdlc3QnKSB7XG4gICAgcmV0dXJuIGRpZ2VzdC5nZW5lcmF0ZShoZWFkZXIsIHVzZXIsIHBhc3MsIG9wdHMubWV0aG9kLCBvcHRzLnBhdGgpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT0gJ0Jhc2ljJykge1xuICAgIHJldHVybiBiYXNpYyh1c2VyLCBwYXNzKTtcbiAgfVxufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gYmFzaWNcblxuZnVuY3Rpb24gbWQ1KHN0cmluZykge1xuICByZXR1cm4gY3JlYXRlSGFzaCgnbWQ1JykudXBkYXRlKHN0cmluZykuZGlnZXN0KCdoZXgnKTtcbn1cblxuZnVuY3Rpb24gYmFzaWModXNlciwgcGFzcykge1xuICB2YXIgc3RyICA9IHR5cGVvZiBwYXNzID09ICd1bmRlZmluZWQnID8gdXNlciA6IFt1c2VyLCBwYXNzXS5qb2luKCc6Jyk7XG4gIHJldHVybiAnQmFzaWMgJyArIEJ1ZmZlci5mcm9tKHN0cikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gZGlnZXN0XG4vLyBsb2dpYyBpbnNwaXJlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW1tZS9ub2RlLWh0dHAtZGlnZXN0LWNsaWVudFxuXG52YXIgZGlnZXN0ID0ge307XG5cbmRpZ2VzdC5wYXJzZV9oZWFkZXIgPSBmdW5jdGlvbihoZWFkZXIpIHtcbiAgdmFyIGNoYWxsZW5nZSA9IHt9LFxuICAgICAgbWF0Y2hlcyAgID0gaGVhZGVyLm1hdGNoKC8oW2EtejAtOV8tXSspPVwiPyhbYS16MC05PVxcL1xcLkBcXHMtXSspXCI/L2dpKTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IG1hdGNoZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIHBhcnRzID0gbWF0Y2hlc1tpXS5zcGxpdCgnPScpLFxuICAgICAgICBrZXkgICA9IHBhcnRzLnNoaWZ0KCksXG4gICAgICAgIHZhbCAgID0gcGFydHMuam9pbignPScpLnJlcGxhY2UoL15cIi8sICcnKS5yZXBsYWNlKC9cIiQvLCAnJyk7XG5cbiAgICBjaGFsbGVuZ2Vba2V5XSA9IHZhbDtcbiAgfVxuXG4gIHJldHVybiBjaGFsbGVuZ2U7XG59XG5cbmRpZ2VzdC51cGRhdGVfbmMgPSBmdW5jdGlvbihuYykge1xuICB2YXIgbWF4ID0gOTk5OTk5OTk7XG4gIG5jKys7XG5cbiAgaWYgKG5jID4gbWF4KVxuICAgIG5jID0gMTtcblxuICB2YXIgcGFkZGluZyA9IG5ldyBBcnJheSg4KS5qb2luKCcwJykgKyAnJztcbiAgbmMgPSBuYyArICcnO1xuICByZXR1cm4gcGFkZGluZy5zdWJzdHIoMCwgOCAtIG5jLmxlbmd0aCkgKyBuYztcbn1cblxuZGlnZXN0LmdlbmVyYXRlID0gZnVuY3Rpb24oaGVhZGVyLCB1c2VyLCBwYXNzLCBtZXRob2QsIHBhdGgpIHtcblxuICB2YXIgbmMgICAgICAgID0gMSxcbiAgICAgIGNub25jZSAgICA9IG51bGwsXG4gICAgICBjaGFsbGVuZ2UgPSBkaWdlc3QucGFyc2VfaGVhZGVyKGhlYWRlcik7XG5cbiAgdmFyIGhhMSAgPSBtZDUodXNlciArICc6JyArIGNoYWxsZW5nZS5yZWFsbSArICc6JyArIHBhc3MpLFxuICAgICAgaGEyICA9IG1kNShtZXRob2QudG9VcHBlckNhc2UoKSArICc6JyArIHBhdGgpLFxuICAgICAgcmVzcCA9IFtoYTEsIGNoYWxsZW5nZS5ub25jZV07XG5cbiAgaWYgKHR5cGVvZiBjaGFsbGVuZ2UucW9wID09PSAnc3RyaW5nJykge1xuICAgIGNub25jZSA9IG1kNShNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KSkuc3Vic3RyKDAsIDgpO1xuICAgIG5jICAgICA9IGRpZ2VzdC51cGRhdGVfbmMobmMpO1xuICAgIHJlc3AgICA9IHJlc3AuY29uY2F0KG5jLCBjbm9uY2UpO1xuICAgIHJlc3AgICA9IHJlc3AuY29uY2F0KGNoYWxsZW5nZS5xb3AsIGhhMik7XG4gIH0gZWxzZSB7XG4gICAgcmVzcCAgID0gcmVzcC5jb25jYXQoaGEyKTtcbiAgfVxuXG5cbiAgdmFyIHBhcmFtcyA9IHtcbiAgICB1cmkgICAgICA6IHBhdGgsXG4gICAgcmVhbG0gICAgOiBjaGFsbGVuZ2UucmVhbG0sXG4gICAgbm9uY2UgICAgOiBjaGFsbGVuZ2Uubm9uY2UsXG4gICAgdXNlcm5hbWUgOiB1c2VyLFxuICAgIHJlc3BvbnNlIDogbWQ1KHJlc3Auam9pbignOicpKVxuICB9XG5cbiAgaWYgKGNoYWxsZW5nZS5xb3ApIHtcbiAgICBwYXJhbXMucW9wID0gY2hhbGxlbmdlLnFvcDtcbiAgfVxuXG4gIGlmIChjaGFsbGVuZ2Uub3BhcXVlKSB7XG4gICAgcGFyYW1zLm9wYXF1ZSA9IGNoYWxsZW5nZS5vcGFxdWU7XG4gIH1cblxuICBpZiAoY25vbmNlKSB7XG4gICAgcGFyYW1zLm5jID0gbmM7XG4gICAgcGFyYW1zLmNub25jZSA9IGNub25jZTtcbiAgfVxuXG4gIGhlYWRlciA9IFtdXG4gIGZvciAodmFyIGsgaW4gcGFyYW1zKVxuICAgIGhlYWRlci5wdXNoKGsgKyAnPVwiJyArIHBhcmFtc1trXSArICdcIicpXG5cbiAgcmV0dXJuICdEaWdlc3QgJyArIGhlYWRlci5qb2luKCcsICcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaGVhZGVyIDogZ2V0X2hlYWRlcixcbiAgYmFzaWMgIDogYmFzaWMsXG4gIGRpZ2VzdCA6IGRpZ2VzdC5nZW5lcmF0ZVxufVxuIiwiXG4vLyAgU2ltcGxlIGNvb2tpZSBoYW5kbGluZyBpbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiB0aGUgc3RhbmRhcmQgUkZDIDYyNjUuXG4vL1xuLy8gIFRoaXMgbW9kdWxlIGp1c3QgaGFzIHR3byBmdW5jdGlvbmFsaXRpZXM6XG4vLyAgICAtIFBhcnNlIGEgc2V0LWNvb2tpZS1oZWFkZXIgYXMgYSBrZXkgdmFsdWUgb2JqZWN0XG4vLyAgICAtIFdyaXRlIGEgY29va2llLXN0cmluZyBmcm9tIGEga2V5IHZhbHVlIG9iamVjdFxuLy9cbi8vICBBbGwgY29va2llIGF0dHJpYnV0ZXMgYXJlIGlnbm9yZWQuXG5cbnZhciB1bmVzY2FwZSA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJykudW5lc2NhcGU7XG5cbnZhciBDT09LSUVfUEFJUiAgICAgICAgPSAvXihbXj1cXHNdKylcXHMqPVxccyooXCI/KVxccyooLiopXFxzKlxcMlxccyokLztcbnZhciBFWENMVURFRF9DSEFSUyAgICAgPSAvW1xceDAwLVxceDFGXFx4N0ZcXHgzQlxceDNCXFxzXFxcIlxcLFxcXFxcIiVdL2c7XG52YXIgVFJBSUxJTkdfU0VNSUNPTE9OID0gL1xceDNCKyQvO1xudmFyIFNFUF9TRU1JQ09MT04gICAgICA9IC9cXHMqXFx4M0JcXHMqLztcblxuLy8gaSBrbm93IHRoZXNlIHNob3VsZCBiZSAnY29uc3QnLCBidXQgSSdkIGxpa2UgdG8ga2VlcFxuLy8gc3VwcG9ydGluZyBlYXJsaWVyIG5vZGUuanMgdmVyc2lvbnMgYXMgbG9uZyBhcyBJIGNhbi4gOilcblxudmFyIEtFWV9JTkRFWCAgID0gMTsgLy8gaW5kZXggb2Yga2V5IGZyb20gQ09PS0lFX1BBSVIgbWF0Y2hcbnZhciBWQUxVRV9JTkRFWCA9IDM7IC8vIGluZGV4IG9mIHZhbHVlIGZyb20gQ09PS0lFX1BBSVIgbWF0Y2hcblxuLy8gUmV0dXJucyBhIGNvcHkgc3RyIHRyaW1tZWQgYW5kIHdpdGhvdXQgdHJhaW5saW5nIHNlbWljb2xvbi5cbmZ1bmN0aW9uIGNsZWFuQ29va2llU3RyaW5nKHN0cikge1xuICByZXR1cm4gc3RyLnRyaW0oKS5yZXBsYWNlKC9cXHgzQiskLywgJycpO1xufVxuXG5mdW5jdGlvbiBnZXRGaXJzdFBhaXIoc3RyKSB7XG4gIHZhciBpbmRleCA9IHN0ci5pbmRleE9mKCdcXHgzQicpO1xuICByZXR1cm4gaW5kZXggPT09IC0xID8gc3RyIDogc3RyLnN1YnN0cigwLCBpbmRleCk7XG59XG5cbi8vIFJldHVybnMgYSBlbmNvZGVkIGNvcHkgb2Ygc3RyIGJhc2VkIG9uIFJGQzYyNjUgUzQuMS4xLlxuZnVuY3Rpb24gZW5jb2RlQ29va2llQ29tcG9uZW50KHN0cikge1xuICByZXR1cm4gc3RyLnRvU3RyaW5nKCkucmVwbGFjZShFWENMVURFRF9DSEFSUywgZW5jb2RlVVJJQ29tcG9uZW50KTtcbn1cblxuLy8gUGFyc2VzIGEgc2V0LWNvb2tpZS1zdHJpbmcgYmFzZWQgb24gdGhlIHN0YW5kYXJkIGRlZmluZWQgaW4gUkZDNjI2NSBTNC4xLjEuXG5mdW5jdGlvbiBwYXJzZVNldENvb2tpZVN0cmluZyhzdHIpIHtcbiAgc3RyID0gY2xlYW5Db29raWVTdHJpbmcoc3RyKTtcbiAgc3RyID0gZ2V0Rmlyc3RQYWlyKHN0cik7XG5cbiAgdmFyIHJlcyA9IENPT0tJRV9QQUlSLmV4ZWMoc3RyKTtcbiAgaWYgKCFyZXMgfHwgIXJlc1tWQUxVRV9JTkRFWF0pIHJldHVybiBudWxsO1xuXG4gIHJldHVybiB7XG4gICAgbmFtZSAgOiB1bmVzY2FwZShyZXNbS0VZX0lOREVYXSksXG4gICAgdmFsdWUgOiB1bmVzY2FwZShyZXNbVkFMVUVfSU5ERVhdKVxuICB9O1xufVxuXG4vLyBQYXJzZXMgYSBzZXQtY29va2llLWhlYWRlciBhbmQgcmV0dXJucyBhIGtleS92YWx1ZSBvYmplY3QuXG4vLyBFYWNoIGtleSByZXByZXNlbnRzIHRoZSBuYW1lIG9mIGEgY29va2llLlxuZnVuY3Rpb24gcGFyc2VTZXRDb29raWVIZWFkZXIoaGVhZGVyKSB7XG4gIGlmICghaGVhZGVyKSByZXR1cm4ge307XG4gIGhlYWRlciA9IEFycmF5LmlzQXJyYXkoaGVhZGVyKSA/IGhlYWRlciA6IFtoZWFkZXJdO1xuXG4gIHJldHVybiBoZWFkZXIucmVkdWNlKGZ1bmN0aW9uKHJlcywgc3RyKSB7XG4gICAgdmFyIGNvb2tpZSA9IHBhcnNlU2V0Q29va2llU3RyaW5nKHN0cik7XG4gICAgaWYgKGNvb2tpZSkgcmVzW2Nvb2tpZS5uYW1lXSA9IGNvb2tpZS52YWx1ZTtcbiAgICByZXR1cm4gcmVzO1xuICB9LCB7fSk7XG59XG5cbi8vIFdyaXRlcyBhIHNldC1jb29raWUtc3RyaW5nIGJhc2VkIG9uIHRoZSBzdGFuZGFyZCBkZWZpbmRlZCBpbiBSRkM2MjY1IFM0LjEuMS5cbmZ1bmN0aW9uIHdyaXRlQ29va2llU3RyaW5nKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5yZWR1Y2UoZnVuY3Rpb24oc3RyLCBuYW1lKSB7XG4gICAgdmFyIGVuY29kZWROYW1lICA9IGVuY29kZUNvb2tpZUNvbXBvbmVudChuYW1lKTtcbiAgICB2YXIgZW5jb2RlZFZhbHVlID0gZW5jb2RlQ29va2llQ29tcG9uZW50KG9ialtuYW1lXSk7XG4gICAgc3RyICs9IChzdHIgPyAnOyAnIDogJycpICsgZW5jb2RlZE5hbWUgKyAnPScgKyBlbmNvZGVkVmFsdWU7XG4gICAgcmV0dXJuIHN0cjtcbiAgfSwgJycpO1xufVxuXG4vLyByZXR1cm5zIGEga2V5L3ZhbCBvYmplY3QgZnJvbSBhbiBhcnJheSBvZiBjb29raWUgc3RyaW5nc1xuZXhwb3J0cy5yZWFkID0gcGFyc2VTZXRDb29raWVIZWFkZXI7XG5cbi8vIHdyaXRlcyBhIGNvb2tpZSBzdHJpbmcgaGVhZGVyXG5leHBvcnRzLndyaXRlID0gd3JpdGVDb29raWVTdHJpbmc7XG4iLCJ2YXIgaWNvbnYsXG4gICAgaW5oZXJpdHMgID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzLFxuICAgIHN0cmVhbSAgICA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG52YXIgcmVnZXggPSAvKD86Y2hhcnNldHxlbmNvZGluZylcXHMqPVxccypbJ1wiXT8gKihbXFx3XFwtXSspL2k7XG5cbmluaGVyaXRzKFN0cmVhbURlY29kZXIsIHN0cmVhbS5UcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBTdHJlYW1EZWNvZGVyKGNoYXJzZXQpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN0cmVhbURlY29kZXIpKVxuICAgIHJldHVybiBuZXcgU3RyZWFtRGVjb2RlcihjaGFyc2V0KTtcblxuICBzdHJlYW0uVHJhbnNmb3JtLmNhbGwodGhpcywgY2hhcnNldCk7XG4gIHRoaXMuY2hhcnNldCA9IGNoYXJzZXQ7XG4gIHRoaXMucGFyc2VkX2NodW5rID0gZmFsc2U7XG59XG5cblN0cmVhbURlY29kZXIucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGRvbmUpIHtcbiAgdmFyIHJlcywgZm91bmQ7XG5cbiAgLy8gdHJ5IGdldCBjaGFyc2V0IGZyb20gY2h1bmssIGp1c3Qgb25jZVxuICBpZiAodGhpcy5jaGFyc2V0ID09ICd1dGY4JyAmJiAhdGhpcy5wYXJzZWRfY2h1bmspIHtcbiAgICB0aGlzLnBhcnNlZF9jaHVuayA9IHRydWU7XG5cbiAgICB2YXIgbWF0Y2hlcyA9IHJlZ2V4LmV4ZWMoY2h1bmsudG9TdHJpbmcoKSk7XG4gICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgIGZvdW5kID0gbWF0Y2hlc1sxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdGhpcy5jaGFyc2V0ID0gZm91bmQgPT0gJ3V0Zi04JyA/ICd1dGY4JyA6IGZvdW5kO1xuICAgIH1cbiAgfVxuXG4gIHRyeSB7XG4gICAgcmVzID0gaWNvbnYuZGVjb2RlKGNodW5rLCB0aGlzLmNoYXJzZXQpO1xuICB9IGNhdGNoKGUpIHsgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmcsIGp1c3QgcmV0dXJuIG9yaWdpbmFsIGNodW5rXG4gICAgcmVzID0gY2h1bms7XG4gIH1cblxuICB0aGlzLnB1c2gocmVzKTtcbiAgZG9uZSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNoYXJzZXQpIHtcbiAgdHJ5IHtcbiAgICBpZiAoIWljb252KSBpY29udiA9IHJlcXVpcmUoJ2ljb252LWxpdGUnKTtcbiAgfSBjYXRjaChlKSB7XG4gICAgLyogaWNvbnYgbm90IGZvdW5kICovXG4gIH1cblxuICBpZiAoaWNvbnYpXG4gICAgcmV0dXJuIG5ldyBTdHJlYW1EZWNvZGVyKGNoYXJzZXQpO1xuICBlbHNlXG4gICAgcmV0dXJuIG5ldyBzdHJlYW0uUGFzc1Rocm91Z2g7XG59XG4iLCJ2YXIgcmVhZEZpbGUgPSByZXF1aXJlKCdmcycpLnJlYWRGaWxlLFxuICAgIGJhc2VuYW1lID0gcmVxdWlyZSgncGF0aCcpLmJhc2VuYW1lO1xuXG5leHBvcnRzLmJ1aWxkID0gZnVuY3Rpb24oZGF0YSwgYm91bmRhcnksIGNhbGxiYWNrKSB7XG5cbiAgaWYgKHR5cGVvZiBkYXRhICE9ICdvYmplY3QnIHx8IHR5cGVvZiBkYXRhLnBpcGUgPT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdNdWx0aXBhcnQgYnVpbGRlciBleHBlY3RzIGRhdGEgYXMga2V5L3ZhbCBvYmplY3QuJykpO1xuXG4gIHZhciBib2R5ICAgPSAnJyxcbiAgICAgIG9iamVjdCA9IGZsYXR0ZW4oZGF0YSksXG4gICAgICBjb3VudCAgPSBPYmplY3Qua2V5cyhvYmplY3QpLmxlbmd0aDtcblxuICBpZiAoY291bnQgPT09IDApXG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignRW1wdHkgbXVsdGlwYXJ0IGJvZHkuIEludmFsaWQgZGF0YS4nKSlcblxuICBmdW5jdGlvbiBkb25lKGVyciwgc2VjdGlvbikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgIGlmIChzZWN0aW9uKSBib2R5ICs9IHNlY3Rpb247XG4gICAgLS1jb3VudCB8fCBjYWxsYmFjayhudWxsLCBib2R5ICsgJy0tJyArIGJvdW5kYXJ5ICsgJy0tJyk7XG4gIH07XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRvbmUoKTtcbiAgICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHZhciBwYXJ0ID0geyBidWZmZXI6IHZhbHVlLCBjb250ZW50X3R5cGU6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nIH07XG4gICAgICBnZW5lcmF0ZV9wYXJ0KGtleSwgcGFydCwgYm91bmRhcnksIGRvbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFydCA9ICh2YWx1ZS5idWZmZXIgfHwgdmFsdWUuZmlsZSB8fCB2YWx1ZS5jb250ZW50X3R5cGUpID8gdmFsdWUgOiB7IHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgZ2VuZXJhdGVfcGFydChrZXksIHBhcnQsIGJvdW5kYXJ5LCBkb25lKTtcbiAgICB9XG4gIH1cblxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZV9wYXJ0KG5hbWUsIHBhcnQsIGJvdW5kYXJ5LCBjYWxsYmFjaykge1xuXG4gIHZhciByZXR1cm5fcGFydCA9ICctLScgKyBib3VuZGFyeSArICdcXHJcXG4nO1xuICByZXR1cm5fcGFydCArPSAnQ29udGVudC1EaXNwb3NpdGlvbjogZm9ybS1kYXRhOyBuYW1lPVwiJyArIG5hbWUgKyAnXCInO1xuXG4gIGZ1bmN0aW9uIGFwcGVuZChkYXRhLCBmaWxlbmFtZSkge1xuXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHZhciBiaW5hcnkgPSBwYXJ0LmNvbnRlbnRfdHlwZS5pbmRleE9mKCd0ZXh0JykgPT0gLTE7XG4gICAgICByZXR1cm5fcGFydCArPSAnOyBmaWxlbmFtZT1cIicgKyBlbmNvZGVVUklDb21wb25lbnQoZmlsZW5hbWUpICsgJ1wiXFxyXFxuJztcbiAgICAgIGlmIChiaW5hcnkpIHJldHVybl9wYXJ0ICs9ICdDb250ZW50LVRyYW5zZmVyLUVuY29kaW5nOiBiaW5hcnlcXHJcXG4nO1xuICAgICAgcmV0dXJuX3BhcnQgKz0gJ0NvbnRlbnQtVHlwZTogJyArIHBhcnQuY29udGVudF90eXBlICsgJ1xcclxcblxcclxcbic7XG4gICAgICByZXR1cm5fcGFydCArPSBiaW5hcnkgPyBkYXRhLnRvU3RyaW5nKCdiaW5hcnknKSA6IGRhdGEudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICB9XG5cbiAgICBjYWxsYmFjayhudWxsLCByZXR1cm5fcGFydCArICdcXHJcXG4nKTtcbiAgfTtcblxuICBpZiAoKHBhcnQuZmlsZSB8fCBwYXJ0LmJ1ZmZlcikgJiYgcGFydC5jb250ZW50X3R5cGUpIHtcblxuICAgIHZhciBmaWxlbmFtZSA9IHBhcnQuZmlsZW5hbWUgPyBwYXJ0LmZpbGVuYW1lIDogcGFydC5maWxlID8gYmFzZW5hbWUocGFydC5maWxlKSA6IG5hbWU7XG4gICAgaWYgKHBhcnQuYnVmZmVyKSByZXR1cm4gYXBwZW5kKHBhcnQuYnVmZmVyLCBmaWxlbmFtZSk7XG5cbiAgICByZWFkRmlsZShwYXJ0LmZpbGUsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICBhcHBlbmQoZGF0YSwgZmlsZW5hbWUpO1xuICAgIH0pO1xuXG4gIH0gZWxzZSB7XG5cbiAgICBpZiAodHlwZW9mIHBhcnQudmFsdWUgPT0gJ29iamVjdCcpXG4gICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdPYmplY3QgcmVjZWl2ZWQgZm9yICcgKyBuYW1lICsgJywgZXhwZWN0ZWQgc3RyaW5nLicpKVxuXG4gICAgaWYgKHBhcnQuY29udGVudF90eXBlKSB7XG4gICAgICByZXR1cm5fcGFydCArPSAnXFxyXFxuJztcbiAgICAgIHJldHVybl9wYXJ0ICs9ICdDb250ZW50LVR5cGU6ICcgKyBwYXJ0LmNvbnRlbnRfdHlwZTtcbiAgICB9XG5cbiAgICByZXR1cm5fcGFydCArPSAnXFxyXFxuXFxyXFxuJztcbiAgICByZXR1cm5fcGFydCArPSBCdWZmZXIuZnJvbShTdHJpbmcocGFydC52YWx1ZSksICd1dGY4JykudG9TdHJpbmcoJ2JpbmFyeScpO1xuICAgIGFwcGVuZCgpO1xuXG4gIH1cblxufVxuXG4vLyBmbGF0dGVucyBuZXN0ZWQgb2JqZWN0cyBmb3IgbXVsdGlwYXJ0IGJvZHlcbmZ1bmN0aW9uIGZsYXR0ZW4ob2JqZWN0LCBpbnRvLCBwcmVmaXgpIHtcbiAgaW50byA9IGludG8gfHwge307XG5cbiAgZm9yKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgdmFyIHByZWZpeF9rZXkgPSBwcmVmaXggPyBwcmVmaXggKyAnWycgKyBrZXkgKyAnXScgOiBrZXk7XG4gICAgdmFyIHByb3AgPSBvYmplY3Rba2V5XTtcblxuICAgIGlmIChwcm9wICYmIHR5cGVvZiBwcm9wID09PSAnb2JqZWN0JyAmJiAhKHByb3AuYnVmZmVyIHx8IHByb3AuZmlsZSB8fCBwcm9wLmNvbnRlbnRfdHlwZSkpXG4gICAgICBmbGF0dGVuKHByb3AsIGludG8sIHByZWZpeF9rZXkpXG4gICAgZWxzZVxuICAgICAgaW50b1twcmVmaXhfa2V5XSA9IHByb3A7XG4gIH1cblxuICByZXR1cm4gaW50bztcbn1cbiIsIi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gTmVlZGxlIC0tIEhUVFAgQ2xpZW50IGZvciBOb2RlLmpzXG4vLyBXcml0dGVuIGJ5IFRvbcOhcyBQb2xsYWsgPHRvbWFzQGZvcmtocS5jb20+XG4vLyAoYykgMjAxMi0yMDIwIC0gRm9yayBMdGQuXG4vLyBNSVQgTGljZW5zZWRcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG52YXIgZnMgICAgICAgICAgPSByZXF1aXJlKCdmcycpLFxuICAgIGh0dHAgICAgICAgID0gcmVxdWlyZSgnaHR0cCcpLFxuICAgIGh0dHBzICAgICAgID0gcmVxdWlyZSgnaHR0cHMnKSxcbiAgICB1cmwgICAgICAgICA9IHJlcXVpcmUoJ3VybCcpLFxuICAgIHN0cmVhbSAgICAgID0gcmVxdWlyZSgnc3RyZWFtJyksXG4gICAgZGVidWcgICAgICAgPSByZXF1aXJlKCdkZWJ1ZycpKCduZWVkbGUnKSxcbiAgICBzdHJpbmdpZnkgICA9IHJlcXVpcmUoJy4vcXVlcnlzdHJpbmcnKS5idWlsZCxcbiAgICBtdWx0aXBhcnQgICA9IHJlcXVpcmUoJy4vbXVsdGlwYXJ0JyksXG4gICAgYXV0aCAgICAgICAgPSByZXF1aXJlKCcuL2F1dGgnKSxcbiAgICBjb29raWVzICAgICA9IHJlcXVpcmUoJy4vY29va2llcycpLFxuICAgIHBhcnNlcnMgICAgID0gcmVxdWlyZSgnLi9wYXJzZXJzJyksXG4gICAgZGVjb2RlciAgICAgPSByZXF1aXJlKCcuL2RlY29kZXInKTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyB2YXJpYWJpbGlhXG5cbnZhciB2ZXJzaW9uICAgICA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG5cbnZhciB1c2VyX2FnZW50ICA9ICdOZWVkbGUvJyArIHZlcnNpb247XG51c2VyX2FnZW50ICAgICArPSAnIChOb2RlLmpzICcgKyBwcm9jZXNzLnZlcnNpb24gKyAnOyAnICsgcHJvY2Vzcy5wbGF0Zm9ybSArICcgJyArIHByb2Nlc3MuYXJjaCArICcpJztcblxudmFyIHRsc19vcHRpb25zID0gJ2FnZW50IHBmeCBrZXkgcGFzc3BocmFzZSBjZXJ0IGNhIGNpcGhlcnMgcmVqZWN0VW5hdXRob3JpemVkIHNlY3VyZVByb3RvY29sIGNoZWNrU2VydmVySWRlbnRpdHkgZmFtaWx5JztcblxuLy8gb2xkZXIgdmVyc2lvbnMgb2Ygbm9kZSAoPCAwLjExLjQpIHByZXZlbnQgdGhlIHJ1bnRpbWUgZnJvbSBleGl0aW5nXG4vLyBiZWNhdXNlIG9mIGNvbm5lY3Rpb25zIGluIGtlZXAtYWxpdmUgc3RhdGUuIHNvIGlmIHRoaXMgaXMgdGhlIGNhc2Vcbi8vIHdlJ2xsIGRlZmF1bHQgbmV3IHJlcXVlc3RzIHRvIHNldCBhIENvbm5lY3Rpb246IGNsb3NlIGhlYWRlci5cbnZhciBjbG9zZV9ieV9kZWZhdWx0ID0gIWh0dHAuQWdlbnQgfHwgaHR0cC5BZ2VudC5kZWZhdWx0TWF4U29ja2V0cyAhPSBJbmZpbml0eTtcblxuLy8gc2VlIGlmIHdlIGhhdmUgT2JqZWN0LmFzc2lnbi4gb3RoZXJ3aXNlIGZhbGwgYmFjayB0byB1dGlsLl9leHRlbmRcbnZhciBleHRlbmQgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbiA6IHJlcXVpcmUoJ3V0aWwnKS5fZXh0ZW5kO1xuXG4vLyB0aGVzZSBhcmUgdGhlIHN0YXR1cyBjb2RlcyB0aGF0IE5lZWRsZSBpbnRlcnByZXRzIGFzIHJlZGlyZWN0cy5cbnZhciByZWRpcmVjdF9jb2RlcyA9IFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF07XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gZGVjb21wcmVzc29ycyBmb3IgZ3ppcC9kZWZsYXRlL2JyIGJvZGllc1xuXG52YXIgZGVjb21wcmVzc29ycyA9IHt9O1xudmFyIGJyb3RsaV9zdXBwb3J0ZWQgPSBmYWxzZTtcblxudHJ5IHtcblxuICB2YXIgemxpYiA9IHJlcXVpcmUoJ3psaWInKTtcbiAgYnJvdGxpX3N1cHBvcnRlZCA9IHR5cGVvZiB6bGliLkJyb3RsaURlY29tcHJlc3MgPT09ICdmdW5jdGlvbic7XG4gIGRlY29tcHJlc3NvcnNbJ3gtZGVmbGF0ZSddID0gemxpYi5JbmZsYXRlO1xuICBkZWNvbXByZXNzb3JzWydkZWZsYXRlJ10gICA9IHpsaWIuSW5mbGF0ZTtcbiAgZGVjb21wcmVzc29yc1sneC1nemlwJ10gICAgPSB6bGliLkd1bnppcDtcbiAgZGVjb21wcmVzc29yc1snZ3ppcCddICAgICAgPSB6bGliLkd1bnppcDtcbiAgaWYgKGJyb3RsaV9zdXBwb3J0ZWQpIHtcbiAgICBkZWNvbXByZXNzb3JzWydiciddICAgICAgPSB6bGliLkJyb3RsaURlY29tcHJlc3M7XG4gIH1cblxuICAvLyBFbmFibGUgWl9TWU5DX0ZMVVNIIHRvIGF2b2lkIFpfQlVGX0VSUk9SIGVycm9ycyAoTm9kZSBQUiAjMjU5NSlcbiAgdmFyIHpsaWJfb3B0aW9ucyA9IHtcbiAgICBmbHVzaDogemxpYi5aX1NZTkNfRkxVU0gsXG4gICAgZmluaXNoRmx1c2g6IHpsaWIuWl9TWU5DX0ZMVVNIXG4gIH1cblxufSBjYXRjaChlKSB7IC8qIHpsaWIgbm90IGF2YWlsYWJsZSAqLyB9XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gb3B0aW9ucyBhbmQgYWxpYXNlc1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIC8vIGRhdGFcbiAgYm91bmRhcnkgICAgICAgICAgICAgICAgOiAnLS0tLS0tLS0tLS0tLS0tLS0tLS1OT0RFTkVFRExFSFRUUENMSUVOVCcsXG4gIGVuY29kaW5nICAgICAgICAgICAgICAgIDogJ3V0ZjgnLFxuICBwYXJzZV9yZXNwb25zZSAgICAgICAgICA6ICdhbGwnLCAvLyBzYW1lIGFzIHRydWUuIHZhbGlkIG9wdGlvbnM6ICdqc29uJywgJ3htbCcgb3IgZmFsc2UvbnVsbFxuICBwcm94eSAgICAgICAgICAgICAgICAgICA6IG51bGwsXG5cbiAgLy8gaGVhZGVyc1xuICBoZWFkZXJzICAgICAgICAgICAgICAgICA6IHt9LFxuICBhY2NlcHQgICAgICAgICAgICAgICAgICA6ICcqLyonLFxuICB1c2VyX2FnZW50ICAgICAgICAgICAgICA6IHVzZXJfYWdlbnQsXG5cbiAgLy8gbnVtYmVyc1xuICBvcGVuX3RpbWVvdXQgICAgICAgICAgICA6IDEwMDAwLFxuICByZXNwb25zZV90aW1lb3V0ICAgICAgICA6IDAsXG4gIHJlYWRfdGltZW91dCAgICAgICAgICAgIDogMCxcbiAgZm9sbG93X21heCAgICAgICAgICAgICAgOiAwLFxuICBzdHJlYW1fbGVuZ3RoICAgICAgICAgICA6IC0xLFxuXG4gIC8vIGJvb2xlYW5zXG4gIGNvbXByZXNzZWQgICAgICAgICAgICAgIDogZmFsc2UsXG4gIGRlY29kZV9yZXNwb25zZSAgICAgICAgIDogdHJ1ZSxcbiAgcGFyc2VfY29va2llcyAgICAgICAgICAgOiB0cnVlLFxuICBmb2xsb3dfc2V0X2Nvb2tpZXMgICAgICA6IGZhbHNlLFxuICBmb2xsb3dfc2V0X3JlZmVyZXIgICAgICA6IGZhbHNlLFxuICBmb2xsb3dfa2VlcF9tZXRob2QgICAgICA6IGZhbHNlLFxuICBmb2xsb3dfaWZfc2FtZV9ob3N0ICAgICA6IGZhbHNlLFxuICBmb2xsb3dfaWZfc2FtZV9wcm90b2NvbCA6IGZhbHNlLFxuICBmb2xsb3dfaWZfc2FtZV9sb2NhdGlvbiA6IGZhbHNlXG59XG5cbnZhciBhbGlhc2VkID0ge1xuICBvcHRpb25zOiB7XG4gICAgZGVjb2RlICA6ICdkZWNvZGVfcmVzcG9uc2UnLFxuICAgIHBhcnNlICAgOiAncGFyc2VfcmVzcG9uc2UnLFxuICAgIHRpbWVvdXQgOiAnb3Blbl90aW1lb3V0JyxcbiAgICBmb2xsb3cgIDogJ2ZvbGxvd19tYXgnXG4gIH0sXG4gIGludmVydGVkOiB7fVxufVxuXG4vLyBvbmx5IG9uY2UsIGludmVydCBhbGlhc2VkIGtleXMgc28gd2UgY2FuIGdldCBwYXNzZWQgb3B0aW9ucy5cbk9iamVjdC5rZXlzKGFsaWFzZWQub3B0aW9ucykubWFwKGZ1bmN0aW9uKGspIHtcbiAgdmFyIHZhbHVlID0gYWxpYXNlZC5vcHRpb25zW2tdO1xuICBhbGlhc2VkLmludmVydGVkW3ZhbHVlXSA9IGs7XG59KTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBoZWxwZXJzXG5cbmZ1bmN0aW9uIGtleXNfYnlfdHlwZSh0eXBlKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhkZWZhdWx0cykubWFwKGZ1bmN0aW9uKGVsKSB7XG4gICAgaWYgKGRlZmF1bHRzW2VsXSAhPT0gbnVsbCAmJiBkZWZhdWx0c1tlbF0uY29uc3RydWN0b3IgPT0gdHlwZSlcbiAgICAgIHJldHVybiBlbDtcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uKGVsKSB7IHJldHVybiBlbCB9KVxufVxuXG5mdW5jdGlvbiBwYXJzZV9jb250ZW50X3R5cGUoaGVhZGVyKSB7XG4gIGlmICghaGVhZGVyIHx8IGhlYWRlciA9PT0gJycpIHJldHVybiB7fTtcblxuICB2YXIgZm91bmQsIGNoYXJzZXQgPSAndXRmOCcsIGFyciA9IGhlYWRlci5zcGxpdCgnOycpO1xuXG4gIGlmIChhcnIubGVuZ3RoID4gMSAmJiAoZm91bmQgPSBhcnJbMV0ubWF0Y2goL2NoYXJzZXQ9KC4rKS8pKSlcbiAgICBjaGFyc2V0ID0gZm91bmRbMV07XG5cbiAgcmV0dXJuIHsgdHlwZTogYXJyWzBdLCBjaGFyc2V0OiBjaGFyc2V0IH07XG59XG5cbmZ1bmN0aW9uIGlzX3N0cmVhbShvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmoucGlwZSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gZ2V0X3N0cmVhbV9sZW5ndGgoc3RyZWFtLCBnaXZlbl9sZW5ndGgsIGNiKSB7XG4gIGlmIChnaXZlbl9sZW5ndGggPiAwKVxuICAgIHJldHVybiBjYihnaXZlbl9sZW5ndGgpO1xuXG4gIGlmIChzdHJlYW0uZW5kICE9PSB2b2lkIDAgJiYgc3RyZWFtLmVuZCAhPT0gSW5maW5pdHkgJiYgc3RyZWFtLnN0YXJ0ICE9PSB2b2lkIDApXG4gICAgcmV0dXJuIGNiKChzdHJlYW0uZW5kICsgMSkgLSAoc3RyZWFtLnN0YXJ0IHx8IDApKTtcblxuICBmcy5zdGF0KHN0cmVhbS5wYXRoLCBmdW5jdGlvbihlcnIsIHN0YXQpIHtcbiAgICBjYihzdGF0ID8gc3RhdC5zaXplIC0gKHN0cmVhbS5zdGFydCB8fCAwKSA6IG51bGwpO1xuICB9KTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyB0aGUgbWFpbiBhY3RcblxuZnVuY3Rpb24gTmVlZGxlKG1ldGhvZCwgdXJpLCBkYXRhLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAvLyBpZiAoISh0aGlzIGluc3RhbmNlb2YgTmVlZGxlKSkge1xuICAvLyAgIHJldHVybiBuZXcgTmVlZGxlKG1ldGhvZCwgdXJpLCBkYXRhLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gIC8vIH1cblxuICBpZiAodHlwZW9mIHVyaSAhPT0gJ3N0cmluZycpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVVJMIG11c3QgYmUgYSBzdHJpbmcsIG5vdCAnICsgdXJpKTtcblxuICB0aGlzLm1ldGhvZCAgID0gbWV0aG9kO1xuICB0aGlzLnVyaSAgICAgID0gdXJpO1xuICB0aGlzLmRhdGEgICAgID0gZGF0YTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIHRoaXMub3B0aW9ucyAgPSB7fTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5vcHRpb25zICA9IG9wdGlvbnM7XG4gIH1cblxufVxuXG5OZWVkbGUucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24odXJpLCBvcHRpb25zKSB7XG5cbiAgZnVuY3Rpb24gZ2V0X29wdGlvbihrZXksIGZhbGxiYWNrKSB7XG4gICAgLy8gaWYgb3JpZ2luYWwgaXMgaW4gb3B0aW9ucywgcmV0dXJuIHRoYXQgdmFsdWVcbiAgICBpZiAodHlwZW9mIG9wdGlvbnNba2V5XSAhPSAndW5kZWZpbmVkJykgcmV0dXJuIG9wdGlvbnNba2V5XTtcblxuICAgIC8vIG90aGVyd2lzZSwgcmV0dXJuIHZhbHVlIGZyb20gYWxpYXMgb3IgZmFsbGJhY2svdW5kZWZpbmVkXG4gICAgcmV0dXJuIHR5cGVvZiBvcHRpb25zW2FsaWFzZWQuaW52ZXJ0ZWRba2V5XV0gIT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICA/IG9wdGlvbnNbYWxpYXNlZC5pbnZlcnRlZFtrZXldXSA6IGZhbGxiYWNrO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tfdmFsdWUoZXhwZWN0ZWQsIGtleSkge1xuICAgIHZhciB2YWx1ZSA9IGdldF9vcHRpb24oa2V5KSxcbiAgICAgICAgdHlwZSAgPSB0eXBlb2YgdmFsdWU7XG5cbiAgICBpZiAodHlwZSAhPSAndW5kZWZpbmVkJyAmJiB0eXBlICE9IGV4cGVjdGVkKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcih0eXBlICsgJyByZWNlaXZlZCBmb3IgJyArIGtleSArICcsIGJ1dCBleHBlY3RlZCBhICcgKyBleHBlY3RlZCk7XG5cbiAgICByZXR1cm4gKHR5cGUgPT0gZXhwZWN0ZWQpID8gdmFsdWUgOiBkZWZhdWx0c1trZXldO1xuICB9XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gdGhlIGJhc2ljc1xuXG4gIHZhciBjb25maWcgPSB7XG4gICAgaHR0cF9vcHRzIDoge1xuICAgICAgbG9jYWxBZGRyZXNzOiBnZXRfb3B0aW9uKCdsb2NhbEFkZHJlc3MnLCB1bmRlZmluZWQpXG4gICAgfSwgLy8gcGFzc2VkIGxhdGVyIHRvIGh0dHAucmVxdWVzdCgpIGRpcmVjdGx5XG4gICAgaGVhZGVycyAgIDoge30sXG4gICAgb3V0cHV0ICAgIDogb3B0aW9ucy5vdXRwdXQsXG4gICAgcHJveHkgICAgIDogZ2V0X29wdGlvbigncHJveHknLCBkZWZhdWx0cy5wcm94eSksXG4gICAgcGFyc2VyICAgIDogZ2V0X29wdGlvbigncGFyc2VfcmVzcG9uc2UnLCBkZWZhdWx0cy5wYXJzZV9yZXNwb25zZSksXG4gICAgZW5jb2RpbmcgIDogb3B0aW9ucy5lbmNvZGluZyB8fCAob3B0aW9ucy5tdWx0aXBhcnQgPyAnYmluYXJ5JyA6IGRlZmF1bHRzLmVuY29kaW5nKVxuICB9XG5cbiAga2V5c19ieV90eXBlKEJvb2xlYW4pLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgY29uZmlnW2tleV0gPSBjaGVja192YWx1ZSgnYm9vbGVhbicsIGtleSk7XG4gIH0pXG5cbiAga2V5c19ieV90eXBlKE51bWJlcikuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBjb25maWdba2V5XSA9IGNoZWNrX3ZhbHVlKCdudW1iZXInLCBrZXkpO1xuICB9KVxuXG4gIC8vIHBvcHVsYXRlIGh0dHBfb3B0cyB3aXRoIGdpdmVuIFRMUyBvcHRpb25zXG4gIHRsc19vcHRpb25zLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnNba2V5XSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgY29uZmlnLmh0dHBfb3B0c1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmFnZW50ID09ICd1bmRlZmluZWQnKVxuICAgICAgICBjb25maWcuaHR0cF9vcHRzLmFnZW50ID0gZmFsc2U7IC8vIG90aGVyd2lzZSB0bHMgb3B0aW9ucyBhcmUgc2tpcHBlZFxuICAgIH1cbiAgfSk7XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gaGVhZGVycywgY29va2llc1xuXG4gIGZvciAodmFyIGtleSBpbiBkZWZhdWx0cy5oZWFkZXJzKVxuICAgIGNvbmZpZy5oZWFkZXJzW2tleV0gPSBkZWZhdWx0cy5oZWFkZXJzW2tleV07XG5cbiAgY29uZmlnLmhlYWRlcnNbJ2FjY2VwdCddID0gb3B0aW9ucy5hY2NlcHQgfHwgZGVmYXVsdHMuYWNjZXB0O1xuICBjb25maWcuaGVhZGVyc1sndXNlci1hZ2VudCddID0gb3B0aW9ucy51c2VyX2FnZW50IHx8IGRlZmF1bHRzLnVzZXJfYWdlbnQ7XG5cbiAgaWYgKG9wdGlvbnMuY29udGVudF90eXBlKVxuICAgIGNvbmZpZy5oZWFkZXJzWydjb250ZW50LXR5cGUnXSA9IG9wdGlvbnMuY29udGVudF90eXBlO1xuXG4gIC8vIHNldCBjb25uZWN0aW9uIGhlYWRlciBpZiBvcHRzLmNvbm5lY3Rpb24gd2FzIHBhc3NlZCwgb3IgaWYgbm9kZSA8IDAuMTEuNCAoY2xvc2UpXG4gIGlmIChvcHRpb25zLmNvbm5lY3Rpb24gfHwgY2xvc2VfYnlfZGVmYXVsdClcbiAgICBjb25maWcuaGVhZGVyc1snY29ubmVjdGlvbiddID0gb3B0aW9ucy5jb25uZWN0aW9uIHx8ICdjbG9zZSc7XG5cbiAgaWYgKChvcHRpb25zLmNvbXByZXNzZWQgfHwgZGVmYXVsdHMuY29tcHJlc3NlZCkgJiYgdHlwZW9mIHpsaWIgIT0gJ3VuZGVmaW5lZCcpXG4gICAgY29uZmlnLmhlYWRlcnNbJ2FjY2VwdC1lbmNvZGluZyddID0gYnJvdGxpX3N1cHBvcnRlZCA/ICdnemlwLCBkZWZsYXRlLCBicicgOiAnZ3ppcCwgZGVmbGF0ZSc7XG5cbiAgaWYgKG9wdGlvbnMuY29va2llcylcbiAgICBjb25maWcuaGVhZGVyc1snY29va2llJ10gPSBjb29raWVzLndyaXRlKG9wdGlvbnMuY29va2llcyk7XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gYmFzaWMvZGlnZXN0IGF1dGhcblxuICBpZiAodXJpLm1hdGNoKC9bXlxcL11ALykpIHsgLy8gdXJsIGNvbnRhaW5zIHVzZXI6cGFzc0Bob3N0LCBzbyBwYXJzZSBpdC5cbiAgICB2YXIgcGFydHMgPSAodXJsLnBhcnNlKHVyaSkuYXV0aCB8fCAnJykuc3BsaXQoJzonKTtcbiAgICBvcHRpb25zLnVzZXJuYW1lID0gcGFydHNbMF07XG4gICAgb3B0aW9ucy5wYXNzd29yZCA9IHBhcnRzWzFdO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMudXNlcm5hbWUpIHtcbiAgICBpZiAob3B0aW9ucy5hdXRoICYmIChvcHRpb25zLmF1dGggPT0gJ2F1dG8nIHx8IG9wdGlvbnMuYXV0aCA9PSAnZGlnZXN0JykpIHtcbiAgICAgIGNvbmZpZy5jcmVkZW50aWFscyA9IFtvcHRpb25zLnVzZXJuYW1lLCBvcHRpb25zLnBhc3N3b3JkXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uZmlnLmhlYWRlcnNbJ2F1dGhvcml6YXRpb24nXSA9IGF1dGguYmFzaWMob3B0aW9ucy51c2VybmFtZSwgb3B0aW9ucy5wYXNzd29yZCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgcHJveHkgaXMgcHJlc2VudCwgc2V0IGF1dGggaGVhZGVyIGZyb20gZWl0aGVyIHVybCBvciBwcm94eV91c2VyIG9wdGlvbi5cbiAgaWYgKGNvbmZpZy5wcm94eSkge1xuICAgIGlmIChjb25maWcucHJveHkuaW5kZXhPZignaHR0cCcpID09PSAtMSlcbiAgICAgIGNvbmZpZy5wcm94eSA9ICdodHRwOi8vJyArIGNvbmZpZy5wcm94eTtcblxuICAgIGlmIChjb25maWcucHJveHkuaW5kZXhPZignQCcpICE9PSAtMSkge1xuICAgICAgdmFyIHByb3h5ID0gKHVybC5wYXJzZShjb25maWcucHJveHkpLmF1dGggfHwgJycpLnNwbGl0KCc6Jyk7XG4gICAgICBvcHRpb25zLnByb3h5X3VzZXIgPSBwcm94eVswXTtcbiAgICAgIG9wdGlvbnMucHJveHlfcGFzcyA9IHByb3h5WzFdO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnByb3h5X3VzZXIpXG4gICAgICBjb25maWcuaGVhZGVyc1sncHJveHktYXV0aG9yaXphdGlvbiddID0gYXV0aC5iYXNpYyhvcHRpb25zLnByb3h5X3VzZXIsIG9wdGlvbnMucHJveHlfcGFzcyk7XG4gIH1cblxuICAvLyBub3cgdGhhdCBhbGwgb3VyIGhlYWRlcnMgYXJlIHNldCwgb3ZlcndyaXRlIHRoZW0gaWYgaW5zdHJ1Y3RlZC5cbiAgZm9yICh2YXIgaCBpbiBvcHRpb25zLmhlYWRlcnMpXG4gICAgY29uZmlnLmhlYWRlcnNbaC50b0xvd2VyQ2FzZSgpXSA9IG9wdGlvbnMuaGVhZGVyc1toXTtcblxuICBjb25maWcudXJpX21vZGlmaWVyID0gZ2V0X29wdGlvbigndXJpX21vZGlmaWVyJywgbnVsbCk7XG5cbiAgcmV0dXJuIGNvbmZpZztcbn1cblxuTmVlZGxlLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXG4gIHZhciBvdXQgICAgICA9IG5ldyBzdHJlYW0uUGFzc1Rocm91Z2goeyBvYmplY3RNb2RlOiBmYWxzZSB9KSxcbiAgICAgIHVyaSAgICAgID0gdGhpcy51cmksXG4gICAgICBkYXRhICAgICA9IHRoaXMuZGF0YSxcbiAgICAgIG1ldGhvZCAgID0gdGhpcy5tZXRob2QsXG4gICAgICBjYWxsYmFjayA9ICh0eXBlb2YgdGhpcy5vcHRpb25zID09ICdmdW5jdGlvbicpID8gdGhpcy5vcHRpb25zIDogdGhpcy5jYWxsYmFjayxcbiAgICAgIG9wdGlvbnMgID0gdGhpcy5vcHRpb25zIHx8IHt9O1xuXG4gIC8vIGlmIG5vICdodHRwJyBpcyBmb3VuZCBvbiBVUkwsIHByZXBlbmQgaXQuXG4gIGlmICh1cmkuaW5kZXhPZignaHR0cCcpID09PSAtMSlcbiAgICB1cmkgPSB1cmkucmVwbGFjZSgvXihcXC9cXC8pPy8sICdodHRwOi8vJyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzLCBib2R5LCB3YWl0aW5nID0gZmFsc2UsIGNvbmZpZyA9IHRoaXMuc2V0dXAodXJpLCBvcHRpb25zKTtcblxuICAvLyB1bmxlc3Mgb3B0aW9ucy5qc29uIHdhcyBzZXQgdG8gZmFsc2UsIGFzc3VtZSBib3NzIGFsc28gd2FudHMgSlNPTiBpZiBjb250ZW50LXR5cGUgbWF0Y2hlcy5cbiAgdmFyIGpzb24gPSBvcHRpb25zLmpzb24gfHwgKG9wdGlvbnMuanNvbiAhPT0gZmFsc2UgJiYgY29uZmlnLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID09ICdhcHBsaWNhdGlvbi9qc29uJyk7XG5cbiAgaWYgKGRhdGEpIHtcblxuICAgIGlmIChvcHRpb25zLm11bHRpcGFydCkgeyAvLyBib3NzIHNheXMgd2UgZG8gbXVsdGlwYXJ0LiBzbyB3ZSBkbyBpdC5cbiAgICAgIHZhciBib3VuZGFyeSA9IG9wdGlvbnMuYm91bmRhcnkgfHwgZGVmYXVsdHMuYm91bmRhcnk7XG5cbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuICAgICAgbXVsdGlwYXJ0LmJ1aWxkKGRhdGEsIGJvdW5kYXJ5LCBmdW5jdGlvbihlcnIsIHBhcnRzKSB7XG4gICAgICAgIGlmIChlcnIpIHRocm93KGVycik7XG5cbiAgICAgICAgY29uZmlnLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gJ211bHRpcGFydC9mb3JtLWRhdGE7IGJvdW5kYXJ5PScgKyBib3VuZGFyeTtcbiAgICAgICAgbmV4dChwYXJ0cyk7XG4gICAgICB9KTtcblxuICAgIH0gZWxzZSBpZiAoaXNfc3RyZWFtKGRhdGEpKSB7XG5cbiAgICAgIGlmIChtZXRob2QudG9VcHBlckNhc2UoKSA9PSAnR0VUJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWZ1c2luZyB0byBwaXBlKCkgYSBzdHJlYW0gdmlhIEdFVC4gRGlkIHlvdSBtZWFuIC5wb3N0PycpO1xuXG4gICAgICBpZiAoY29uZmlnLnN0cmVhbV9sZW5ndGggPiAwIHx8IChjb25maWcuc3RyZWFtX2xlbmd0aCA9PT0gMCAmJiBkYXRhLnBhdGgpKSB7XG4gICAgICAgIC8vIG9rLCBsZXQncyBnZXQgdGhlIHN0cmVhbSdzIGxlbmd0aCBhbmQgc2V0IGl0IGFzIHRoZSBjb250ZW50LWxlbmd0aCBoZWFkZXIuXG4gICAgICAgIC8vIHRoaXMgcHJldmVudHMgc29tZSBzZXJ2ZXJzIGZyb20gY3V0dGluZyB1cyBvZmYgYmVmb3JlIGFsbCB0aGUgZGF0YSBpcyBzZW50LlxuICAgICAgICB3YWl0aW5nID0gdHJ1ZTtcbiAgICAgICAgZ2V0X3N0cmVhbV9sZW5ndGgoZGF0YSwgY29uZmlnLnN0cmVhbV9sZW5ndGgsIGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgICAgICAgIGRhdGEubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAgIG5leHQoZGF0YSk7XG4gICAgICAgIH0pXG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIHRoZSBib3NzIGRvZXNuJ3Qgd2FudCB1cyB0byBnZXQgdGhlIHN0cmVhbSdzIGxlbmd0aCwgb3IgaWYgaXQgZG9lc24ndFxuICAgICAgICAvLyBoYXZlIGEgZmlsZSBkZXNjcmlwdG9yIGZvciB0aGF0IHB1cnBvc2UsIHRoZW4ganVzdCBoZWFkIG9uLlxuICAgICAgICBib2R5ID0gZGF0YTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG5cbiAgICAgIGJvZHkgPSBkYXRhOyAvLyB1c2UgdGhlIHJhdyBidWZmZXIgYXMgcmVxdWVzdCBib2R5LlxuXG4gICAgfSBlbHNlIGlmIChtZXRob2QudG9VcHBlckNhc2UoKSA9PSAnR0VUJyAmJiAhanNvbikge1xuXG4gICAgICAvLyBhcHBlbmQgdGhlIGRhdGEgdG8gdGhlIFVSSSBhcyBhIHF1ZXJ5c3RyaW5nLlxuICAgICAgdXJpID0gdXJpLnJlcGxhY2UoL1xcPy4qfCQvLCAnPycgKyBzdHJpbmdpZnkoZGF0YSkpO1xuXG4gICAgfSBlbHNlIHsgLy8gc3RyaW5nIG9yIG9iamVjdCBkYXRhLCBubyBtdWx0aXBhcnQuXG5cbiAgICAgIC8vIGlmIHN0cmluZywgbGVhdmUgaXQgYXMgaXQgaXMsIG90aGVyd2lzZSwgc3RyaW5naWZ5LlxuICAgICAgYm9keSA9ICh0eXBlb2YoZGF0YSkgPT09ICdzdHJpbmcnKSA/IGRhdGFcbiAgICAgICAgICAgICA6IGpzb24gPyBKU09OLnN0cmluZ2lmeShkYXRhKSA6IHN0cmluZ2lmeShkYXRhKTtcblxuICAgICAgLy8gZW5zdXJlIHdlIGhhdmUgYSBidWZmZXIgc28gYnl0ZWNvdW50IGlzIGNvcnJlY3QuXG4gICAgICBib2R5ID0gQnVmZmVyLmZyb20oYm9keSwgY29uZmlnLmVuY29kaW5nKTtcbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHQoYm9keSkge1xuICAgIGlmIChib2R5KSB7XG4gICAgICBpZiAoYm9keS5sZW5ndGgpIGNvbmZpZy5oZWFkZXJzWydjb250ZW50LWxlbmd0aCddID0gYm9keS5sZW5ndGg7XG5cbiAgICAgIC8vIGlmIG5vIGNvbnRlbnQtdHlwZSB3YXMgcGFzc2VkLCBkZXRlcm1pbmUgaWYganNvbiBvciBub3QuXG4gICAgICBpZiAoIWNvbmZpZy5oZWFkZXJzWydjb250ZW50LXR5cGUnXSkge1xuICAgICAgICBjb25maWcuaGVhZGVyc1snY29udGVudC10eXBlJ10gPSBqc29uXG4gICAgICAgID8gJ2FwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLTgnXG4gICAgICAgIDogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7IC8vIG5vIGNoYXJzZXQgc2F5cyBXMyBzcGVjLlxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHVubGVzcyBhIHNwZWNpZmljIGFjY2VwdCBoZWFkZXIgd2FzIHNldCwgYXNzdW1lIGpzb246IHRydWUgd2FudHMgSlNPTiBiYWNrLlxuICAgIGlmIChvcHRpb25zLmpzb24gJiYgKCFvcHRpb25zLmFjY2VwdCAmJiAhKG9wdGlvbnMuaGVhZGVycyB8fCB7fSkuYWNjZXB0KSlcbiAgICAgIGNvbmZpZy5oZWFkZXJzWydhY2NlcHQnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcblxuICAgIHNlbGYuc2VuZF9yZXF1ZXN0KDEsIG1ldGhvZCwgdXJpLCBjb25maWcsIGJvZHksIG91dCwgY2FsbGJhY2spO1xuICB9XG5cbiAgaWYgKCF3YWl0aW5nKSBuZXh0KGJvZHkpO1xuICByZXR1cm4gb3V0O1xufVxuXG5OZWVkbGUucHJvdG90eXBlLmdldF9yZXF1ZXN0X29wdHMgPSBmdW5jdGlvbihtZXRob2QsIHVyaSwgY29uZmlnKSB7XG4gIHZhciBvcHRzICAgICAgPSBjb25maWcuaHR0cF9vcHRzLFxuICAgICAgcHJveHkgICAgID0gY29uZmlnLnByb3h5LFxuICAgICAgcmVtb3RlICAgID0gcHJveHkgPyB1cmwucGFyc2UocHJveHkpIDogdXJsLnBhcnNlKHVyaSk7XG5cbiAgb3B0cy5wcm90b2NvbCA9IHJlbW90ZS5wcm90b2NvbDtcbiAgb3B0cy5ob3N0ICAgICA9IHJlbW90ZS5ob3N0bmFtZTtcbiAgb3B0cy5wb3J0ICAgICA9IHJlbW90ZS5wb3J0IHx8IChyZW1vdGUucHJvdG9jb2wgPT0gJ2h0dHBzOicgPyA0NDMgOiA4MCk7XG4gIG9wdHMucGF0aCAgICAgPSBwcm94eSA/IHVyaSA6IHJlbW90ZS5wYXRobmFtZSArIChyZW1vdGUuc2VhcmNoIHx8ICcnKTtcbiAgb3B0cy5tZXRob2QgICA9IG1ldGhvZDtcbiAgb3B0cy5oZWFkZXJzICA9IGNvbmZpZy5oZWFkZXJzO1xuXG4gIGlmICghb3B0cy5oZWFkZXJzWydob3N0J10pIHtcbiAgICAvLyBpZiB1c2luZyBwcm94eSwgbWFrZSBzdXJlIHRoZSBob3N0IGhlYWRlciBzaG93cyB0aGUgZmluYWwgZGVzdGluYXRpb25cbiAgICB2YXIgdGFyZ2V0ID0gcHJveHkgPyB1cmwucGFyc2UodXJpKSA6IHJlbW90ZTtcbiAgICBvcHRzLmhlYWRlcnNbJ2hvc3QnXSA9IHRhcmdldC5ob3N0bmFtZTtcblxuICAgIC8vIGFuZCBpZiBhIG5vbiBzdGFuZGFyZCBwb3J0IHdhcyBwYXNzZWQsIGFwcGVuZCBpdCB0byB0aGUgcG9ydCBoZWFkZXJcbiAgICBpZiAodGFyZ2V0LnBvcnQgJiYgWzgwLCA0NDNdLmluZGV4T2YodGFyZ2V0LnBvcnQpID09PSAtMSkge1xuICAgICAgb3B0cy5oZWFkZXJzWydob3N0J10gKz0gJzonICsgdGFyZ2V0LnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9wdHM7XG59XG5cbk5lZWRsZS5wcm90b3R5cGUuc2hvdWxkX2ZvbGxvdyA9IGZ1bmN0aW9uKGxvY2F0aW9uLCBjb25maWcsIG9yaWdpbmFsKSB7XG4gIGlmICghbG9jYXRpb24pIHJldHVybiBmYWxzZTtcblxuICAvLyByZXR1cm5zIHRydWUgaWYgbG9jYXRpb24gY29udGFpbnMgbWF0Y2hpbmcgcHJvcGVydHkgKGhvc3Qgb3IgcHJvdG9jb2wpXG4gIGZ1bmN0aW9uIG1hdGNoZXMocHJvcGVydHkpIHtcbiAgICB2YXIgcHJvcGVydHkgPSBvcmlnaW5hbFtwcm9wZXJ0eV07XG4gICAgcmV0dXJuIGxvY2F0aW9uLmluZGV4T2YocHJvcGVydHkpICE9PSAtMTtcbiAgfVxuXG4gIC8vIGZpcnN0LCBjaGVjayB3aGV0aGVyIHRoZSByZXF1ZXN0ZWQgbG9jYXRpb24gaXMgYWN0dWFsbHkgZGlmZmVyZW50IGZyb20gdGhlIG9yaWdpbmFsXG4gIGlmICghY29uZmlnLmZvbGxvd19pZl9zYW1lX2xvY2F0aW9uICYmIGxvY2F0aW9uID09PSBvcmlnaW5hbClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGNvbmZpZy5mb2xsb3dfaWZfc2FtZV9ob3N0ICYmICFtYXRjaGVzKCdob3N0JykpXG4gICAgcmV0dXJuIGZhbHNlOyAvLyBob3N0IGRvZXMgbm90IG1hdGNoLCBzbyBub3QgZm9sbG93aW5nXG5cbiAgaWYgKGNvbmZpZy5mb2xsb3dfaWZfc2FtZV9wcm90b2NvbCAmJiAhbWF0Y2hlcygncHJvdG9jb2wnKSlcbiAgICByZXR1cm4gZmFsc2U7IC8vIHByb2NvdG9sIGRvZXMgbm90IG1hdGNoLCBzbyBub3QgZm9sbG93aW5nXG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbk5lZWRsZS5wcm90b3R5cGUuc2VuZF9yZXF1ZXN0ID0gZnVuY3Rpb24oY291bnQsIG1ldGhvZCwgdXJpLCBjb25maWcsIHBvc3RfZGF0YSwgb3V0LCBjYWxsYmFjaykge1xuXG4gIGlmICh0eXBlb2YgY29uZmlnLnVyaV9tb2RpZmllciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBtb2RpZmllZF91cmkgPSBjb25maWcudXJpX21vZGlmaWVyKHVyaSk7XG4gICAgZGVidWcoJ01vZGlmeWluZyByZXF1ZXN0IFVSSScsIHVyaSArICcgPT4gJyArIG1vZGlmaWVkX3VyaSk7XG4gICAgdXJpID0gbW9kaWZpZWRfdXJpO1xuICB9XG5cbiAgdmFyIHRpbWVyLFxuICAgICAgcmV0dXJuZWQgICAgID0gMCxcbiAgICAgIHNlbGYgICAgICAgICA9IHRoaXMsXG4gICAgICByZXF1ZXN0X29wdHMgPSB0aGlzLmdldF9yZXF1ZXN0X29wdHMobWV0aG9kLCB1cmksIGNvbmZpZyksXG4gICAgICBwcm90b2NvbCAgICAgPSByZXF1ZXN0X29wdHMucHJvdG9jb2wgPT0gJ2h0dHBzOicgPyBodHRwcyA6IGh0dHA7XG5cbiAgZnVuY3Rpb24gZG9uZShlcnIsIHJlc3ApIHtcbiAgICBpZiAocmV0dXJuZWQrKyA+IDApXG4gICAgICByZXR1cm4gZGVidWcoJ0FscmVhZHkgZmluaXNoZWQsIHN0b3BwaW5nIGhlcmUuJyk7XG5cbiAgICBpZiAodGltZXIpIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBoYWRfZXJyb3IpO1xuXG4gICAgaWYgKGNhbGxiYWNrKVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgcmVzcCwgcmVzcCA/IHJlc3AuYm9keSA6IHVuZGVmaW5lZCk7XG5cbiAgICAvLyBOT1RFOiB0aGlzIGV2ZW50IHVzZWQgdG8gYmUgY2FsbGVkICdlbmQnLCBidXQgdGhlIGJlaGF2aW91ciB3YXMgY29uZnVzaW5nXG4gICAgLy8gd2hlbiBlcnJvcnMgb2N1cnJlZCwgYmVjYXVzZSB0aGUgc3RyZWFtIHdvdWxkIHN0aWxsIGVtaXQgYW4gJ2VuZCcgZXZlbnQuXG4gICAgb3V0LmVtaXQoJ2RvbmUnLCBlcnIpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFkX2Vycm9yKGVycikge1xuICAgIGRlYnVnKCdSZXF1ZXN0IGVycm9yJywgZXJyKTtcbiAgICBvdXQuZW1pdCgnZXJyJywgZXJyKTtcbiAgICBkb25lKGVyciB8fCBuZXcgRXJyb3IoJ1Vua25vd24gZXJyb3Igd2hlbiBtYWtpbmcgcmVxdWVzdC4nKSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRfdGltZW91dCh0eXBlLCBtaWxpc2Vjcykge1xuICAgIGlmICh0aW1lcikgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICBpZiAobWlsaXNlY3MgPD0gMCkgcmV0dXJuO1xuXG4gICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgb3V0LmVtaXQoJ3RpbWVvdXQnLCB0eXBlKTtcbiAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgIC8vIGFsc28gaW52b2tlIGRvbmUoKSB0byB0ZXJtaW5hdGUgam9iIG9uIHJlYWRfdGltZW91dFxuICAgICAgaWYgKHR5cGUgPT0gJ3JlYWQnKSBkb25lKG5ldyBFcnJvcih0eXBlICsgJyB0aW1lb3V0JykpO1xuICAgIH0sIG1pbGlzZWNzKTtcbiAgfVxuXG4gIC8vIGhhbmRsZSBlcnJvcnMgb24gdGhlIHVuZGVybHlpbmcgc29ja2V0LCB0aGF0IG1heSBiZSBjbG9zZWQgd2hpbGUgd3JpdGluZ1xuICAvLyBmb3IgYW4gZXhhbXBsZSBjYXNlLCBzZWUgdGVzdC9sb25nX3N0cmluZ19zcGVjLmpzLiB3ZSBtYWtlIHN1cmUgdGhpc1xuICAvLyBzY2VuYXJpbyBvY3VycmVkIGJ5IHZlcmlmeWluZyB0aGUgc29ja2V0J3Mgd3JpdGFibGUgJiBkZXN0cm95ZWQgc3RhdGVzLlxuICBmdW5jdGlvbiBvbl9zb2NrZXRfZW5kKCkge1xuICAgIGlmIChyZXR1cm5lZCAmJiAhdGhpcy53cml0YWJsZSAmJiB0aGlzLmRlc3Ryb3llZCA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgaGFkX2Vycm9yKG5ldyBFcnJvcignUmVtb3RlIGVuZCBjbG9zZWQgc29ja2V0IGFicnVwdGx5LicpKVxuICAgIH1cbiAgfVxuXG4gIGRlYnVnKCdNYWtpbmcgcmVxdWVzdCAjJyArIGNvdW50LCByZXF1ZXN0X29wdHMpO1xuICB2YXIgcmVxdWVzdCA9IHByb3RvY29sLnJlcXVlc3QocmVxdWVzdF9vcHRzLCBmdW5jdGlvbihyZXNwKSB7XG5cbiAgICB2YXIgaGVhZGVycyA9IHJlc3AuaGVhZGVycztcbiAgICBkZWJ1ZygnR290IHJlc3BvbnNlJywgcmVzcC5zdGF0dXNDb2RlLCBoZWFkZXJzKTtcbiAgICBvdXQuZW1pdCgncmVzcG9uc2UnLCByZXNwKTtcblxuICAgIHNldF90aW1lb3V0KCdyZWFkJywgY29uZmlnLnJlYWRfdGltZW91dCk7XG5cbiAgICAvLyBpZiB3ZSBnb3QgY29va2llcywgcGFyc2UgdGhlbSB1bmxlc3Mgd2Ugd2VyZSBpbnN0cnVjdGVkIG5vdCB0by4gbWFrZSBzdXJlIHRvIGluY2x1ZGUgYW55XG4gICAgLy8gY29va2llcyB0aGF0IG1pZ2h0IGhhdmUgYmVlbiBzZXQgb24gcHJldmlvdXMgcmVkaXJlY3RzLlxuICAgIGlmIChjb25maWcucGFyc2VfY29va2llcyAmJiAoaGVhZGVyc1snc2V0LWNvb2tpZSddIHx8IGNvbmZpZy5wcmV2aW91c19yZXNwX2Nvb2tpZXMpKSB7XG4gICAgICByZXNwLmNvb2tpZXMgPSBleHRlbmQoY29uZmlnLnByZXZpb3VzX3Jlc3BfY29va2llcyB8fCB7fSwgY29va2llcy5yZWFkKGhlYWRlcnNbJ3NldC1jb29raWUnXSkpO1xuICAgICAgZGVidWcoJ0dvdCBjb29raWVzJywgcmVzcC5jb29raWVzKTtcbiAgICB9XG5cbiAgICAvLyBpZiByZWRpcmVjdCBjb2RlIGlzIGZvdW5kLCBkZXRlcm1pbmUgaWYgd2Ugc2hvdWxkIGZvbGxvdyBpdCBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIG9wdGlvbnMuXG4gICAgaWYgKHJlZGlyZWN0X2NvZGVzLmluZGV4T2YocmVzcC5zdGF0dXNDb2RlKSAhPT0gLTEgJiYgc2VsZi5zaG91bGRfZm9sbG93KGhlYWRlcnMubG9jYXRpb24sIGNvbmZpZywgdXJpKSkge1xuICAgICAgLy8gY2xlYXIgdGltZXIgYmVmb3JlIGZvbGxvd2luZyByZWRpcmVjdHMgdG8gcHJldmVudCB1bmV4cGVjdGVkIHNldFRpbWVvdXQgY29uc2VxdWVuY2VcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG5cbiAgICAgIGlmIChjb3VudCA8PSBjb25maWcuZm9sbG93X21heCkge1xuICAgICAgICBvdXQuZW1pdCgncmVkaXJlY3QnLCBoZWFkZXJzLmxvY2F0aW9uKTtcblxuICAgICAgICAvLyB1bmxlc3MgJ2ZvbGxvd19rZWVwX21ldGhvZCcgaXMgdHJ1ZSwgcmV3cml0ZSB0aGUgcmVxdWVzdCB0byBHRVQgYmVmb3JlIGNvbnRpbnVpbmcuXG4gICAgICAgIGlmICghY29uZmlnLmZvbGxvd19rZWVwX21ldGhvZCkge1xuICAgICAgICAgIG1ldGhvZCAgICA9ICdHRVQnO1xuICAgICAgICAgIHBvc3RfZGF0YSA9IG51bGw7XG4gICAgICAgICAgZGVsZXRlIGNvbmZpZy5oZWFkZXJzWydjb250ZW50LWxlbmd0aCddOyAvLyBpbiBjYXNlIHRoZSBvcmlnaW5hbCB3YXMgYSBtdWx0aXBhcnQgUE9TVCByZXF1ZXN0LlxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgZm9sbG93X3NldF9jb29raWVzIGlzIHRydWUsIGluc2VydCBjb29raWVzIGluIHRoZSBuZXh0IHJlcXVlc3QncyBoZWFkZXJzLlxuICAgICAgICAvLyB3ZSBzZXQgYm90aCB0aGUgb3JpZ2luYWwgcmVxdWVzdCBjb29raWVzIHBsdXMgYW55IHJlc3BvbnNlIGNvb2tpZXMgd2UgbWlnaHQgaGF2ZSByZWNlaXZlZC5cbiAgICAgICAgaWYgKGNvbmZpZy5mb2xsb3dfc2V0X2Nvb2tpZXMpIHtcbiAgICAgICAgICB2YXIgcmVxdWVzdF9jb29raWVzID0gY29va2llcy5yZWFkKGNvbmZpZy5oZWFkZXJzWydjb29raWUnXSk7XG4gICAgICAgICAgY29uZmlnLnByZXZpb3VzX3Jlc3BfY29va2llcyA9IHJlc3AuY29va2llcztcbiAgICAgICAgICBpZiAoT2JqZWN0LmtleXMocmVxdWVzdF9jb29raWVzKS5sZW5ndGggfHwgT2JqZWN0LmtleXMocmVzcC5jb29raWVzIHx8IHt9KS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbmZpZy5oZWFkZXJzWydjb29raWUnXSA9IGNvb2tpZXMud3JpdGUoZXh0ZW5kKHJlcXVlc3RfY29va2llcywgcmVzcC5jb29raWVzKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5oZWFkZXJzWydjb29raWUnXSkge1xuICAgICAgICAgIGRlYnVnKCdDbGVhcmluZyBvcmlnaW5hbCByZXF1ZXN0IGNvb2tpZScsIGNvbmZpZy5oZWFkZXJzWydjb29raWUnXSk7XG4gICAgICAgICAgZGVsZXRlIGNvbmZpZy5oZWFkZXJzWydjb29raWUnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuZm9sbG93X3NldF9yZWZlcmVyKVxuICAgICAgICAgIGNvbmZpZy5oZWFkZXJzWydyZWZlcmVyJ10gPSBlbmNvZGVVUkkodXJpKTsgLy8gdGhlIG9yaWdpbmFsLCBub3QgdGhlIGRlc3RpbmF0aW9uIFVSTC5cblxuICAgICAgICBjb25maWcuaGVhZGVyc1snaG9zdCddID0gbnVsbDsgLy8gY2xlYXIgcHJldmlvdXMgSG9zdCBoZWFkZXIgdG8gYXZvaWQgY29uZmxpY3RzLlxuXG4gICAgICAgIGRlYnVnKCdSZWRpcmVjdGluZyB0byAnICsgdXJsLnJlc29sdmUodXJpLCBoZWFkZXJzLmxvY2F0aW9uKSk7XG4gICAgICAgIHJldHVybiBzZWxmLnNlbmRfcmVxdWVzdCgrK2NvdW50LCBtZXRob2QsIHVybC5yZXNvbHZlKHVyaSwgaGVhZGVycy5sb2NhdGlvbiksIGNvbmZpZywgcG9zdF9kYXRhLCBvdXQsIGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnLmZvbGxvd19tYXggPiAwKSB7XG4gICAgICAgIHJldHVybiBkb25lKG5ldyBFcnJvcignTWF4IHJlZGlyZWN0cyByZWFjaGVkLiBQb3NzaWJsZSBsb29wIGluOiAnICsgaGVhZGVycy5sb2NhdGlvbikpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIGF1dGggaXMgcmVxdWVzdGVkIGFuZCBjcmVkZW50aWFscyB3ZXJlIG5vdCBwYXNzZWQsIHJlc2VuZCByZXF1ZXN0LCBwcm92aWRlZCB3ZSBoYXZlIHVzZXIvcGFzcy5cbiAgICBpZiAocmVzcC5zdGF0dXNDb2RlID09IDQwMSAmJiBoZWFkZXJzWyd3d3ctYXV0aGVudGljYXRlJ10gJiYgY29uZmlnLmNyZWRlbnRpYWxzKSB7XG4gICAgICBpZiAoIWNvbmZpZy5oZWFkZXJzWydhdXRob3JpemF0aW9uJ10pIHsgLy8gb25seSBpZiBhdXRoZW50aWNhdGlvbiBoYXNuJ3QgYmVlbiBzZW50XG4gICAgICAgIHZhciBhdXRoX2hlYWRlciA9IGF1dGguaGVhZGVyKGhlYWRlcnNbJ3d3dy1hdXRoZW50aWNhdGUnXSwgY29uZmlnLmNyZWRlbnRpYWxzLCByZXF1ZXN0X29wdHMpO1xuXG4gICAgICAgIGlmIChhdXRoX2hlYWRlcikge1xuICAgICAgICAgIGNvbmZpZy5oZWFkZXJzWydhdXRob3JpemF0aW9uJ10gPSBhdXRoX2hlYWRlcjtcbiAgICAgICAgICByZXR1cm4gc2VsZi5zZW5kX3JlcXVlc3QoY291bnQsIG1ldGhvZCwgdXJpLCBjb25maWcsIHBvc3RfZGF0YSwgb3V0LCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBvaywgc28gd2UgZ290IGEgdmFsaWQgKG5vbi1yZWRpcmVjdCAmIGF1dGhvcml6ZWQpIHJlc3BvbnNlLiBsZXQncyBub3RpZnkgdGhlIHN0cmVhbSBndXlzLlxuICAgIG91dC5lbWl0KCdoZWFkZXInLCByZXNwLnN0YXR1c0NvZGUsIGhlYWRlcnMpO1xuICAgIG91dC5lbWl0KCdoZWFkZXJzJywgaGVhZGVycyk7XG5cbiAgICB2YXIgcGlwZWxpbmUgICAgICA9IFtdLFxuICAgICAgICBtaW1lICAgICAgICAgID0gcGFyc2VfY29udGVudF90eXBlKGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddKSxcbiAgICAgICAgdGV4dF9yZXNwb25zZSA9IG1pbWUudHlwZSAmJiBtaW1lLnR5cGUuaW5kZXhPZigndGV4dC8nKSAhPSAtMTtcblxuICAgIC8vIFRvIHN0YXJ0LCBpZiBvdXIgYm9keSBpcyBjb21wcmVzc2VkIGFuZCB3ZSdyZSBhYmxlIHRvIGluZmxhdGUgaXQsIGRvIGl0LlxuICAgIGlmIChoZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ10gJiYgZGVjb21wcmVzc29yc1toZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ11dKSB7XG5cbiAgICAgIHZhciBkZWNvbXByZXNzb3IgPSBkZWNvbXByZXNzb3JzW2hlYWRlcnNbJ2NvbnRlbnQtZW5jb2RpbmcnXV0oemxpYl9vcHRpb25zKTtcblxuICAgICAgLy8gbWFrZSBzdXJlIHdlIGNhdGNoIGVycm9ycyB0cmlnZ2VyZWQgYnkgdGhlIGRlY29tcHJlc3Nvci5cbiAgICAgIGRlY29tcHJlc3Nvci5vbignZXJyb3InLCBoYWRfZXJyb3IpO1xuICAgICAgcGlwZWxpbmUucHVzaChkZWNvbXByZXNzb3IpO1xuICAgIH1cblxuICAgIC8vIElmIHBhcnNlIGlzIGVuYWJsZWQgYW5kIHdlIGhhdmUgYSBwYXJzZXIgZm9yIGl0LCB0aGVuIGdvIGZvciBpdC5cbiAgICBpZiAoY29uZmlnLnBhcnNlciAmJiBwYXJzZXJzW21pbWUudHlwZV0pIHtcblxuICAgICAgLy8gSWYgYSBzcGVjaWZpYyBwYXJzZXIgd2FzIHJlcXVlc3RlZCwgbWFrZSBzdXJlIHdlIGRvbid0IHBhcnNlIG90aGVyIHR5cGVzLlxuICAgICAgdmFyIHBhcnNlcl9uYW1lID0gY29uZmlnLnBhcnNlci50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoWyd4bWwnLCAnanNvbiddLmluZGV4T2YocGFyc2VyX25hbWUpID09IC0xIHx8IHBhcnNlcnNbbWltZS50eXBlXS5uYW1lID09IHBhcnNlcl9uYW1lKSB7XG5cbiAgICAgICAgLy8gT0ssIHNvIGVpdGhlciB3ZSdyZSBwYXJzaW5nIGFsbCBjb250ZW50IHR5cGVzIG9yIHRoZSBvbmUgcmVxdWVzdGVkIG1hdGNoZXMuXG4gICAgICAgIG91dC5wYXJzZXIgPSBwYXJzZXJzW21pbWUudHlwZV0ubmFtZTtcbiAgICAgICAgcGlwZWxpbmUucHVzaChwYXJzZXJzW21pbWUudHlwZV0uZm4oKSk7XG5cbiAgICAgICAgLy8gU2V0IG9iamVjdE1vZGUgb24gb3V0IHN0cmVhbSB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuICAgICAgICBvdXQuX3dyaXRhYmxlU3RhdGUub2JqZWN0TW9kZSA9IHRydWU7XG4gICAgICAgIG91dC5fcmVhZGFibGVTdGF0ZS5vYmplY3RNb2RlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgIC8vIElmIHdlJ3JlIG5vdCBwYXJzaW5nLCBhbmQgdW5sZXNzIGRlY29kaW5nIHdhcyBkaXNhYmxlZCwgd2UnbGwgdHJ5XG4gICAgLy8gZGVjb2Rpbmcgbm9uIFVURi04IGJvZGllcyB0byBVVEYtOCwgdXNpbmcgdGhlIGljb252LWxpdGUgbGlicmFyeS5cbiAgICB9IGVsc2UgaWYgKHRleHRfcmVzcG9uc2UgJiYgY29uZmlnLmRlY29kZV9yZXNwb25zZVxuICAgICAgJiYgbWltZS5jaGFyc2V0KSB7XG4gICAgICAgIHBpcGVsaW5lLnB1c2goZGVjb2RlcihtaW1lLmNoYXJzZXQpKTtcbiAgICB9XG4gICAgLy8gQW5kIGBvdXRgIGlzIHRoZSBzdHJlYW0gd2UgZmluYWxseSBwdXNoIHRoZSBkZWNvZGVkL3BhcnNlZCBvdXRwdXQgdG8uXG4gICAgcGlwZWxpbmUucHVzaChvdXQpO1xuXG4gICAgLy8gTm93LCByZWxlYXNlIHRoZSBrcmFrZW4hXG4gICAgdmFyIHRtcCA9IHJlc3A7XG4gICAgd2hpbGUgKHBpcGVsaW5lLmxlbmd0aCkge1xuICAgICAgdG1wID0gdG1wLnBpcGUocGlwZWxpbmUuc2hpZnQoKSk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHVzZXIgaGFzIHJlcXVlc3RlZCBhbmQgb3V0cHV0IGZpbGUsIHBpcGUgdGhlIG91dHB1dCBzdHJlYW0gdG8gaXQuXG4gICAgLy8gSW4gc3RyZWFtIG1vZGUsIHdlIHdpbGwgc3RpbGwgZ2V0IHRoZSByZXNwb25zZSBzdHJlYW0gdG8gcGxheSB3aXRoLlxuICAgIGlmIChjb25maWcub3V0cHV0ICYmIHJlc3Auc3RhdHVzQ29kZSA9PSAyMDApIHtcblxuICAgICAgLy8gZm9yIHNvbWUgcmVhc29uLCBzaW1wbHkgcGlwaW5nIHJlc3AgdG8gdGhlIHdyaXRhYmxlIHN0cmVhbSBkb2Vzbid0XG4gICAgICAvLyB3b3JrIGFsbCB0aGUgdGltZSAoc3RyZWFtIGdldHMgY3V0IGluIHRoZSBtaWRkbGUgd2l0aCBubyB3YXJuaW5nKS5cbiAgICAgIC8vIHNvIHdlJ2xsIG1hbnVhbGx5IG5lZWQgdG8gZG8gdGhlIHJlYWRhYmxlL3dyaXRlKGNodW5rKSB0cmljay5cbiAgICAgIHZhciBmaWxlID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0oY29uZmlnLm91dHB1dCk7XG4gICAgICBmaWxlLm9uKCdlcnJvcicsIGhhZF9lcnJvcik7XG5cbiAgICAgIG91dC5vbignZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChmaWxlLndyaXRhYmxlKSBmaWxlLmVuZCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGZpbGUub24oJ2Nsb3NlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGRlbGV0ZSBvdXQuZmlsZTtcbiAgICAgIH0pXG5cbiAgICAgIG91dC5vbigncmVhZGFibGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNodW5rO1xuICAgICAgICB3aGlsZSAoKGNodW5rID0gdGhpcy5yZWFkKCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKGZpbGUud3JpdGFibGUpIGZpbGUud3JpdGUoY2h1bmspO1xuXG4gICAgICAgICAgLy8gaWYgY2FsbGJhY2sgd2FzIHJlcXVlc3RlZCwgYWxzbyBwdXNoIGl0IHRvIHJlc3AuYm9keVxuICAgICAgICAgIGlmIChyZXNwLmJvZHkpIHJlc3AuYm9keS5wdXNoKGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgb3V0LmZpbGUgPSBmaWxlO1xuICAgIH1cblxuICAgIC8vIE9ubHkgYWdncmVnYXRlIHRoZSBmdWxsIGJvZHkgaWYgYSBjYWxsYmFjayB3YXMgcmVxdWVzdGVkLlxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgcmVzcC5yYXcgICA9IFtdO1xuICAgICAgcmVzcC5ib2R5ICA9IFtdO1xuICAgICAgcmVzcC5ieXRlcyA9IDA7XG5cbiAgICAgIC8vIEdhdGhlciBhbmQgY291bnQgdGhlIGFtb3VudCBvZiAocmF3KSBieXRlcyB1c2luZyBhIFBhc3NUaHJvdWdoIHN0cmVhbS5cbiAgICAgIHZhciBjbGVhbl9waXBlID0gbmV3IHN0cmVhbS5QYXNzVGhyb3VnaCgpO1xuICAgICAgcmVzcC5waXBlKGNsZWFuX3BpcGUpO1xuXG4gICAgICBjbGVhbl9waXBlLm9uKCdyZWFkYWJsZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2h1bms7XG4gICAgICAgIHdoaWxlICgoY2h1bmsgPSB0aGlzLnJlYWQoKSkgIT0gbnVsbCkge1xuICAgICAgICAgIHJlc3AuYnl0ZXMgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICAgIHJlc3AucmF3LnB1c2goY2h1bmspO1xuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICAvLyBMaXN0ZW4gb24gdGhlICdyZWFkYWJsZScgZXZlbnQgdG8gYWdncmVnYXRlIHRoZSBjaHVua3MsIGJ1dCBvbmx5IGlmXG4gICAgICAvLyBmaWxlIG91dHB1dCB3YXNuJ3QgcmVxdWVzdGVkLiBPdGhlcndpc2Ugd2UnZCBoYXZlIHR3byBzdHJlYW0gcmVhZGVycy5cbiAgICAgIGlmICghY29uZmlnLm91dHB1dCB8fCByZXNwLnN0YXR1c0NvZGUgIT0gMjAwKSB7XG4gICAgICAgIG91dC5vbigncmVhZGFibGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgY2h1bms7XG4gICAgICAgICAgd2hpbGUgKChjaHVuayA9IHRoaXMucmVhZCgpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gV2UncmUgZWl0aGVyIHB1c2hpbmcgYnVmZmVycyBvciBvYmplY3RzLCBuZXZlciBzdHJpbmdzLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PSAnc3RyaW5nJykgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuayk7XG5cbiAgICAgICAgICAgIC8vIFB1c2ggYWxsIGNodW5rcyB0byByZXNwLmJvZHkuIFdlJ2xsIGJpbmQgdGhlbSBpbiByZXNwLmVuZCgpLlxuICAgICAgICAgICAgcmVzcC5ib2R5LnB1c2goY2h1bmspO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbmQgc2V0IHRoZSAuYm9keSBwcm9wZXJ0eSBvbmNlIGFsbCBkYXRhIGlzIGluLlxuICAgIG91dC5vbignZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAocmVzcC5ib2R5KSB7IC8vIGNhbGxiYWNrIG1vZGVcblxuICAgICAgICAvLyB3ZSB3YW50IHRvIGJlIGFibGUgdG8gYWNjZXNzIHRvIHRoZSByYXcgZGF0YSBsYXRlciwgc28ga2VlcCBhIHJlZmVyZW5jZS5cbiAgICAgICAgcmVzcC5yYXcgPSBCdWZmZXIuY29uY2F0KHJlc3AucmF3KTtcblxuICAgICAgICAvLyBpZiBwYXJzZSB3YXMgc3VjY2Vzc2Z1bCwgd2Ugc2hvdWxkIGhhdmUgYW4gYXJyYXkgd2l0aCBvbmUgb2JqZWN0XG4gICAgICAgIGlmIChyZXNwLmJvZHlbMF0gIT09IHVuZGVmaW5lZCAmJiAhQnVmZmVyLmlzQnVmZmVyKHJlc3AuYm9keVswXSkpIHtcblxuICAgICAgICAgIC8vIHRoYXQncyBvdXIgYm9keSByaWdodCB0aGVyZS5cbiAgICAgICAgICByZXNwLmJvZHkgPSByZXNwLmJvZHlbMF07XG5cbiAgICAgICAgICAvLyBzZXQgdGhlIHBhcnNlciBwcm9wZXJ0eSBvbiBvdXIgcmVzcG9uc2UuIHdlIG1heSB3YW50IHRvIGNoZWNrLlxuICAgICAgICAgIGlmIChvdXQucGFyc2VyKSByZXNwLnBhcnNlciA9IG91dC5wYXJzZXI7XG5cbiAgICAgICAgfSBlbHNlIHsgLy8gd2UgZ290IG9uZSBvciBzZXZlcmFsIGJ1ZmZlcnMuIHN0cmluZyBvciBiaW5hcnkuXG4gICAgICAgICAgcmVzcC5ib2R5ID0gQnVmZmVyLmNvbmNhdChyZXNwLmJvZHkpO1xuXG4gICAgICAgICAgLy8gaWYgd2UncmUgaGVyZSBhbmQgcGFyc2VkIGlzIHRydWUsIGl0IG1lYW5zIHdlIHRyaWVkIHRvIGJ1dCBpdCBkaWRuJ3Qgd29yay5cbiAgICAgICAgICAvLyBzbyBnaXZlbiB0aGF0IHdlIGdvdCBhIHRleHQgcmVzcG9uc2UsIGxldCdzIHN0cmluZ2lmeSBpdC5cbiAgICAgICAgICBpZiAodGV4dF9yZXNwb25zZSB8fCBvdXQucGFyc2VyKSB7XG4gICAgICAgICAgICByZXNwLmJvZHkgPSByZXNwLmJvZHkudG9TdHJpbmcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gaWYgYW4gb3V0cHV0IGZpbGUgaXMgYmVpbmcgd3JpdHRlbiB0bywgbWFrZSBzdXJlIHRoZSBjYWxsYmFja1xuICAgICAgLy8gaXMgdHJpZ2dlcmVkIGFmdGVyIGFsbCBkYXRhIGhhcyBiZWVuIHdyaXR0ZW4gdG8gaXQuXG4gICAgICBpZiAob3V0LmZpbGUpIHtcbiAgICAgICAgb3V0LmZpbGUub24oJ2Nsb3NlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZG9uZShudWxsLCByZXNwLCByZXNwLmJvZHkpO1xuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHsgLy8gZWx2aXMgaGFzIGxlZnQgdGhlIGJ1aWxkaW5nLlxuICAgICAgICBkb25lKG51bGwsIHJlc3AsIHJlc3AuYm9keSk7XG4gICAgICB9XG5cbiAgICB9KTtcblxuICB9KTsgLy8gZW5kIHJlcXVlc3QgY2FsbFxuXG4gIC8vIHVubGVzcyBvcGVuX3RpbWVvdXQgd2FzIGRpc2FibGVkLCBzZXQgYSB0aW1lb3V0IHRvIGFib3J0IHRoZSByZXF1ZXN0LlxuICBzZXRfdGltZW91dCgnb3BlbicsIGNvbmZpZy5vcGVuX3RpbWVvdXQpO1xuXG4gIC8vIGhhbmRsZSBlcnJvcnMgb24gdGhlIHJlcXVlc3Qgb2JqZWN0LiB0aGluZ3MgbWlnaHQgZ2V0IGJ1bXB5LlxuICByZXF1ZXN0Lm9uKCdlcnJvcicsIGhhZF9lcnJvcik7XG5cbiAgLy8gbWFrZSBzdXJlIHRpbWVyIGlzIGNsZWFyZWQgaWYgcmVxdWVzdCBpcyBhYm9ydGVkIChpc3N1ZSAjMjU3KVxuICByZXF1ZXN0Lm9uY2UoJ2Fib3J0JywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRpbWVyKSBjbGVhclRpbWVvdXQodGltZXIpO1xuICB9KVxuXG4gIC8vIGhhbmRsZSBzb2NrZXQgJ2VuZCcgZXZlbnQgdG8gZW5zdXJlIHdlIGRvbid0IGdldCBkZWxheWVkIEVQSVBFIGVycm9ycy5cbiAgcmVxdWVzdC5vbmNlKCdzb2NrZXQnLCBmdW5jdGlvbihzb2NrZXQpIHtcbiAgICBpZiAoc29ja2V0LmNvbm5lY3RpbmcpIHtcbiAgICAgIHNvY2tldC5vbmNlKCdjb25uZWN0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHNldF90aW1lb3V0KCdyZXNwb25zZScsIGNvbmZpZy5yZXNwb25zZV90aW1lb3V0KTtcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHNldF90aW1lb3V0KCdyZXNwb25zZScsIGNvbmZpZy5yZXNwb25zZV90aW1lb3V0KTtcbiAgICB9XG5cbiAgICAvLyBjb25zb2xlLmxvZyhzb2NrZXQpO1xuICAgIGlmICghc29ja2V0Lm9uX3NvY2tldF9lbmQpIHtcbiAgICAgIHNvY2tldC5vbl9zb2NrZXRfZW5kID0gb25fc29ja2V0X2VuZDtcbiAgICAgIHNvY2tldC5vbmNlKCdlbmQnLCBmdW5jdGlvbigpIHsgcHJvY2Vzcy5uZXh0VGljayhvbl9zb2NrZXRfZW5kLmJpbmQoc29ja2V0KSkgfSk7XG4gICAgfVxuICB9KVxuXG4gIGlmIChwb3N0X2RhdGEpIHtcbiAgICBpZiAoaXNfc3RyZWFtKHBvc3RfZGF0YSkpIHtcbiAgICAgIHBvc3RfZGF0YS5waXBlKHJlcXVlc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXF1ZXN0LndyaXRlKHBvc3RfZGF0YSwgY29uZmlnLmVuY29kaW5nKTtcbiAgICAgIHJlcXVlc3QuZW5kKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlcXVlc3QuZW5kKCk7XG4gIH1cblxuICBvdXQucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gZXhwb3J0c1xuXG5pZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZlcmIsIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICBpZiAoYXJnc1swXS5tYXRjaCgvXFwufFxcLy8pKSAvLyBmaXJzdCBhcmd1bWVudCBsb29rcyBsaWtlIGEgVVJMXG4gICAgICB2ZXJiID0gKGFyZ3MubGVuZ3RoID4gMikgPyAncG9zdCcgOiAnZ2V0JztcbiAgICBlbHNlXG4gICAgICB2ZXJiID0gYXJncy5zaGlmdCgpO1xuXG4gICAgaWYgKHZlcmIubWF0Y2goL2dldHxoZWFkLykgJiYgYXJncy5sZW5ndGggPT0gMilcbiAgICAgIGFyZ3Muc3BsaWNlKDEsIDAsIG51bGwpOyAvLyBhc3N1bWUgbm8gZGF0YSBpZiBoZWFkL2dldCB3aXRoIHR3byBhcmdzICh1cmwsIG9wdGlvbnMpXG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBtb2R1bGUuZXhwb3J0cy5yZXF1ZXN0KHZlcmIsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGZ1bmN0aW9uKGVyciwgcmVzcCkge1xuICAgICAgICByZXR1cm4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKHJlc3ApO1xuICAgICAgfSk7XG4gICAgfSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcblxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdHMgPSBmdW5jdGlvbihvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIHZhciB0YXJnZXRfa2V5ID0gYWxpYXNlZC5vcHRpb25zW2tleV0gfHwga2V5O1xuXG4gICAgaWYgKGRlZmF1bHRzLmhhc093blByb3BlcnR5KHRhcmdldF9rZXkpICYmIHR5cGVvZiBvYmpba2V5XSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKHRhcmdldF9rZXkgIT0gJ3BhcnNlX3Jlc3BvbnNlJyAmJiB0YXJnZXRfa2V5ICE9ICdwcm94eScpIHtcbiAgICAgICAgLy8gZW5zdXJlIHR5cGUgbWF0Y2hlcyB0aGUgb3JpZ2luYWwsIGV4Y2VwdCBmb3IgcHJveHkvcGFyc2VfcmVzcG9uc2UgdGhhdCBjYW4gYmUgbnVsbC9ib29sIG9yIHN0cmluZ1xuICAgICAgICB2YXIgdmFsaWRfdHlwZSA9IGRlZmF1bHRzW3RhcmdldF9rZXldLmNvbnN0cnVjdG9yLm5hbWU7XG5cbiAgICAgICAgaWYgKG9ialtrZXldLmNvbnN0cnVjdG9yLm5hbWUgIT0gdmFsaWRfdHlwZSlcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHR5cGUgZm9yICcgKyBrZXkgKyAnLCBzaG91bGQgYmUgJyArIHZhbGlkX3R5cGUpO1xuICAgICAgfVxuICAgICAgZGVmYXVsdHNbdGFyZ2V0X2tleV0gPSBvYmpba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHByb3BlcnR5IGZvciBkZWZhdWx0czonICsgdGFyZ2V0X2tleSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRzO1xufVxuXG4naGVhZCBnZXQnLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgbW9kdWxlLmV4cG9ydHNbbWV0aG9kXSA9IGZ1bmN0aW9uKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gbmV3IE5lZWRsZShtZXRob2QsIHVyaSwgbnVsbCwgb3B0aW9ucywgY2FsbGJhY2spLnN0YXJ0KCk7XG4gIH1cbn0pXG5cbidwb3N0IHB1dCBwYXRjaCBkZWxldGUnLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgbW9kdWxlLmV4cG9ydHNbbWV0aG9kXSA9IGZ1bmN0aW9uKHVyaSwgZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gbmV3IE5lZWRsZShtZXRob2QsIHVyaSwgZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spLnN0YXJ0KCk7XG4gIH1cbn0pXG5cbm1vZHVsZS5leHBvcnRzLnJlcXVlc3QgPSBmdW5jdGlvbihtZXRob2QsIHVyaSwgZGF0YSwgb3B0cywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIG5ldyBOZWVkbGUobWV0aG9kLCB1cmksIGRhdGEsIG9wdHMsIGNhbGxiYWNrKS5zdGFydCgpO1xufTtcbiIsIi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gRGVmaW5lcyBtYXBwaW5ncyBiZXR3ZWVuIGNvbnRlbnQtdHlwZVxuLy8gYW5kIHRoZSBhcHByb3ByaWF0ZSBwYXJzZXJzLlxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdzdHJlYW0nKS5UcmFuc2Zvcm07XG52YXIgc2F4ID0gcmVxdWlyZSgnc2F4Jyk7XG5cbmZ1bmN0aW9uIHBhcnNlWE1MKHN0ciwgY2IpIHtcbiAgdmFyIG9iaiwgY3VycmVudCwgcGFyc2VyID0gc2F4LnBhcnNlcih0cnVlLCB7IHRyaW06IHRydWUsIGxvd2VyY2FzZTogdHJ1ZSB9KVxuICBwYXJzZXIub25lcnJvciA9IHBhcnNlci5vbmVuZCA9IGRvbmU7XG5cbiAgZnVuY3Rpb24gZG9uZShlcnIpIHtcbiAgICBwYXJzZXIub25lcnJvciA9IHBhcnNlci5vbmVuZCA9IGZ1bmN0aW9uKCkgeyB9XG4gICAgY2IoZXJyLCBvYmopXG4gIH1cblxuICBmdW5jdGlvbiBuZXdFbGVtZW50KG5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSB8fCAnJyxcbiAgICAgIHZhbHVlOiAnJyxcbiAgICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMgfHwge30sXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9XG4gIH1cblxuICBwYXJzZXIub25jZGF0YSA9IHBhcnNlci5vbnRleHQgPSBmdW5jdGlvbih0KSB7XG4gICAgaWYgKGN1cnJlbnQpIGN1cnJlbnQudmFsdWUgKz0gdFxuICB9XG5cbiAgcGFyc2VyLm9ub3BlbnRhZyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgZWxlbWVudCA9IG5ld0VsZW1lbnQobm9kZS5uYW1lLCBub2RlLmF0dHJpYnV0ZXMpXG4gICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgIGVsZW1lbnQucGFyZW50ID0gY3VycmVudFxuICAgICAgY3VycmVudC5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpXG4gICAgfSBlbHNlIHsgLy8gcm9vdCBvYmplY3RcbiAgICAgIG9iaiA9IGVsZW1lbnRcbiAgICB9XG5cbiAgICBjdXJyZW50ID0gZWxlbWVudFxuICB9O1xuXG4gIHBhcnNlci5vbmNsb3NldGFnID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHR5cGVvZiBjdXJyZW50LnBhcmVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBqdXN0X2Nsb3NlZCA9IGN1cnJlbnRcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudFxuICAgICAgZGVsZXRlIGp1c3RfY2xvc2VkLnBhcmVudFxuICAgIH1cbiAgfVxuXG4gIHBhcnNlci53cml0ZShzdHIpLmNsb3NlKClcbn1cblxuZnVuY3Rpb24gcGFyc2VyRmFjdG9yeShuYW1lLCBmbikge1xuXG4gIGZ1bmN0aW9uIHBhcnNlcigpIHtcbiAgICB2YXIgY2h1bmtzID0gW10sXG4gICAgICAgIHN0cmVhbSA9IG5ldyBUcmFuc2Zvcm0oeyBvYmplY3RNb2RlOiB0cnVlIH0pO1xuXG4gICAgLy8gQnVmZmVyIGFsbCBvdXIgZGF0YVxuICAgIHN0cmVhbS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBkb25lKSB7XG4gICAgICBjaHVua3MucHVzaChjaHVuayk7XG4gICAgICBkb25lKCk7XG4gICAgfVxuXG4gICAgLy8gQW5kIGNhbGwgdGhlIHBhcnNlciB3aGVuIGFsbCBpcyB0aGVyZS5cbiAgICBzdHJlYW0uX2ZsdXNoID0gZnVuY3Rpb24oZG9uZSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgIGRhdGEgPSBCdWZmZXIuY29uY2F0KGNodW5rcyk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKGRhdGEsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gICAgICAgICAgaWYgKGVycikgdGhyb3cgZXJyO1xuICAgICAgICAgIHNlbGYucHVzaChyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBzZWxmLnB1c2goZGF0YSk7IC8vIGp1c3QgcGFzcyB0aGUgb3JpZ2luYWwgZGF0YVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHJlYW07XG4gIH1cblxuICByZXR1cm4geyBmbjogcGFyc2VyLCBuYW1lOiBuYW1lIH07XG59XG5cbnZhciBwYXJzZXJzID0ge31cblxuZnVuY3Rpb24gYnVpbGRQYXJzZXIobmFtZSwgdHlwZXMsIGZuKSB7XG4gIHZhciBwYXJzZXIgPSBwYXJzZXJGYWN0b3J5KG5hbWUsIGZuKTtcbiAgdHlwZXMuZm9yRWFjaChmdW5jdGlvbih0eXBlKSB7XG4gICAgcGFyc2Vyc1t0eXBlXSA9IHBhcnNlcjtcbiAgfSlcbn1cblxuYnVpbGRQYXJzZXIoJ2pzb24nLCBbXG4gICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgJ3RleHQvamF2YXNjcmlwdCdcbl0sIGZ1bmN0aW9uKGJ1ZmZlciwgY2IpIHtcbiAgdmFyIGVyciwgZGF0YTtcbiAgdHJ5IHsgZGF0YSA9IEpTT04ucGFyc2UoYnVmZmVyKTsgfSBjYXRjaCAoZSkgeyBlcnIgPSBlOyB9XG4gIGNiKGVyciwgZGF0YSk7XG59KTtcblxuYnVpbGRQYXJzZXIoJ3htbCcsIFtcbiAgJ3RleHQveG1sJyxcbiAgJ2FwcGxpY2F0aW9uL3htbCcsXG4gICdhcHBsaWNhdGlvbi9yZGYreG1sJyxcbiAgJ2FwcGxpY2F0aW9uL3Jzcyt4bWwnLFxuICAnYXBwbGljYXRpb24vYXRvbSt4bWwnXG5dLCBmdW5jdGlvbihidWZmZXIsIGNiKSB7XG4gIHBhcnNlWE1MKGJ1ZmZlci50b1N0cmluZygpLCBmdW5jdGlvbihlcnIsIG9iaikge1xuICAgIGNiKGVyciwgb2JqKVxuICB9KVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2Vycztcbm1vZHVsZS5leHBvcnRzLnVzZSA9IGJ1aWxkUGFyc2VyO1xuIiwiLy8gYmFzZWQgb24gdGhlIHFzIG1vZHVsZSwgYnV0IGhhbmRsZXMgbnVsbCBvYmplY3RzIGFzIGV4cGVjdGVkXG4vLyBmaXhlcyBieSBUb21hcyBQb2xsYWsuXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShvYmosIHByZWZpeCkge1xuICBpZiAocHJlZml4ICYmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA9PSAndW5kZWZpbmVkJykpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgJz0nO1xuICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5KG9iaiwgcHJlZml4KTtcbiAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0KG9iaiwgcHJlZml4KTtcbiAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgRGF0ZV0nKSB7XG4gICAgcmV0dXJuIG9iai50b0lTT1N0cmluZygpO1xuICB9IGVsc2UgaWYgKHByZWZpeCkgeyAvLyBzdHJpbmcgaW5zaWRlIGFycmF5IG9yIGhhc2hcbiAgICByZXR1cm4gcHJlZml4ICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhvYmopKTtcbiAgfSBlbHNlIGlmIChTdHJpbmcob2JqKS5pbmRleE9mKCc9JykgIT09IC0xKSB7IC8vIHN0cmluZyB3aXRoIGVxdWFsIHNpZ25cbiAgICByZXR1cm4gU3RyaW5nKG9iaik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGJ1aWxkIGEgcXVlcnlzdHJpbmcgb3V0IG9mOiAnICsgb2JqKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gc3RyaW5naWZ5QXJyYXkoYXJyLCBwcmVmaXgpIHtcbiAgdmFyIHJldCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAocHJlZml4KVxuICAgICAgcmV0LnB1c2goc3RyaW5naWZ5KGFycltpXSwgcHJlZml4ICsgJ1tdJykpO1xuICAgIGVsc2VcbiAgICAgIHJldC5wdXNoKHN0cmluZ2lmeShhcnJbaV0pKTtcbiAgfVxuXG4gIHJldHVybiByZXQuam9pbignJicpO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlPYmplY3Qob2JqLCBwcmVmaXgpIHtcbiAgdmFyIHJldCA9IFtdO1xuXG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICByZXQucHVzaChzdHJpbmdpZnkob2JqW2tleV0sIHByZWZpeFxuICAgICAgPyBwcmVmaXggKyAnWycgKyBlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICddJ1xuICAgICAgOiBlbmNvZGVVUklDb21wb25lbnQoa2V5KSkpO1xuICB9KVxuXG4gIHJldHVybiByZXQuam9pbignJicpO1xufVxuXG5leHBvcnRzLmJ1aWxkID0gc3RyaW5naWZ5O1xuIiwiZnVuY3Rpb24gd2VicGFja0VtcHR5Q29udGV4dChyZXEpIHtcblx0dmFyIGUgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInXCIpO1xuXHRlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7XG5cdHRocm93IGU7XG59XG53ZWJwYWNrRW1wdHlDb250ZXh0LmtleXMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIFtdOyB9O1xud2VicGFja0VtcHR5Q29udGV4dC5yZXNvbHZlID0gd2VicGFja0VtcHR5Q29udGV4dDtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0VtcHR5Q29udGV4dDtcbndlYnBhY2tFbXB0eUNvbnRleHQuaWQgPSBcIi4vbm9kZV9tb2R1bGVzL25vZGUtcHJlLWd5cC9saWIgc3luYyByZWN1cnNpdmVcIjsiLCJ2YXIgbWFwID0ge1xuXHRcIi4vYnVpbGRcIjogXCIuL25vZGVfbW9kdWxlcy9ub2RlLXByZS1neXAvbGliL2J1aWxkLmpzXCIsXG5cdFwiLi9idWlsZC5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL25vZGUtcHJlLWd5cC9saWIvYnVpbGQuanNcIixcblx0XCIuL2NsZWFuXCI6IFwiLi9ub2RlX21vZHVsZXMvbm9kZS1wcmUtZ3lwL2xpYi9jbGVhbi5qc1wiLFxuXHRcIi4vY2xlYW4uanNcIjogXCIuL25vZGVfbW9kdWxlcy9ub2RlLXByZS1neXAvbGliL2NsZWFuLmpzXCIsXG5cdFwiLi9jb25maWd1cmVcIjogXCIuL25vZGVfbW9kdWxlcy9ub2RlLXByZS1neXAvbGliL2NvbmZpZ3VyZS5qc1wiLFxuXHRcIi4vY29uZmlndXJlLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbm9kZS1wcmUtZ3lwL2xpYi9jb25maWd1cmUuanNcIixcblx0XCIuL2luZm9cIjogXCIuL25vZGVfbW9kdWxlcy9ub2RlLXByZS1neXAvbGliL2luZm8uanNcIixcblx0XCIuL2luZm8uanNcIjogXCIuL25vZGVfbW9kdWxlcy9ub2RlLXByZS1neXAvbGliL2luZm8uanNcIixcblx0XCIuL2luc3RhbGxcIjogXCIuL25vZGVfbW9kdWxlcy9ub2RlLXByZS1neXAvbGliL2luc3RhbGwuanNcIixcblx0XCIuL2luc3RhbGwuanNcIjogXCIuL25vZGVfbW9kdWxlcy9ub2RlLXByZS1neXAvbGliL2luc3RhbGwuanNcIixcblx0XCIuL25vZGUtcHJlLWd5cFwiOiBcIi4vbm9kZV9tb2R1bGVzL25vZGUtcHJlLWd5cC9saWIvbm9kZS1wcmUtZ3lwLmpzXCIsXG5cdFwiLi9ub2RlLXByZS1neXAuanNcIjogXCIuL25vZGVfbW9kdWxlcy9ub2RlLXByZS1neXAvbGliL25vZGUtcHJlLWd5cC5qc1wiLFxuXHRcIi4vcGFja2FnZVwiOiBcIi4vbm9kZV9tb2R1bGVzL25vZGUtcHJlLWd5cC9saWIvcGFja2FnZS5qc1wiLFxuXHRcIi4vcGFja2FnZS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL25vZGUtcHJlLWd5cC9saWIvcGFja2FnZS5qc1wiLFxuXHRcIi4vcHJlLWJpbmRpbmdcIjogXCIuL25vZGVfbW9kdWxlcy9ub2RlLXByZS1neXAvbGliL3ByZS1iaW5kaW5nLmpzXCIsXG5cdFwiLi9wcmUtYmluZGluZy5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL25vZGUtcHJlLWd5cC9saWIvcHJlLWJpbmRpbmcuanNcIixcblx0XCIuL3B1Ymxpc2hcIjogXCIuL25vZGVfbW9kdWxlcy9ub2RlLXByZS1neXAvbGliL3B1Ymxpc2guanNcIixcblx0XCIuL3B1Ymxpc2guanNcIjogXCIuL25vZGVfbW9kdWxlcy9ub2RlLXByZS1neXAvbGliL3B1Ymxpc2guanNcIixcblx0XCIuL3JlYnVpbGRcIjogXCIuL25vZGVfbW9kdWxlcy9ub2RlLXByZS1neXAvbGliL3JlYnVpbGQuanNcIixcblx0XCIuL3JlYnVpbGQuanNcIjogXCIuL25vZGVfbW9kdWxlcy9ub2RlLXByZS1neXAvbGliL3JlYnVpbGQuanNcIixcblx0XCIuL3JlaW5zdGFsbFwiOiBcIi4vbm9kZV9tb2R1bGVzL25vZGUtcHJlLWd5cC9saWIvcmVpbnN0YWxsLmpzXCIsXG5cdFwiLi9yZWluc3RhbGwuanNcIjogXCIuL25vZGVfbW9kdWxlcy9ub2RlLXByZS1neXAvbGliL3JlaW5zdGFsbC5qc1wiLFxuXHRcIi4vcmV2ZWFsXCI6IFwiLi9ub2RlX21vZHVsZXMvbm9kZS1wcmUtZ3lwL2xpYi9yZXZlYWwuanNcIixcblx0XCIuL3JldmVhbC5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL25vZGUtcHJlLWd5cC9saWIvcmV2ZWFsLmpzXCIsXG5cdFwiLi90ZXN0YmluYXJ5XCI6IFwiLi9ub2RlX21vZHVsZXMvbm9kZS1wcmUtZ3lwL2xpYi90ZXN0YmluYXJ5LmpzXCIsXG5cdFwiLi90ZXN0YmluYXJ5LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbm9kZS1wcmUtZ3lwL2xpYi90ZXN0YmluYXJ5LmpzXCIsXG5cdFwiLi90ZXN0cGFja2FnZVwiOiBcIi4vbm9kZV9tb2R1bGVzL25vZGUtcHJlLWd5cC9saWIvdGVzdHBhY2thZ2UuanNcIixcblx0XCIuL3Rlc3RwYWNrYWdlLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbm9kZS1wcmUtZ3lwL2xpYi90ZXN0cGFja2FnZS5qc1wiLFxuXHRcIi4vdW5wdWJsaXNoXCI6IFwiLi9ub2RlX21vZHVsZXMvbm9kZS1wcmUtZ3lwL2xpYi91bnB1Ymxpc2guanNcIixcblx0XCIuL3VucHVibGlzaC5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL25vZGUtcHJlLWd5cC9saWIvdW5wdWJsaXNoLmpzXCIsXG5cdFwiLi91dGlsL2FiaV9jcm9zc3dhbGsuanNvblwiOiBcIi4vbm9kZV9tb2R1bGVzL25vZGUtcHJlLWd5cC9saWIvdXRpbC9hYmlfY3Jvc3N3YWxrLmpzb25cIixcblx0XCIuL3V0aWwvY29tcGlsZVwiOiBcIi4vbm9kZV9tb2R1bGVzL25vZGUtcHJlLWd5cC9saWIvdXRpbC9jb21waWxlLmpzXCIsXG5cdFwiLi91dGlsL2NvbXBpbGUuanNcIjogXCIuL25vZGVfbW9kdWxlcy9ub2RlLXByZS1neXAvbGliL3V0aWwvY29tcGlsZS5qc1wiLFxuXHRcIi4vdXRpbC9oYW5kbGVfZ3lwX29wdHNcIjogXCIuL25vZGVfbW9kdWxlcy9ub2RlLXByZS1neXAvbGliL3V0aWwvaGFuZGxlX2d5cF9vcHRzLmpzXCIsXG5cdFwiLi91dGlsL2hhbmRsZV9neXBfb3B0cy5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL25vZGUtcHJlLWd5cC9saWIvdXRpbC9oYW5kbGVfZ3lwX29wdHMuanNcIixcblx0XCIuL3V0aWwvbmFwaVwiOiBcIi4vbm9kZV9tb2R1bGVzL25vZGUtcHJlLWd5cC9saWIvdXRpbC9uYXBpLmpzXCIsXG5cdFwiLi91dGlsL25hcGkuanNcIjogXCIuL25vZGVfbW9kdWxlcy9ub2RlLXByZS1neXAvbGliL3V0aWwvbmFwaS5qc1wiLFxuXHRcIi4vdXRpbC9udy1wcmUtZ3lwL2luZGV4Lmh0bWxcIjogXCIuL25vZGVfbW9kdWxlcy9ub2RlLXByZS1neXAvbGliL3V0aWwvbnctcHJlLWd5cC9pbmRleC5odG1sXCIsXG5cdFwiLi91dGlsL253LXByZS1neXAvcGFja2FnZS5qc29uXCI6IFwiLi9ub2RlX21vZHVsZXMvbm9kZS1wcmUtZ3lwL2xpYi91dGlsL253LXByZS1neXAvcGFja2FnZS5qc29uXCIsXG5cdFwiLi91dGlsL3MzX3NldHVwXCI6IFwiLi9ub2RlX21vZHVsZXMvbm9kZS1wcmUtZ3lwL2xpYi91dGlsL3MzX3NldHVwLmpzXCIsXG5cdFwiLi91dGlsL3MzX3NldHVwLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbm9kZS1wcmUtZ3lwL2xpYi91dGlsL3MzX3NldHVwLmpzXCIsXG5cdFwiLi91dGlsL3ZlcnNpb25pbmdcIjogXCIuL25vZGVfbW9kdWxlcy9ub2RlLXByZS1neXAvbGliL3V0aWwvdmVyc2lvbmluZy5qc1wiLFxuXHRcIi4vdXRpbC92ZXJzaW9uaW5nLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbm9kZS1wcmUtZ3lwL2xpYi91dGlsL3ZlcnNpb25pbmcuanNcIlxufTtcblxuXG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dChyZXEpIHtcblx0dmFyIGlkID0gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSk7XG5cdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKGlkKTtcbn1cbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpIHtcblx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhtYXAsIHJlcSkpIHtcblx0XHR2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIidcIik7XG5cdFx0ZS5jb2RlID0gJ01PRFVMRV9OT1RfRk9VTkQnO1xuXHRcdHRocm93IGU7XG5cdH1cblx0cmV0dXJuIG1hcFtyZXFdO1xufVxud2VicGFja0NvbnRleHQua2V5cyA9IGZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0S2V5cygpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKG1hcCk7XG59O1xud2VicGFja0NvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZTtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0NvbnRleHQ7XG53ZWJwYWNrQ29udGV4dC5pZCA9IFwiLi9ub2RlX21vZHVsZXMvbm9kZS1wcmUtZ3lwL2xpYiBzeW5jIHJlY3Vyc2l2ZSBeXFxcXC5cXFxcLy4qJFwiOyIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBidWlsZDtcblxuZXhwb3J0cy51c2FnZSA9ICdBdHRlbXB0cyB0byBjb21waWxlIHRoZSBtb2R1bGUgYnkgZGlzcGF0Y2hpbmcgdG8gbm9kZS1neXAgb3IgbnctZ3lwJztcblxudmFyIG5hcGkgPSByZXF1aXJlKCcuL3V0aWwvbmFwaS5qcycpO1xudmFyIGNvbXBpbGUgPSByZXF1aXJlKCcuL3V0aWwvY29tcGlsZS5qcycpO1xudmFyIGhhbmRsZV9neXBfb3B0cyA9IHJlcXVpcmUoJy4vdXRpbC9oYW5kbGVfZ3lwX29wdHMuanMnKTtcbnZhciBjb25maWd1cmUgPSByZXF1aXJlKCcuL2NvbmZpZ3VyZS5qcycpO1xuXG5mdW5jdGlvbiBkb19idWlsZChneXAsYXJndixjYWxsYmFjaykge1xuICAgIGhhbmRsZV9neXBfb3B0cyhneXAsYXJndixmdW5jdGlvbihlcnIscmVzdWx0KSB7XG4gICAgICAgIHZhciBmaW5hbF9hcmdzID0gWydidWlsZCddLmNvbmNhdChyZXN1bHQuZ3lwKS5jb25jYXQocmVzdWx0LnByZSk7XG4gICAgICAgIGlmIChyZXN1bHQudW5wYXJzZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZmluYWxfYXJncyA9IGZpbmFsX2FyZ3MuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmNhdChbJy0tJ10pLlxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25jYXQocmVzdWx0LnVucGFyc2VkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVyciAmJiByZXN1bHQub3B0cy5uYXBpX2J1aWxkX3ZlcnNpb24pIHtcbiAgICAgICAgICAgIG5hcGkuc3dhcF9idWlsZF9kaXJfaW4ocmVzdWx0Lm9wdHMubmFwaV9idWlsZF92ZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjb21waWxlLnJ1bl9neXAoZmluYWxfYXJncyxyZXN1bHQub3B0cyxmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQub3B0cy5uYXBpX2J1aWxkX3ZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICBuYXBpLnN3YXBfYnVpbGRfZGlyX291dChyZXN1bHQub3B0cy5uYXBpX2J1aWxkX3ZlcnNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBidWlsZChneXAsIGFyZ3YsIGNhbGxiYWNrKSB7XG5cbiAgICAvLyBGb3JtIHVwIGNvbW1hbmRzIHRvIHBhc3MgdG8gbm9kZS1neXA6XG4gICAgLy8gV2UgbWFwIGBub2RlLXByZS1neXAgYnVpbGRgIHRvIGBub2RlLWd5cCBjb25maWd1cmUgYnVpbGRgIHNvIHRoYXQgd2UgZG8gbm90XG4gICAgLy8gdHJpZ2dlciBhIGNsZWFuIGFuZCB0aGVyZWZvcmUgZG8gbm90IHBheSB0aGUgcGVuYWx0eSBvZiBhIGZ1bGwgcmVjb21waWxlXG4gICAgaWYgKGFyZ3YubGVuZ3RoICYmIChhcmd2LmluZGV4T2YoJ3JlYnVpbGQnKSA+IC0xKSkge1xuICAgICAgICBhcmd2LnNoaWZ0KCk7IC8vIHJlbW92ZSBgcmVidWlsZGBcbiAgICAgICAgLy8gaGVyZSB3ZSBtYXAgYG5vZGUtcHJlLWd5cCByZWJ1aWxkYCB0byBgbm9kZS1neXAgcmVidWlsZGAgd2hpY2ggaW50ZXJuYWxseSBtZWFuc1xuICAgICAgICAvLyBcImNsZWFuICsgY29uZmlndXJlICsgYnVpbGRcIiBhbmQgdHJpZ2dlcnMgYSBmdWxsIHJlY29tcGlsZVxuICAgICAgICBjb21waWxlLnJ1bl9neXAoWydjbGVhbiddLHt9LGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICBjb25maWd1cmUoZ3lwLGFyZ3YsZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvX2J1aWxkKGd5cCxhcmd2LGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZG9fYnVpbGQoZ3lwLGFyZ3YsY2FsbGJhY2spOyAgICAgICAgXG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGNsZWFuO1xuXG5leHBvcnRzLnVzYWdlID0gJ1JlbW92ZXMgdGhlIGVudGlyZSBmb2xkZXIgY29udGFpbmluZyB0aGUgY29tcGlsZWQgLm5vZGUgbW9kdWxlJztcblxudmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbnZhciBybSA9IHJlcXVpcmUoJ3JpbXJhZicpO1xudmFyIGV4aXN0cyA9IHJlcXVpcmUoJ2ZzJykuZXhpc3RzIHx8IHJlcXVpcmUoJ3BhdGgnKS5leGlzdHM7XG52YXIgdmVyc2lvbmluZyA9IHJlcXVpcmUoJy4vdXRpbC92ZXJzaW9uaW5nLmpzJyk7XG52YXIgbmFwaSA9IHJlcXVpcmUoJy4vdXRpbC9uYXBpLmpzJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxuZnVuY3Rpb24gY2xlYW4gKGd5cCwgYXJndiwgY2FsbGJhY2spIHtcbiAgICB2YXIgcGFja2FnZV9qc29uID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMoJy4vcGFja2FnZS5qc29uJykpO1xuICAgIHZhciBuYXBpX2J1aWxkX3ZlcnNpb24gPSBuYXBpLmdldF9uYXBpX2J1aWxkX3ZlcnNpb25fZnJvbV9jb21tYW5kX2FyZ3MoYXJndik7XG4gICAgdmFyIG9wdHMgPSB2ZXJzaW9uaW5nLmV2YWx1YXRlKHBhY2thZ2VfanNvbiwgZ3lwLm9wdHMsIG5hcGlfYnVpbGRfdmVyc2lvbik7XG4gICAgdmFyIHRvX2RlbGV0ZSA9IG9wdHMubW9kdWxlX3BhdGg7XG4gICAgaWYgKCF0b19kZWxldGUpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihcIm1vZHVsZV9wYXRoIGlzIGVtcHR5LCByZWZ1c2luZyB0byBkZWxldGVcIikpO1xuICAgIH0gZWxzZSBpZiAocGF0aC5ub3JtYWxpemUodG9fZGVsZXRlKSA9PSBwYXRoLm5vcm1hbGl6ZShwcm9jZXNzLmN3ZCgpKSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKFwibW9kdWxlX3BhdGggaXMgbm90IHNldCwgcmVmdXNpbmcgdG8gZGVsZXRlXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBleGlzdHModG9fZGVsZXRlLCBmdW5jdGlvbihmb3VuZCkge1xuICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFneXAub3B0cy5zaWxlbnRfY2xlYW4pIGNvbnNvbGUubG9nKCdbJytwYWNrYWdlX2pzb24ubmFtZSsnXSBSZW1vdmluZyBcIiVzXCInLCB0b19kZWxldGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBybSh0b19kZWxldGUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gY29uZmlndXJlO1xuXG5leHBvcnRzLnVzYWdlID0gJ0F0dGVtcHRzIHRvIGNvbmZpZ3VyZSBub2RlLWd5cCBvciBudy1neXAgYnVpbGQnO1xuXG52YXIgbmFwaSA9IHJlcXVpcmUoJy4vdXRpbC9uYXBpLmpzJyk7XG52YXIgY29tcGlsZSA9IHJlcXVpcmUoJy4vdXRpbC9jb21waWxlLmpzJyk7XG52YXIgaGFuZGxlX2d5cF9vcHRzID0gcmVxdWlyZSgnLi91dGlsL2hhbmRsZV9neXBfb3B0cy5qcycpO1xuXG5mdW5jdGlvbiBjb25maWd1cmUoZ3lwLCBhcmd2LCBjYWxsYmFjaykge1xuICAgIGhhbmRsZV9neXBfb3B0cyhneXAsYXJndixmdW5jdGlvbihlcnIscmVzdWx0KSB7XG4gICAgICAgIHZhciBmaW5hbF9hcmdzID0gcmVzdWx0Lmd5cC5jb25jYXQocmVzdWx0LnByZSk7XG4gICAgICAgIC8vIHB1bGwgc2VsZWN0IG5vZGUtZ3lwIGNvbmZpZ3VyZSBvcHRpb25zIG91dCBvZiB0aGUgbnBtIGVudmlyb25cbiAgICAgICAgdmFyIGtub3duX2d5cF9hcmdzID0gWydkaXN0LXVybCcsJ3B5dGhvbicsJ25vZGVkaXInLCdtc3ZzX3ZlcnNpb24nXTtcbiAgICAgICAga25vd25fZ3lwX2FyZ3MuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBneXAub3B0c1trZXldIHx8IGd5cC5vcHRzW2tleS5yZXBsYWNlKCctJywnXycpXTtcbiAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgIGZpbmFsX2FyZ3MucHVzaCgnLS0nK2tleSsnPScrdmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIC0tZW5zdXJlPWZhbHNlIHRlbGwgbm9kZS1neXAgdG8gcmUtaW5zdGFsbCBub2RlIGRldmVsb3BtZW50IGhlYWRlcnNcbiAgICAgICAgLy8gYnV0IGl0IGlzIG9ubHkgcmVzcGVjdGVkIGJ5IG5vZGUtZ3lwIGluc3RhbGwsIHNvIHdlIGhhdmUgdG8gY2FsbCBpbnN0YWxsXG4gICAgICAgIC8vIGFzIGEgc2VwYXJhdGUgc3RlcCBpZiB0aGUgdXNlciBwYXNzZXMgaXRcbiAgICAgICAgaWYgKGd5cC5vcHRzLmVuc3VyZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YWxsX2FyZ3MgPSBmaW5hbF9hcmdzLmNvbmNhdChbJ2luc3RhbGwnLCctLWVuc3VyZT1mYWxzZSddKTtcbiAgICAgICAgICAgIGNvbXBpbGUucnVuX2d5cChpbnN0YWxsX2FyZ3MscmVzdWx0Lm9wdHMsZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC51bnBhcnNlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsX2FyZ3MgPSBmaW5hbF9hcmdzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmNhdChbJy0tJ10pLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmNhdChyZXN1bHQudW5wYXJzZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb21waWxlLnJ1bl9neXAoWydjb25maWd1cmUnXS5jb25jYXQoZmluYWxfYXJncykscmVzdWx0Lm9wdHMsZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnVucGFyc2VkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmaW5hbF9hcmdzID0gZmluYWxfYXJncy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmNhdChbJy0tJ10pLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uY2F0KHJlc3VsdC51bnBhcnNlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21waWxlLnJ1bl9neXAoWydjb25maWd1cmUnXS5jb25jYXQoZmluYWxfYXJncykscmVzdWx0Lm9wdHMsZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlcnIgJiYgcmVzdWx0Lm9wdHMubmFwaV9idWlsZF92ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hcGkuc3dhcF9idWlsZF9kaXJfb3V0KHJlc3VsdC5vcHRzLm5hcGlfYnVpbGRfdmVyc2lvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSB1bnB1Ymxpc2g7XG5cbmV4cG9ydHMudXNhZ2UgPSAnTGlzdHMgYWxsIHB1Ymxpc2hlZCBiaW5hcmllcyAocmVxdWlyZXMgYXdzLXNkayknO1xuXG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIGxvZyA9IHJlcXVpcmUoJ25wbWxvZycpO1xudmFyIHZlcnNpb25pbmcgPSByZXF1aXJlKCcuL3V0aWwvdmVyc2lvbmluZy5qcycpO1xudmFyIHMzX3NldHVwID0gcmVxdWlyZSgnLi91dGlsL3MzX3NldHVwLmpzJyk7XG52YXIgY29uZmlnID0gcmVxdWlyZSgncmMnKShcIm5vZGVfcHJlX2d5cFwiLHthY2w6XCJwdWJsaWMtcmVhZFwifSk7XG5cbmZ1bmN0aW9uIHVucHVibGlzaChneXAsIGFyZ3YsIGNhbGxiYWNrKSB7XG4gICAgdmFyIEFXUyA9IHJlcXVpcmUoXCJhd3Mtc2RrXCIpO1xuICAgIHZhciBwYWNrYWdlX2pzb24gPSBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYygnLi9wYWNrYWdlLmpzb24nKSk7XG4gICAgdmFyIG9wdHMgPSB2ZXJzaW9uaW5nLmV2YWx1YXRlKHBhY2thZ2VfanNvbiwgZ3lwLm9wdHMpO1xuICAgIHMzX3NldHVwLmRldGVjdChvcHRzLmhvc3RlZF9wYXRoLGNvbmZpZyk7XG4gICAgQVdTLmNvbmZpZy51cGRhdGUoY29uZmlnKTtcbiAgICB2YXIgczMgPSAgbmV3IEFXUy5TMygpO1xuICAgIHZhciBzM19vcHRzID0geyAgQnVja2V0OiBjb25maWcuYnVja2V0LFxuICAgICAgICAgICAgICAgICAgICAgUHJlZml4OiBjb25maWcucHJlZml4XG4gICAgICAgICAgICAgICAgICB9O1xuICAgIHMzLmxpc3RPYmplY3RzKHMzX29wdHMsIGZ1bmN0aW9uKGVyciwgbWV0YSl7XG4gICAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgPT0gJ05vdEZvdW5kJykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignWycrcGFja2FnZV9qc29uLm5hbWUrJ10gTm90IGZvdW5kOiBodHRwczovLycgKyBzM19vcHRzLkJ1Y2tldCArICcuczMuYW1hem9uYXdzLmNvbS8nK2NvbmZpZy5wcmVmaXgpKTtcbiAgICAgICAgfSBlbHNlIGlmKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2cudmVyYm9zZShKU09OLnN0cmluZ2lmeShtZXRhLG51bGwsMSkpO1xuICAgICAgICAgICAgaWYgKG1ldGEgJiYgbWV0YS5Db250ZW50cykge1xuICAgICAgICAgICAgICAgIG1ldGEuQ29udGVudHMuZm9yRWFjaChmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cob2JqLktleSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1snK3BhY2thZ2VfanNvbi5uYW1lKyddIE5vIG9iamVjdHMgZm91bmQgYXQgaHR0cHM6Ly8nICsgczNfb3B0cy5CdWNrZXQgKyAnLnMzLmFtYXpvbmF3cy5jb20vJytjb25maWcucHJlZml4ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGluc3RhbGw7XG5cbmV4cG9ydHMudXNhZ2UgPSAnQXR0ZW1wdHMgdG8gaW5zdGFsbCBwcmUtYnVpbHQgYmluYXJ5IGZvciBtb2R1bGUnO1xuXG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgbG9nID0gcmVxdWlyZSgnbnBtbG9nJyk7XG52YXIgZXhpc3RzQXN5bmMgPSBmcy5leGlzdHMgfHwgcGF0aC5leGlzdHM7XG52YXIgdmVyc2lvbmluZyA9IHJlcXVpcmUoJy4vdXRpbC92ZXJzaW9uaW5nLmpzJyk7XG52YXIgbmFwaSA9IHJlcXVpcmUoJy4vdXRpbC9uYXBpLmpzJyk7XG52YXIgbWtkaXJwID0gcmVxdWlyZSgnbWtkaXJwJyk7XG5cbnZhciBucGdWZXJzaW9uID0gJ3Vua25vd24nO1xudHJ5IHtcbiAgICAvLyBSZWFkIG93biBwYWNrYWdlLmpzb24gdG8gZ2V0IHRoZSBjdXJyZW50IG5vZGUtcHJlLXB5cCB2ZXJzaW9uLlxuICAgIHZhciBvd25QYWNrYWdlSlNPTiA9IGZzLnJlYWRGaWxlU3luYyhwYXRoLmpvaW4oX19kaXJuYW1lLCAnLi4nLCAncGFja2FnZS5qc29uJyksICd1dGY4Jyk7XG4gICAgbnBnVmVyc2lvbiA9IEpTT04ucGFyc2Uob3duUGFja2FnZUpTT04pLnZlcnNpb247XG59IGNhdGNoIChlKSB7fVxuXG52YXIgaHR0cF9nZXQgPSB7XG4gICAgaW1wbDogdW5kZWZpbmVkLFxuICAgIHR5cGU6IHVuZGVmaW5lZFxufTtcblxudHJ5IHtcbiAgaHR0cF9nZXQuaW1wbCA9IHJlcXVpcmUoJ3JlcXVlc3QnKTtcbiAgaHR0cF9nZXQudHlwZSA9ICdyZXF1ZXN0JztcbiAgbG9nLndhcm4oXCJVc2luZyByZXF1ZXN0IGZvciBub2RlLXByZS1neXAgaHR0cHMgZG93bmxvYWRcIik7XG59IGNhdGNoIChlKSB7XG4gIGh0dHBfZ2V0LmltcGwgPSByZXF1aXJlKCduZWVkbGUnKTtcbiAgaHR0cF9nZXQudHlwZSA9ICduZWVkbGUnO1xuICBsb2cud2FybihcIlVzaW5nIG5lZWRsZSBmb3Igbm9kZS1wcmUtZ3lwIGh0dHBzIGRvd25sb2FkXCIpO1xufVxuXG5mdW5jdGlvbiBkb3dubG9hZCh1cmksb3B0cyxjYWxsYmFjaykge1xuICAgIGxvZy5odHRwKCdHRVQnLCB1cmkpO1xuXG4gICAgdmFyIHJlcSA9IG51bGw7XG5cbiAgICAvLyBUcnkgZ2V0dGluZyB2ZXJzaW9uIGluZm8gZnJvbSB0aGUgY3VycmVudGx5IHJ1bm5pbmcgbnBtLlxuICAgIHZhciBlbnZWZXJzaW9uSW5mbyA9IHByb2Nlc3MuZW52Lm5wbV9jb25maWdfdXNlcl9hZ2VudCB8fFxuICAgICAgICAnbm9kZSAnICsgcHJvY2Vzcy52ZXJzaW9uO1xuXG4gICAgdmFyIHJlcXVlc3RPcHRzID0ge1xuICAgICAgICB1cmk6IHVyaS5yZXBsYWNlKCcrJywnJTJCJyksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnVXNlci1BZ2VudCc6ICdub2RlLXByZS1neXAgKHYnICsgbnBnVmVyc2lvbiArICcsICcgKyBlbnZWZXJzaW9uSW5mbyArICcpJ1xuICAgICAgICB9LFxuICAgICAgICBmb2xsb3dfbWF4OiAxMCxcbiAgICB9O1xuXG4gICAgaWYgKG9wdHMuY2FmaWxlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXF1ZXN0T3B0cy5jYSA9IGZzLnJlYWRGaWxlU3luYyhvcHRzLmNhZmlsZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3B0cy5jYSkge1xuICAgICAgICByZXF1ZXN0T3B0cy5jYSA9IG9wdHMuY2E7XG4gICAgfVxuXG4gICAgdmFyIHByb3h5VXJsID0gb3B0cy5wcm94eSB8fFxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5odHRwX3Byb3h5IHx8XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52LkhUVFBfUFJPWFkgfHxcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYubnBtX2NvbmZpZ19wcm94eTtcbiAgICBpZiAocHJveHlVcmwpIHtcbiAgICAgIGlmICgvXmh0dHBzPzpcXC9cXC8vaS50ZXN0KHByb3h5VXJsKSkge1xuICAgICAgICBsb2cudmVyYm9zZSgnZG93bmxvYWQnLCAndXNpbmcgcHJveHkgdXJsOiBcIiVzXCInLCBwcm94eVVybCk7XG4gICAgICAgIHJlcXVlc3RPcHRzLnByb3h5ID0gcHJveHlVcmw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2cud2FybignZG93bmxvYWQnLCAnaWdub3JpbmcgaW52YWxpZCBcInByb3h5XCIgY29uZmlnIHNldHRpbmc6IFwiJXNcIicsIHByb3h5VXJsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmVxID0gaHR0cF9nZXQuaW1wbC5nZXQocmVxdWVzdE9wdHMudXJpLCByZXF1ZXN0T3B0cyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZSk7XG4gICAgfVxuICAgIGlmIChyZXEpIHtcbiAgICAgIHJlcS5vbigncmVzcG9uc2UnLCBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIGxvZy5odHRwKHJlcy5zdGF0dXNDb2RlLCB1cmkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjYWxsYmFjayhudWxsLHJlcSk7XG59XG5cbmZ1bmN0aW9uIHBsYWNlX2JpbmFyeShmcm9tLHRvLG9wdHMsY2FsbGJhY2spIHtcbiAgICBkb3dubG9hZChmcm9tLG9wdHMsZnVuY3Rpb24oZXJyLHJlcSkge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgaWYgKCFyZXEpIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoXCJlbXB0eSByZXFcIikpO1xuICAgICAgICB2YXIgYmFkRG93bmxvYWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGhhc1Jlc3BvbnNlID0gZmFsc2U7XG5cbiAgICAgICAgZnVuY3Rpb24gYWZ0ZXJFeHRyYWN0KGVyciwgZXh0cmFjdENvdW50KSB7XG4gICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIGlmIChiYWREb3dubG9hZCkgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihcImJhZCBkb3dubG9hZFwiKSk7XG4gICAgICAgICAgICBpZiAoZXh0cmFjdENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignVGhlcmUgd2FzIGEgZmF0YWwgcHJvYmxlbSB3aGlsZSBkb3dubG9hZGluZy9leHRyYWN0aW5nIHRoZSB0YXJiYWxsJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nLmluZm8oJ3RhcmJhbGwnLCAnZG9uZSBwYXJzaW5nIHRhcmJhbGwnKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmb3IgcmVxdWVzdCBjb21wYXRpYmlsaXR5XG4gICAgICAgIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGJhZERvd25sb2FkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghaGFzUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBoYXNSZXNwb25zZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGZvciBuZWVkbGUgY29tcGF0aWJpbGl0eVxuICAgICAgICByZXEub24oJ2VycicsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgYmFkRG93bmxvYWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCFoYXNSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGhhc1Jlc3BvbnNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVxLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghaGFzUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBoYXNSZXNwb25zZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignQ29ubmVjdGlvbiBjbG9zZWQgd2hpbGUgZG93bmxvYWRpbmcgdGFyYmFsbCBmaWxlJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgcmVxLm9uKCdyZXNwb25zZScsIGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgLy8gaWdub3JlIHJlZGlyZWN0cywgbmVlZGxlIGhhbmRsZXMgdGhlc2UgYXV0b21hdGljYWxseS5cbiAgICAgICAgICAgIGlmIChodHRwX2dldC50eXBlID09PSAnbmVlZGxlJyAmJiByZXMuaGVhZGVycy5oYXNPd25Qcm9wZXJ0eSgnbG9jYXRpb24nKSAmJiByZXMuaGVhZGVycy5sb2NhdGlvbiAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYXNSZXNwb25zZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAocmVzLnN0YXR1c0NvZGUgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgIGJhZERvd25sb2FkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKHJlcy5zdGF0dXNDb2RlICsgJyBzdGF0dXMgY29kZSBkb3dubG9hZGluZyB0YXJiYWxsICcgKyBmcm9tKTtcbiAgICAgICAgICAgICAgICBlcnIuc3RhdHVzQ29kZSA9IHJlcy5zdGF0dXNDb2RlO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc3RhcnQgdW56aXBwaW5nIGFuZCB1bnRhcmluZ1xuICAgICAgICAgICAgcmVxLnBpcGUoZXh0cmFjdCh0bywgYWZ0ZXJFeHRyYWN0KSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0X2Zyb21fbG9jYWwoZnJvbSwgdG8sIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKGZyb20pKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIGZpbGUgJyArIGZyb20pKTtcbiAgICB9XG4gICAgbG9nLmluZm8oJ0ZvdW5kIGxvY2FsIGZpbGUgdG8gZXh0cmFjdCBmcm9tICcgKyBmcm9tKTtcbiAgICBmdW5jdGlvbiBhZnRlckV4dHJhY3QoZXJyLCBleHRyYWN0Q291bnQpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIGlmIChleHRyYWN0Q291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ1RoZXJlIHdhcyBhIGZhdGFsIHByb2JsZW0gd2hpbGUgZXh0cmFjdGluZyB0aGUgdGFyYmFsbCcpKTtcbiAgICAgICAgfVxuICAgICAgICBsb2cuaW5mbygndGFyYmFsbCcsICdkb25lIHBhcnNpbmcgdGFyYmFsbCcpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgICBmcy5jcmVhdGVSZWFkU3RyZWFtKGZyb20pLnBpcGUoZXh0cmFjdCh0bywgYWZ0ZXJFeHRyYWN0KSk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3QodG8sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGV4dHJhY3RDb3VudCA9IDA7XG4gICAgZnVuY3Rpb24gZmlsdGVyX2Z1bmMoZW50cnkpIHtcbiAgICAgICAgbG9nLmluZm8oJ2luc3RhbGwnLCd1bnBhY2tpbmcgJyArIGVudHJ5LnBhdGgpO1xuICAgICAgICBleHRyYWN0Q291bnQrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZnRlclRhcmJhbGwoZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgZXh0cmFjdENvdW50KTtcbiAgICB9XG5cbiAgICB2YXIgdGFyID0gcmVxdWlyZSgndGFyJyk7XG4gICAgcmV0dXJuIHRhci5leHRyYWN0KHtcbiAgICAgICAgY3dkOiB0byxcbiAgICAgICAgc3RyaXA6IDEsXG4gICAgICAgIG9uZW50cnk6IGZpbHRlcl9mdW5jXG4gICAgfSkub24oJ2Nsb3NlJywgYWZ0ZXJUYXJiYWxsKS5vbignZXJyb3InLCBjYWxsYmFjayk7XG59XG5cblxuZnVuY3Rpb24gZG9fYnVpbGQoZ3lwLGFyZ3YsY2FsbGJhY2spIHtcbiAgdmFyIGFyZ3MgPSBbJ3JlYnVpbGQnXS5jb25jYXQoYXJndik7XG4gIGd5cC50b2RvLnB1c2goIHsgbmFtZTogJ2J1aWxkJywgYXJnczogYXJncyB9ICk7XG4gIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBwcmludF9mYWxsYmFja19lcnJvcihlcnIsb3B0cyxwYWNrYWdlX2pzb24pIHtcbiAgICB2YXIgZmFsbGJhY2tfbWVzc2FnZSA9ICcgKGZhbGxpbmcgYmFjayB0byBzb3VyY2UgY29tcGlsZSB3aXRoIG5vZGUtZ3lwKSc7XG4gICAgdmFyIGZ1bGxfbWVzc2FnZSA9ICcnO1xuICAgIGlmIChlcnIuc3RhdHVzQ29kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIElmIHdlIGdvdCBhIG5ldHdvcmsgcmVzcG9uc2UgaXQgYnV0IGZhaWxlZCB0byBkb3dubG9hZFxuICAgICAgICAvLyBpdCBtZWFucyByZW1vdGUgYmluYXJpZXMgYXJlIG5vdCBhdmFpbGFibGUsIHNvIGxldCdzIHRyeSB0byBoZWxwXG4gICAgICAgIC8vIHRoZSB1c2VyL2RldmVsb3BlciB3aXRoIHRoZSBpbmZvIHRvIGRlYnVnIHdoeVxuICAgICAgICBmdWxsX21lc3NhZ2UgPSBcIlByZS1idWlsdCBiaW5hcmllcyBub3QgZm91bmQgZm9yIFwiICsgcGFja2FnZV9qc29uLm5hbWUgKyBcIkBcIiArIHBhY2thZ2VfanNvbi52ZXJzaW9uO1xuICAgICAgICBmdWxsX21lc3NhZ2UgKz0gXCIgYW5kIFwiICsgb3B0cy5ydW50aW1lICsgXCJAXCIgKyAob3B0cy50YXJnZXQgfHwgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlKSArIFwiIChcIiArIG9wdHMubm9kZV9hYmkgKyBcIiBBQkksIFwiICsgb3B0cy5saWJjICsgXCIpXCI7XG4gICAgICAgIGZ1bGxfbWVzc2FnZSArPSBmYWxsYmFja19tZXNzYWdlO1xuICAgICAgICBsb2cud2FybihcIlRyaWVkIHRvIGRvd25sb2FkKFwiICsgZXJyLnN0YXR1c0NvZGUgKyBcIik6IFwiICsgb3B0cy5ob3N0ZWRfdGFyYmFsbCk7XG4gICAgICAgIGxvZy53YXJuKGZ1bGxfbWVzc2FnZSk7XG4gICAgICAgIGxvZy5odHRwKGVyci5tZXNzYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB3ZSBkbyBub3QgaGF2ZSBhIHN0YXR1c0NvZGUgdGhhdCBtZWFucyBhbiB1bmV4cGVjdGVkIGVycm9yXG4gICAgICAgIC8vIGhhcHBlbmVkIGFuZCBwcmV2ZW50ZWQgYW4gaHR0cCByZXNwb25zZSwgc28gd2Ugb3V0cHV0IHRoZSBleGFjdCBlcnJvclxuICAgICAgICBmdWxsX21lc3NhZ2UgPSBcIlByZS1idWlsdCBiaW5hcmllcyBub3QgaW5zdGFsbGFibGUgZm9yIFwiICsgcGFja2FnZV9qc29uLm5hbWUgKyBcIkBcIiArIHBhY2thZ2VfanNvbi52ZXJzaW9uO1xuICAgICAgICBmdWxsX21lc3NhZ2UgKz0gXCIgYW5kIFwiICsgb3B0cy5ydW50aW1lICsgXCJAXCIgKyAob3B0cy50YXJnZXQgfHwgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlKSArIFwiIChcIiArIG9wdHMubm9kZV9hYmkgKyBcIiBBQkksIFwiICsgb3B0cy5saWJjICsgXCIpXCI7XG4gICAgICAgIGZ1bGxfbWVzc2FnZSArPSBmYWxsYmFja19tZXNzYWdlO1xuICAgICAgICBsb2cud2FybihmdWxsX21lc3NhZ2UpO1xuICAgICAgICBsb2cud2FybihcIkhpdCBlcnJvciBcIiArIGVyci5tZXNzYWdlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGluc3RhbGwoZ3lwLCBhcmd2LCBjYWxsYmFjaykge1xuICAgIHZhciBwYWNrYWdlX2pzb24gPSBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYygnLi9wYWNrYWdlLmpzb24nKSk7XG5cdHZhciBuYXBpX2J1aWxkX3ZlcnNpb24gPSBuYXBpLmdldF9uYXBpX2J1aWxkX3ZlcnNpb25fZnJvbV9jb21tYW5kX2FyZ3MoYXJndik7XG4gICAgdmFyIHNvdXJjZV9idWlsZCA9IGd5cC5vcHRzWydidWlsZC1mcm9tLXNvdXJjZSddIHx8IGd5cC5vcHRzLmJ1aWxkX2Zyb21fc291cmNlO1xuICAgIHZhciB1cGRhdGVfYmluYXJ5ID0gZ3lwLm9wdHNbJ3VwZGF0ZS1iaW5hcnknXSB8fCBneXAub3B0cy51cGRhdGVfYmluYXJ5O1xuICAgIHZhciBzaG91bGRfZG9fc291cmNlX2J1aWxkID0gc291cmNlX2J1aWxkID09PSBwYWNrYWdlX2pzb24ubmFtZSB8fCAoc291cmNlX2J1aWxkID09PSB0cnVlIHx8IHNvdXJjZV9idWlsZCA9PT0gJ3RydWUnKTtcbiAgICBpZiAoc2hvdWxkX2RvX3NvdXJjZV9idWlsZCkge1xuICAgICAgICBsb2cuaW5mbygnYnVpbGQnLCdyZXF1ZXN0aW5nIHNvdXJjZSBjb21waWxlJyk7XG4gICAgICAgIHJldHVybiBkb19idWlsZChneXAsYXJndixjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGZhbGxiYWNrX3RvX2J1aWxkID0gZ3lwLm9wdHNbJ2ZhbGxiYWNrLXRvLWJ1aWxkJ10gfHwgZ3lwLm9wdHMuZmFsbGJhY2tfdG9fYnVpbGQ7XG4gICAgICAgIHZhciBzaG91bGRfZG9fZmFsbGJhY2tfYnVpbGQgPSBmYWxsYmFja190b19idWlsZCA9PT0gcGFja2FnZV9qc29uLm5hbWUgfHwgKGZhbGxiYWNrX3RvX2J1aWxkID09PSB0cnVlIHx8IGZhbGxiYWNrX3RvX2J1aWxkID09PSAndHJ1ZScpO1xuICAgICAgICAvLyBidXQgYWxsb3cgb3ZlcnJpZGUgZnJvbSBucG1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lm5wbV9jb25maWdfYXJndikge1xuICAgICAgICAgICAgdmFyIGNvb2tlZCA9IEpTT04ucGFyc2UocHJvY2Vzcy5lbnYubnBtX2NvbmZpZ19hcmd2KS5jb29rZWQ7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBjb29rZWQuaW5kZXhPZihcIi0tZmFsbGJhY2stdG8tYnVpbGRcIik7XG4gICAgICAgICAgICBpZiAobWF0Y2ggPiAtMSAmJiBjb29rZWQubGVuZ3RoID4gbWF0Y2ggJiYgY29va2VkW21hdGNoKzFdID09IFwiZmFsc2VcIikge1xuICAgICAgICAgICAgICAgIHNob3VsZF9kb19mYWxsYmFja19idWlsZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxvZy5pbmZvKCdpbnN0YWxsJywnQnVpbGQgZmFsbGJhY2sgZGlzYWJsZWQgdmlhIG5wbSBmbGFnOiAtLWZhbGxiYWNrLXRvLWJ1aWxkPWZhbHNlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wdHM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvcHRzID0gdmVyc2lvbmluZy5ldmFsdWF0ZShwYWNrYWdlX2pzb24sIGd5cC5vcHRzLCBuYXBpX2J1aWxkX3ZlcnNpb24pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0cy5jYSA9IGd5cC5vcHRzLmNhO1xuICAgICAgICBvcHRzLmNhZmlsZSA9IGd5cC5vcHRzLmNhZmlsZTtcblxuICAgICAgICB2YXIgZnJvbSA9IG9wdHMuaG9zdGVkX3RhcmJhbGw7XG4gICAgICAgIHZhciB0byA9IG9wdHMubW9kdWxlX3BhdGg7XG4gICAgICAgIHZhciBiaW5hcnlfbW9kdWxlID0gcGF0aC5qb2luKHRvLG9wdHMubW9kdWxlX25hbWUgKyAnLm5vZGUnKTtcbiAgICAgICAgZXhpc3RzQXN5bmMoYmluYXJ5X21vZHVsZSxmdW5jdGlvbihmb3VuZCkge1xuICAgICAgICAgICAgaWYgKGZvdW5kICYmICF1cGRhdGVfYmluYXJ5KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1snK3BhY2thZ2VfanNvbi5uYW1lKyddIFN1Y2Nlc3M6IFwiJyArIGJpbmFyeV9tb2R1bGUgKyAnXCIgYWxyZWFkeSBpbnN0YWxsZWQnKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUGFzcyAtLXVwZGF0ZS1iaW5hcnkgdG8gcmVpbnN0YWxsIG9yIC0tYnVpbGQtZnJvbS1zb3VyY2UgdG8gcmVjb21waWxlJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghdXBkYXRlX2JpbmFyeSkgbG9nLmluZm8oJ2NoZWNrJywnY2hlY2tlZCBmb3IgXCInICsgYmluYXJ5X21vZHVsZSArICdcIiAobm90IGZvdW5kKScpO1xuICAgICAgICAgICAgICAgIG1rZGlycCh0byxmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXJfcGxhY2UoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWxlTmFtZSA9IGZyb20uc3RhcnRzV2l0aCgnZmlsZTovLycpICYmIGZyb20ucmVwbGFjZSgvXmZpbGU6XFwvXFwvLywgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdF9mcm9tX2xvY2FsKGZpbGVOYW1lLCB0bywgYWZ0ZXJfcGxhY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZV9iaW5hcnkoZnJvbSx0byxvcHRzLGFmdGVyX3BsYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gYWZ0ZXJfcGxhY2UoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyciAmJiBzaG91bGRfZG9fZmFsbGJhY2tfYnVpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRfZmFsbGJhY2tfZXJyb3IoZXJyLG9wdHMscGFja2FnZV9qc29uKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvX2J1aWxkKGd5cCxhcmd2LGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnWycrcGFja2FnZV9qc29uLm5hbWUrJ10gU3VjY2VzczogXCInICsgYmluYXJ5X21vZHVsZSArICdcIiBpcyBpbnN0YWxsZWQgdmlhIHJlbW90ZScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciBub3B0ID0gcmVxdWlyZSgnbm9wdCcpO1xudmFyIGxvZyA9IHJlcXVpcmUoJ25wbWxvZycpO1xubG9nLmRpc2FibGVQcm9ncmVzcygpO1xudmFyIG5hcGkgPSByZXF1aXJlKCcuL3V0aWwvbmFwaS5qcycpO1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHM7XG52YXIgY29tbWFuZHMgPSBbXG4gICAgICAnY2xlYW4nLFxuICAgICAgJ2luc3RhbGwnLFxuICAgICAgJ3JlaW5zdGFsbCcsXG4gICAgICAnYnVpbGQnLFxuICAgICAgJ3JlYnVpbGQnLFxuICAgICAgJ3BhY2thZ2UnLFxuICAgICAgJ3Rlc3RwYWNrYWdlJyxcbiAgICAgICdwdWJsaXNoJyxcbiAgICAgICd1bnB1Ymxpc2gnLFxuICAgICAgJ2luZm8nLFxuICAgICAgJ3Rlc3RiaW5hcnknLFxuICAgICAgJ3JldmVhbCcsXG4gICAgICAnY29uZmlndXJlJ1xuICAgIF07XG52YXIgYWxpYXNlcyA9IHt9O1xuXG4vLyBkaWZmZXJlbnRpYXRlIG5vZGUtcHJlLWd5cCdzIGxvZ3MgZnJvbSBucG0nc1xubG9nLmhlYWRpbmcgPSAnbm9kZS1wcmUtZ3lwJztcblxuZXhwb3J0cy5maW5kID0gcmVxdWlyZSgnLi9wcmUtYmluZGluZycpLmZpbmQ7XG5cbmZ1bmN0aW9uIFJ1bigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMuY29tbWFuZHMgPSB7fTtcblxuICBjb21tYW5kcy5mb3JFYWNoKGZ1bmN0aW9uIChjb21tYW5kKSB7XG4gICAgc2VsZi5jb21tYW5kc1tjb21tYW5kXSA9IGZ1bmN0aW9uIChhcmd2LCBjYWxsYmFjaykge1xuICAgICAgbG9nLnZlcmJvc2UoJ2NvbW1hbmQnLCBjb21tYW5kLCBhcmd2KTtcbiAgICAgIHJldHVybiByZXF1aXJlKCcuLycgKyBjb21tYW5kKShzZWxmLCBhcmd2LCBjYWxsYmFjayk7XG4gICAgfTtcbiAgfSk7XG59XG5pbmhlcml0cyhSdW4sIEVFKTtcbmV4cG9ydHMuUnVuID0gUnVuO1xudmFyIHByb3RvID0gUnVuLnByb3RvdHlwZTtcblxuLyoqXG4gKiBFeHBvcnQgdGhlIGNvbnRlbnRzIG9mIHRoZSBwYWNrYWdlLmpzb24uXG4gKi9cblxucHJvdG8ucGFja2FnZSA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpO1xuXG4vKipcbiAqIG5vcHQgY29uZmlndXJhdGlvbiBkZWZpbml0aW9uc1xuICovXG5cbnByb3RvLmNvbmZpZ0RlZnMgPSB7XG4gICAgaGVscDogQm9vbGVhbiwgICAgIC8vIGV2ZXJ5d2hlcmVcbiAgICBhcmNoOiBTdHJpbmcsICAgICAgLy8gJ2NvbmZpZ3VyZSdcbiAgICBkZWJ1ZzogQm9vbGVhbiwgICAgLy8gJ2J1aWxkJ1xuICAgIGRpcmVjdG9yeTogU3RyaW5nLCAvLyBiaW5cbiAgICBwcm94eTogU3RyaW5nLCAgICAgLy8gJ2luc3RhbGwnXG4gICAgbG9nbGV2ZWw6IFN0cmluZywgIC8vIGV2ZXJ5d2hlcmVcbn07XG5cbi8qKlxuICogbm9wdCBzaG9ydGhhbmRzXG4gKi9cblxucHJvdG8uc2hvcnRoYW5kcyA9IHtcbiAgICByZWxlYXNlOiAnLS1uby1kZWJ1ZycsXG4gICAgQzogJy0tZGlyZWN0b3J5JyxcbiAgICBkZWJ1ZzogJy0tZGVidWcnLFxuICAgIGo6ICctLWpvYnMnLFxuICAgIHNpbGVudDogJy0tbG9nbGV2ZWw9c2lsZW50JyxcbiAgICBzaWxseTogJy0tbG9nbGV2ZWw9c2lsbHknLFxuICAgIHZlcmJvc2U6ICctLWxvZ2xldmVsPXZlcmJvc2UnLFxufTtcblxuLyoqXG4gKiBleHBvc2UgdGhlIGNvbW1hbmQgYWxpYXNlcyBmb3IgdGhlIGJpbiBmaWxlIHRvIHVzZS5cbiAqL1xuXG5wcm90by5hbGlhc2VzID0gYWxpYXNlcztcblxuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIGFyZ3YgYXJyYXkgYW5kIHNldHMgdGhlICdvcHRzJyxcbiAqICdhcmd2JyBhbmQgJ2NvbW1hbmQnIHByb3BlcnRpZXMuXG4gKi9cblxucHJvdG8ucGFyc2VBcmd2ID0gZnVuY3Rpb24gcGFyc2VPcHRzIChhcmd2KSB7XG4gIHRoaXMub3B0cyA9IG5vcHQodGhpcy5jb25maWdEZWZzLCB0aGlzLnNob3J0aGFuZHMsIGFyZ3YpO1xuICB0aGlzLmFyZ3YgPSB0aGlzLm9wdHMuYXJndi5yZW1haW4uc2xpY2UoKTtcbiAgdmFyIGNvbW1hbmRzID0gdGhpcy50b2RvID0gW107XG5cbiAgLy8gY3JlYXRlIGEgY29weSBvZiB0aGUgYXJndiBhcnJheSB3aXRoIGFsaWFzZXMgbWFwcGVkXG4gIGFyZ3YgPSB0aGlzLmFyZ3YubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAvLyBpcyB0aGlzIGFuIGFsaWFzP1xuICAgIGlmIChhcmcgaW4gdGhpcy5hbGlhc2VzKSB7XG4gICAgICBhcmcgPSB0aGlzLmFsaWFzZXNbYXJnXTtcbiAgICB9XG4gICAgcmV0dXJuIGFyZztcbiAgfSwgdGhpcyk7XG5cbiAgLy8gcHJvY2VzcyB0aGUgbWFwcGVkIGFyZ3MgaW50byBcImNvbW1hbmRcIiBvYmplY3RzIChcIm5hbWVcIiBhbmQgXCJhcmdzXCIgcHJvcHMpXG4gIGFyZ3Yuc2xpY2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChhcmcpIHtcbiAgICBpZiAoYXJnIGluIHRoaXMuY29tbWFuZHMpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndi5zcGxpY2UoMCwgYXJndi5pbmRleE9mKGFyZykpO1xuICAgICAgYXJndi5zaGlmdCgpO1xuICAgICAgaWYgKGNvbW1hbmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29tbWFuZHNbY29tbWFuZHMubGVuZ3RoIC0gMV0uYXJncyA9IGFyZ3M7XG4gICAgICB9XG4gICAgICBjb21tYW5kcy5wdXNoKHsgbmFtZTogYXJnLCBhcmdzOiBbXSB9KTtcbiAgICB9XG4gIH0sIHRoaXMpO1xuICBpZiAoY29tbWFuZHMubGVuZ3RoID4gMCkge1xuICAgIGNvbW1hbmRzW2NvbW1hbmRzLmxlbmd0aCAtIDFdLmFyZ3MgPSBhcmd2LnNwbGljZSgwKTtcbiAgfVxuXG4gIC8vIGV4cGFuZCBjb21tYW5kcyBlbnRyaWVzIGZvciBtdWx0aXBsZSBuYXBpIGJ1aWxkc1xuICB2YXIgZGlyID0gdGhpcy5vcHRzLmRpcmVjdG9yeTtcbiAgaWYgKGRpciA9PSBudWxsKSBkaXIgPSBwcm9jZXNzLmN3ZCgpO1xuICB2YXIgcGFja2FnZV9qc29uID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMocGF0aC5qb2luKGRpciwncGFja2FnZS5qc29uJykpKTtcblxuICB0aGlzLnRvZG8gPSBuYXBpLmV4cGFuZF9jb21tYW5kcyAocGFja2FnZV9qc29uLCB0aGlzLm9wdHMsIGNvbW1hbmRzKTtcblxuICAvLyBzdXBwb3J0IGZvciBpbmhlcml0aW5nIGNvbmZpZyBlbnYgdmFyaWFibGVzIGZyb20gbnBtXG4gIHZhciBucG1fY29uZmlnX3ByZWZpeCA9ICducG1fY29uZmlnXyc7XG4gIE9iamVjdC5rZXlzKHByb2Nlc3MuZW52KS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUuaW5kZXhPZihucG1fY29uZmlnX3ByZWZpeCkgIT09IDApIHJldHVybjtcbiAgICB2YXIgdmFsID0gcHJvY2Vzcy5lbnZbbmFtZV07XG4gICAgaWYgKG5hbWUgPT09IG5wbV9jb25maWdfcHJlZml4ICsgJ2xvZ2xldmVsJykge1xuICAgICAgbG9nLmxldmVsID0gdmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhZGQgdGhlIHVzZXItZGVmaW5lZCBvcHRpb25zIHRvIHRoZSBjb25maWdcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZyhucG1fY29uZmlnX3ByZWZpeC5sZW5ndGgpO1xuICAgICAgLy8gYXZvaWQgbnBtIGFyZ3YgY2xvYmJlciBhbHJlYWR5IHByZXNlbnQgYXJnc1xuICAgICAgLy8gd2hpY2ggYXZvaWRzIHByb2JsZW0gb2YgJ25wbSB0ZXN0JyBjYWxsaW5nXG4gICAgICAvLyBzY3JpcHQgdGhhdCBydW5zIHVuaXF1ZSBucG0gaW5zdGFsbCBjb21tYW5kc1xuICAgICAgaWYgKG5hbWUgPT09ICdhcmd2Jykge1xuICAgICAgICAgaWYgKHRoaXMub3B0cy5hcmd2ICYmXG4gICAgICAgICAgICAgdGhpcy5vcHRzLmFyZ3YucmVtYWluICYmXG4gICAgICAgICAgICAgdGhpcy5vcHRzLmFyZ3YucmVtYWluLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3B0c1tuYW1lXSA9IHZhbDtcbiAgICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3B0c1tuYW1lXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHRoaXMpO1xuXG4gIGlmICh0aGlzLm9wdHMubG9nbGV2ZWwpIHtcbiAgICBsb2cubGV2ZWwgPSB0aGlzLm9wdHMubG9nbGV2ZWw7XG4gIH1cbiAgbG9nLnJlc3VtZSgpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB1c2FnZSBpbnN0cnVjdGlvbnMgZm9yIG5vZGUtcHJlLWd5cC5cbiAqL1xuXG5wcm90by51c2FnZSA9IGZ1bmN0aW9uIHVzYWdlICgpIHtcbiAgdmFyIHN0ciA9IFtcbiAgICAgICcnLFxuICAgICAgJyAgVXNhZ2U6IG5vZGUtcHJlLWd5cCA8Y29tbWFuZD4gW29wdGlvbnNdJyxcbiAgICAgICcnLFxuICAgICAgJyAgd2hlcmUgPGNvbW1hbmQ+IGlzIG9uZSBvZjonLFxuICAgICAgY29tbWFuZHMubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiAnICAgIC0gJyArIGMgKyAnIC0gJyArIHJlcXVpcmUoJy4vJyArIGMpLnVzYWdlO1xuICAgICAgfSkuam9pbignXFxuJyksXG4gICAgICAnJyxcbiAgICAgICdub2RlLXByZS1neXBAJyArIHRoaXMudmVyc2lvbiArICcgICcgKyBwYXRoLnJlc29sdmUoX19kaXJuYW1lLCAnLi4nKSxcbiAgICAgICdub2RlQCcgKyBwcm9jZXNzLnZlcnNpb25zLm5vZGVcbiAgXS5qb2luKCdcXG4nKTtcbiAgcmV0dXJuIHN0cjtcbn07XG5cbi8qKlxuICogVmVyc2lvbiBudW1iZXIgZ2V0dGVyLlxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgJ3ZlcnNpb24nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYWNrYWdlLnZlcnNpb247XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG59KTtcblxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IF9wYWNrYWdlO1xuXG5leHBvcnRzLnVzYWdlID0gJ1BhY2tzIGJpbmFyeSAoYW5kIGVuY2xvc2luZyBkaXJlY3RvcnkpIGludG8gbG9jYWxseSBzdGFnZWQgdGFyYmFsbCc7XG5cbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciBsb2cgPSByZXF1aXJlKCducG1sb2cnKTtcbnZhciB2ZXJzaW9uaW5nID0gcmVxdWlyZSgnLi91dGlsL3ZlcnNpb25pbmcuanMnKTtcbnZhciBuYXBpID0gcmVxdWlyZSgnLi91dGlsL25hcGkuanMnKTtcbnZhciB3cml0ZSA9IHJlcXVpcmUoJ2ZzJykuY3JlYXRlV3JpdGVTdHJlYW07XG52YXIgZXhpc3RzQXN5bmMgPSBmcy5leGlzdHMgfHwgcGF0aC5leGlzdHM7XG52YXIgbWtkaXJwID0gcmVxdWlyZSgnbWtkaXJwJyk7XG52YXIgdGFyID0gcmVxdWlyZSgndGFyJyk7XG5cbmZ1bmN0aW9uIF9wYWNrYWdlKGd5cCwgYXJndiwgY2FsbGJhY2spIHtcbiAgICB2YXIgcGFja2xpc3QgPSByZXF1aXJlKCducG0tcGFja2xpc3QnKTtcbiAgICB2YXIgcGFja2FnZV9qc29uID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMoJy4vcGFja2FnZS5qc29uJykpO1xuICAgIHZhciBuYXBpX2J1aWxkX3ZlcnNpb24gPSBuYXBpLmdldF9uYXBpX2J1aWxkX3ZlcnNpb25fZnJvbV9jb21tYW5kX2FyZ3MoYXJndik7XG4gICAgdmFyIG9wdHMgPSB2ZXJzaW9uaW5nLmV2YWx1YXRlKHBhY2thZ2VfanNvbiwgZ3lwLm9wdHMsIG5hcGlfYnVpbGRfdmVyc2lvbik7XG4gICAgdmFyIGZyb20gPSBvcHRzLm1vZHVsZV9wYXRoO1xuICAgIHZhciBiaW5hcnlfbW9kdWxlID0gcGF0aC5qb2luKGZyb20sb3B0cy5tb2R1bGVfbmFtZSArICcubm9kZScpO1xuICAgIGV4aXN0c0FzeW5jKGJpbmFyeV9tb2R1bGUsZnVuY3Rpb24oZm91bmQpIHtcbiAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihcIkNhbm5vdCBwYWNrYWdlIGJlY2F1c2UgXCIgKyBiaW5hcnlfbW9kdWxlICsgXCIgbWlzc2luZzogcnVuIGBub2RlLXByZS1neXAgcmVidWlsZGAgZmlyc3RcIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0YXJiYWxsID0gb3B0cy5zdGFnZWRfdGFyYmFsbDtcbiAgICAgICAgdmFyIGZpbHRlcl9mdW5jID0gZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgIC8vIGVuc3VyZSBkaXJlY3RvcmllcyBhcmUgK3hcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBuaWsvbm9kZS1tYXBuaWsvaXNzdWVzLzI2MlxuICAgICAgICAgICAgbG9nLmluZm8oJ3BhY2thZ2UnLCdwYWNraW5nICcgKyBlbnRyeS5wYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBta2RpcnAocGF0aC5kaXJuYW1lKHRhcmJhbGwpLGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICBwYWNrbGlzdCh7IHBhdGg6IGZyb20gfSkudGhlbihmdW5jdGlvbihmaWxlcykge1xuICAgICAgICAgICAgICAgIHZhciBiYXNlID0gcGF0aC5iYXNlbmFtZShmcm9tKTtcbiAgICAgICAgICAgICAgICBmaWxlcyA9IGZpbGVzLm1hcChmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRoLmpvaW4oYmFzZSwgZmlsZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGFyLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHBvcnRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBnemlwOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBvbmVudHJ5OiBmaWx0ZXJfZnVuYyxcbiAgICAgICAgICAgICAgICAgICAgZmlsZTogdGFyYmFsbCxcbiAgICAgICAgICAgICAgICAgICAgY3dkOiBwYXRoLmRpcm5hbWUoZnJvbSlcbiAgICAgICAgICAgICAgICB9LCBmaWxlcywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpICBjb25zb2xlLmVycm9yKCdbJytwYWNrYWdlX2pzb24ubmFtZSsnXSAnICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGxvZy5pbmZvKCdwYWNrYWdlJywnQmluYXJ5IHN0YWdlZCBhdCBcIicgKyB0YXJiYWxsICsgJ1wiJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdmVyc2lvbmluZyA9IHJlcXVpcmUoJy4uL2xpYi91dGlsL3ZlcnNpb25pbmcuanMnKTtcbnZhciBuYXBpID0gcmVxdWlyZSgnLi4vbGliL3V0aWwvbmFwaS5qcycpO1xudmFyIGV4aXN0c1N5bmMgPSByZXF1aXJlKCdmcycpLmV4aXN0c1N5bmMgfHwgcmVxdWlyZSgncGF0aCcpLmV4aXN0c1N5bmM7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuXG5leHBvcnRzLnVzYWdlID0gJ0ZpbmRzIHRoZSByZXF1aXJlIHBhdGggZm9yIHRoZSBub2RlLXByZS1neXAgaW5zdGFsbGVkIG1vZHVsZSc7XG5cbmV4cG9ydHMudmFsaWRhdGUgPSBmdW5jdGlvbihwYWNrYWdlX2pzb24sb3B0cykge1xuICAgIHZlcnNpb25pbmcudmFsaWRhdGVfY29uZmlnKHBhY2thZ2VfanNvbixvcHRzKTtcbn07XG5cbmV4cG9ydHMuZmluZCA9IGZ1bmN0aW9uKHBhY2thZ2VfanNvbl9wYXRoLG9wdHMpIHtcbiAgIGlmICghZXhpc3RzU3luYyhwYWNrYWdlX2pzb25fcGF0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGFja2FnZS5qc29uIGRvZXMgbm90IGV4aXN0IGF0IFwiICsgcGFja2FnZV9qc29uX3BhdGgpO1xuICAgfVxuICAgdmFyIHBhY2thZ2VfanNvbiA9IHJlcXVpcmUocGFja2FnZV9qc29uX3BhdGgpO1xuICAgdmVyc2lvbmluZy52YWxpZGF0ZV9jb25maWcocGFja2FnZV9qc29uLG9wdHMpO1xuICAgdmFyIG5hcGlfYnVpbGRfdmVyc2lvbjtcbiAgIGlmIChuYXBpLmdldF9uYXBpX2J1aWxkX3ZlcnNpb25zIChwYWNrYWdlX2pzb24sIG9wdHMpKSB7XG4gICAgICAgbmFwaV9idWlsZF92ZXJzaW9uID0gbmFwaS5nZXRfYmVzdF9uYXBpX2J1aWxkX3ZlcnNpb24ocGFja2FnZV9qc29uLCBvcHRzKTtcbiAgIH1cbiAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgaWYgKCFvcHRzLm1vZHVsZV9yb290KSBvcHRzLm1vZHVsZV9yb290ID0gcGF0aC5kaXJuYW1lKHBhY2thZ2VfanNvbl9wYXRoKTtcbiAgIHZhciBtZXRhID0gdmVyc2lvbmluZy5ldmFsdWF0ZShwYWNrYWdlX2pzb24sb3B0cyxuYXBpX2J1aWxkX3ZlcnNpb24pO1xuICAgcmV0dXJuIG1ldGEubW9kdWxlO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBwdWJsaXNoO1xuXG5leHBvcnRzLnVzYWdlID0gJ1B1Ymxpc2hlcyBwcmUtYnVpbHQgYmluYXJ5IChyZXF1aXJlcyBhd3Mtc2RrKSc7XG5cbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciBsb2cgPSByZXF1aXJlKCducG1sb2cnKTtcbnZhciB2ZXJzaW9uaW5nID0gcmVxdWlyZSgnLi91dGlsL3ZlcnNpb25pbmcuanMnKTtcbnZhciBuYXBpID0gcmVxdWlyZSgnLi91dGlsL25hcGkuanMnKTtcbnZhciBzM19zZXR1cCA9IHJlcXVpcmUoJy4vdXRpbC9zM19zZXR1cC5qcycpO1xudmFyIGV4aXN0c0FzeW5jID0gZnMuZXhpc3RzIHx8IHBhdGguZXhpc3RzO1xudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJ3JjJykoXCJub2RlX3ByZV9neXBcIix7YWNsOlwicHVibGljLXJlYWRcIn0pO1xuXG5mdW5jdGlvbiBwdWJsaXNoKGd5cCwgYXJndiwgY2FsbGJhY2spIHtcbiAgICB2YXIgQVdTID0gcmVxdWlyZShcImF3cy1zZGtcIik7XG4gICAgdmFyIHBhY2thZ2VfanNvbiA9IEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKCcuL3BhY2thZ2UuanNvbicpKTtcbiAgICB2YXIgbmFwaV9idWlsZF92ZXJzaW9uID0gbmFwaS5nZXRfbmFwaV9idWlsZF92ZXJzaW9uX2Zyb21fY29tbWFuZF9hcmdzKGFyZ3YpO1xuICAgIHZhciBvcHRzID0gdmVyc2lvbmluZy5ldmFsdWF0ZShwYWNrYWdlX2pzb24sIGd5cC5vcHRzLCBuYXBpX2J1aWxkX3ZlcnNpb24pO1xuICAgIHZhciB0YXJiYWxsID0gb3B0cy5zdGFnZWRfdGFyYmFsbDtcbiAgICBleGlzdHNBc3luYyh0YXJiYWxsLGZ1bmN0aW9uKGZvdW5kKSB7XG4gICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoXCJDYW5ub3QgcHVibGlzaCBiZWNhdXNlIFwiICsgdGFyYmFsbCArIFwiIG1pc3Npbmc6IHJ1biBgbm9kZS1wcmUtZ3lwIHBhY2thZ2VgIGZpcnN0XCIpKTtcbiAgICAgICAgfVxuICAgICAgICBsb2cuaW5mbygncHVibGlzaCcsICdEZXRlY3RpbmcgczMgY3JlZGVudGlhbHMnKTtcbiAgICAgICAgczNfc2V0dXAuZGV0ZWN0KG9wdHMuaG9zdGVkX3BhdGgsY29uZmlnKTtcbiAgICAgICAgdmFyIGtleV9uYW1lID0gdXJsLnJlc29sdmUoY29uZmlnLnByZWZpeCxvcHRzLnBhY2thZ2VfbmFtZSk7XG4gICAgICAgIGxvZy5pbmZvKCdwdWJsaXNoJywgJ0F1dGhlbnRpY2F0aW5nIHdpdGggczMnKTtcbiAgICAgICAgQVdTLmNvbmZpZy51cGRhdGUoY29uZmlnKTtcbiAgICAgICAgdmFyIHMzID0gIG5ldyBBV1MuUzMoKTtcbiAgICAgICAgdmFyIHMzX29wdHMgPSB7ICBCdWNrZXQ6IGNvbmZpZy5idWNrZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgS2V5OiBrZXlfbmFtZVxuICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgIHZhciByZW1vdGVfcGFja2FnZSA9ICdodHRwczovLycgKyBzM19vcHRzLkJ1Y2tldCArICcuczMuYW1hem9uYXdzLmNvbS8nICsgczNfb3B0cy5LZXk7XG4gICAgICAgIGxvZy5pbmZvKCdwdWJsaXNoJywgJ0NoZWNraW5nIGZvciBleGlzdGluZyBiaW5hcnkgYXQgJyArIHJlbW90ZV9wYWNrYWdlKTtcbiAgICAgICAgczMuaGVhZE9iamVjdChzM19vcHRzLCBmdW5jdGlvbihlcnIsIG1ldGEpe1xuICAgICAgICAgICAgaWYgKG1ldGEpIGxvZy5pbmZvKCdwdWJsaXNoJywgSlNPTi5zdHJpbmdpZnkobWV0YSkpO1xuICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIuY29kZSA9PSAnTm90Rm91bmQnKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgYXJlIHNhZmUgdG8gcHVibGlzaCBiZWNhdXNlXG4gICAgICAgICAgICAgICAgLy8gdGhlIG9iamVjdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0XG4gICAgICAgICAgICAgICAgbG9nLmluZm8oJ3B1Ymxpc2gnLCAnUHJlcGFyaW5nIHRvIHB1dCBvYmplY3QnKTtcbiAgICAgICAgICAgICAgICB2YXIgczNfcHV0ID0gbmV3IEFXUy5TMygpO1xuICAgICAgICAgICAgICAgIHZhciBzM19wdXRfb3B0cyA9IHsgIEFDTDogY29uZmlnLmFjbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBCb2R5OiBmcy5jcmVhdGVSZWFkU3RyZWFtKHRhcmJhbGwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJ1Y2tldDogY29uZmlnLmJ1Y2tldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBLZXk6IGtleV9uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBsb2cuaW5mbygncHVibGlzaCcsICdQdXR0aW5nIG9iamVjdCcpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHMzX3B1dC5wdXRPYmplY3QoczNfcHV0X29wdHMsIGZ1bmN0aW9uKGVyciwgcmVzcCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cuaW5mbygncHVibGlzaCcsICdyZXR1cm5lZCBmcm9tIHB1dHRpbmcgb2JqZWN0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5pbmZvKCdwdWJsaXNoJywgJ3MzIHB1dE9iamVjdCBlcnJvcjogXCInICsgZXJyICsgJ1wiJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwKSBsb2cuaW5mbygncHVibGlzaCcsICdzMyBwdXRPYmplY3QgcmVzcG9uc2U6IFwiJyArIEpTT04uc3RyaW5naWZ5KHJlc3ApICsgJ1wiJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cuaW5mbygncHVibGlzaCcsICdzdWNjZXNzZnVsbHkgcHV0IG9iamVjdCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1snK3BhY2thZ2VfanNvbi5uYW1lKyddIHB1Ymxpc2hlZCB0byAnICsgcmVtb3RlX3BhY2thZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICBsb2cuaW5mbygncHVibGlzaCcsICdzMyBwdXRPYmplY3QgZXJyb3I6IFwiJyArIGVyciArICdcIicpO1xuICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGxvZy5pbmZvKCdwdWJsaXNoJywgJ3MzIGhlYWRPYmplY3QgZXJyb3I6IFwiJyArIGVyciArICdcIicpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2cuZXJyb3IoJ3B1Ymxpc2gnLCdDYW5ub3QgcHVibGlzaCBvdmVyIGV4aXN0aW5nIHZlcnNpb24nKTtcbiAgICAgICAgICAgICAgICBsb2cuZXJyb3IoJ3B1Ymxpc2gnLFwiVXBkYXRlIHRoZSAndmVyc2lvbicgZmllbGQgaW4gcGFja2FnZS5qc29uIGFuZCB0cnkgYWdhaW5cIik7XG4gICAgICAgICAgICAgICAgbG9nLmVycm9yKCdwdWJsaXNoJywnSWYgdGhlIHByZXZpb3VzIHZlcnNpb24gd2FzIHB1Ymxpc2hlZCBpbiBlcnJvciBzZWU6Jyk7XG4gICAgICAgICAgICAgICAgbG9nLmVycm9yKCdwdWJsaXNoJywnXFx0IG5vZGUtcHJlLWd5cCB1bnB1Ymxpc2gnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdGYWlsZWQgcHVibGlzaGluZyB0byAnICsgcmVtb3RlX3BhY2thZ2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gcmVidWlsZDtcblxuZXhwb3J0cy51c2FnZSA9ICdSdW5zIFwiY2xlYW5cIiBhbmQgXCJidWlsZFwiIGF0IG9uY2UnO1xuXG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIG5hcGkgPSByZXF1aXJlKCcuL3V0aWwvbmFwaS5qcycpO1xuXG5mdW5jdGlvbiByZWJ1aWxkIChneXAsIGFyZ3YsIGNhbGxiYWNrKSB7XG4gIHZhciBwYWNrYWdlX2pzb24gPSBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYygnLi9wYWNrYWdlLmpzb24nKSk7XG4gIHZhciBjb21tYW5kcyA9IFtcbiAgICB7IG5hbWU6ICdjbGVhbicsIGFyZ3M6IFtdIH0sXG4gICAgeyBuYW1lOiAnYnVpbGQnLCBhcmdzOiBbJ3JlYnVpbGQnXSB9XG4gICAgXTtcbiAgY29tbWFuZHMgPSBuYXBpLmV4cGFuZF9jb21tYW5kcyhwYWNrYWdlX2pzb24sIGd5cC5vcHRzLCBjb21tYW5kcyk7XG4gIGZvciAodmFyIGkgPSBjb21tYW5kcy5sZW5ndGg7IGkgIT09IDA7IGktLSkge1xuICAgIGd5cC50b2RvLnVuc2hpZnQoY29tbWFuZHNbaS0xXSk7XG4gIH1cbiAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjayk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gcmVidWlsZDtcblxuZXhwb3J0cy51c2FnZSA9ICdSdW5zIFwiY2xlYW5cIiBhbmQgXCJpbnN0YWxsXCIgYXQgb25jZSc7XG5cbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgbmFwaSA9IHJlcXVpcmUoJy4vdXRpbC9uYXBpLmpzJyk7XG5cbmZ1bmN0aW9uIHJlYnVpbGQgKGd5cCwgYXJndiwgY2FsbGJhY2spIHtcbiAgdmFyIHBhY2thZ2VfanNvbiA9IEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKCcuL3BhY2thZ2UuanNvbicpKTtcbiAgdmFyIGluc3RhbGxBcmdzID0gW107XG4gIHZhciBuYXBpX2J1aWxkX3ZlcnNpb24gPSBuYXBpLmdldF9iZXN0X25hcGlfYnVpbGRfdmVyc2lvbihwYWNrYWdlX2pzb24sIGd5cC5vcHRzKTtcbiAgaWYgKG5hcGlfYnVpbGRfdmVyc2lvbiAhPSBudWxsKSBpbnN0YWxsQXJncyA9IFsgbmFwaS5nZXRfY29tbWFuZF9hcmcgKG5hcGlfYnVpbGRfdmVyc2lvbikgXTtcbiAgZ3lwLnRvZG8udW5zaGlmdChcbiAgICAgIHsgbmFtZTogJ2NsZWFuJywgYXJnczogW10gfSxcbiAgICAgIHsgbmFtZTogJ2luc3RhbGwnLCBhcmdzOiBpbnN0YWxsQXJncyB9XG4gICk7XG4gIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2spO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IHJldmVhbDtcblxuZXhwb3J0cy51c2FnZSA9ICdSZXZlYWxzIGRhdGEgb24gdGhlIHZlcnNpb25lZCBiaW5hcnknO1xuXG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIHZlcnNpb25pbmcgPSByZXF1aXJlKCcuL3V0aWwvdmVyc2lvbmluZy5qcycpO1xudmFyIG5hcGkgPSByZXF1aXJlKCcuL3V0aWwvbmFwaS5qcycpO1xuXG5mdW5jdGlvbiB1bml4X3BhdGhzKGtleSwgdmFsKSB7XG4gICAgcmV0dXJuIHZhbCAmJiB2YWwucmVwbGFjZSA/IHZhbC5yZXBsYWNlKC9cXFxcL2csICcvJykgOiB2YWw7XG59XG5cbmZ1bmN0aW9uIHJldmVhbChneXAsIGFyZ3YsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHBhY2thZ2VfanNvbiA9IEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKCcuL3BhY2thZ2UuanNvbicpKTtcbiAgICB2YXIgbmFwaV9idWlsZF92ZXJzaW9uID0gbmFwaS5nZXRfbmFwaV9idWlsZF92ZXJzaW9uX2Zyb21fY29tbWFuZF9hcmdzKGFyZ3YpO1xuICAgIHZhciBvcHRzID0gdmVyc2lvbmluZy5ldmFsdWF0ZShwYWNrYWdlX2pzb24sIGd5cC5vcHRzLCBuYXBpX2J1aWxkX3ZlcnNpb24pO1xuICAgIHZhciBoaXQgPSBmYWxzZTtcbiAgICAvLyBpZiBhIHNlY29uZCBhcmcgaXMgcGFzc2VkIGxvb2sgdG8gc2VlXG4gICAgLy8gaWYgaXQgaXMgYSBrbm93biBvcHRpb25cbiAgICAvL2NvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KGd5cC5vcHRzLG51bGwsMSkpXG4gICAgdmFyIHJlbWFpbiA9IGd5cC5vcHRzLmFyZ3YucmVtYWluW2d5cC5vcHRzLmFyZ3YucmVtYWluLmxlbmd0aC0xXTtcbiAgICBpZiAocmVtYWluICYmIG9wdHMuaGFzT3duUHJvcGVydHkocmVtYWluKSkge1xuICAgICAgICBjb25zb2xlLmxvZyhvcHRzW3JlbWFpbl0ucmVwbGFjZSgvXFxcXC9nLCAnLycpKTtcbiAgICAgICAgaGl0ID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gb3RoZXJ3aXNlIHJldHVybiBhbGwgb3B0aW9ucyBhcyBqc29uXG4gICAgaWYgKCFoaXQpIHtcbiAgICAgICAgY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkob3B0cyx1bml4X3BhdGhzLDIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGxiYWNrKCk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gdGVzdGJpbmFyeTtcblxuZXhwb3J0cy51c2FnZSA9ICdUZXN0cyB0aGF0IHRoZSBiaW5hcnkubm9kZSBjYW4gYmUgcmVxdWlyZWQnO1xuXG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgbG9nID0gcmVxdWlyZSgnbnBtbG9nJyk7XG52YXIgY3AgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJyk7XG52YXIgdmVyc2lvbmluZyA9IHJlcXVpcmUoJy4vdXRpbC92ZXJzaW9uaW5nLmpzJyk7XG52YXIgbmFwaSA9IHJlcXVpcmUoJy4vdXRpbC9uYXBpLmpzJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxuZnVuY3Rpb24gdGVzdGJpbmFyeShneXAsIGFyZ3YsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgIHZhciBzaGVsbF9jbWQgPSBwcm9jZXNzLmV4ZWNQYXRoO1xuICAgIHZhciBwYWNrYWdlX2pzb24gPSBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYygnLi9wYWNrYWdlLmpzb24nKSk7XG4gICAgdmFyIG5hcGlfYnVpbGRfdmVyc2lvbiA9IG5hcGkuZ2V0X25hcGlfYnVpbGRfdmVyc2lvbl9mcm9tX2NvbW1hbmRfYXJncyhhcmd2KTtcbiAgICB2YXIgb3B0cyA9IHZlcnNpb25pbmcuZXZhbHVhdGUocGFja2FnZV9qc29uLCBneXAub3B0cywgbmFwaV9idWlsZF92ZXJzaW9uKTtcbiAgICAvLyBza2lwIHZhbGlkYXRpb24gZm9yIHJ1bnRpbWVzIHdlIGRvbid0IGV4cGxpY2l0bHkgc3VwcG9ydCAobGlrZSBlbGVjdHJvbilcbiAgICBpZiAob3B0cy5ydW50aW1lICYmXG4gICAgICAgIG9wdHMucnVudGltZSAhPT0gJ25vZGUtd2Via2l0JyAmJlxuICAgICAgICBvcHRzLnJ1bnRpbWUgIT09ICdub2RlJykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG4gICAgdmFyIG53ID0gKG9wdHMucnVudGltZSAmJiBvcHRzLnJ1bnRpbWUgPT09ICdub2RlLXdlYmtpdCcpO1xuICAgIC8vIGVuc3VyZSBvbiB3aW5kb3dzIHRoYXQgLyBhcmUgdXNlZCBmb3IgcmVxdWlyZSBwYXRoXG4gICAgdmFyIGJpbmFyeV9tb2R1bGUgPSBvcHRzLm1vZHVsZS5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG4gICAgaWYgKChwcm9jZXNzLmFyY2ggIT0gb3B0cy50YXJnZXRfYXJjaCkgfHxcbiAgICAgICAgKHByb2Nlc3MucGxhdGZvcm0gIT0gb3B0cy50YXJnZXRfcGxhdGZvcm0pKSB7XG4gICAgICAgIHZhciBtc2cgPSBcInNraXBwaW5nIHZhbGlkYXRpb24gc2luY2UgaG9zdCBwbGF0Zm9ybS9hcmNoIChcIjtcbiAgICAgICAgbXNnICs9IHByb2Nlc3MucGxhdGZvcm0rJy8nK3Byb2Nlc3MuYXJjaCtcIilcIjtcbiAgICAgICAgbXNnICs9IFwiIGRvZXMgbm90IG1hdGNoIHRhcmdldCAoXCI7XG4gICAgICAgIG1zZyArPSBvcHRzLnRhcmdldF9wbGF0Zm9ybSsnLycrb3B0cy50YXJnZXRfYXJjaCtcIilcIjtcbiAgICAgICAgbG9nLmluZm8oJ3ZhbGlkYXRlJywgbXNnKTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIGlmIChudykge1xuICAgICAgICBvcHRpb25zLnRpbWVvdXQgPSA1MDAwO1xuICAgICAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicpIHtcbiAgICAgICAgICAgIHNoZWxsX2NtZCA9ICdub2RlLXdlYmtpdCc7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgICAgICAgICAgc2hlbGxfY21kID0gJ253LmV4ZSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaGVsbF9jbWQgPSAnbncnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtb2R1bGVQYXRoID0gcGF0aC5yZXNvbHZlKGJpbmFyeV9tb2R1bGUpO1xuICAgICAgICB2YXIgYXBwRGlyID0gcGF0aC5qb2luKF9fZGlybmFtZSwgJ3V0aWwnLCAnbnctcHJlLWd5cCcpO1xuICAgICAgICBhcmdzLnB1c2goYXBwRGlyKTtcbiAgICAgICAgYXJncy5wdXNoKG1vZHVsZVBhdGgpO1xuICAgICAgICBsb2cuaW5mbyhcInZhbGlkYXRlXCIsXCJSdW5uaW5nIHRlc3QgY29tbWFuZDogJ1wiICsgc2hlbGxfY21kICsgJyAnICsgYXJncy5qb2luKCcgJykgKyBcIidcIik7XG4gICAgICAgIGNwLmV4ZWNGaWxlKHNoZWxsX2NtZCwgYXJncywgb3B0aW9ucywgZnVuY3Rpb24oZXJyLCBzdGRvdXQsIHN0ZGVycikge1xuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIG5vcm1hbCB0aW1lb3V0IGZvciBub2RlLXdlYmtpdFxuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIua2lsbGVkID09PSB0cnVlICYmIGVyci5zaWduYWwgJiYgZXJyLnNpZ25hbC5pbmRleE9mKCdTSUcnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc3RkZXJyTG9nID0gc3RkZXJyLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgbG9nLmluZm8oJ3N0ZGVycicsIHN0ZGVyckxvZyk7XG4gICAgICAgICAgICAgICAgaWYoIC9eXFxzKlhsaWI6XFxzKmV4dGVuc2lvblxccypcIlJBTkRSXCJcXHMqbWlzc2luZ1xccypvblxccypkaXNwbGF5XFxzKlwiOlxcZCtcXC5cXGQrXCJcXC5cXHMqJC8udGVzdChzdGRlcnJMb2cpICl7XG4gICAgICAgICAgICAgICAgICAgIGxvZy5pbmZvKCdSQU5EUicsICdzdGRlcnIgY29udGFpbnMgb25seSBSQU5EUiBlcnJvciwgaWdub3JlZCcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXJncy5wdXNoKCctLWV2YWwnKTtcbiAgICBhcmdzLnB1c2goXCJyZXF1aXJlKCdcIiArIGJpbmFyeV9tb2R1bGUucmVwbGFjZSgvJy9nLCAnXFwnJykgK1wiJylcIik7XG4gICAgbG9nLmluZm8oXCJ2YWxpZGF0ZVwiLFwiUnVubmluZyB0ZXN0IGNvbW1hbmQ6ICdcIiArIHNoZWxsX2NtZCArICcgJyArIGFyZ3Muam9pbignICcpICsgXCInXCIpO1xuICAgIGNwLmV4ZWNGaWxlKHNoZWxsX2NtZCwgYXJncywgb3B0aW9ucywgZnVuY3Rpb24oZXJyLCBzdGRvdXQsIHN0ZGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCB7IHN0ZG91dDpzdGRvdXQsIHN0ZGVycjpzdGRlcnJ9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9KTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSB0ZXN0cGFja2FnZTtcblxuZXhwb3J0cy51c2FnZSA9ICdUZXN0cyB0aGF0IHRoZSBzdGFnZWQgcGFja2FnZSBpcyB2YWxpZCc7XG5cbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciBsb2cgPSByZXF1aXJlKCducG1sb2cnKTtcbnZhciBleGlzdHNBc3luYyA9IGZzLmV4aXN0cyB8fCBwYXRoLmV4aXN0cztcbnZhciB2ZXJzaW9uaW5nID0gcmVxdWlyZSgnLi91dGlsL3ZlcnNpb25pbmcuanMnKTtcbnZhciBuYXBpID0gcmVxdWlyZSgnLi91dGlsL25hcGkuanMnKTtcbnZhciB0ZXN0YmluYXJ5ID0gcmVxdWlyZSgnLi90ZXN0YmluYXJ5LmpzJyk7XG52YXIgdGFyID0gcmVxdWlyZSgndGFyJyk7XG52YXIgbWtkaXJwID0gcmVxdWlyZSgnbWtkaXJwJyk7XG5cbmZ1bmN0aW9uIHRlc3RwYWNrYWdlKGd5cCwgYXJndiwgY2FsbGJhY2spIHtcbiAgICB2YXIgcGFja2FnZV9qc29uID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMoJy4vcGFja2FnZS5qc29uJykpO1xuICAgIHZhciBuYXBpX2J1aWxkX3ZlcnNpb24gPSBuYXBpLmdldF9uYXBpX2J1aWxkX3ZlcnNpb25fZnJvbV9jb21tYW5kX2FyZ3MoYXJndik7XG4gICAgdmFyIG9wdHMgPSB2ZXJzaW9uaW5nLmV2YWx1YXRlKHBhY2thZ2VfanNvbiwgZ3lwLm9wdHMsIG5hcGlfYnVpbGRfdmVyc2lvbik7XG4gICAgdmFyIHRhcmJhbGwgPSBvcHRzLnN0YWdlZF90YXJiYWxsO1xuICAgIGV4aXN0c0FzeW5jKHRhcmJhbGwsIGZ1bmN0aW9uKGZvdW5kKSB7XG4gICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoXCJDYW5ub3QgdGVzdCBwYWNrYWdlIGJlY2F1c2UgXCIgKyB0YXJiYWxsICsgXCIgbWlzc2luZzogcnVuIGBub2RlLXByZS1neXAgcGFja2FnZWAgZmlyc3RcIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0byA9IG9wdHMubW9kdWxlX3BhdGg7XG4gICAgICAgIGZ1bmN0aW9uIGZpbHRlcl9mdW5jKGVudHJ5KSB7XG4gICAgICAgICAgICBsb2cuaW5mbygnaW5zdGFsbCcsJ3VucGFja2luZyBbJyArIGVudHJ5LnBhdGggKyAnXScpO1xuICAgICAgICB9XG5cbiAgICAgICAgbWtkaXJwKHRvLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyLmV4dHJhY3Qoe1xuICAgICAgICAgICAgICAgICAgICBmaWxlOiB0YXJiYWxsLFxuICAgICAgICAgICAgICAgICAgICBjd2Q6IHRvLFxuICAgICAgICAgICAgICAgICAgICBzdHJpcDogMSxcbiAgICAgICAgICAgICAgICAgICAgb25lbnRyeTogZmlsdGVyX2Z1bmNcbiAgICAgICAgICAgICAgICB9KS50aGVuKGFmdGVyX2V4dHJhY3QsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gYWZ0ZXJfZXh0cmFjdCgpIHtcbiAgICAgICAgICAgIHRlc3RiaW5hcnkoZ3lwLGFyZ3YsZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnWycrcGFja2FnZV9qc29uLm5hbWUrJ10gUGFja2FnZSBhcHBlYXJzIHZhbGlkJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gdW5wdWJsaXNoO1xuXG5leHBvcnRzLnVzYWdlID0gJ1VucHVibGlzaGVzIHByZS1idWlsdCBiaW5hcnkgKHJlcXVpcmVzIGF3cy1zZGspJztcblxudmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbnZhciBsb2cgPSByZXF1aXJlKCducG1sb2cnKTtcbnZhciB2ZXJzaW9uaW5nID0gcmVxdWlyZSgnLi91dGlsL3ZlcnNpb25pbmcuanMnKTtcbnZhciBuYXBpID0gcmVxdWlyZSgnLi91dGlsL25hcGkuanMnKTtcbnZhciBzM19zZXR1cCA9IHJlcXVpcmUoJy4vdXRpbC9zM19zZXR1cC5qcycpO1xudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJ3JjJykoXCJub2RlX3ByZV9neXBcIix7YWNsOlwicHVibGljLXJlYWRcIn0pO1xuXG5mdW5jdGlvbiB1bnB1Ymxpc2goZ3lwLCBhcmd2LCBjYWxsYmFjaykge1xuICAgIHZhciBBV1MgPSByZXF1aXJlKFwiYXdzLXNka1wiKTtcbiAgICB2YXIgcGFja2FnZV9qc29uID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMoJy4vcGFja2FnZS5qc29uJykpO1xuICAgIHZhciBuYXBpX2J1aWxkX3ZlcnNpb24gPSBuYXBpLmdldF9uYXBpX2J1aWxkX3ZlcnNpb25fZnJvbV9jb21tYW5kX2FyZ3MoYXJndik7XG4gICAgdmFyIG9wdHMgPSB2ZXJzaW9uaW5nLmV2YWx1YXRlKHBhY2thZ2VfanNvbiwgZ3lwLm9wdHMsIG5hcGlfYnVpbGRfdmVyc2lvbik7XG4gICAgczNfc2V0dXAuZGV0ZWN0KG9wdHMuaG9zdGVkX3BhdGgsY29uZmlnKTtcbiAgICBBV1MuY29uZmlnLnVwZGF0ZShjb25maWcpO1xuICAgIHZhciBrZXlfbmFtZSA9IHVybC5yZXNvbHZlKGNvbmZpZy5wcmVmaXgsb3B0cy5wYWNrYWdlX25hbWUpO1xuICAgIHZhciBzMyA9ICBuZXcgQVdTLlMzKCk7XG4gICAgdmFyIHMzX29wdHMgPSB7ICBCdWNrZXQ6IGNvbmZpZy5idWNrZXQsXG4gICAgICAgICAgICAgICAgICAgICBLZXk6IGtleV9uYW1lXG4gICAgICAgICAgICAgICAgICB9O1xuICAgIHMzLmhlYWRPYmplY3QoczNfb3B0cywgZnVuY3Rpb24oZXJyLCBtZXRhKSB7XG4gICAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgPT0gJ05vdEZvdW5kJykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1snK3BhY2thZ2VfanNvbi5uYW1lKyddIE5vdCBmb3VuZDogaHR0cHM6Ly8nICsgczNfb3B0cy5CdWNrZXQgKyAnLnMzLmFtYXpvbmF3cy5jb20vJyArIHMzX29wdHMuS2V5KTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9IGVsc2UgaWYoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZy5pbmZvKCd1bnB1Ymxpc2gnLCBKU09OLnN0cmluZ2lmeShtZXRhKSk7XG4gICAgICAgICAgICBzMy5kZWxldGVPYmplY3QoczNfb3B0cywgZnVuY3Rpb24oZXJyLCByZXNwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgbG9nLmluZm8oSlNPTi5zdHJpbmdpZnkocmVzcCkpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbJytwYWNrYWdlX2pzb24ubmFtZSsnXSBTdWNjZXNzOiByZW1vdmVkIGh0dHBzOi8vJyArIHMzX29wdHMuQnVja2V0ICsgJy5zMy5hbWF6b25hd3MuY29tLycgKyBzM19vcHRzLktleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuIiwiZnVuY3Rpb24gd2VicGFja0VtcHR5Q29udGV4dChyZXEpIHtcblx0dmFyIGUgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInXCIpO1xuXHRlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7XG5cdHRocm93IGU7XG59XG53ZWJwYWNrRW1wdHlDb250ZXh0LmtleXMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIFtdOyB9O1xud2VicGFja0VtcHR5Q29udGV4dC5yZXNvbHZlID0gd2VicGFja0VtcHR5Q29udGV4dDtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0VtcHR5Q29udGV4dDtcbndlYnBhY2tFbXB0eUNvbnRleHQuaWQgPSBcIi4vbm9kZV9tb2R1bGVzL25vZGUtcHJlLWd5cC9saWIvdXRpbCBzeW5jIHJlY3Vyc2l2ZVwiOyIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG5cbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciB3aW4gPSBwcm9jZXNzLnBsYXRmb3JtID09ICd3aW4zMic7XG52YXIgZXhpc3RzU3luYyA9IGZzLmV4aXN0c1N5bmMgfHwgcGF0aC5leGlzdHNTeW5jO1xudmFyIGNwID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpO1xuXG4vLyB0cnkgdG8gYnVpbGQgdXAgdGhlIGNvbXBsZXRlIHBhdGggdG8gbm9kZS1neXBcbi8qIHByaW9yaXR5OlxuICAtIG5vZGUtZ3lwIG9uIEVOVjpucG1fY29uZmlnX25vZGVfZ3lwIChodHRwczovL2dpdGh1Yi5jb20vbnBtL25wbS9wdWxsLzQ4ODcpXG4gIC0gbm9kZS1neXAgb24gTk9ERV9QQVRIXG4gIC0gbm9kZS1neXAgaW5zaWRlIG5wbSBvbiBOT0RFX1BBVEggKGlnbm9yZSBvbiBpb2pzKVxuICAtIG5vZGUtZ3lwIGluc2lkZSBucG0gYmVzaWRlIG5vZGUgZXhlXG4qL1xuZnVuY3Rpb24gd2hpY2hfbm9kZV9neXAoKSB7XG4gICAgdmFyIG5vZGVfZ3lwX2JpbjtcbiAgICBpZiAocHJvY2Vzcy5lbnYubnBtX2NvbmZpZ19ub2RlX2d5cCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgICBub2RlX2d5cF9iaW4gPSBwcm9jZXNzLmVudi5ucG1fY29uZmlnX25vZGVfZ3lwO1xuICAgICAgICAgIGlmIChleGlzdHNTeW5jKG5vZGVfZ3lwX2JpbikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5vZGVfZ3lwX2JpbjtcbiAgICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHsgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgICB2YXIgbm9kZV9neXBfbWFpbiA9IHJlcXVpcmUucmVzb2x2ZSgnbm9kZS1neXAnKTtcbiAgICAgICAgbm9kZV9neXBfYmluID0gcGF0aC5qb2luKHBhdGguZGlybmFtZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmRpcm5hbWUobm9kZV9neXBfbWFpbikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdiaW4vbm9kZS1neXAuanMnKTtcbiAgICAgICAgaWYgKGV4aXN0c1N5bmMobm9kZV9neXBfYmluKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVfZ3lwX2JpbjtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikgeyB9XG4gICAgaWYgKHByb2Nlc3MuZXhlY1BhdGguaW5kZXhPZignaW9qcycpID09PSAtMSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIG5wbV9tYWluID0gcmVxdWlyZS5yZXNvbHZlKCducG0nKTtcbiAgICAgICAgICAgIG5vZGVfZ3lwX2JpbiA9IHBhdGguam9pbihwYXRoLmRpcm5hbWUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguZGlybmFtZShucG1fbWFpbikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbm9kZV9tb2R1bGVzL25vZGUtZ3lwL2Jpbi9ub2RlLWd5cC5qcycpO1xuICAgICAgICAgICAgaWYgKGV4aXN0c1N5bmMobm9kZV9neXBfYmluKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlX2d5cF9iaW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikgeyB9XG4gICAgfVxuICAgIHZhciBucG1fYmFzZSA9IHBhdGguam9pbihwYXRoLmRpcm5hbWUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguZGlybmFtZShwcm9jZXNzLmV4ZWNQYXRoKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICdsaWIvbm9kZV9tb2R1bGVzL25wbS8nKTtcbiAgICBub2RlX2d5cF9iaW4gPSBwYXRoLmpvaW4obnBtX2Jhc2UsICdub2RlX21vZHVsZXMvbm9kZS1neXAvYmluL25vZGUtZ3lwLmpzJyk7XG4gICAgaWYgKGV4aXN0c1N5bmMobm9kZV9neXBfYmluKSkge1xuICAgICAgICByZXR1cm4gbm9kZV9neXBfYmluO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMucnVuX2d5cCA9IGZ1bmN0aW9uKGFyZ3Msb3B0cyxjYWxsYmFjaykge1xuICAgIHZhciBzaGVsbF9jbWQgPSAnJztcbiAgICB2YXIgY21kX2FyZ3MgPSBbXTtcbiAgICBpZiAob3B0cy5ydW50aW1lICYmIG9wdHMucnVudGltZSA9PSAnbm9kZS13ZWJraXQnKSB7XG4gICAgICAgIHNoZWxsX2NtZCA9ICdudy1neXAnO1xuICAgICAgICBpZiAod2luKSBzaGVsbF9jbWQgKz0gJy5jbWQnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBub2RlX2d5cF9wYXRoID0gd2hpY2hfbm9kZV9neXAoKTtcbiAgICAgICAgaWYgKG5vZGVfZ3lwX3BhdGgpIHtcbiAgICAgICAgICAgIHNoZWxsX2NtZCA9IHByb2Nlc3MuZXhlY1BhdGg7XG4gICAgICAgICAgICBjbWRfYXJncy5wdXNoKG5vZGVfZ3lwX3BhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2hlbGxfY21kID0gJ25vZGUtZ3lwJztcbiAgICAgICAgICAgIGlmICh3aW4pIHNoZWxsX2NtZCArPSAnLmNtZCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGZpbmFsX2FyZ3MgPSBjbWRfYXJncy5jb25jYXQoYXJncyk7XG4gICAgdmFyIGNtZCA9IGNwLnNwYXduKHNoZWxsX2NtZCwgZmluYWxfYXJncywge2N3ZDogdW5kZWZpbmVkLCBlbnY6IHByb2Nlc3MuZW52LCBzdGRpbzogWyAwLCAxLCAyXX0pO1xuICAgIGNtZC5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZXhlY3V0ZSAnXCIgKyBzaGVsbF9jbWQgKyAnICcgKyBmaW5hbF9hcmdzLmpvaW4oJyAnKSArIFwiJyAoXCIgKyBlcnIgKyBcIilcIikpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwsb3B0cyk7XG4gICAgfSk7XG4gICAgY21kLm9uKCdjbG9zZScsIGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgIGlmIChjb2RlICYmIGNvZGUgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZXhlY3V0ZSAnXCIgKyBzaGVsbF9jbWQgKyAnICcgKyBmaW5hbF9hcmdzLmpvaW4oJyAnKSArIFwiJyAoXCIgKyBjb2RlICsgXCIpXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhudWxsLG9wdHMpO1xuICAgIH0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBoYW5kbGVfZ3lwX29wdHM7XG5cbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgdmVyc2lvbmluZyA9IHJlcXVpcmUoJy4vdmVyc2lvbmluZy5qcycpO1xudmFyIG5hcGkgPSByZXF1aXJlKCcuL25hcGkuanMnKTtcblxuLypcblxuSGVyZSB3ZSBnYXRoZXIgbm9kZS1wcmUtZ3lwIGdlbmVyYXRlZCBvcHRpb25zIChmcm9tIHZlcnNpb25pbmcpIGFuZCBwYXNzIHRoZW0gYWxvbmcgdG8gbm9kZS1neXAuXG5cbldlIG1hc3NhZ2UgdGhlIGFyZ3MgYW5kIG9wdGlvbnMgc2xpZ2h0bHkgdG8gYWNjb3VudCBmb3IgZGlmZmVyZW5jZXMgaW4gd2hhdCBjb21tYW5kcyBtZWFuIGJldHdlZW5cbm5vZGUtcHJlLWd5cCBhbmQgbm9kZS1neXAgKGUuZy4gc2VlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gXCJidWlsZFwiIGFuZCBcInJlYnVpbGRcIiBiZWxvdylcblxuS2VlcCBpbiBtaW5kOiB0aGUgdmFsdWVzIGluc2lkZSBgYXJndmAgYW5kIGBneXAub3B0c2AgYmVsb3cgYXJlIGRpZmZlcmVudCBkZXBlbmRpbmcgb24gd2hldGhlclxubm9kZS1wcmUtZ3lwIGlzIGNhbGxlZCBkaXJlY3RvcnksIG9yIGlmIGl0IGlzIGNhbGxlZCBpbiBhIGBydW4tc2NyaXB0YCBwaGFzZSBvZiBucG0uXG5cbldlIGFsc28gdHJ5IHRvIHByZXNlcnZlIGFueSBjb21tYW5kIGxpbmUgb3B0aW9ucyB0aGF0IG1pZ2h0IGhhdmUgYmVlbiBwYXNzZWQgdG8gbnBtIG9yIG5vZGUtcHJlLWd5cC5cbkJ1dCB0aGlzIGlzIGZhaXJseSBkaWZmaWN1bHQgd2l0aG91dCBwYXNzaW5nIHdheSB0byBtdWNoIHRocm91Z2guIEZvciBleGFtcGxlIGBneXAub3B0c2AgY29udGFpbnMgYWxsXG50aGUgcHJvY2Vzcy5lbnYgYW5kIG5wbSBwdXNoZXMgYSBsb3Qgb2YgdmFyaWFibGVzIGludG8gcHJvY2Vzcy5lbnYgd2hpY2ggbm9kZS1wcmUtZ3lwIGluaGVyaXRzLiBTbyB3ZSBoYXZlXG50byBiZSB2ZXJ5IHNlbGVjdGl2ZSBhYm91dCB3aGF0IHdlIHBhc3MgdGhyb3VnaC5cblxuRm9yIGV4YW1wbGU6XG5cbmBucG0gaW5zdGFsbCAtLWJ1aWxkLWZyb20tc291cmNlYCB3aWxsIGdpdmU6XG5cbmFyZ3YgPT0gWyAncmVidWlsZCcgXVxuZ3lwLm9wdHMuYXJndiA9PSB7IHJlbWFpbjogWyAnaW5zdGFsbCcgXSxcbiAgY29va2VkOiBbICdpbnN0YWxsJywgJy0tZmFsbGJhY2stdG8tYnVpbGQnIF0sXG4gIG9yaWdpbmFsOiBbICdpbnN0YWxsJywgJy0tZmFsbGJhY2stdG8tYnVpbGQnIF0gfVxuXG5gLi9iaW4vbm9kZS1wcmUtZ3lwIGJ1aWxkYCB3aWxsIGdpdmU6XG5cbmFyZ3YgPT0gW11cbmd5cC5vcHRzLmFyZ3YgPT0geyByZW1haW46IFsgJ2J1aWxkJyBdLFxuICBjb29rZWQ6IFsgJ2J1aWxkJyBdLFxuICBvcmlnaW5hbDogWyAnLUMnLCAndGVzdC9hcHAxJywgJ2J1aWxkJyBdIH1cblxuKi9cblxuLy8gc2VsZWN0IHNldCBvZiBub2RlLXByZS1neXAgdmVyc2lvbmluZyBpbmZvXG4vLyB0byBzaGFyZSB3aXRoIG5vZGUtZ3lwXG52YXIgc2hhcmVfd2l0aF9ub2RlX2d5cCA9IFtcbiAgJ21vZHVsZScsXG4gICdtb2R1bGVfbmFtZScsXG4gICdtb2R1bGVfcGF0aCcsXG4gICduYXBpX3ZlcnNpb24nLFxuICAnbm9kZV9hYmlfbmFwaScsXG4gICduYXBpX2J1aWxkX3ZlcnNpb24nLFxuICAnbm9kZV9uYXBpX2xhYmVsJ1xuXTtcblxuZnVuY3Rpb24gaGFuZGxlX2d5cF9vcHRzKGd5cCwgYXJndiwgY2FsbGJhY2spIHtcblxuICAgIC8vIENvbGxlY3Qgbm9kZS1wcmUtZ3lwIHNwZWNpZmljIHZhcmlhYmxlcyB0byBwYXNzIHRvIG5vZGUtZ3lwXG4gICAgdmFyIG5vZGVfcHJlX2d5cF9vcHRpb25zID0gW107XG4gICAgLy8gZ2VuZXJhdGUgY3VzdG9tIG5vZGUtcHJlLWd5cCB2ZXJzaW9uaW5nIGluZm9cbiAgICB2YXIgbmFwaV9idWlsZF92ZXJzaW9uID0gbmFwaS5nZXRfbmFwaV9idWlsZF92ZXJzaW9uX2Zyb21fY29tbWFuZF9hcmdzKGFyZ3YpO1xuICAgIHZhciBvcHRzID0gdmVyc2lvbmluZy5ldmFsdWF0ZShKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYygnLi9wYWNrYWdlLmpzb24nKSksIGd5cC5vcHRzLCBuYXBpX2J1aWxkX3ZlcnNpb24pO1xuICAgIHNoYXJlX3dpdGhfbm9kZV9neXAuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIHZhbCA9IG9wdHNba2V5XTtcbiAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgbm9kZV9wcmVfZ3lwX29wdGlvbnMucHVzaCgnLS0nICsga2V5ICsgJz0nICsgdmFsKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICduYXBpX2J1aWxkX3ZlcnNpb24nKSB7XG4gICAgICAgICAgICBub2RlX3ByZV9neXBfb3B0aW9ucy5wdXNoKCctLScgKyBrZXkgKyAnPTAnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChrZXkgIT09ICduYXBpX3ZlcnNpb24nICYmIGtleSAhPT0gJ25vZGVfYWJpX25hcGknKVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoXCJPcHRpb24gXCIgKyBrZXkgKyBcIiByZXF1aXJlZCBidXQgbm90IGZvdW5kIGJ5IG5vZGUtcHJlLWd5cFwiKSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIENvbGxlY3Qgb3B0aW9ucyB0aGF0IGZvbGxvdyB0aGUgc3BlY2lhbCAtLSB3aGljaCBkaXNhYmxlcyBub3B0IHBhcnNpbmdcbiAgICB2YXIgdW5wYXJzZWRfb3B0aW9ucyA9IFtdO1xuICAgIHZhciBkb3VibGVfaHlwaGVuX2ZvdW5kID0gZmFsc2U7XG4gICAgZ3lwLm9wdHMuYXJndi5vcmlnaW5hbC5mb3JFYWNoKGZ1bmN0aW9uKG9wdCkge1xuICAgICAgICBpZiAoZG91YmxlX2h5cGhlbl9mb3VuZCkge1xuICAgICAgICAgICAgdW5wYXJzZWRfb3B0aW9ucy5wdXNoKG9wdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdCA9PSAnLS0nKSB7XG4gICAgICAgICAgICBkb3VibGVfaHlwaGVuX2ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gV2UgdHJ5IHJlc3BlY3QgYW5kIHBhc3MgdGhyb3VnaCByZW1haW5pbmcgY29tbWFuZFxuICAgIC8vIGxpbmUgb3B0aW9ucyAobGlrZSAtLWZvbz1iYXIpIHRvIG5vZGUtZ3lwXG4gICAgdmFyIGNvb2tlZCA9IGd5cC5vcHRzLmFyZ3YuY29va2VkO1xuICAgIHZhciBub2RlX2d5cF9vcHRpb25zID0gW107XG4gICAgY29va2VkLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDIgJiYgdmFsdWUuc2xpY2UoMCwyKSA9PSAnLS0nKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gdmFsdWUuc2xpY2UoMik7XG4gICAgICAgICAgICB2YXIgdmFsID0gY29va2VkW2Nvb2tlZC5pbmRleE9mKHZhbHVlKSsxXTtcbiAgICAgICAgICAgIGlmICh2YWwgJiYgdmFsLmluZGV4T2YoJy0tJykgPT09IC0xKSB7IC8vIGhhbmRsZSAnLS1mb289YmFyJyBvciBbJy0tZm9vJywnYmFyJ11cbiAgICAgICAgICAgICAgICBub2RlX2d5cF9vcHRpb25zLnB1c2goJy0tJyArIGtleSArICc9JyArIHZhbCk7XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBwYXNzIHRocm91Z2ggLS1mb29cbiAgICAgICAgICAgICAgICBub2RlX2d5cF9vcHRpb25zLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVzdWx0ID0geydvcHRzJzpvcHRzLCdneXAnOm5vZGVfZ3lwX29wdGlvbnMsJ3ByZSc6bm9kZV9wcmVfZ3lwX29wdGlvbnMsJ3VucGFyc2VkJzp1bnBhcnNlZF9vcHRpb25zfTtcbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCxyZXN1bHQpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcblxudmFyIHZlcnNpb25BcnJheSA9IHByb2Nlc3MudmVyc2lvblxuXHQuc3Vic3RyKDEpXG5cdC5yZXBsYWNlKC8tLiokLywgJycpXG5cdC5zcGxpdCgnLicpXG5cdC5tYXAoZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiAraXRlbTtcblx0fSk7XG5cbnZhciBuYXBpX211bHRpcGxlX2NvbW1hbmRzID0gW1xuXHQnYnVpbGQnLFxuXHQnY2xlYW4nLFxuXHQnY29uZmlndXJlJyxcblx0J3BhY2thZ2UnLFxuXHQncHVibGlzaCcsXG5cdCdyZXZlYWwnLFxuXHQndGVzdGJpbmFyeScsXG5cdCd0ZXN0cGFja2FnZScsXG5cdCd1bnB1Ymxpc2gnXG5dO1xuXG52YXIgbmFwaV9idWlsZF92ZXJzaW9uX3RhZyA9ICduYXBpX2J1aWxkX3ZlcnNpb249JztcblxubW9kdWxlLmV4cG9ydHMuZ2V0X25hcGlfdmVyc2lvbiA9IGZ1bmN0aW9uKHRhcmdldCkgeyAvLyB0YXJnZXQgbWF5IGJlIHVuZGVmaW5lZFxuXHQvLyByZXR1cm5zIHRoZSBub24temVybyBudW1lcmljIG5hcGkgdmVyc2lvbiBvciB1bmRlZmluZWQgaWYgbmFwaSBpcyBub3Qgc3VwcG9ydGVkLlxuXHQvLyBjb3JyZWN0bHkgc3VwcG9ydGluZyB0YXJnZXQgcmVxdWlyZXMgYW4gdXBkYXRlZCBjcm9zcy13YWxrXG5cdHZhciB2ZXJzaW9uID0gcHJvY2Vzcy52ZXJzaW9ucy5uYXBpOyAvLyBjYW4gYmUgdW5kZWZpbmVkXG5cdGlmICghdmVyc2lvbikgeyAvLyB0aGlzIGNvZGUgc2hvdWxkIG5ldmVyIG5lZWQgdG8gYmUgdXBkYXRlZFxuXHRcdGlmICh2ZXJzaW9uQXJyYXlbMF0gPT09IDkgJiYgdmVyc2lvbkFycmF5WzFdID49IDMpIHZlcnNpb24gPSAyOyAvLyA5LjMuMCtcblx0XHRlbHNlIGlmICh2ZXJzaW9uQXJyYXlbMF0gPT09IDgpIHZlcnNpb24gPSAxOyAvLyA4LjAuMCtcblx0fVxuXHRyZXR1cm4gdmVyc2lvbjtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmdldF9uYXBpX3ZlcnNpb25fYXNfc3RyaW5nID0gZnVuY3Rpb24odGFyZ2V0KSB7XG5cdC8vIHJldHVybnMgdGhlIG5hcGkgdmVyc2lvbiBhcyBhIHN0cmluZyBvciBhbiBlbXB0eSBzdHJpbmcgaWYgbmFwaSBpcyBub3Qgc3VwcG9ydGVkLlxuXHR2YXIgdmVyc2lvbiA9IG1vZHVsZS5leHBvcnRzLmdldF9uYXBpX3ZlcnNpb24odGFyZ2V0KTtcblx0cmV0dXJuIHZlcnNpb24gPyAnJyt2ZXJzaW9uIDogJyc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy52YWxpZGF0ZV9wYWNrYWdlX2pzb24gPSBmdW5jdGlvbihwYWNrYWdlX2pzb24sIG9wdHMpIHsgLy8gdGhyb3dzIEVycm9yXG5cblx0dmFyIGJpbmFyeSA9IHBhY2thZ2VfanNvbi5iaW5hcnk7XG5cdHZhciBtb2R1bGVfcGF0aF9vayA9IHBhdGhPSyhiaW5hcnkubW9kdWxlX3BhdGgpO1xuXHR2YXIgcmVtb3RlX3BhdGhfb2sgPSBwYXRoT0soYmluYXJ5LnJlbW90ZV9wYXRoKTtcblx0dmFyIHBhY2thZ2VfbmFtZV9vayA9IHBhdGhPSyhiaW5hcnkucGFja2FnZV9uYW1lKTtcblx0dmFyIG5hcGlfYnVpbGRfdmVyc2lvbnMgPSBtb2R1bGUuZXhwb3J0cy5nZXRfbmFwaV9idWlsZF92ZXJzaW9ucyhwYWNrYWdlX2pzb24sb3B0cyx0cnVlKTtcblx0dmFyIG5hcGlfYnVpbGRfdmVyc2lvbnNfcmF3ID0gbW9kdWxlLmV4cG9ydHMuZ2V0X25hcGlfYnVpbGRfdmVyc2lvbnNfcmF3KHBhY2thZ2VfanNvbik7XG5cblx0aWYgKG5hcGlfYnVpbGRfdmVyc2lvbnMpIHtcblx0XHRuYXBpX2J1aWxkX3ZlcnNpb25zLmZvckVhY2goZnVuY3Rpb24obmFwaV9idWlsZF92ZXJzaW9uKXtcblx0XHRcdGlmICghKHBhcnNlSW50KG5hcGlfYnVpbGRfdmVyc2lvbiwxMCkgPT09IG5hcGlfYnVpbGRfdmVyc2lvbiAmJiBuYXBpX2J1aWxkX3ZlcnNpb24gPiAwKSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBbGwgdmFsdWVzIHNwZWNpZmllZCBpbiBuYXBpX3ZlcnNpb25zIG11c3QgYmUgcG9zaXRpdmUgaW50ZWdlcnMuXCIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0aWYgKG5hcGlfYnVpbGRfdmVyc2lvbnMgJiYgKCFtb2R1bGVfcGF0aF9vayB8fCAoIXJlbW90ZV9wYXRoX29rICYmICFwYWNrYWdlX25hbWVfb2spKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIldoZW4gbmFwaV92ZXJzaW9ucyBpcyBzcGVjaWZpZWQ7IG1vZHVsZV9wYXRoIGFuZCBlaXRoZXIgcmVtb3RlX3BhdGggb3IgXCIgK1xuXHRcdFx0XCJwYWNrYWdlX25hbWUgbXVzdCBjb250YWluIHRoZSBzdWJzdGl0dXRpb24gc3RyaW5nICd7bmFwaV9idWlsZF92ZXJzaW9ufWAuXCIpO1xuXHR9XG5cblx0aWYgKChtb2R1bGVfcGF0aF9vayB8fCByZW1vdGVfcGF0aF9vayB8fCBwYWNrYWdlX25hbWVfb2spICYmICFuYXBpX2J1aWxkX3ZlcnNpb25zX3Jhdykge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIldoZW4gdGhlIHN1YnN0aXR1dGlvbiBzdHJpbmcgJ3tuYXBpX2J1aWxkX3ZlcnNpb259YCBpcyBzcGVjaWZpZWQgaW4gXCIgK1xuXHRcdFx0XCJtb2R1bGVfcGF0aCwgcmVtb3RlX3BhdGgsIG9yIHBhY2thZ2VfbmFtZTsgbmFwaV92ZXJzaW9ucyBtdXN0IGFsc28gYmUgc3BlY2lmaWVkLlwiKTtcblx0fVxuXG5cdGlmIChuYXBpX2J1aWxkX3ZlcnNpb25zICYmICFtb2R1bGUuZXhwb3J0cy5nZXRfYmVzdF9uYXBpX2J1aWxkX3ZlcnNpb24ocGFja2FnZV9qc29uLCBvcHRzKSAmJiBcblx0bW9kdWxlLmV4cG9ydHMuYnVpbGRfbmFwaV9vbmx5KHBhY2thZ2VfanNvbikpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHQnVGhlIE4tQVBJIHZlcnNpb24gb2YgdGhpcyBOb2RlIGluc3RhbmNlIGlzICcgKyBtb2R1bGUuZXhwb3J0cy5nZXRfbmFwaV92ZXJzaW9uKG9wdHMgPyBvcHRzLnRhcmdldCA6IHVuZGVmaW5lZCkgKyAnLiAnICtcblx0XHRcdCdUaGlzIG1vZHVsZSBzdXBwb3J0cyBOLUFQSSB2ZXJzaW9uKHMpICcgKyBtb2R1bGUuZXhwb3J0cy5nZXRfbmFwaV9idWlsZF92ZXJzaW9uc19yYXcocGFja2FnZV9qc29uKSArICcuICcgK1xuXHRcdFx0J1RoaXMgTm9kZSBpbnN0YW5jZSBjYW5ub3QgcnVuIHRoaXMgbW9kdWxlLicpO1xuXHR9XG5cblx0aWYgKG5hcGlfYnVpbGRfdmVyc2lvbnNfcmF3ICYmICFuYXBpX2J1aWxkX3ZlcnNpb25zICYmIG1vZHVsZS5leHBvcnRzLmJ1aWxkX25hcGlfb25seShwYWNrYWdlX2pzb24pKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0J1RoZSBOLUFQSSB2ZXJzaW9uIG9mIHRoaXMgTm9kZSBpbnN0YW5jZSBpcyAnICsgbW9kdWxlLmV4cG9ydHMuZ2V0X25hcGlfdmVyc2lvbihvcHRzID8gb3B0cy50YXJnZXQgOiB1bmRlZmluZWQpICsgJy4gJyArXG5cdFx0XHQnVGhpcyBtb2R1bGUgc3VwcG9ydHMgTi1BUEkgdmVyc2lvbihzKSAnICsgbW9kdWxlLmV4cG9ydHMuZ2V0X25hcGlfYnVpbGRfdmVyc2lvbnNfcmF3KHBhY2thZ2VfanNvbikgKyAnLiAnICtcblx0XHRcdCdUaGlzIE5vZGUgaW5zdGFuY2UgY2Fubm90IHJ1biB0aGlzIG1vZHVsZS4nKTtcblx0fVxuXG59O1xuXG5mdW5jdGlvbiBwYXRoT0sgKHBhdGgpIHtcblx0cmV0dXJuIHBhdGggJiYgKHBhdGguaW5kZXhPZigne25hcGlfYnVpbGRfdmVyc2lvbn0nKSAhPT0gLTEgfHwgcGF0aC5pbmRleE9mKCd7bm9kZV9uYXBpX2xhYmVsfScpICE9PSAtMSk7XG59XG5cbm1vZHVsZS5leHBvcnRzLmV4cGFuZF9jb21tYW5kcyA9IGZ1bmN0aW9uKHBhY2thZ2VfanNvbiwgb3B0cywgY29tbWFuZHMpIHtcblx0dmFyIGV4cGFuZGVkX2NvbW1hbmRzID0gW107XG5cdHZhciBuYXBpX2J1aWxkX3ZlcnNpb25zID0gbW9kdWxlLmV4cG9ydHMuZ2V0X25hcGlfYnVpbGRfdmVyc2lvbnMocGFja2FnZV9qc29uLCBvcHRzKTtcblx0Y29tbWFuZHMuZm9yRWFjaChmdW5jdGlvbihjb21tYW5kKXtcblx0XHRpZiAobmFwaV9idWlsZF92ZXJzaW9ucyAmJiBjb21tYW5kLm5hbWUgPT09ICdpbnN0YWxsJykge1xuXHRcdFx0dmFyIG5hcGlfYnVpbGRfdmVyc2lvbiA9IG1vZHVsZS5leHBvcnRzLmdldF9iZXN0X25hcGlfYnVpbGRfdmVyc2lvbihwYWNrYWdlX2pzb24sIG9wdHMpO1xuXHRcdFx0dmFyIGFyZ3MgPSBuYXBpX2J1aWxkX3ZlcnNpb24gPyBbIG5hcGlfYnVpbGRfdmVyc2lvbl90YWcrbmFwaV9idWlsZF92ZXJzaW9uIF0gOiBbIF07XG5cdFx0XHRleHBhbmRlZF9jb21tYW5kcy5wdXNoICh7IG5hbWU6IGNvbW1hbmQubmFtZSwgYXJnczogYXJncyB9KTtcblx0XHR9IGVsc2UgaWYgKG5hcGlfYnVpbGRfdmVyc2lvbnMgJiYgbmFwaV9tdWx0aXBsZV9jb21tYW5kcy5pbmRleE9mKGNvbW1hbmQubmFtZSkgIT09IC0xKSB7XG5cdFx0XHRuYXBpX2J1aWxkX3ZlcnNpb25zLmZvckVhY2goZnVuY3Rpb24obmFwaV9idWlsZF92ZXJzaW9uKXtcblx0XHRcdFx0dmFyIGFyZ3MgPSBjb21tYW5kLmFyZ3Muc2xpY2UoKTtcblx0XHRcdFx0YXJncy5wdXNoIChuYXBpX2J1aWxkX3ZlcnNpb25fdGFnK25hcGlfYnVpbGRfdmVyc2lvbik7XG5cdFx0XHRcdGV4cGFuZGVkX2NvbW1hbmRzLnB1c2ggKHsgbmFtZTogY29tbWFuZC5uYW1lLCBhcmdzOiBhcmdzIH0pO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV4cGFuZGVkX2NvbW1hbmRzLnB1c2ggKGNvbW1hbmQpO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBleHBhbmRlZF9jb21tYW5kcztcbn07XG5cbm1vZHVsZS5leHBvcnRzLmdldF9uYXBpX2J1aWxkX3ZlcnNpb25zID0gZnVuY3Rpb24ocGFja2FnZV9qc29uLCBvcHRzLCB3YXJuaW5ncykgeyAvLyBvcHRzIG1heSBiZSB1bmRlZmluZWRcblx0dmFyIGxvZyA9IHJlcXVpcmUoJ25wbWxvZycpO1xuXHR2YXIgbmFwaV9idWlsZF92ZXJzaW9ucyA9IFtdO1xuXHR2YXIgc3VwcG9ydGVkX25hcGlfdmVyc2lvbiA9IG1vZHVsZS5leHBvcnRzLmdldF9uYXBpX3ZlcnNpb24ob3B0cyA/IG9wdHMudGFyZ2V0IDogdW5kZWZpbmVkKTtcblx0Ly8gcmVtb3ZlIGR1cGxpY2F0ZXMsIHZlcmlmeSBlYWNoIG5hcGkgdmVyc2lvbiBjYW4gYWN0YXVsbHkgYmUgYnVpbHRcblx0aWYgKHBhY2thZ2VfanNvbi5iaW5hcnkgJiYgcGFja2FnZV9qc29uLmJpbmFyeS5uYXBpX3ZlcnNpb25zKSB7XG5cdFx0cGFja2FnZV9qc29uLmJpbmFyeS5uYXBpX3ZlcnNpb25zLmZvckVhY2goZnVuY3Rpb24obmFwaV92ZXJzaW9uKSB7XG5cdFx0XHR2YXIgZHVwbGljYXRlZCA9IG5hcGlfYnVpbGRfdmVyc2lvbnMuaW5kZXhPZihuYXBpX3ZlcnNpb24pICE9PSAtMTtcblx0XHRcdGlmICghZHVwbGljYXRlZCAmJiBzdXBwb3J0ZWRfbmFwaV92ZXJzaW9uICYmIG5hcGlfdmVyc2lvbiA8PSBzdXBwb3J0ZWRfbmFwaV92ZXJzaW9uKSB7XG5cdFx0XHRcdG5hcGlfYnVpbGRfdmVyc2lvbnMucHVzaChuYXBpX3ZlcnNpb24pO1xuXHRcdFx0fSBlbHNlIGlmICh3YXJuaW5ncyAmJiAhZHVwbGljYXRlZCAmJiBzdXBwb3J0ZWRfbmFwaV92ZXJzaW9uKSB7XG5cdFx0XHRcdGxvZy5pbmZvKCdUaGlzIE5vZGUgaW5zdGFuY2UgZG9lcyBub3Qgc3VwcG9ydCBidWlsZHMgZm9yIE4tQVBJIHZlcnNpb24nLCBuYXBpX3ZlcnNpb24pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cdGlmIChvcHRzICYmIG9wdHNbXCJidWlsZC1sYXRlc3QtbmFwaS12ZXJzaW9uLW9ubHlcIl0pIHtcblx0XHR2YXIgbGF0ZXN0X3ZlcnNpb24gPSAwO1xuXHRcdG5hcGlfYnVpbGRfdmVyc2lvbnMuZm9yRWFjaChmdW5jdGlvbihuYXBpX3ZlcnNpb24pIHtcblx0XHRcdGlmIChuYXBpX3ZlcnNpb24gPiBsYXRlc3RfdmVyc2lvbikgbGF0ZXN0X3ZlcnNpb24gPSBuYXBpX3ZlcnNpb247XG5cdFx0fSk7XG5cdFx0bmFwaV9idWlsZF92ZXJzaW9ucyA9IGxhdGVzdF92ZXJzaW9uID8gWyBsYXRlc3RfdmVyc2lvbiBdIDogW107XG5cdH1cblx0cmV0dXJuIG5hcGlfYnVpbGRfdmVyc2lvbnMubGVuZ3RoID8gbmFwaV9idWlsZF92ZXJzaW9ucyA6IHVuZGVmaW5lZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmdldF9uYXBpX2J1aWxkX3ZlcnNpb25zX3JhdyA9IGZ1bmN0aW9uKHBhY2thZ2VfanNvbikge1xuXHR2YXIgbmFwaV9idWlsZF92ZXJzaW9ucyA9IFtdO1xuXHQvLyByZW1vdmUgZHVwbGljYXRlc1xuXHRpZiAocGFja2FnZV9qc29uLmJpbmFyeSAmJiBwYWNrYWdlX2pzb24uYmluYXJ5Lm5hcGlfdmVyc2lvbnMpIHtcblx0XHRwYWNrYWdlX2pzb24uYmluYXJ5Lm5hcGlfdmVyc2lvbnMuZm9yRWFjaChmdW5jdGlvbihuYXBpX3ZlcnNpb24pIHtcblx0XHRcdGlmIChuYXBpX2J1aWxkX3ZlcnNpb25zLmluZGV4T2YobmFwaV92ZXJzaW9uKSA9PT0gLTEpIHtcblx0XHRcdFx0bmFwaV9idWlsZF92ZXJzaW9ucy5wdXNoKG5hcGlfdmVyc2lvbik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblx0cmV0dXJuIG5hcGlfYnVpbGRfdmVyc2lvbnMubGVuZ3RoID8gbmFwaV9idWlsZF92ZXJzaW9ucyA6IHVuZGVmaW5lZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmdldF9jb21tYW5kX2FyZyA9IGZ1bmN0aW9uKG5hcGlfYnVpbGRfdmVyc2lvbikge1xuXHRyZXR1cm4gbmFwaV9idWlsZF92ZXJzaW9uX3RhZyArIG5hcGlfYnVpbGRfdmVyc2lvbjtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmdldF9uYXBpX2J1aWxkX3ZlcnNpb25fZnJvbV9jb21tYW5kX2FyZ3MgPSBmdW5jdGlvbihjb21tYW5kX2FyZ3MpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb21tYW5kX2FyZ3MubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgYXJnID0gY29tbWFuZF9hcmdzW2ldO1xuXHRcdGlmIChhcmcuaW5kZXhPZihuYXBpX2J1aWxkX3ZlcnNpb25fdGFnKSA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIHBhcnNlSW50KGFyZy5zdWJzdHIobmFwaV9idWlsZF92ZXJzaW9uX3RhZy5sZW5ndGgpLDEwKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzLnN3YXBfYnVpbGRfZGlyX291dCA9IGZ1bmN0aW9uKG5hcGlfYnVpbGRfdmVyc2lvbikge1xuXHRpZiAobmFwaV9idWlsZF92ZXJzaW9uKSB7XG5cdFx0dmFyIHJtID0gcmVxdWlyZSgncmltcmFmJyk7XG5cdFx0cm0uc3luYyhtb2R1bGUuZXhwb3J0cy5nZXRfYnVpbGRfZGlyKG5hcGlfYnVpbGRfdmVyc2lvbikpO1xuXHRcdGZzLnJlbmFtZVN5bmMoJ2J1aWxkJywgbW9kdWxlLmV4cG9ydHMuZ2V0X2J1aWxkX2RpcihuYXBpX2J1aWxkX3ZlcnNpb24pKTtcblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMuc3dhcF9idWlsZF9kaXJfaW4gPSBmdW5jdGlvbihuYXBpX2J1aWxkX3ZlcnNpb24pIHtcblx0aWYgKG5hcGlfYnVpbGRfdmVyc2lvbikge1xuXHRcdHZhciBybSA9IHJlcXVpcmUoJ3JpbXJhZicpO1xuXHRcdHJtLnN5bmMoJ2J1aWxkJyk7XG5cdFx0ZnMucmVuYW1lU3luYyhtb2R1bGUuZXhwb3J0cy5nZXRfYnVpbGRfZGlyKG5hcGlfYnVpbGRfdmVyc2lvbiksICdidWlsZCcpO1xuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5nZXRfYnVpbGRfZGlyID0gZnVuY3Rpb24obmFwaV9idWlsZF92ZXJzaW9uKSB7XG5cdHJldHVybiAnYnVpbGQtdG1wLW5hcGktdicrbmFwaV9idWlsZF92ZXJzaW9uO1xufTtcblxubW9kdWxlLmV4cG9ydHMuZ2V0X2Jlc3RfbmFwaV9idWlsZF92ZXJzaW9uID0gZnVuY3Rpb24ocGFja2FnZV9qc29uLCBvcHRzKSB7XG5cdHZhciBiZXN0X25hcGlfYnVpbGRfdmVyc2lvbiA9IDA7XG5cdHZhciBuYXBpX2J1aWxkX3ZlcnNpb25zID0gbW9kdWxlLmV4cG9ydHMuZ2V0X25hcGlfYnVpbGRfdmVyc2lvbnMgKHBhY2thZ2VfanNvbiwgb3B0cyk7XG5cdGlmIChuYXBpX2J1aWxkX3ZlcnNpb25zKSB7XG5cdFx0dmFyIG91cl9uYXBpX3ZlcnNpb24gPSBtb2R1bGUuZXhwb3J0cy5nZXRfbmFwaV92ZXJzaW9uKG9wdHMgPyBvcHRzLnRhcmdldCA6IHVuZGVmaW5lZCk7XG5cdFx0bmFwaV9idWlsZF92ZXJzaW9ucy5mb3JFYWNoKGZ1bmN0aW9uKG5hcGlfYnVpbGRfdmVyc2lvbil7XG5cdFx0XHRpZiAobmFwaV9idWlsZF92ZXJzaW9uID4gYmVzdF9uYXBpX2J1aWxkX3ZlcnNpb24gJiZcblx0XHRcdFx0bmFwaV9idWlsZF92ZXJzaW9uIDw9IG91cl9uYXBpX3ZlcnNpb24pIHtcblx0XHRcdFx0YmVzdF9uYXBpX2J1aWxkX3ZlcnNpb24gPSBuYXBpX2J1aWxkX3ZlcnNpb247XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblx0cmV0dXJuIGJlc3RfbmFwaV9idWlsZF92ZXJzaW9uID09PSAwID8gdW5kZWZpbmVkIDogYmVzdF9uYXBpX2J1aWxkX3ZlcnNpb247XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5idWlsZF9uYXBpX29ubHkgPSBmdW5jdGlvbihwYWNrYWdlX2pzb24pIHtcblx0cmV0dXJuIHBhY2thZ2VfanNvbi5iaW5hcnkgJiYgcGFja2FnZV9qc29uLmJpbmFyeS5wYWNrYWdlX25hbWUgJiYgXG5cdHBhY2thZ2VfanNvbi5iaW5hcnkucGFja2FnZV9uYW1lLmluZGV4T2YoJ3tub2RlX25hcGlfbGFiZWx9JykgPT09IC0xO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuXG52YXIgdXJsID0gcmVxdWlyZSgndXJsJyk7XG5cbnZhciBVUklfUkVHRVg9XCJeKC4qKVxcLihzMyg/Oi0uKik/KVxcLmFtYXpvbmF3c1xcLmNvbSRcIjtcblxubW9kdWxlLmV4cG9ydHMuZGV0ZWN0ID0gZnVuY3Rpb24odG8sY29uZmlnKSB7XG4gICAgdmFyIHVyaSA9IHVybC5wYXJzZSh0byk7XG4gICAgdmFyIGhvc3RuYW1lX21hdGNoZXMgPSB1cmkuaG9zdG5hbWUubWF0Y2goVVJJX1JFR0VYKTtcbiAgICBjb25maWcucHJlZml4ID0gKCF1cmkucGF0aG5hbWUgfHwgdXJpLnBhdGhuYW1lID09ICcvJykgPyAnJyA6IHVyaS5wYXRobmFtZS5yZXBsYWNlKCcvJywnJyk7XG4gICAgaWYoIWhvc3RuYW1lX21hdGNoZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNvbmZpZy5idWNrZXQpIHtcbiAgICAgICAgY29uZmlnLmJ1Y2tldCA9IGhvc3RuYW1lX21hdGNoZXNbMV07XG4gICAgfVxuICAgIGlmICghY29uZmlnLnJlZ2lvbikge1xuICAgICAgICB2YXIgczNfZG9tYWluID0gaG9zdG5hbWVfbWF0Y2hlc1syXTtcbiAgICAgICAgaWYgKHMzX2RvbWFpbi5zbGljZSgwLDMpID09ICdzMy0nICYmXG4gICAgICAgICAgICBzM19kb21haW4ubGVuZ3RoID49IDMpIHtcbiAgICAgICAgICAgIC8vIGl0IGFwcGVhcnMgdGhlIHJlZ2lvbiBpcyBleHBsaWNpdCBpbiB0aGUgdXJsXG4gICAgICAgICAgICBjb25maWcucmVnaW9uID0gczNfZG9tYWluLnJlcGxhY2UoJ3MzLScsJycpO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG5cbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIHNlbXZlciA9IHJlcXVpcmUoJ3NlbXZlcicpO1xudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpO1xudmFyIGRldGVjdF9saWJjID0gcmVxdWlyZSgnZGV0ZWN0LWxpYmMnKTtcbnZhciBuYXBpID0gcmVxdWlyZSgnLi9uYXBpLmpzJyk7XG5cbnZhciBhYmlfY3Jvc3N3YWxrO1xuXG4vLyBUaGlzIGlzIHVzZWQgZm9yIHVuaXQgdGVzdGluZyB0byBwcm92aWRlIGEgZmFrZVxuLy8gQUJJIGNyb3Nzd2FsayB0aGF0IGVtdWxhdGVzIG9uZSB0aGF0IGlzIG5vdCB1cGRhdGVkXG4vLyBmb3IgdGhlIGN1cnJlbnQgdmVyc2lvblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfUFJFX0dZUF9BQklfQ1JPU1NXQUxLKSB7XG4gICAgYWJpX2Nyb3Nzd2FsayA9IHJlcXVpcmUocHJvY2Vzcy5lbnYuTk9ERV9QUkVfR1lQX0FCSV9DUk9TU1dBTEspO1xufSBlbHNlIHtcbiAgICBhYmlfY3Jvc3N3YWxrID0gcmVxdWlyZSgnLi9hYmlfY3Jvc3N3YWxrLmpzb24nKTtcbn1cblxudmFyIG1ham9yX3ZlcnNpb25zID0ge307XG5PYmplY3Qua2V5cyhhYmlfY3Jvc3N3YWxrKS5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgbWFqb3IgPSB2LnNwbGl0KCcuJylbMF07XG4gICAgaWYgKCFtYWpvcl92ZXJzaW9uc1ttYWpvcl0pIHtcbiAgICAgICAgbWFqb3JfdmVyc2lvbnNbbWFqb3JdID0gdjtcbiAgICB9XG59KTtcblxuZnVuY3Rpb24gZ2V0X2VsZWN0cm9uX2FiaShydW50aW1lLCB0YXJnZXRfdmVyc2lvbikge1xuICAgIGlmICghcnVudGltZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXRfZWxlY3Ryb25fYWJpIHJlcXVpcmVzIHZhbGlkIHJ1bnRpbWUgYXJnXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRhcmdldF92ZXJzaW9uID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBlcnJvbmVvdXMgQ0xJIGNhbGxcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW1wdHkgdGFyZ2V0IHZlcnNpb24gaXMgbm90IHN1cHBvcnRlZCBpZiBlbGVjdHJvbiBpcyB0aGUgdGFyZ2V0LlwiKTtcbiAgICB9XG4gICAgLy8gRWxlY3Ryb24gZ3VhcmFudGVlcyB0aGF0IHBhdGNoIHZlcnNpb24gdXBkYXRlIHdvbid0IGJyZWFrIG5hdGl2ZSBtb2R1bGVzLlxuICAgIHZhciBzZW1fdmVyID0gc2VtdmVyLnBhcnNlKHRhcmdldF92ZXJzaW9uKTtcbiAgICByZXR1cm4gcnVudGltZSArICctdicgKyBzZW1fdmVyLm1ham9yICsgJy4nICsgc2VtX3Zlci5taW5vcjtcbn1cbm1vZHVsZS5leHBvcnRzLmdldF9lbGVjdHJvbl9hYmkgPSBnZXRfZWxlY3Ryb25fYWJpO1xuXG5mdW5jdGlvbiBnZXRfbm9kZV93ZWJraXRfYWJpKHJ1bnRpbWUsIHRhcmdldF92ZXJzaW9uKSB7XG4gICAgaWYgKCFydW50aW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImdldF9ub2RlX3dlYmtpdF9hYmkgcmVxdWlyZXMgdmFsaWQgcnVudGltZSBhcmdcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGFyZ2V0X3ZlcnNpb24gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIGVycm9uZW91cyBDTEkgY2FsbFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbXB0eSB0YXJnZXQgdmVyc2lvbiBpcyBub3Qgc3VwcG9ydGVkIGlmIG5vZGUtd2Via2l0IGlzIHRoZSB0YXJnZXQuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcnVudGltZSArICctdicgKyB0YXJnZXRfdmVyc2lvbjtcbn1cbm1vZHVsZS5leHBvcnRzLmdldF9ub2RlX3dlYmtpdF9hYmkgPSBnZXRfbm9kZV93ZWJraXRfYWJpO1xuXG5mdW5jdGlvbiBnZXRfbm9kZV9hYmkocnVudGltZSwgdmVyc2lvbnMpIHtcbiAgICBpZiAoIXJ1bnRpbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2V0X25vZGVfYWJpIHJlcXVpcmVzIHZhbGlkIHJ1bnRpbWUgYXJnXCIpO1xuICAgIH1cbiAgICBpZiAoIXZlcnNpb25zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImdldF9ub2RlX2FiaSByZXF1aXJlcyB2YWxpZCBwcm9jZXNzLnZlcnNpb25zIG9iamVjdFwiKTtcbiAgICB9XG4gICAgdmFyIHNlbV92ZXIgPSBzZW12ZXIucGFyc2UodmVyc2lvbnMubm9kZSk7XG4gICAgaWYgKHNlbV92ZXIubWFqb3IgPT09IDAgJiYgc2VtX3Zlci5taW5vciAlIDIpIHsgLy8gb2RkIHNlcmllc1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L25vZGUtcHJlLWd5cC9pc3N1ZXMvMTI0XG4gICAgICAgIHJldHVybiBydW50aW1lKyctdicrdmVyc2lvbnMubm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBwcm9jZXNzLnZlcnNpb25zLm1vZHVsZXMgYWRkZWQgaW4gPj0gdjAuMTAuNCBhbmQgdjAuMTEuN1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvY29tbWl0L2NjYWJkNGE2ZmE4YTZlYjc5ZDI5YmMzYmJlOWZlMmI2NTMxYzJkOGVcbiAgICAgICAgcmV0dXJuIHZlcnNpb25zLm1vZHVsZXMgPyBydW50aW1lKyctdicgKyAoK3ZlcnNpb25zLm1vZHVsZXMpIDpcbiAgICAgICAgICAgICd2OC0nICsgdmVyc2lvbnMudjguc3BsaXQoJy4nKS5zbGljZSgwLDIpLmpvaW4oJy4nKTtcbiAgICB9XG59XG5tb2R1bGUuZXhwb3J0cy5nZXRfbm9kZV9hYmkgPSBnZXRfbm9kZV9hYmk7XG5cbmZ1bmN0aW9uIGdldF9ydW50aW1lX2FiaShydW50aW1lLCB0YXJnZXRfdmVyc2lvbikge1xuICAgIGlmICghcnVudGltZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXRfcnVudGltZV9hYmkgcmVxdWlyZXMgdmFsaWQgcnVudGltZSBhcmdcIik7XG4gICAgfVxuICAgIGlmIChydW50aW1lID09PSAnbm9kZS13ZWJraXQnKSB7XG4gICAgICAgIHJldHVybiBnZXRfbm9kZV93ZWJraXRfYWJpKHJ1bnRpbWUsIHRhcmdldF92ZXJzaW9uIHx8IHByb2Nlc3MudmVyc2lvbnNbJ25vZGUtd2Via2l0J10pO1xuICAgIH0gZWxzZSBpZiAocnVudGltZSA9PT0gJ2VsZWN0cm9uJykge1xuICAgICAgICByZXR1cm4gZ2V0X2VsZWN0cm9uX2FiaShydW50aW1lLCB0YXJnZXRfdmVyc2lvbiB8fCBwcm9jZXNzLnZlcnNpb25zLmVsZWN0cm9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocnVudGltZSAhPSAnbm9kZScpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gUnVudGltZTogJ1wiICsgcnVudGltZSArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRhcmdldF92ZXJzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0X25vZGVfYWJpKHJ1bnRpbWUscHJvY2Vzcy52ZXJzaW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgY3Jvc3Nfb2JqO1xuICAgICAgICAgICAgLy8gYWJpX2Nyb3Nzd2FsayBnZW5lcmF0ZWQgd2l0aCAuL3NjcmlwdHMvYWJpX2Nyb3Nzd2Fsay5qc1xuICAgICAgICAgICAgaWYgKGFiaV9jcm9zc3dhbGtbdGFyZ2V0X3ZlcnNpb25dKSB7XG4gICAgICAgICAgICAgICAgY3Jvc3Nfb2JqID0gYWJpX2Nyb3Nzd2Fsa1t0YXJnZXRfdmVyc2lvbl07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRfcGFydHMgPSB0YXJnZXRfdmVyc2lvbi5zcGxpdCgnLicpLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiAraTsgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldF9wYXJ0cy5sZW5ndGggIT0gMykgeyAvLyBwYXJzZSBmYWlsZWRcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0YXJnZXQgdmVyc2lvbjogXCIgKyB0YXJnZXRfdmVyc2lvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgIFRoZSBiZWxvdyBjb2RlIHRyaWVzIHRvIGluZmVyIHRoZSBsYXN0IGtub3duIEFCSSBjb21wYXRpYmxlIHZlcnNpb25cbiAgICAgICAgICAgICAgICAgICAgdGhhdCB3ZSBoYXZlIHJlY29yZGVkIGluIHRoZSBhYmlfY3Jvc3N3YWxrLmpzb24gd2hlbiBhbiBleGFjdCBtYXRjaFxuICAgICAgICAgICAgICAgICAgICBpcyBub3QgcG9zc2libGUuIFRoZSByZWFzb25zIGZvciB0aGlzIHRvIGV4aXN0IGFyZSBjb21wbGljYXRlZDpcblxuICAgICAgICAgICAgICAgICAgICAgICAtIFdlIHN1cHBvcnQgcGFzc2luZyAtLXRhcmdldCB0byBiZSBhYmxlIHRvIGFsbG93IGRldmVsb3BlcnMgdG8gcGFja2FnZSBiaW5hcmllcyBmb3IgdmVyc2lvbnMgb2Ygbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgYXJlIG5vdCB0aGUgc2FtZSBvbmUgYXMgdGhleSBhcmUgcnVubmluZy4gVGhpcyBtaWdodCBhbHNvIGJlIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAtLXRhcmdldF9hcmNoIG9yIC0tdGFyZ2V0X3BsYXRmb3JtIGZsYWdzIHRvIGFsc28gcGFja2FnZSBiaW5hcmllcyBmb3IgYWx0ZXJuYXRpdmUgcGxhdGZvcm1zXG4gICAgICAgICAgICAgICAgICAgICAgIC0gV2hlbiAtLXRhcmdldCBpcyBwYXNzZWQgd2UgY2FuJ3QgdGhlcmVmb3JlIGRldGVybWluZSB0aGUgQUJJIChwcm9jZXNzLnZlcnNpb25zLm1vZHVsZXMpIGZyb20gdGhlIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uIHRoYXQgaXMgcnVubmluZyBpbiBtZW1vcnlcbiAgICAgICAgICAgICAgICAgICAgICAgLSBTbywgdGhlcmVmb3JlIG5vZGUtcHJlLWd5cCBrZWVwcyBhbiBcIkFCSSBjcm9zc3dhbGtcIiAobGliL3V0aWwvYWJpX2Nyb3Nzd2Fsay5qc29uKSB0byBiZSBhYmxlIHRvIGxvb2tcbiAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIGluZm8gdXAgZm9yIGFsbCB2ZXJzaW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAtIEJ1dCB3ZSBjYW5ub3QgZWFzaWx5IHByZWRpY3Qgd2hhdCB0aGUgZnV0dXJlIEFCSSB3aWxsIGJlIGZvciByZWxlYXNlZCB2ZXJzaW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAtIEFuZCBub2RlLXByZS1neXAgbmVlZHMgdG8gYmUgYSBgYnVuZGxlZERlcGVuZGVuY3lgIGluIGFwcHMgdGhhdCBkZXBlbmQgb24gaXQgaW4gb3JkZXIgdG8gd29yayBjb3JyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgICAgICBieSBiZWluZyBmdWxseSBhdmFpbGFibGUgYXQgaW5zdGFsbCB0aW1lLlxuICAgICAgICAgICAgICAgICAgICAgICAtIFNvLCB0aGUgc3BlZWQgb2Ygbm9kZSByZWxlYXNlcyBhbmQgdGhlIGJ1bmRsZWQgbmF0dXJlIG9mIG5vZGUtcHJlLWd5cCBtZWFuIHRoYXQgYSBuZXcgbm9kZS1wcmUtZ3lwIHJlbGVhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICBuZWVkIHRvIGhhcHBlbiBmb3IgZXZlcnkgbm9kZS5qcy9pby5qcy9ub2RlLXdlYmtpdC9udy5qcy9hdG9tLXNoZWxsL2V0YyByZWxlYXNlIHRoYXQgbWlnaHQgY29tZSBvbmxpbmUgaWZcbiAgICAgICAgICAgICAgICAgICAgICAgICB5b3Ugd2FudCB0aGUgYC0tdGFyZ2V0YCBmbGFnIHRvIGtlZXAgd29ya2luZyBmb3IgdGhlIGxhdGVzdCB2ZXJzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgIC0gV2hpY2ggaXMgaW1wcmFjdGljYWwgXl5cbiAgICAgICAgICAgICAgICAgICAgICAgLSBIZW5jZSB0aGUgYmVsb3cgY29kZSBndWVzc2VzIGFib3V0IGZ1dHVyZSBBQkkgdG8gbWFrZSB0aGUgbmVlZCB0byB1cGRhdGUgbm9kZS1wcmUtZ3lwIGxlc3MgZGVtYW5kaW5nLlxuXG4gICAgICAgICAgICAgICAgICAgIEluIHByYWN0aWNlIHRoZW4geW91IGNhbiBoYXZlIGEgZGVwZW5kZW5jeSBvZiB5b3VyIGFwcCBsaWtlIGBub2RlLXNxbGl0ZTNgIHRoYXQgYnVuZGxlcyBhIGBub2RlLXByZS1neXBgIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgb25seSBrbm93cyBhYm91dCBub2RlIHYwLjEwLjMzIGluIHRoZSBgYWJpX2Nyb3Nzd2Fsay5qc29uYCBidXQgdGFyZ2V0IG5vZGUgdjAuMTAuMzQgKHdoaWNoIGlzIGFzc3VtZWQgdG8gYmVcbiAgICAgICAgICAgICAgICAgICAgQUJJIGNvbXBhdGlibGUgd2l0aCB2MC4xMC4zMykuXG5cbiAgICAgICAgICAgICAgICAgICAgVE9ETzogdXNlIHNlbXZlciBtb2R1bGUgaW5zdGVhZCBvZiBjdXN0b20gdmVyc2lvbiBwYXJzaW5nXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgbWFqb3IgPSB0YXJnZXRfcGFydHNbMF07XG4gICAgICAgICAgICAgICAgdmFyIG1pbm9yID0gdGFyZ2V0X3BhcnRzWzFdO1xuICAgICAgICAgICAgICAgIHZhciBwYXRjaCA9IHRhcmdldF9wYXJ0c1syXTtcbiAgICAgICAgICAgICAgICAvLyBpby5qczogeWVhaCBpZiBub2RlLmpzIGV2ZXIgcmVsZWFzZXMgMS54IHRoaXMgd2lsbCBicmVha1xuICAgICAgICAgICAgICAgIC8vIGJ1dCB0aGF0IGlzIHVubGlrZWx5IHRvIGhhcHBlbjogaHR0cHM6Ly9naXRodWIuY29tL2lvanMvaW8uanMvcHVsbC8yNTMjaXNzdWVjb21tZW50LTY5NDMyNjE2XG4gICAgICAgICAgICAgICAgaWYgKG1ham9yID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxvb2sgZm9yIGxhc3QgcmVsZWFzZSB0aGF0IGlzIHRoZSBzYW1lIG1ham9yIHZlcnNpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gZS5nLiB3ZSBhc3N1bWUgaW8uanMgMS54IGlzIEFCSSBjb21wYXRpYmxlIHdpdGggPj0gMS4wLjBcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaW5vciA+IDApIC0tbWlub3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGF0Y2ggPiAwKSAtLXBhdGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld19pb2pzX3RhcmdldCA9ICcnICsgbWFqb3IgKyAnLicgKyBtaW5vciArICcuJyArIHBhdGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFiaV9jcm9zc3dhbGtbbmV3X2lvanNfdGFyZ2V0XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyb3NzX29iaiA9IGFiaV9jcm9zc3dhbGtbbmV3X2lvanNfdGFyZ2V0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnV2FybmluZzogbm9kZS1wcmUtZ3lwIGNvdWxkIG5vdCBmaW5kIGV4YWN0IG1hdGNoIGZvciAnICsgdGFyZ2V0X3ZlcnNpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXYXJuaW5nOiBidXQgbm9kZS1wcmUtZ3lwIHN1Y2Nlc3NmdWxseSBjaG9vc2UgJyArIG5ld19pb2pzX3RhcmdldCArICcgYXMgQUJJIGNvbXBhdGlibGUgdGFyZ2V0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWlub3IgPT09IDAgJiYgcGF0Y2ggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWFqb3IgPj0gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBsb29rIGZvciBsYXN0IHJlbGVhc2UgdGhhdCBpcyB0aGUgc2FtZSBtYWpvciB2ZXJzaW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYWpvcl92ZXJzaW9uc1ttYWpvcl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyb3NzX29iaiA9IGFiaV9jcm9zc3dhbGtbbWFqb3JfdmVyc2lvbnNbbWFqb3JdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXYXJuaW5nOiBub2RlLXByZS1neXAgY291bGQgbm90IGZpbmQgZXhhY3QgbWF0Y2ggZm9yICcgKyB0YXJnZXRfdmVyc2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnV2FybmluZzogYnV0IG5vZGUtcHJlLWd5cCBzdWNjZXNzZnVsbHkgY2hvb3NlICcgKyBtYWpvcl92ZXJzaW9uc1ttYWpvcl0gKyAnIGFzIEFCSSBjb21wYXRpYmxlIHRhcmdldCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYWpvciA9PT0gMCkgeyAvLyBub2RlLmpzXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRfcGFydHNbMV0gJSAyID09PSAwKSB7IC8vIGZvciBzdGFibGUvZXZlbiBub2RlLmpzIHNlcmllc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9vayBmb3IgdGhlIGxhc3QgcmVsZWFzZSB0aGF0IGlzIHRoZSBzYW1lIG1pbm9yIHJlbGVhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGUuZy4gd2UgYXNzdW1lIG5vZGUgMC4xMC54IGlzIEFCSSBjb21wYXRpYmxlIHdpdGggPj0gMC4xMC4wXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoLS1wYXRjaCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3X25vZGVfdGFyZ2V0ID0gJycgKyBtYWpvciArICcuJyArIG1pbm9yICsgJy4nICsgcGF0Y2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFiaV9jcm9zc3dhbGtbbmV3X25vZGVfdGFyZ2V0XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcm9zc19vYmogPSBhYmlfY3Jvc3N3YWxrW25ld19ub2RlX3RhcmdldF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXYXJuaW5nOiBub2RlLXByZS1neXAgY291bGQgbm90IGZpbmQgZXhhY3QgbWF0Y2ggZm9yICcgKyB0YXJnZXRfdmVyc2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXYXJuaW5nOiBidXQgbm9kZS1wcmUtZ3lwIHN1Y2Nlc3NmdWxseSBjaG9vc2UgJyArIG5ld19ub2RlX3RhcmdldCArICcgYXMgQUJJIGNvbXBhdGlibGUgdGFyZ2V0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY3Jvc3Nfb2JqKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgdGFyZ2V0IHZlcnNpb246IFwiICsgdGFyZ2V0X3ZlcnNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZW11bGF0ZSBwcm9jZXNzLnZlcnNpb25zXG4gICAgICAgICAgICB2YXIgdmVyc2lvbnNfb2JqID0ge1xuICAgICAgICAgICAgICAgIG5vZGU6IHRhcmdldF92ZXJzaW9uLFxuICAgICAgICAgICAgICAgIHY4OiBjcm9zc19vYmoudjgrJy4wJyxcbiAgICAgICAgICAgICAgICAvLyBhYmlfY3Jvc3N3YWxrIHVzZXMgMSBmb3Igbm9kZSB2ZXJzaW9ucyBsYWNraW5nIHByb2Nlc3MudmVyc2lvbnMubW9kdWxlc1xuICAgICAgICAgICAgICAgIC8vIHByb2Nlc3MudmVyc2lvbnMubW9kdWxlcyBhZGRlZCBpbiA+PSB2MC4xMC40IGFuZCB2MC4xMS43XG4gICAgICAgICAgICAgICAgbW9kdWxlczogY3Jvc3Nfb2JqLm5vZGVfYWJpID4gMSA/IGNyb3NzX29iai5ub2RlX2FiaSA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBnZXRfbm9kZV9hYmkocnVudGltZSwgdmVyc2lvbnNfb2JqKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzLmdldF9ydW50aW1lX2FiaSA9IGdldF9ydW50aW1lX2FiaTtcblxudmFyIHJlcXVpcmVkX3BhcmFtZXRlcnMgPSBbXG4gICAgJ21vZHVsZV9uYW1lJyxcbiAgICAnbW9kdWxlX3BhdGgnLFxuICAgICdob3N0J1xuXTtcblxuZnVuY3Rpb24gdmFsaWRhdGVfY29uZmlnKHBhY2thZ2VfanNvbixvcHRzKSB7XG4gICAgdmFyIG1zZyA9IHBhY2thZ2VfanNvbi5uYW1lICsgJyBwYWNrYWdlLmpzb24gaXMgbm90IG5vZGUtcHJlLWd5cCByZWFkeTpcXG4nO1xuICAgIHZhciBtaXNzaW5nID0gW107XG4gICAgaWYgKCFwYWNrYWdlX2pzb24ubWFpbikge1xuICAgICAgICBtaXNzaW5nLnB1c2goJ21haW4nKTtcbiAgICB9XG4gICAgaWYgKCFwYWNrYWdlX2pzb24udmVyc2lvbikge1xuICAgICAgICBtaXNzaW5nLnB1c2goJ3ZlcnNpb24nKTtcbiAgICB9XG4gICAgaWYgKCFwYWNrYWdlX2pzb24ubmFtZSkge1xuICAgICAgICBtaXNzaW5nLnB1c2goJ25hbWUnKTtcbiAgICB9XG4gICAgaWYgKCFwYWNrYWdlX2pzb24uYmluYXJ5KSB7XG4gICAgICAgIG1pc3NpbmcucHVzaCgnYmluYXJ5Jyk7XG4gICAgfVxuICAgIHZhciBvID0gcGFja2FnZV9qc29uLmJpbmFyeTtcbiAgICByZXF1aXJlZF9wYXJhbWV0ZXJzLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICBpZiAobWlzc2luZy5pbmRleE9mKCdiaW5hcnknKSA+IC0xKSB7XG4gICAgICAgICAgICBtaXNzaW5nLnBvcCgnYmluYXJ5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvIHx8IG9bcF0gPT09IHVuZGVmaW5lZCB8fCBvW3BdID09PSBcIlwiKSB7XG4gICAgICAgICAgICBtaXNzaW5nLnB1c2goJ2JpbmFyeS4nICsgcCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAobWlzc2luZy5sZW5ndGggPj0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnK1wicGFja2FnZS5qc29uIG11c3QgZGVjbGFyZSB0aGVzZSBwcm9wZXJ0aWVzOiBcXG5cIiArIG1pc3Npbmcuam9pbignXFxuJykpO1xuICAgIH1cbiAgICBpZiAobykge1xuICAgICAgICAvLyBlbmZvcmNlIGh0dHBzIG92ZXIgaHR0cFxuICAgICAgICB2YXIgcHJvdG9jb2wgPSB1cmwucGFyc2Uoby5ob3N0KS5wcm90b2NvbDtcbiAgICAgICAgaWYgKHByb3RvY29sID09PSAnaHR0cDonKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCInaG9zdCcgcHJvdG9jb2wgKFwiK3Byb3RvY29sK1wiKSBpcyBpbnZhbGlkIC0gb25seSAnaHR0cHM6JyBpcyBhY2NlcHRlZFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuYXBpLnZhbGlkYXRlX3BhY2thZ2VfanNvbihwYWNrYWdlX2pzb24sb3B0cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzLnZhbGlkYXRlX2NvbmZpZyA9IHZhbGlkYXRlX2NvbmZpZztcblxuZnVuY3Rpb24gZXZhbF90ZW1wbGF0ZSh0ZW1wbGF0ZSxvcHRzKSB7XG4gICAgT2JqZWN0LmtleXMob3B0cykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSAneycra2V5Kyd9JztcbiAgICAgICAgd2hpbGUgKHRlbXBsYXRlLmluZGV4T2YocGF0dGVybikgPiAtMSkge1xuICAgICAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKHBhdHRlcm4sb3B0c1trZXldKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0ZW1wbGF0ZTtcbn1cblxuLy8gdXJsLnJlc29sdmUgbmVlZHMgc2luZ2xlIHRyYWlsaW5nIHNsYXNoXG4vLyB0byBiZWhhdmUgY29ycmVjdGx5LCBvdGhlcndpc2UgYSBkb3VibGUgc2xhc2hcbi8vIG1heSBlbmQgdXAgaW4gdGhlIHVybCB3aGljaCBicmVha3MgcmVxdWVzdHNcbi8vIGFuZCBhIGxhY2tpbmcgc2xhc2ggbWF5IG5vdCBsZWFkIHRvIHByb3BlciBqb2luaW5nXG5mdW5jdGlvbiBmaXhfc2xhc2hlcyhwYXRobmFtZSkge1xuICAgIGlmIChwYXRobmFtZS5zbGljZSgtMSkgIT0gJy8nKSB7XG4gICAgICAgIHJldHVybiBwYXRobmFtZSArICcvJztcbiAgICB9XG4gICAgcmV0dXJuIHBhdGhuYW1lO1xufVxuXG4vLyByZW1vdmUgZG91YmxlIHNsYXNoZXNcbi8vIG5vdGU6IHBhdGgubm9ybWFsaXplIHdpbGwgbm90IHdvcmsgYmVjYXVzZVxuLy8gaXQgd2lsbCBjb252ZXJ0IGZvcndhcmQgdG8gYmFjayBzbGFzaGVzXG5mdW5jdGlvbiBkcm9wX2RvdWJsZV9zbGFzaGVzKHBhdGhuYW1lKSB7XG4gICAgcmV0dXJuIHBhdGhuYW1lLnJlcGxhY2UoL1xcL1xcLy9nLCcvJyk7XG59XG5cbmZ1bmN0aW9uIGdldF9wcm9jZXNzX3J1bnRpbWUodmVyc2lvbnMpIHtcbiAgICB2YXIgcnVudGltZSA9ICdub2RlJztcbiAgICBpZiAodmVyc2lvbnNbJ25vZGUtd2Via2l0J10pIHtcbiAgICAgICAgcnVudGltZSA9ICdub2RlLXdlYmtpdCc7XG4gICAgfSBlbHNlIGlmICh2ZXJzaW9ucy5lbGVjdHJvbikge1xuICAgICAgICBydW50aW1lID0gJ2VsZWN0cm9uJztcbiAgICB9XG4gICAgcmV0dXJuIHJ1bnRpbWU7XG59XG5cbm1vZHVsZS5leHBvcnRzLmdldF9wcm9jZXNzX3J1bnRpbWUgPSBnZXRfcHJvY2Vzc19ydW50aW1lO1xuXG52YXIgZGVmYXVsdF9wYWNrYWdlX25hbWUgPSAne21vZHVsZV9uYW1lfS12e3ZlcnNpb259LXtub2RlX2FiaX0te3BsYXRmb3JtfS17YXJjaH0udGFyLmd6JztcbnZhciBkZWZhdWx0X3JlbW90ZV9wYXRoID0gJyc7XG5cbm1vZHVsZS5leHBvcnRzLmV2YWx1YXRlID0gZnVuY3Rpb24ocGFja2FnZV9qc29uLG9wdGlvbnMsbmFwaV9idWlsZF92ZXJzaW9uKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFsaWRhdGVfY29uZmlnKHBhY2thZ2VfanNvbixvcHRpb25zKTsgLy8gb3B0aW9ucyBpcyBhIHN1aXRhYmxlIHN1YnN0aXR1dGUgZm9yIG9wdHMgaW4gdGhpcyBjYXNlXG4gICAgdmFyIHYgPSBwYWNrYWdlX2pzb24udmVyc2lvbjtcbiAgICB2YXIgbW9kdWxlX3ZlcnNpb24gPSBzZW12ZXIucGFyc2Uodik7XG4gICAgdmFyIHJ1bnRpbWUgPSBvcHRpb25zLnJ1bnRpbWUgfHwgZ2V0X3Byb2Nlc3NfcnVudGltZShwcm9jZXNzLnZlcnNpb25zKTtcbiAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgbmFtZTogcGFja2FnZV9qc29uLm5hbWUsXG4gICAgICAgIGNvbmZpZ3VyYXRpb246IEJvb2xlYW4ob3B0aW9ucy5kZWJ1ZykgPyAnRGVidWcnIDogJ1JlbGVhc2UnLFxuICAgICAgICBkZWJ1Zzogb3B0aW9ucy5kZWJ1ZyxcbiAgICAgICAgbW9kdWxlX25hbWU6IHBhY2thZ2VfanNvbi5iaW5hcnkubW9kdWxlX25hbWUsXG4gICAgICAgIHZlcnNpb246IG1vZHVsZV92ZXJzaW9uLnZlcnNpb24sXG4gICAgICAgIHByZXJlbGVhc2U6IG1vZHVsZV92ZXJzaW9uLnByZXJlbGVhc2UubGVuZ3RoID8gbW9kdWxlX3ZlcnNpb24ucHJlcmVsZWFzZS5qb2luKCcuJykgOiAnJyxcbiAgICAgICAgYnVpbGQ6IG1vZHVsZV92ZXJzaW9uLmJ1aWxkLmxlbmd0aCA/IG1vZHVsZV92ZXJzaW9uLmJ1aWxkLmpvaW4oJy4nKSA6ICcnLFxuICAgICAgICBtYWpvcjogbW9kdWxlX3ZlcnNpb24ubWFqb3IsXG4gICAgICAgIG1pbm9yOiBtb2R1bGVfdmVyc2lvbi5taW5vcixcbiAgICAgICAgcGF0Y2g6IG1vZHVsZV92ZXJzaW9uLnBhdGNoLFxuICAgICAgICBydW50aW1lOiBydW50aW1lLFxuICAgICAgICBub2RlX2FiaTogZ2V0X3J1bnRpbWVfYWJpKHJ1bnRpbWUsb3B0aW9ucy50YXJnZXQpLFxuICAgICAgICBub2RlX2FiaV9uYXBpOiBuYXBpLmdldF9uYXBpX3ZlcnNpb24ob3B0aW9ucy50YXJnZXQpID8gJ25hcGknIDogZ2V0X3J1bnRpbWVfYWJpKHJ1bnRpbWUsb3B0aW9ucy50YXJnZXQpLFxuICAgICAgICBuYXBpX3ZlcnNpb246IG5hcGkuZ2V0X25hcGlfdmVyc2lvbihvcHRpb25zLnRhcmdldCksIC8vIG5vbi16ZXJvIG51bWVyaWMsIHVuZGVmaW5lZCBpZiB1bnN1cHBvcnRlZFxuICAgICAgICBuYXBpX2J1aWxkX3ZlcnNpb246IG5hcGlfYnVpbGRfdmVyc2lvbiB8fCAnJyxcbiAgICAgICAgbm9kZV9uYXBpX2xhYmVsOiBuYXBpX2J1aWxkX3ZlcnNpb24gPyAnbmFwaS12JyArIG5hcGlfYnVpbGRfdmVyc2lvbiA6IGdldF9ydW50aW1lX2FiaShydW50aW1lLG9wdGlvbnMudGFyZ2V0KSxcbiAgICAgICAgdGFyZ2V0OiBvcHRpb25zLnRhcmdldCB8fCAnJyxcbiAgICAgICAgcGxhdGZvcm06IG9wdGlvbnMudGFyZ2V0X3BsYXRmb3JtIHx8IHByb2Nlc3MucGxhdGZvcm0sXG4gICAgICAgIHRhcmdldF9wbGF0Zm9ybTogb3B0aW9ucy50YXJnZXRfcGxhdGZvcm0gfHwgcHJvY2Vzcy5wbGF0Zm9ybSxcbiAgICAgICAgYXJjaDogb3B0aW9ucy50YXJnZXRfYXJjaCB8fCBwcm9jZXNzLmFyY2gsXG4gICAgICAgIHRhcmdldF9hcmNoOiBvcHRpb25zLnRhcmdldF9hcmNoIHx8IHByb2Nlc3MuYXJjaCxcbiAgICAgICAgbGliYzogb3B0aW9ucy50YXJnZXRfbGliYyB8fCBkZXRlY3RfbGliYy5mYW1pbHkgfHwgJ3Vua25vd24nLFxuICAgICAgICBtb2R1bGVfbWFpbjogcGFja2FnZV9qc29uLm1haW4sXG4gICAgICAgIHRvb2xzZXQgOiBvcHRpb25zLnRvb2xzZXQgfHwgJycgLy8gYWRkcmVzcyBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L25vZGUtcHJlLWd5cC9pc3N1ZXMvMTE5XG4gICAgfTtcbiAgICAvLyBzdXBwb3J0IGhvc3QgbWlycm9yIHdpdGggbnBtIGNvbmZpZyBgLS17bW9kdWxlX25hbWV9X2JpbmFyeV9ob3N0X21pcnJvcmBcbiAgICAvLyBlLmcuOiBodHRwczovL2dpdGh1Yi5jb20vbm9kZS1pbnNwZWN0b3IvdjgtcHJvZmlsZXIvYmxvYi9tYXN0ZXIvcGFja2FnZS5qc29uI0wyNVxuICAgIC8vID4gbnBtIGluc3RhbGwgdjgtcHJvZmlsZXIgLS1wcm9maWxlcl9iaW5hcnlfaG9zdF9taXJyb3I9aHR0cHM6Ly9ucG0udGFvYmFvLm9yZy9taXJyb3JzL25vZGUtaW5zcGVjdG9yL1xuICAgIHZhciBob3N0ID0gcHJvY2Vzcy5lbnZbJ25wbV9jb25maWdfJyArIG9wdHMubW9kdWxlX25hbWUgKyAnX2JpbmFyeV9ob3N0X21pcnJvciddIHx8IHBhY2thZ2VfanNvbi5iaW5hcnkuaG9zdDtcbiAgICBvcHRzLmhvc3QgPSBmaXhfc2xhc2hlcyhldmFsX3RlbXBsYXRlKGhvc3Qsb3B0cykpO1xuICAgIG9wdHMubW9kdWxlX3BhdGggPSBldmFsX3RlbXBsYXRlKHBhY2thZ2VfanNvbi5iaW5hcnkubW9kdWxlX3BhdGgsb3B0cyk7XG4gICAgLy8gbm93IHdlIHJlc29sdmUgdGhlIG1vZHVsZV9wYXRoIHRvIGVuc3VyZSBpdCBpcyBhYnNvbHV0ZSBzbyB0aGF0IGJpbmRpbmcuZ3lwIHZhcmlhYmxlcyB3b3JrIHByZWRpY3RhYmx5XG4gICAgaWYgKG9wdGlvbnMubW9kdWxlX3Jvb3QpIHtcbiAgICAgICAgLy8gcmVzb2x2ZSByZWxhdGl2ZSB0byBrbm93biBtb2R1bGUgcm9vdDogd29ya3MgZm9yIHByZS1iaW5kaW5nIHJlcXVpcmVcbiAgICAgICAgb3B0cy5tb2R1bGVfcGF0aCA9IHBhdGguam9pbihvcHRpb25zLm1vZHVsZV9yb290LG9wdHMubW9kdWxlX3BhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlc29sdmUgcmVsYXRpdmUgdG8gY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeTogd29ya3MgZm9yIG5vZGUtcHJlLWd5cCBjb21tYW5kc1xuICAgICAgICBvcHRzLm1vZHVsZV9wYXRoID0gcGF0aC5yZXNvbHZlKG9wdHMubW9kdWxlX3BhdGgpO1xuICAgIH1cbiAgICBvcHRzLm1vZHVsZSA9IHBhdGguam9pbihvcHRzLm1vZHVsZV9wYXRoLG9wdHMubW9kdWxlX25hbWUgKyAnLm5vZGUnKTtcbiAgICBvcHRzLnJlbW90ZV9wYXRoID0gcGFja2FnZV9qc29uLmJpbmFyeS5yZW1vdGVfcGF0aCA/IGRyb3BfZG91YmxlX3NsYXNoZXMoZml4X3NsYXNoZXMoZXZhbF90ZW1wbGF0ZShwYWNrYWdlX2pzb24uYmluYXJ5LnJlbW90ZV9wYXRoLG9wdHMpKSkgOiBkZWZhdWx0X3JlbW90ZV9wYXRoO1xuICAgIHZhciBwYWNrYWdlX25hbWUgPSBwYWNrYWdlX2pzb24uYmluYXJ5LnBhY2thZ2VfbmFtZSA/IHBhY2thZ2VfanNvbi5iaW5hcnkucGFja2FnZV9uYW1lIDogZGVmYXVsdF9wYWNrYWdlX25hbWU7XG4gICAgb3B0cy5wYWNrYWdlX25hbWUgPSBldmFsX3RlbXBsYXRlKHBhY2thZ2VfbmFtZSxvcHRzKTtcbiAgICBvcHRzLnN0YWdlZF90YXJiYWxsID0gcGF0aC5qb2luKCdidWlsZC9zdGFnZScsb3B0cy5yZW1vdGVfcGF0aCxvcHRzLnBhY2thZ2VfbmFtZSk7XG4gICAgb3B0cy5ob3N0ZWRfcGF0aCA9IHVybC5yZXNvbHZlKG9wdHMuaG9zdCxvcHRzLnJlbW90ZV9wYXRoKTtcbiAgICBvcHRzLmhvc3RlZF90YXJiYWxsID0gdXJsLnJlc29sdmUob3B0cy5ob3N0ZWRfcGF0aCxvcHRzLnBhY2thZ2VfbmFtZSk7XG4gICAgcmV0dXJuIG9wdHM7XG59O1xuIiwiLy8gaW5mbyBhYm91dCBlYWNoIGNvbmZpZyBvcHRpb24uXG5cbnZhciBkZWJ1ZyA9IHByb2Nlc3MuZW52LkRFQlVHX05PUFQgfHwgcHJvY2Vzcy5lbnYuTk9QVF9ERUJVR1xuICA/IGZ1bmN0aW9uICgpIHsgY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpIH1cbiAgOiBmdW5jdGlvbiAoKSB7fVxuXG52YXIgdXJsID0gcmVxdWlyZShcInVybFwiKVxuICAsIHBhdGggPSByZXF1aXJlKFwicGF0aFwiKVxuICAsIFN0cmVhbSA9IHJlcXVpcmUoXCJzdHJlYW1cIikuU3RyZWFtXG4gICwgYWJicmV2ID0gcmVxdWlyZShcImFiYnJldlwiKVxuICAsIG9zZW52ID0gcmVxdWlyZShcIm9zZW52XCIpXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IG5vcHRcbmV4cG9ydHMuY2xlYW4gPSBjbGVhblxuXG5leHBvcnRzLnR5cGVEZWZzID1cbiAgeyBTdHJpbmcgIDogeyB0eXBlOiBTdHJpbmcsICB2YWxpZGF0ZTogdmFsaWRhdGVTdHJpbmcgIH1cbiAgLCBCb29sZWFuIDogeyB0eXBlOiBCb29sZWFuLCB2YWxpZGF0ZTogdmFsaWRhdGVCb29sZWFuIH1cbiAgLCB1cmwgICAgIDogeyB0eXBlOiB1cmwsICAgICB2YWxpZGF0ZTogdmFsaWRhdGVVcmwgICAgIH1cbiAgLCBOdW1iZXIgIDogeyB0eXBlOiBOdW1iZXIsICB2YWxpZGF0ZTogdmFsaWRhdGVOdW1iZXIgIH1cbiAgLCBwYXRoICAgIDogeyB0eXBlOiBwYXRoLCAgICB2YWxpZGF0ZTogdmFsaWRhdGVQYXRoICAgIH1cbiAgLCBTdHJlYW0gIDogeyB0eXBlOiBTdHJlYW0sICB2YWxpZGF0ZTogdmFsaWRhdGVTdHJlYW0gIH1cbiAgLCBEYXRlICAgIDogeyB0eXBlOiBEYXRlLCAgICB2YWxpZGF0ZTogdmFsaWRhdGVEYXRlICAgIH1cbiAgfVxuXG5mdW5jdGlvbiBub3B0ICh0eXBlcywgc2hvcnRoYW5kcywgYXJncywgc2xpY2UpIHtcbiAgYXJncyA9IGFyZ3MgfHwgcHJvY2Vzcy5hcmd2XG4gIHR5cGVzID0gdHlwZXMgfHwge31cbiAgc2hvcnRoYW5kcyA9IHNob3J0aGFuZHMgfHwge31cbiAgaWYgKHR5cGVvZiBzbGljZSAhPT0gXCJudW1iZXJcIikgc2xpY2UgPSAyXG5cbiAgZGVidWcodHlwZXMsIHNob3J0aGFuZHMsIGFyZ3MsIHNsaWNlKVxuXG4gIGFyZ3MgPSBhcmdzLnNsaWNlKHNsaWNlKVxuICB2YXIgZGF0YSA9IHt9XG4gICAgLCBrZXlcbiAgICAsIGFyZ3YgPSB7XG4gICAgICAgIHJlbWFpbjogW10sXG4gICAgICAgIGNvb2tlZDogYXJncyxcbiAgICAgICAgb3JpZ2luYWw6IGFyZ3Muc2xpY2UoMClcbiAgICAgIH1cblxuICBwYXJzZShhcmdzLCBkYXRhLCBhcmd2LnJlbWFpbiwgdHlwZXMsIHNob3J0aGFuZHMpXG4gIC8vIG5vdyBkYXRhIGlzIGZ1bGxcbiAgY2xlYW4oZGF0YSwgdHlwZXMsIGV4cG9ydHMudHlwZURlZnMpXG4gIGRhdGEuYXJndiA9IGFyZ3ZcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRhdGEuYXJndiwgJ3RvU3RyaW5nJywgeyB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm9yaWdpbmFsLm1hcChKU09OLnN0cmluZ2lmeSkuam9pbihcIiBcIilcbiAgfSwgZW51bWVyYWJsZTogZmFsc2UgfSlcbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gY2xlYW4gKGRhdGEsIHR5cGVzLCB0eXBlRGVmcykge1xuICB0eXBlRGVmcyA9IHR5cGVEZWZzIHx8IGV4cG9ydHMudHlwZURlZnNcbiAgdmFyIHJlbW92ZSA9IHt9XG4gICAgLCB0eXBlRGVmYXVsdCA9IFtmYWxzZSwgdHJ1ZSwgbnVsbCwgU3RyaW5nLCBBcnJheV1cblxuICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKGsgPT09IFwiYXJndlwiKSByZXR1cm5cbiAgICB2YXIgdmFsID0gZGF0YVtrXVxuICAgICAgLCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSh2YWwpXG4gICAgICAsIHR5cGUgPSB0eXBlc1trXVxuICAgIGlmICghaXNBcnJheSkgdmFsID0gW3ZhbF1cbiAgICBpZiAoIXR5cGUpIHR5cGUgPSB0eXBlRGVmYXVsdFxuICAgIGlmICh0eXBlID09PSBBcnJheSkgdHlwZSA9IHR5cGVEZWZhdWx0LmNvbmNhdChBcnJheSlcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHlwZSkpIHR5cGUgPSBbdHlwZV1cblxuICAgIGRlYnVnKFwidmFsPSVqXCIsIHZhbClcbiAgICBkZWJ1ZyhcInR5cGVzPVwiLCB0eXBlKVxuICAgIHZhbCA9IHZhbC5tYXAoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgLy8gaWYgaXQncyBhbiB1bmtub3duIHZhbHVlLCB0aGVuIHBhcnNlIGZhbHNlL3RydWUvbnVsbC9udW1iZXJzL2RhdGVzXG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBkZWJ1ZyhcInN0cmluZyAlalwiLCB2YWwpXG4gICAgICAgIHZhbCA9IHZhbC50cmltKClcbiAgICAgICAgaWYgKCh2YWwgPT09IFwibnVsbFwiICYmIH50eXBlLmluZGV4T2YobnVsbCkpXG4gICAgICAgICAgICB8fCAodmFsID09PSBcInRydWVcIiAmJlxuICAgICAgICAgICAgICAgKH50eXBlLmluZGV4T2YodHJ1ZSkgfHwgfnR5cGUuaW5kZXhPZihCb29sZWFuKSkpXG4gICAgICAgICAgICB8fCAodmFsID09PSBcImZhbHNlXCIgJiZcbiAgICAgICAgICAgICAgICh+dHlwZS5pbmRleE9mKGZhbHNlKSB8fCB+dHlwZS5pbmRleE9mKEJvb2xlYW4pKSkpIHtcbiAgICAgICAgICB2YWwgPSBKU09OLnBhcnNlKHZhbClcbiAgICAgICAgICBkZWJ1ZyhcImpzb25hYmxlICVqXCIsIHZhbClcbiAgICAgICAgfSBlbHNlIGlmICh+dHlwZS5pbmRleE9mKE51bWJlcikgJiYgIWlzTmFOKHZhbCkpIHtcbiAgICAgICAgICBkZWJ1ZyhcImNvbnZlcnQgdG8gbnVtYmVyXCIsIHZhbClcbiAgICAgICAgICB2YWwgPSArdmFsXG4gICAgICAgIH0gZWxzZSBpZiAofnR5cGUuaW5kZXhPZihEYXRlKSAmJiAhaXNOYU4oRGF0ZS5wYXJzZSh2YWwpKSkge1xuICAgICAgICAgIGRlYnVnKFwiY29udmVydCB0byBkYXRlXCIsIHZhbClcbiAgICAgICAgICB2YWwgPSBuZXcgRGF0ZSh2YWwpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF0eXBlcy5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICByZXR1cm4gdmFsXG4gICAgICB9XG5cbiAgICAgIC8vIGFsbG93IGAtLW5vLWJsYWhgIHRvIHNldCAnYmxhaCcgdG8gbnVsbCBpZiBudWxsIGlzIGFsbG93ZWRcbiAgICAgIGlmICh2YWwgPT09IGZhbHNlICYmIH50eXBlLmluZGV4T2YobnVsbCkgJiZcbiAgICAgICAgICAhKH50eXBlLmluZGV4T2YoZmFsc2UpIHx8IH50eXBlLmluZGV4T2YoQm9vbGVhbikpKSB7XG4gICAgICAgIHZhbCA9IG51bGxcbiAgICAgIH1cblxuICAgICAgdmFyIGQgPSB7fVxuICAgICAgZFtrXSA9IHZhbFxuICAgICAgZGVidWcoXCJwcmV2YWxpZGF0ZWQgdmFsXCIsIGQsIHZhbCwgdHlwZXNba10pXG4gICAgICBpZiAoIXZhbGlkYXRlKGQsIGssIHZhbCwgdHlwZXNba10sIHR5cGVEZWZzKSkge1xuICAgICAgICBpZiAoZXhwb3J0cy5pbnZhbGlkSGFuZGxlcikge1xuICAgICAgICAgIGV4cG9ydHMuaW52YWxpZEhhbmRsZXIoaywgdmFsLCB0eXBlc1trXSwgZGF0YSlcbiAgICAgICAgfSBlbHNlIGlmIChleHBvcnRzLmludmFsaWRIYW5kbGVyICE9PSBmYWxzZSkge1xuICAgICAgICAgIGRlYnVnKFwiaW52YWxpZDogXCIraytcIj1cIit2YWwsIHR5cGVzW2tdKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZW1vdmVcbiAgICAgIH1cbiAgICAgIGRlYnVnKFwidmFsaWRhdGVkIHZhbFwiLCBkLCB2YWwsIHR5cGVzW2tdKVxuICAgICAgcmV0dXJuIGRba11cbiAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsICE9PSByZW1vdmUgfSlcblxuICAgIC8vIGlmIHdlIGFsbG93IEFycmF5IHNwZWNpZmljYWxseSwgdGhlbiBhbiBlbXB0eSBhcnJheSBpcyBob3cgd2VcbiAgICAvLyBleHByZXNzICdubyB2YWx1ZSBoZXJlJywgbm90IG51bGwuICBBbGxvdyBpdC5cbiAgICBpZiAoIXZhbC5sZW5ndGggJiYgdHlwZS5pbmRleE9mKEFycmF5KSA9PT0gLTEpIHtcbiAgICAgIGRlYnVnKCdWQUwgSEFTIE5PIExFTkdUSCwgREVMRVRFIElUJywgdmFsLCBrLCB0eXBlLmluZGV4T2YoQXJyYXkpKVxuICAgICAgZGVsZXRlIGRhdGFba11cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBcnJheSkge1xuICAgICAgZGVidWcoaXNBcnJheSwgZGF0YVtrXSwgdmFsKVxuICAgICAgZGF0YVtrXSA9IHZhbFxuICAgIH0gZWxzZSBkYXRhW2tdID0gdmFsWzBdXG5cbiAgICBkZWJ1ZyhcIms9JXMgdmFsPSVqXCIsIGssIHZhbCwgZGF0YVtrXSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVTdHJpbmcgKGRhdGEsIGssIHZhbCkge1xuICBkYXRhW2tdID0gU3RyaW5nKHZhbClcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQYXRoIChkYXRhLCBrLCB2YWwpIHtcbiAgaWYgKHZhbCA9PT0gdHJ1ZSkgcmV0dXJuIGZhbHNlXG4gIGlmICh2YWwgPT09IG51bGwpIHJldHVybiB0cnVlXG5cbiAgdmFsID0gU3RyaW5nKHZhbClcblxuICB2YXIgaXNXaW4gICAgICAgPSBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInXG4gICAgLCBob21lUGF0dGVybiA9IGlzV2luID8gL15+KFxcL3xcXFxcKS8gOiAvXn5cXC8vXG4gICAgLCBob21lICAgICAgICA9IG9zZW52LmhvbWUoKVxuXG4gIGlmIChob21lICYmIHZhbC5tYXRjaChob21lUGF0dGVybikpIHtcbiAgICBkYXRhW2tdID0gcGF0aC5yZXNvbHZlKGhvbWUsIHZhbC5zdWJzdHIoMikpXG4gIH0gZWxzZSB7XG4gICAgZGF0YVtrXSA9IHBhdGgucmVzb2x2ZSh2YWwpXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXIgKGRhdGEsIGssIHZhbCkge1xuICBkZWJ1ZyhcInZhbGlkYXRlIE51bWJlciAlaiAlaiAlalwiLCBrLCB2YWwsIGlzTmFOKHZhbCkpXG4gIGlmIChpc05hTih2YWwpKSByZXR1cm4gZmFsc2VcbiAgZGF0YVtrXSA9ICt2YWxcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVEYXRlIChkYXRhLCBrLCB2YWwpIHtcbiAgdmFyIHMgPSBEYXRlLnBhcnNlKHZhbClcbiAgZGVidWcoXCJ2YWxpZGF0ZSBEYXRlICVqICVqICVqXCIsIGssIHZhbCwgcylcbiAgaWYgKGlzTmFOKHMpKSByZXR1cm4gZmFsc2VcbiAgZGF0YVtrXSA9IG5ldyBEYXRlKHZhbClcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVCb29sZWFuIChkYXRhLCBrLCB2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEJvb2xlYW4pIHZhbCA9IHZhbC52YWx1ZU9mKClcbiAgZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmICghaXNOYU4odmFsKSkgdmFsID0gISEoK3ZhbClcbiAgICBlbHNlIGlmICh2YWwgPT09IFwibnVsbFwiIHx8IHZhbCA9PT0gXCJmYWxzZVwiKSB2YWwgPSBmYWxzZVxuICAgIGVsc2UgdmFsID0gdHJ1ZVxuICB9IGVsc2UgdmFsID0gISF2YWxcbiAgZGF0YVtrXSA9IHZhbFxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVVybCAoZGF0YSwgaywgdmFsKSB7XG4gIHZhbCA9IHVybC5wYXJzZShTdHJpbmcodmFsKSlcbiAgaWYgKCF2YWwuaG9zdCkgcmV0dXJuIGZhbHNlXG4gIGRhdGFba10gPSB2YWwuaHJlZlxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVN0cmVhbSAoZGF0YSwgaywgdmFsKSB7XG4gIGlmICghKHZhbCBpbnN0YW5jZW9mIFN0cmVhbSkpIHJldHVybiBmYWxzZVxuICBkYXRhW2tdID0gdmFsXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlIChkYXRhLCBrLCB2YWwsIHR5cGUsIHR5cGVEZWZzKSB7XG4gIC8vIGFycmF5cyBhcmUgbGlzdHMgb2YgdHlwZXMuXG4gIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0eXBlLmxlbmd0aDsgaSA8IGw7IGkgKyspIHtcbiAgICAgIGlmICh0eXBlW2ldID09PSBBcnJheSkgY29udGludWVcbiAgICAgIGlmICh2YWxpZGF0ZShkYXRhLCBrLCB2YWwsIHR5cGVbaV0sIHR5cGVEZWZzKSkgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgZGVsZXRlIGRhdGFba11cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIGFuIGFycmF5IG9mIGFueXRoaW5nP1xuICBpZiAodHlwZSA9PT0gQXJyYXkpIHJldHVybiB0cnVlXG5cbiAgLy8gTmFOIGlzIHBvaXNvbm91cy4gIE1lYW5zIHRoYXQgc29tZXRoaW5nIGlzIG5vdCBhbGxvd2VkLlxuICBpZiAodHlwZSAhPT0gdHlwZSkge1xuICAgIGRlYnVnKFwiUG9pc29uIE5hTlwiLCBrLCB2YWwsIHR5cGUpXG4gICAgZGVsZXRlIGRhdGFba11cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIGV4cGxpY2l0IGxpc3Qgb2YgdmFsdWVzXG4gIGlmICh2YWwgPT09IHR5cGUpIHtcbiAgICBkZWJ1ZyhcIkV4cGxpY2l0bHkgYWxsb3dlZCAlalwiLCB2YWwpXG4gICAgLy8gaWYgKGlzQXJyYXkpIChkYXRhW2tdID0gZGF0YVtrXSB8fCBbXSkucHVzaCh2YWwpXG4gICAgLy8gZWxzZSBkYXRhW2tdID0gdmFsXG4gICAgZGF0YVtrXSA9IHZhbFxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyBub3cgZ28gdGhyb3VnaCB0aGUgbGlzdCBvZiB0eXBlRGVmcywgdmFsaWRhdGUgYWdhaW5zdCBlYWNoIG9uZS5cbiAgdmFyIG9rID0gZmFsc2VcbiAgICAsIHR5cGVzID0gT2JqZWN0LmtleXModHlwZURlZnMpXG4gIGZvciAodmFyIGkgPSAwLCBsID0gdHlwZXMubGVuZ3RoOyBpIDwgbDsgaSArKykge1xuICAgIGRlYnVnKFwidGVzdCB0eXBlICVqICVqICVqXCIsIGssIHZhbCwgdHlwZXNbaV0pXG4gICAgdmFyIHQgPSB0eXBlRGVmc1t0eXBlc1tpXV1cbiAgICBpZiAodCAmJlxuICAgICAgKCh0eXBlICYmIHR5cGUubmFtZSAmJiB0LnR5cGUgJiYgdC50eXBlLm5hbWUpID8gKHR5cGUubmFtZSA9PT0gdC50eXBlLm5hbWUpIDogKHR5cGUgPT09IHQudHlwZSkpKSB7XG4gICAgICB2YXIgZCA9IHt9XG4gICAgICBvayA9IGZhbHNlICE9PSB0LnZhbGlkYXRlKGQsIGssIHZhbClcbiAgICAgIHZhbCA9IGRba11cbiAgICAgIGlmIChvaykge1xuICAgICAgICAvLyBpZiAoaXNBcnJheSkgKGRhdGFba10gPSBkYXRhW2tdIHx8IFtdKS5wdXNoKHZhbClcbiAgICAgICAgLy8gZWxzZSBkYXRhW2tdID0gdmFsXG4gICAgICAgIGRhdGFba10gPSB2YWxcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZGVidWcoXCJPSz8gJWogKCVqICVqICVqKVwiLCBvaywgaywgdmFsLCB0eXBlc1tpXSlcblxuICBpZiAoIW9rKSBkZWxldGUgZGF0YVtrXVxuICByZXR1cm4gb2tcbn1cblxuZnVuY3Rpb24gcGFyc2UgKGFyZ3MsIGRhdGEsIHJlbWFpbiwgdHlwZXMsIHNob3J0aGFuZHMpIHtcbiAgZGVidWcoXCJwYXJzZVwiLCBhcmdzLCBkYXRhLCByZW1haW4pXG5cbiAgdmFyIGtleSA9IG51bGxcbiAgICAsIGFiYnJldnMgPSBhYmJyZXYoT2JqZWN0LmtleXModHlwZXMpKVxuICAgICwgc2hvcnRBYmJyID0gYWJicmV2KE9iamVjdC5rZXlzKHNob3J0aGFuZHMpKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkgKyspIHtcbiAgICB2YXIgYXJnID0gYXJnc1tpXVxuICAgIGRlYnVnKFwiYXJnXCIsIGFyZylcblxuICAgIGlmIChhcmcubWF0Y2goL14tezIsfSQvKSkge1xuICAgICAgLy8gZG9uZSB3aXRoIGtleXMuXG4gICAgICAvLyB0aGUgcmVzdCBhcmUgYXJncy5cbiAgICAgIHJlbWFpbi5wdXNoLmFwcGx5KHJlbWFpbiwgYXJncy5zbGljZShpICsgMSkpXG4gICAgICBhcmdzW2ldID0gXCItLVwiXG4gICAgICBicmVha1xuICAgIH1cbiAgICB2YXIgaGFkRXEgPSBmYWxzZVxuICAgIGlmIChhcmcuY2hhckF0KDApID09PSBcIi1cIiAmJiBhcmcubGVuZ3RoID4gMSkge1xuICAgICAgdmFyIGF0ID0gYXJnLmluZGV4T2YoJz0nKVxuICAgICAgaWYgKGF0ID4gLTEpIHtcbiAgICAgICAgaGFkRXEgPSB0cnVlXG4gICAgICAgIHZhciB2ID0gYXJnLnN1YnN0cihhdCArIDEpXG4gICAgICAgIGFyZyA9IGFyZy5zdWJzdHIoMCwgYXQpXG4gICAgICAgIGFyZ3Muc3BsaWNlKGksIDEsIGFyZywgdilcbiAgICAgIH1cblxuICAgICAgLy8gc2VlIGlmIGl0J3MgYSBzaG9ydGhhbmRcbiAgICAgIC8vIGlmIHNvLCBzcGxpY2UgYW5kIGJhY2sgdXAgdG8gcmUtcGFyc2UgaXQuXG4gICAgICB2YXIgc2hSZXMgPSByZXNvbHZlU2hvcnQoYXJnLCBzaG9ydGhhbmRzLCBzaG9ydEFiYnIsIGFiYnJldnMpXG4gICAgICBkZWJ1ZyhcImFyZz0laiBzaFJlcz0lalwiLCBhcmcsIHNoUmVzKVxuICAgICAgaWYgKHNoUmVzKSB7XG4gICAgICAgIGRlYnVnKGFyZywgc2hSZXMpXG4gICAgICAgIGFyZ3Muc3BsaWNlLmFwcGx5KGFyZ3MsIFtpLCAxXS5jb25jYXQoc2hSZXMpKVxuICAgICAgICBpZiAoYXJnICE9PSBzaFJlc1swXSkge1xuICAgICAgICAgIGkgLS1cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcmcgPSBhcmcucmVwbGFjZSgvXi0rLywgXCJcIilcbiAgICAgIHZhciBubyA9IG51bGxcbiAgICAgIHdoaWxlIChhcmcudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwibm8tXCIpID09PSAwKSB7XG4gICAgICAgIG5vID0gIW5vXG4gICAgICAgIGFyZyA9IGFyZy5zdWJzdHIoMylcbiAgICAgIH1cblxuICAgICAgaWYgKGFiYnJldnNbYXJnXSkgYXJnID0gYWJicmV2c1thcmddXG5cbiAgICAgIHZhciBhcmdUeXBlID0gdHlwZXNbYXJnXVxuICAgICAgdmFyIGlzVHlwZUFycmF5ID0gQXJyYXkuaXNBcnJheShhcmdUeXBlKVxuICAgICAgaWYgKGlzVHlwZUFycmF5ICYmIGFyZ1R5cGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlzVHlwZUFycmF5ID0gZmFsc2VcbiAgICAgICAgYXJnVHlwZSA9IGFyZ1R5cGVbMF1cbiAgICAgIH1cblxuICAgICAgdmFyIGlzQXJyYXkgPSBhcmdUeXBlID09PSBBcnJheSB8fFxuICAgICAgICBpc1R5cGVBcnJheSAmJiBhcmdUeXBlLmluZGV4T2YoQXJyYXkpICE9PSAtMVxuXG4gICAgICAvLyBhbGxvdyB1bmtub3duIHRoaW5ncyB0byBiZSBhcnJheXMgaWYgc3BlY2lmaWVkIG11bHRpcGxlIHRpbWVzLlxuICAgICAgaWYgKCF0eXBlcy5oYXNPd25Qcm9wZXJ0eShhcmcpICYmIGRhdGEuaGFzT3duUHJvcGVydHkoYXJnKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YVthcmddKSlcbiAgICAgICAgICBkYXRhW2FyZ10gPSBbZGF0YVthcmddXVxuICAgICAgICBpc0FycmF5ID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsXG4gICAgICAgICwgbGEgPSBhcmdzW2kgKyAxXVxuXG4gICAgICB2YXIgaXNCb29sID0gdHlwZW9mIG5vID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgYXJnVHlwZSA9PT0gQm9vbGVhbiB8fFxuICAgICAgICBpc1R5cGVBcnJheSAmJiBhcmdUeXBlLmluZGV4T2YoQm9vbGVhbikgIT09IC0xIHx8XG4gICAgICAgICh0eXBlb2YgYXJnVHlwZSA9PT0gJ3VuZGVmaW5lZCcgJiYgIWhhZEVxKSB8fFxuICAgICAgICAobGEgPT09IFwiZmFsc2VcIiAmJlxuICAgICAgICAgKGFyZ1R5cGUgPT09IG51bGwgfHxcbiAgICAgICAgICBpc1R5cGVBcnJheSAmJiB+YXJnVHlwZS5pbmRleE9mKG51bGwpKSlcblxuICAgICAgaWYgKGlzQm9vbCkge1xuICAgICAgICAvLyBqdXN0IHNldCBhbmQgbW92ZSBhbG9uZ1xuICAgICAgICB2YWwgPSAhbm9cbiAgICAgICAgLy8gaG93ZXZlciwgYWxzbyBzdXBwb3J0IC0tYm9vbCB0cnVlIG9yIC0tYm9vbCBmYWxzZVxuICAgICAgICBpZiAobGEgPT09IFwidHJ1ZVwiIHx8IGxhID09PSBcImZhbHNlXCIpIHtcbiAgICAgICAgICB2YWwgPSBKU09OLnBhcnNlKGxhKVxuICAgICAgICAgIGxhID0gbnVsbFxuICAgICAgICAgIGlmIChubykgdmFsID0gIXZhbFxuICAgICAgICAgIGkgKytcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFsc28gc3VwcG9ydCBcImZvb1wiOltCb29sZWFuLCBcImJhclwiXSBhbmQgXCItLWZvbyBiYXJcIlxuICAgICAgICBpZiAoaXNUeXBlQXJyYXkgJiYgbGEpIHtcbiAgICAgICAgICBpZiAofmFyZ1R5cGUuaW5kZXhPZihsYSkpIHtcbiAgICAgICAgICAgIC8vIGFuIGV4cGxpY2l0IHR5cGVcbiAgICAgICAgICAgIHZhbCA9IGxhXG4gICAgICAgICAgICBpICsrXG4gICAgICAgICAgfSBlbHNlIGlmICggbGEgPT09IFwibnVsbFwiICYmIH5hcmdUeXBlLmluZGV4T2YobnVsbCkgKSB7XG4gICAgICAgICAgICAvLyBudWxsIGFsbG93ZWRcbiAgICAgICAgICAgIHZhbCA9IG51bGxcbiAgICAgICAgICAgIGkgKytcbiAgICAgICAgICB9IGVsc2UgaWYgKCAhbGEubWF0Y2goL14tezIsfVteLV0vKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICFpc05hTihsYSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICB+YXJnVHlwZS5pbmRleE9mKE51bWJlcikgKSB7XG4gICAgICAgICAgICAvLyBudW1iZXJcbiAgICAgICAgICAgIHZhbCA9ICtsYVxuICAgICAgICAgICAgaSArK1xuICAgICAgICAgIH0gZWxzZSBpZiAoICFsYS5tYXRjaCgvXi1bXi1dLykgJiYgfmFyZ1R5cGUuaW5kZXhPZihTdHJpbmcpICkge1xuICAgICAgICAgICAgLy8gc3RyaW5nXG4gICAgICAgICAgICB2YWwgPSBsYVxuICAgICAgICAgICAgaSArK1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0FycmF5KSAoZGF0YVthcmddID0gZGF0YVthcmddIHx8IFtdKS5wdXNoKHZhbClcbiAgICAgICAgZWxzZSBkYXRhW2FyZ10gPSB2YWxcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBpZiAoYXJnVHlwZSA9PT0gU3RyaW5nKSB7XG4gICAgICAgIGlmIChsYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGEgPSBcIlwiXG4gICAgICAgIH0gZWxzZSBpZiAobGEubWF0Y2goL14tezEsMn1bXi1dKy8pKSB7XG4gICAgICAgICAgbGEgPSBcIlwiXG4gICAgICAgICAgaSAtLVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChsYSAmJiBsYS5tYXRjaCgvXi17Mix9JC8pKSB7XG4gICAgICAgIGxhID0gdW5kZWZpbmVkXG4gICAgICAgIGkgLS1cbiAgICAgIH1cblxuICAgICAgdmFsID0gbGEgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBsYVxuICAgICAgaWYgKGlzQXJyYXkpIChkYXRhW2FyZ10gPSBkYXRhW2FyZ10gfHwgW10pLnB1c2godmFsKVxuICAgICAgZWxzZSBkYXRhW2FyZ10gPSB2YWxcblxuICAgICAgaSArK1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgcmVtYWluLnB1c2goYXJnKVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTaG9ydCAoYXJnLCBzaG9ydGhhbmRzLCBzaG9ydEFiYnIsIGFiYnJldnMpIHtcbiAgLy8gaGFuZGxlIHNpbmdsZS1jaGFyIHNob3J0aGFuZHMgZ2xvbW1lZCB0b2dldGhlciwgbGlrZVxuICAvLyBucG0gbHMgLWdscCwgYnV0IG9ubHkgaWYgdGhlcmUgaXMgb25lIGRhc2gsIGFuZCBvbmx5IGlmXG4gIC8vIGFsbCBvZiB0aGUgY2hhcnMgYXJlIHNpbmdsZS1jaGFyIHNob3J0aGFuZHMsIGFuZCBpdCdzXG4gIC8vIG5vdCBhIG1hdGNoIHRvIHNvbWUgb3RoZXIgYWJicmV2LlxuICBhcmcgPSBhcmcucmVwbGFjZSgvXi0rLywgJycpXG5cbiAgLy8gaWYgaXQncyBhbiBleGFjdCBrbm93biBvcHRpb24sIHRoZW4gZG9uJ3QgZ28gYW55IGZ1cnRoZXJcbiAgaWYgKGFiYnJldnNbYXJnXSA9PT0gYXJnKVxuICAgIHJldHVybiBudWxsXG5cbiAgLy8gaWYgaXQncyBhbiBleGFjdCBrbm93biBzaG9ydG9wdCwgc2FtZSBkZWFsXG4gIGlmIChzaG9ydGhhbmRzW2FyZ10pIHtcbiAgICAvLyBtYWtlIGl0IGFuIGFycmF5LCBpZiBpdCdzIGEgbGlzdCBvZiB3b3Jkc1xuICAgIGlmIChzaG9ydGhhbmRzW2FyZ10gJiYgIUFycmF5LmlzQXJyYXkoc2hvcnRoYW5kc1thcmddKSlcbiAgICAgIHNob3J0aGFuZHNbYXJnXSA9IHNob3J0aGFuZHNbYXJnXS5zcGxpdCgvXFxzKy8pXG5cbiAgICByZXR1cm4gc2hvcnRoYW5kc1thcmddXG4gIH1cblxuICAvLyBmaXJzdCBjaGVjayB0byBzZWUgaWYgdGhpcyBhcmcgaXMgYSBzZXQgb2Ygc2luZ2xlLWNoYXIgc2hvcnRoYW5kc1xuICB2YXIgc2luZ2xlcyA9IHNob3J0aGFuZHMuX19fc2luZ2xlc1xuICBpZiAoIXNpbmdsZXMpIHtcbiAgICBzaW5nbGVzID0gT2JqZWN0LmtleXMoc2hvcnRoYW5kcykuZmlsdGVyKGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXR1cm4gcy5sZW5ndGggPT09IDFcbiAgICB9KS5yZWR1Y2UoZnVuY3Rpb24gKGwscikge1xuICAgICAgbFtyXSA9IHRydWVcbiAgICAgIHJldHVybiBsXG4gICAgfSwge30pXG4gICAgc2hvcnRoYW5kcy5fX19zaW5nbGVzID0gc2luZ2xlc1xuICAgIGRlYnVnKCdzaG9ydGhhbmQgc2luZ2xlcycsIHNpbmdsZXMpXG4gIH1cblxuICB2YXIgY2hycyA9IGFyZy5zcGxpdChcIlwiKS5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gc2luZ2xlc1tjXVxuICB9KVxuXG4gIGlmIChjaHJzLmpvaW4oXCJcIikgPT09IGFyZykgcmV0dXJuIGNocnMubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuIHNob3J0aGFuZHNbY11cbiAgfSkucmVkdWNlKGZ1bmN0aW9uIChsLCByKSB7XG4gICAgcmV0dXJuIGwuY29uY2F0KHIpXG4gIH0sIFtdKVxuXG5cbiAgLy8gaWYgaXQncyBhbiBhcmcgYWJicmV2LCBhbmQgbm90IGEgbGl0ZXJhbCBzaG9ydGhhbmQsIHRoZW4gcHJlZmVyIHRoZSBhcmdcbiAgaWYgKGFiYnJldnNbYXJnXSAmJiAhc2hvcnRoYW5kc1thcmddKVxuICAgIHJldHVybiBudWxsXG5cbiAgLy8gaWYgaXQncyBhbiBhYmJyIGZvciBhIHNob3J0aGFuZCwgdGhlbiB1c2UgdGhhdFxuICBpZiAoc2hvcnRBYmJyW2FyZ10pXG4gICAgYXJnID0gc2hvcnRBYmJyW2FyZ11cblxuICAvLyBtYWtlIGl0IGFuIGFycmF5LCBpZiBpdCdzIGEgbGlzdCBvZiB3b3Jkc1xuICBpZiAoc2hvcnRoYW5kc1thcmddICYmICFBcnJheS5pc0FycmF5KHNob3J0aGFuZHNbYXJnXSkpXG4gICAgc2hvcnRoYW5kc1thcmddID0gc2hvcnRoYW5kc1thcmddLnNwbGl0KC9cXHMrLylcblxuICByZXR1cm4gc2hvcnRoYW5kc1thcmddXG59XG4iLCIndXNlIHN0cmljdCdcblxuLy8gd2FsayB0aGUgdHJlZSBvZiBkZXBzIHN0YXJ0aW5nIGZyb20gdGhlIHRvcCBsZXZlbCBsaXN0IG9mIGJ1bmRsZWQgZGVwc1xuLy8gQW55IGRlcHMgYXQgdGhlIHRvcCBsZXZlbCB0aGF0IGFyZSBkZXBlbmRlZCBvbiBieSBhIGJ1bmRsZWQgZGVwIHRoYXRcbi8vIGRvZXMgbm90IGhhdmUgdGhhdCBkZXAgaW4gaXRzIG93biBub2RlX21vZHVsZXMgZm9sZGVyIGFyZSBjb25zaWRlcmVkXG4vLyBidW5kbGVkIGRlcHMgYXMgd2VsbC4gIFRoaXMgbGlzdCBvZiBuYW1lcyBjYW4gYmUgcGFzc2VkIHRvIG5wbS1wYWNrbGlzdFxuLy8gYXMgdGhlIFwiYnVuZGxlZFwiIGFyZ3VtZW50LiAgQWRkaXRpb25hbGx5LCBwYWNrYWdlSnNvbkNhY2hlIGlzIHNoYXJlZCBzb1xuLy8gcGFja2xpc3QgZG9lc24ndCBoYXZlIHRvIHJlLXJlYWQgZmlsZXMgYWxyZWFkeSBjb25zdW1lZCBpbiB0aGlzIHBhc3NcblxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGUgcGFja2FnZSBiaW5zLCBidXQgd2Ugc2hhcmUgYSBwaiBjYWNoZVxuLy8gd2l0aCBvdGhlciBtb2R1bGVzIHRoYXQgRE8gY2FyZSBhYm91dCBpdCwgc28ga2VlcCBpdCBuaWNlLlxuY29uc3Qgbm9ybWFsaXplUGFja2FnZUJpbiA9IHJlcXVpcmUoJ25wbS1ub3JtYWxpemUtcGFja2FnZS1iaW4nKVxuXG5jbGFzcyBCdW5kbGVXYWxrZXIgZXh0ZW5kcyBFRSB7XG4gIGNvbnN0cnVjdG9yIChvcHQpIHtcbiAgICBvcHQgPSBvcHQgfHwge31cbiAgICBzdXBlcihvcHQpXG4gICAgdGhpcy5wYXRoID0gcGF0aC5yZXNvbHZlKG9wdC5wYXRoIHx8IHByb2Nlc3MuY3dkKCkpXG5cbiAgICB0aGlzLnBhcmVudCA9IG9wdC5wYXJlbnQgfHwgbnVsbFxuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLnBhcmVudC5yZXN1bHRcbiAgICAgIC8vIG9ubHkgY29sbGVjdCByZXN1bHRzIGluIG5vZGVfbW9kdWxlcyBmb2xkZXJzIGF0IHRoZSB0b3AgbGV2ZWxcbiAgICAgIC8vIHNpbmNlIHRoZSBub2RlX21vZHVsZXMgaW4gYSBidW5kbGVkIGRlcCBpcyBpbmNsdWRlZCBhbHdheXNcbiAgICAgIGlmICghdGhpcy5wYXJlbnQucGFyZW50KSB7XG4gICAgICAgIGNvbnN0IGJhc2UgPSBwYXRoLmJhc2VuYW1lKHRoaXMucGF0aClcbiAgICAgICAgY29uc3Qgc2NvcGUgPSBwYXRoLmJhc2VuYW1lKHBhdGguZGlybmFtZSh0aGlzLnBhdGgpKVxuICAgICAgICB0aGlzLnJlc3VsdC5hZGQoL15ALy50ZXN0KHNjb3BlKSA/IHNjb3BlICsgJy8nICsgYmFzZSA6IGJhc2UpXG4gICAgICB9XG4gICAgICB0aGlzLnJvb3QgPSB0aGlzLnBhcmVudC5yb290XG4gICAgICB0aGlzLnBhY2thZ2VKc29uQ2FjaGUgPSB0aGlzLnBhcmVudC5wYWNrYWdlSnNvbkNhY2hlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gbmV3IFNldCgpXG4gICAgICB0aGlzLnJvb3QgPSB0aGlzLnBhdGhcbiAgICAgIHRoaXMucGFja2FnZUpzb25DYWNoZSA9IG9wdC5wYWNrYWdlSnNvbkNhY2hlIHx8IG5ldyBNYXAoKVxuICAgIH1cblxuICAgIHRoaXMuc2VlbiA9IG5ldyBTZXQoKVxuICAgIHRoaXMuZGlkRG9uZSA9IGZhbHNlXG4gICAgdGhpcy5jaGlsZHJlbiA9IDBcbiAgICB0aGlzLm5vZGVfbW9kdWxlcyA9IFtdXG4gICAgdGhpcy5wYWNrYWdlID0gbnVsbFxuICAgIHRoaXMuYnVuZGxlID0gbnVsbFxuICB9XG5cbiAgYWRkTGlzdGVuZXIgKGV2LCBmbikge1xuICAgIHJldHVybiB0aGlzLm9uKGV2LCBmbilcbiAgfVxuXG4gIG9uIChldiwgZm4pIHtcbiAgICBjb25zdCByZXQgPSBzdXBlci5vbihldiwgZm4pXG4gICAgaWYgKGV2ID09PSAnZG9uZScgJiYgdGhpcy5kaWREb25lKSB7XG4gICAgICB0aGlzLmVtaXQoJ2RvbmUnLCB0aGlzLnJlc3VsdClcbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgZG9uZSAoKSB7XG4gICAgaWYgKCF0aGlzLmRpZERvbmUpIHtcbiAgICAgIHRoaXMuZGlkRG9uZSA9IHRydWVcbiAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgY29uc3QgcmVzID0gQXJyYXkuZnJvbSh0aGlzLnJlc3VsdClcbiAgICAgICAgdGhpcy5yZXN1bHQgPSByZXNcbiAgICAgICAgdGhpcy5lbWl0KCdkb25lJywgcmVzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbWl0KCdkb25lJylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdGFydCAoKSB7XG4gICAgY29uc3QgcGogPSBwYXRoLnJlc29sdmUodGhpcy5wYXRoLCAncGFja2FnZS5qc29uJylcbiAgICBpZiAodGhpcy5wYWNrYWdlSnNvbkNhY2hlLmhhcyhwaikpXG4gICAgICB0aGlzLm9uUGFja2FnZSh0aGlzLnBhY2thZ2VKc29uQ2FjaGUuZ2V0KHBqKSlcbiAgICBlbHNlXG4gICAgICB0aGlzLnJlYWRQYWNrYWdlSnNvbihwailcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcmVhZFBhY2thZ2VKc29uIChwaikge1xuICAgIGZzLnJlYWRGaWxlKHBqLCAoZXIsIGRhdGEpID0+XG4gICAgICBlciA/IHRoaXMuZG9uZSgpIDogdGhpcy5vblBhY2thZ2VKc29uKHBqLCBkYXRhKSlcbiAgfVxuXG4gIG9uUGFja2FnZUpzb24gKHBqLCBkYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucGFja2FnZSA9IG5vcm1hbGl6ZVBhY2thZ2VCaW4oSlNPTi5wYXJzZShkYXRhICsgJycpKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5kb25lKClcbiAgICB9XG4gICAgdGhpcy5wYWNrYWdlSnNvbkNhY2hlLnNldChwaiwgdGhpcy5wYWNrYWdlKVxuICAgIHRoaXMub25QYWNrYWdlKHRoaXMucGFja2FnZSlcbiAgfVxuXG4gIGFsbERlcHNCdW5kbGVkIChwa2cpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocGtnLmRlcGVuZGVuY2llcyB8fCB7fSkuY29uY2F0KFxuICAgICAgT2JqZWN0LmtleXMocGtnLm9wdGlvbmFsRGVwZW5kZW5jaWVzIHx8IHt9KSlcbiAgfVxuXG4gIG9uUGFja2FnZSAocGtnKSB7XG4gICAgLy8gYWxsIGRlcHMgYXJlIGJ1bmRsZWQgaWYgd2UgZ290IGhlcmUgYXMgYSBjaGlsZC5cbiAgICAvLyBvdGhlcndpc2UsIG9ubHkgYnVuZGxlIGJ1bmRsZWREZXBzXG4gICAgLy8gR2V0IGEgdW5pcXVlLWlmaWVkIGFycmF5IHdpdGggYSBzaG9ydC1saXZlZCBTZXRcbiAgICBjb25zdCBiZFJhdyA9IHRoaXMucGFyZW50ID8gdGhpcy5hbGxEZXBzQnVuZGxlZChwa2cpXG4gICAgICA6IHBrZy5idW5kbGVEZXBlbmRlbmNpZXMgfHwgcGtnLmJ1bmRsZWREZXBlbmRlbmNpZXMgfHwgW11cblxuICAgIGNvbnN0IGJkID0gQXJyYXkuZnJvbShuZXcgU2V0KFxuICAgICAgQXJyYXkuaXNBcnJheShiZFJhdykgPyBiZFJhd1xuICAgICAgOiBiZFJhdyA9PT0gdHJ1ZSA/IHRoaXMuYWxsRGVwc0J1bmRsZWQocGtnKVxuICAgICAgOiBPYmplY3Qua2V5cyhiZFJhdykpKVxuXG4gICAgaWYgKCFiZC5sZW5ndGgpXG4gICAgICByZXR1cm4gdGhpcy5kb25lKClcblxuICAgIHRoaXMuYnVuZGxlID0gYmRcbiAgICBjb25zdCBubSA9IHRoaXMucGF0aCArICcvbm9kZV9tb2R1bGVzJ1xuICAgIHRoaXMucmVhZE1vZHVsZXMoKVxuICB9XG5cbiAgcmVhZE1vZHVsZXMgKCkge1xuICAgIHJlYWRkaXJOb2RlTW9kdWxlcyh0aGlzLnBhdGggKyAnL25vZGVfbW9kdWxlcycsIChlciwgbm0pID0+XG4gICAgICBlciA/IHRoaXMub25SZWFkZGlyKFtdKSA6IHRoaXMub25SZWFkZGlyKG5tKSlcbiAgfVxuXG4gIG9uUmVhZGRpciAobm0pIHtcbiAgICAvLyBrZWVwIHRyYWNrIG9mIHdoYXQgd2UgaGF2ZSwgaW4gY2FzZSBjaGlsZHJlbiBuZWVkIGl0XG4gICAgdGhpcy5ub2RlX21vZHVsZXMgPSBubVxuXG4gICAgdGhpcy5idW5kbGUuZm9yRWFjaChkZXAgPT4gdGhpcy5jaGlsZERlcChkZXApKVxuICAgIGlmICh0aGlzLmNoaWxkcmVuID09PSAwKVxuICAgICAgdGhpcy5kb25lKClcbiAgfVxuXG4gIGNoaWxkRGVwIChkZXApIHtcbiAgICBpZiAodGhpcy5ub2RlX21vZHVsZXMuaW5kZXhPZihkZXApICE9PSAtMSAmJiAhdGhpcy5zZWVuLmhhcyhkZXApKSB7XG4gICAgICB0aGlzLnNlZW4uYWRkKGRlcClcbiAgICAgIHRoaXMuY2hpbGQoZGVwKVxuICAgIH0gZWxzZSBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50LmNoaWxkRGVwKGRlcClcbiAgICB9XG4gIH1cblxuICBjaGlsZCAoZGVwKSB7XG4gICAgY29uc3QgcCA9IHRoaXMucGF0aCArICcvbm9kZV9tb2R1bGVzLycgKyBkZXBcbiAgICB0aGlzLmNoaWxkcmVuICs9IDFcbiAgICBjb25zdCBjaGlsZCA9IG5ldyBCdW5kbGVXYWxrZXIoe1xuICAgICAgcGF0aDogcCxcbiAgICAgIHBhcmVudDogdGhpc1xuICAgIH0pXG4gICAgY2hpbGQub24oJ2RvbmUnLCBfID0+IHtcbiAgICAgIGlmICgtLXRoaXMuY2hpbGRyZW4gPT09IDApXG4gICAgICAgIHRoaXMuZG9uZSgpXG4gICAgfSlcbiAgICBjaGlsZC5zdGFydCgpXG4gIH1cbn1cblxuY2xhc3MgQnVuZGxlV2Fsa2VyU3luYyBleHRlbmRzIEJ1bmRsZVdhbGtlciB7XG4gIGNvbnN0cnVjdG9yIChvcHQpIHtcbiAgICBzdXBlcihvcHQpXG4gIH1cblxuICBzdGFydCAoKSB7XG4gICAgc3VwZXIuc3RhcnQoKVxuICAgIHRoaXMuZG9uZSgpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHJlYWRQYWNrYWdlSnNvbiAocGopIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5vblBhY2thZ2VKc29uKHBqLCBmcy5yZWFkRmlsZVN5bmMocGopKVxuICAgIH0gY2F0Y2ggKGVyKSB7fVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICByZWFkTW9kdWxlcyAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMub25SZWFkZGlyKHJlYWRkaXJOb2RlTW9kdWxlc1N5bmModGhpcy5wYXRoICsgJy9ub2RlX21vZHVsZXMnKSlcbiAgICB9IGNhdGNoIChlcikge1xuICAgICAgdGhpcy5vblJlYWRkaXIoW10pXG4gICAgfVxuICB9XG5cbiAgY2hpbGQgKGRlcCkge1xuICAgIG5ldyBCdW5kbGVXYWxrZXJTeW5jKHtcbiAgICAgIHBhdGg6IHRoaXMucGF0aCArICcvbm9kZV9tb2R1bGVzLycgKyBkZXAsXG4gICAgICBwYXJlbnQ6IHRoaXNcbiAgICB9KS5zdGFydCgpXG4gIH1cbn1cblxuY29uc3QgcmVhZGRpck5vZGVNb2R1bGVzID0gKG5tLCBjYikgPT4ge1xuICBmcy5yZWFkZGlyKG5tLCAoZXIsIHNldCkgPT4ge1xuICAgIGlmIChlcilcbiAgICAgIGNiKGVyKVxuICAgIGVsc2Uge1xuICAgICAgY29uc3Qgc2NvcGVzID0gc2V0LmZpbHRlcihmID0+IC9eQC8udGVzdChmKSlcbiAgICAgIGlmICghc2NvcGVzLmxlbmd0aClcbiAgICAgICAgY2IobnVsbCwgc2V0KVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHVuc2NvcGVkID0gc2V0LmZpbHRlcihmID0+ICEvXkAvLnRlc3QoZikpXG4gICAgICAgIGxldCBjb3VudCA9IHNjb3Blcy5sZW5ndGhcbiAgICAgICAgc2NvcGVzLmZvckVhY2goc2NvcGUgPT4ge1xuICAgICAgICAgIGZzLnJlYWRkaXIobm0gKyAnLycgKyBzY29wZSwgKGVyLCBwa2dzKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXIgfHwgIXBrZ3MubGVuZ3RoKVxuICAgICAgICAgICAgICB1bnNjb3BlZC5wdXNoKHNjb3BlKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICB1bnNjb3BlZC5wdXNoLmFwcGx5KHVuc2NvcGVkLCBwa2dzLm1hcChwID0+IHNjb3BlICsgJy8nICsgcCkpXG4gICAgICAgICAgICBpZiAoLS1jb3VudCA9PT0gMClcbiAgICAgICAgICAgICAgY2IobnVsbCwgdW5zY29wZWQpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH0pXG59XG5cbmNvbnN0IHJlYWRkaXJOb2RlTW9kdWxlc1N5bmMgPSBubSA9PiB7XG4gIGNvbnN0IHNldCA9IGZzLnJlYWRkaXJTeW5jKG5tKVxuICBjb25zdCB1bnNjb3BlZCA9IHNldC5maWx0ZXIoZiA9PiAhL15ALy50ZXN0KGYpKVxuICBjb25zdCBzY29wZXMgPSBzZXQuZmlsdGVyKGYgPT4gL15ALy50ZXN0KGYpKS5tYXAoc2NvcGUgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwa2dzID0gZnMucmVhZGRpclN5bmMobm0gKyAnLycgKyBzY29wZSlcbiAgICAgIHJldHVybiBwa2dzLmxlbmd0aCA/IHBrZ3MubWFwKHAgPT4gc2NvcGUgKyAnLycgKyBwKSA6IFtzY29wZV1cbiAgICB9IGNhdGNoIChlcikge1xuICAgICAgcmV0dXJuIFtzY29wZV1cbiAgICB9XG4gIH0pLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYiksIFtdKVxuICByZXR1cm4gdW5zY29wZWQuY29uY2F0KHNjb3Blcylcbn1cblxuY29uc3Qgd2FsayA9IChvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICBjb25zdCBwID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIG5ldyBCdW5kbGVXYWxrZXIob3B0aW9ucykub24oJ2RvbmUnLCByZXNvbHZlKS5vbignZXJyb3InLCByZWplY3QpLnN0YXJ0KClcbiAgfSlcbiAgcmV0dXJuIGNhbGxiYWNrID8gcC50aGVuKHJlcyA9PiBjYWxsYmFjayhudWxsLCByZXMpLCBjYWxsYmFjaykgOiBwXG59XG5cbmNvbnN0IHdhbGtTeW5jID0gb3B0aW9ucyA9PiB7XG4gIHJldHVybiBuZXcgQnVuZGxlV2Fsa2VyU3luYyhvcHRpb25zKS5zdGFydCgpLnJlc3VsdFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhbGtcbndhbGsuc3luYyA9IHdhbGtTeW5jXG53YWxrLkJ1bmRsZVdhbGtlciA9IEJ1bmRsZVdhbGtlclxud2Fsay5CdW5kbGVXYWxrZXJTeW5jID0gQnVuZGxlV2Fsa2VyU3luY1xuIiwiLy8gcGFzcyBpbiBhIG1hbmlmZXN0IHdpdGggYSAnYmluJyBmaWVsZCBoZXJlLCBhbmQgaXQnbGwgdHVybiBpdFxuLy8gaW50byBhIHByb3Blcmx5IHNhbnRpemVkIGJpbiBvYmplY3RcbmNvbnN0IHtqb2luLCBiYXNlbmFtZX0gPSByZXF1aXJlKCdwYXRoJylcblxuY29uc3Qgbm9ybWFsaXplID0gcGtnID0+XG4gICFwa2cuYmluID8gcmVtb3ZlQmluKHBrZylcbiAgOiB0eXBlb2YgcGtnLmJpbiA9PT0gJ3N0cmluZycgPyBub3JtYWxpemVTdHJpbmcocGtnKVxuICA6IEFycmF5LmlzQXJyYXkocGtnLmJpbikgPyBub3JtYWxpemVBcnJheShwa2cpXG4gIDogdHlwZW9mIHBrZy5iaW4gPT09ICdvYmplY3QnID8gbm9ybWFsaXplT2JqZWN0KHBrZylcbiAgOiByZW1vdmVCaW4ocGtnKVxuXG5jb25zdCBub3JtYWxpemVTdHJpbmcgPSBwa2cgPT4ge1xuICBpZiAoIXBrZy5uYW1lKVxuICAgIHJldHVybiByZW1vdmVCaW4ocGtnKVxuICBwa2cuYmluID0geyBbcGtnLm5hbWVdOiBwa2cuYmluIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZU9iamVjdChwa2cpXG59XG5cbmNvbnN0IG5vcm1hbGl6ZUFycmF5ID0gcGtnID0+IHtcbiAgcGtnLmJpbiA9IHBrZy5iaW4ucmVkdWNlKChhY2MsIGspID0+IHtcbiAgICBhY2NbYmFzZW5hbWUoayldID0ga1xuICAgIHJldHVybiBhY2NcbiAgfSwge30pXG4gIHJldHVybiBub3JtYWxpemVPYmplY3QocGtnKVxufVxuXG5jb25zdCByZW1vdmVCaW4gPSBwa2cgPT4ge1xuICBkZWxldGUgcGtnLmJpblxuICByZXR1cm4gcGtnXG59XG5cbmNvbnN0IG5vcm1hbGl6ZU9iamVjdCA9IHBrZyA9PiB7XG4gIGNvbnN0IG9yaWcgPSBwa2cuYmluXG4gIGNvbnN0IGNsZWFuID0ge31cbiAgbGV0IGhhc0JpbnMgPSBmYWxzZVxuICBPYmplY3Qua2V5cyhvcmlnKS5mb3JFYWNoKGJpbktleSA9PiB7XG4gICAgY29uc3QgYmFzZSA9IGpvaW4oJy8nLCBiYXNlbmFtZShiaW5LZXkucmVwbGFjZSgvXFxcXHw6L2csICcvJykpKS5zdWJzdHIoMSlcblxuICAgIGlmICh0eXBlb2Ygb3JpZ1tiaW5LZXldICE9PSAnc3RyaW5nJyB8fCAhYmFzZSlcbiAgICAgIHJldHVyblxuXG4gICAgY29uc3QgYmluVGFyZ2V0ID0gam9pbignLycsIG9yaWdbYmluS2V5XSlcbiAgICAgIC5yZXBsYWNlKC9cXFxcL2csICcvJykuc3Vic3RyKDEpXG5cbiAgICBpZiAoIWJpblRhcmdldClcbiAgICAgIHJldHVyblxuXG4gICAgY2xlYW5bYmFzZV0gPSBiaW5UYXJnZXRcbiAgICBoYXNCaW5zID0gdHJ1ZVxuICB9KVxuXG4gIGlmIChoYXNCaW5zKVxuICAgIHBrZy5iaW4gPSBjbGVhblxuICBlbHNlXG4gICAgZGVsZXRlIHBrZy5iaW5cblxuICByZXR1cm4gcGtnXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbm9ybWFsaXplXG4iLCIndXNlIHN0cmljdCdcblxuLy8gRG8gYSB0d28tcGFzcyB3YWxrLCBmaXJzdCB0byBnZXQgdGhlIGxpc3Qgb2YgcGFja2FnZXMgdGhhdCBuZWVkIHRvIGJlXG4vLyBidW5kbGVkLCB0aGVuIGFnYWluIHRvIGdldCB0aGUgYWN0dWFsIGZpbGVzIGFuZCBmb2xkZXJzLlxuLy8gS2VlcCBhIGNhY2hlIG9mIG5vZGVfbW9kdWxlcyBjb250ZW50IGFuZCBwYWNrYWdlLmpzb24gZGF0YSwgc28gdGhhdCB0aGVcbi8vIHNlY29uZCB3YWxrIGRvZXNuJ3QgaGF2ZSB0byByZS1kbyBhbGwgdGhlIHNhbWUgd29yay5cblxuY29uc3QgYnVuZGxlV2FsayA9IHJlcXVpcmUoJ25wbS1idW5kbGVkJylcbmNvbnN0IEJ1bmRsZVdhbGtlciA9IGJ1bmRsZVdhbGsuQnVuZGxlV2Fsa2VyXG5jb25zdCBCdW5kbGVXYWxrZXJTeW5jID0gYnVuZGxlV2Fsay5CdW5kbGVXYWxrZXJTeW5jXG5cbmNvbnN0IGlnbm9yZVdhbGsgPSByZXF1aXJlKCdpZ25vcmUtd2FsaycpXG5jb25zdCBJZ25vcmVXYWxrZXIgPSBpZ25vcmVXYWxrLldhbGtlclxuY29uc3QgSWdub3JlV2Fsa2VyU3luYyA9IGlnbm9yZVdhbGsuV2Fsa2VyU3luY1xuXG5jb25zdCByb290QnVpbHRpblJ1bGVzID0gU3ltYm9sKCdyb290LWJ1aWx0aW4tcnVsZXMnKVxuY29uc3QgcGFja2FnZU5lY2Vzc2FyeVJ1bGVzID0gU3ltYm9sKCdwYWNrYWdlLW5lY2Vzc2FyeS1ydWxlcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5cbmNvbnN0IG5vcm1hbGl6ZVBhY2thZ2VCaW4gPSByZXF1aXJlKCducG0tbm9ybWFsaXplLXBhY2thZ2UtYmluJylcblxuY29uc3QgZGVmYXVsdFJ1bGVzID0gW1xuICAnLm5wbWlnbm9yZScsXG4gICcuZ2l0aWdub3JlJyxcbiAgJyoqLy5naXQnLFxuICAnKiovLnN2bicsXG4gICcqKi8uaGcnLFxuICAnKiovQ1ZTJyxcbiAgJyoqLy5naXQvKionLFxuICAnKiovLnN2bi8qKicsXG4gICcqKi8uaGcvKionLFxuICAnKiovQ1ZTLyoqJyxcbiAgJy8ubG9jay13c2NyaXB0JyxcbiAgJy8ud2FmcGlja2xlLSonLFxuICAnL2J1aWxkL2NvbmZpZy5neXBpJyxcbiAgJ25wbS1kZWJ1Zy5sb2cnLFxuICAnKiovLm5wbXJjJyxcbiAgJy4qLnN3cCcsXG4gICcuRFNfU3RvcmUnLFxuICAnKiovLkRTX1N0b3JlLyoqJyxcbiAgJy5fKicsXG4gICcqKi8uXyovKionLFxuICAnKi5vcmlnJyxcbiAgJy9wYWNrYWdlLWxvY2suanNvbicsXG4gICcveWFybi5sb2NrJyxcbiAgJ2FyY2hpdmVkLXBhY2thZ2VzLyoqJyxcbiAgJ2NvcmUnLFxuICAnIWNvcmUvJyxcbiAgJyEqKi9jb3JlLycsXG4gICcqLmNvcmUnLFxuICAnKi52Z2NvcmUnLFxuICAndmdjb3JlLionLFxuICAnY29yZS4rKFswLTldKScsXG5dXG5cbi8vIFRoZXJlIG1heSBiZSBvdGhlcnMsIGJ1dCA6P3w8PiBhcmUgaGFuZGxlZCBieSBub2RlLXRhclxuY29uc3QgbmFtZUlzQmFkRm9yV2luZG93cyA9IGZpbGUgPT4gL1xcKi8udGVzdChmaWxlKVxuXG4vLyBhIGRlY29yYXRvciB0aGF0IGFwcGxpZXMgb3VyIGN1c3RvbSBydWxlcyB0byBhbiBpZ25vcmUgd2Fsa2VyXG5jb25zdCBucG1XYWxrZXIgPSBDbGFzcyA9PiBjbGFzcyBXYWxrZXIgZXh0ZW5kcyBDbGFzcyB7XG4gIGNvbnN0cnVjdG9yIChvcHQpIHtcbiAgICBvcHQgPSBvcHQgfHwge31cblxuICAgIC8vIHRoZSBvcmRlciBpbiB3aGljaCBydWxlcyBhcmUgYXBwbGllZC5cbiAgICBvcHQuaWdub3JlRmlsZXMgPSBbXG4gICAgICByb290QnVpbHRpblJ1bGVzLFxuICAgICAgJ3BhY2thZ2UuanNvbicsXG4gICAgICAnLm5wbWlnbm9yZScsXG4gICAgICAnLmdpdGlnbm9yZScsXG4gICAgICBwYWNrYWdlTmVjZXNzYXJ5UnVsZXNcbiAgICBdXG5cbiAgICBvcHQuaW5jbHVkZUVtcHR5ID0gZmFsc2VcbiAgICBvcHQucGF0aCA9IG9wdC5wYXRoIHx8IHByb2Nlc3MuY3dkKClcbiAgICBjb25zdCBkaXJOYW1lID0gcGF0aC5iYXNlbmFtZShvcHQucGF0aClcbiAgICBjb25zdCBwYXJlbnROYW1lID0gcGF0aC5iYXNlbmFtZShwYXRoLmRpcm5hbWUob3B0LnBhdGgpKVxuICAgIG9wdC5mb2xsb3cgPVxuICAgICAgZGlyTmFtZSA9PT0gJ25vZGVfbW9kdWxlcycgfHxcbiAgICAgIChwYXJlbnROYW1lID09PSAnbm9kZV9tb2R1bGVzJyAmJiAvXkAvLnRlc3QoZGlyTmFtZSkpXG4gICAgc3VwZXIob3B0KVxuXG4gICAgLy8gaWdub3JlIGEgYnVuY2ggb2YgdGhpbmdzIGJ5IGRlZmF1bHQgYXQgdGhlIHJvb3QgbGV2ZWwuXG4gICAgLy8gYWxzbyBpZ25vcmUgYW55dGhpbmcgaW4gbm9kZV9tb2R1bGVzLCBleGNlcHQgYnVuZGxlZCBkZXBlbmRlbmNpZXNcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLmJ1bmRsZWQgPSBvcHQuYnVuZGxlZCB8fCBbXVxuICAgICAgdGhpcy5idW5kbGVkU2NvcGVzID0gQXJyYXkuZnJvbShuZXcgU2V0KFxuICAgICAgICB0aGlzLmJ1bmRsZWQuZmlsdGVyKGYgPT4gL15ALy50ZXN0KGYpKVxuICAgICAgICAubWFwKGYgPT4gZi5zcGxpdCgnLycpWzBdKSkpXG4gICAgICBjb25zdCBydWxlcyA9IGRlZmF1bHRSdWxlcy5qb2luKCdcXG4nKSArICdcXG4nXG4gICAgICB0aGlzLnBhY2thZ2VKc29uQ2FjaGUgPSBvcHQucGFja2FnZUpzb25DYWNoZSB8fCBuZXcgTWFwKClcbiAgICAgIHN1cGVyLm9uUmVhZElnbm9yZUZpbGUocm9vdEJ1aWx0aW5SdWxlcywgcnVsZXMsIF89Pl8pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYnVuZGxlZCA9IFtdXG4gICAgICB0aGlzLmJ1bmRsZWRTY29wZXMgPSBbXVxuICAgICAgdGhpcy5wYWNrYWdlSnNvbkNhY2hlID0gdGhpcy5wYXJlbnQucGFja2FnZUpzb25DYWNoZVxuICAgIH1cbiAgfVxuXG4gIG9uUmVhZGRpciAoZW50cmllcykge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIGVudHJpZXMgPSBlbnRyaWVzLmZpbHRlcihlID0+XG4gICAgICAgIGUgIT09ICcuZ2l0JyAmJlxuICAgICAgICAhKGUgPT09ICdub2RlX21vZHVsZXMnICYmIHRoaXMuYnVuZGxlZC5sZW5ndGggPT09IDApXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBzdXBlci5vblJlYWRkaXIoZW50cmllcylcbiAgfVxuXG4gIGZpbHRlckVudHJ5IChlbnRyeSwgcGFydGlhbCkge1xuICAgIC8vIGdldCB0aGUgcGFydGlhbCBwYXRoIGZyb20gdGhlIHJvb3Qgb2YgdGhlIHdhbGtcbiAgICBjb25zdCBwID0gdGhpcy5wYXRoLnN1YnN0cih0aGlzLnJvb3QubGVuZ3RoICsgMSlcbiAgICBjb25zdCBwa2dyZSA9IC9ebm9kZV9tb2R1bGVzXFwvKEBbXlxcL10rXFwvP1teXFwvXSt8W15cXC9dKykoXFwvLiopPyQvXG4gICAgY29uc3QgaXNSb290ID0gIXRoaXMucGFyZW50XG4gICAgY29uc3QgcGtnID0gaXNSb290ICYmIHBrZ3JlLnRlc3QoZW50cnkpID9cbiAgICAgIGVudHJ5LnJlcGxhY2UocGtncmUsICckMScpIDogbnVsbFxuICAgIGNvbnN0IHJvb3ROTSA9IGlzUm9vdCAmJiBlbnRyeSA9PT0gJ25vZGVfbW9kdWxlcydcbiAgICBjb25zdCByb290UEogPSBpc1Jvb3QgJiYgZW50cnkgPT09ICdwYWNrYWdlLmpzb24nXG5cbiAgICByZXR1cm4gKFxuICAgICAgLy8gaWYgd2UncmUgaW4gYSBidW5kbGVkIHBhY2thZ2UsIGNoZWNrIHdpdGggdGhlIHBhcmVudC5cbiAgICAgIC9ebm9kZV9tb2R1bGVzKCR8XFwvKS9pLnRlc3QocCkgPyB0aGlzLnBhcmVudC5maWx0ZXJFbnRyeShcbiAgICAgICAgICB0aGlzLmJhc2VuYW1lICsgJy8nICsgZW50cnksIHBhcnRpYWwpXG5cbiAgICAgIC8vIGlmIHBhY2thZ2UgaXMgYnVuZGxlZCwgYWxsIGZpbGVzIGluY2x1ZGVkXG4gICAgICAvLyBhbHNvIGluY2x1ZGUgQHNjb3BlIGRpcnMgZm9yIGJ1bmRsZWQgc2NvcGVkIGRlcHNcbiAgICAgIC8vIHRoZXknbGwgYmUgaWdub3JlZCBpZiBubyBmaWxlcyBlbmQgdXAgaW4gdGhlbS5cbiAgICAgIC8vIEhvd2V2ZXIsIHRoaXMgb25seSBtYXR0ZXJzIGlmIHdlJ3JlIGluIHRoZSByb290LlxuICAgICAgLy8gbm9kZV9tb2R1bGVzIGZvbGRlcnMgZWxzZXdoZXJlLCBsaWtlIGxpYi9ub2RlX21vZHVsZXMsXG4gICAgICAvLyBzaG91bGQgYmUgaW5jbHVkZWQgbm9ybWFsbHkgdW5sZXNzIGlnbm9yZWQuXG4gICAgICA6IHBrZyA/IC0xICE9PSB0aGlzLmJ1bmRsZWQuaW5kZXhPZihwa2cpIHx8XG4gICAgICAgIC0xICE9PSB0aGlzLmJ1bmRsZWRTY29wZXMuaW5kZXhPZihwa2cpXG5cbiAgICAgIC8vIG9ubHkgd2FsayB0b3Agbm9kZV9tb2R1bGVzIGlmIHdlIHdhbnQgdG8gYnVuZGxlIHNvbWV0aGluZ1xuICAgICAgOiByb290Tk0gPyAhIXRoaXMuYnVuZGxlZC5sZW5ndGhcblxuICAgICAgLy8gYWx3YXlzIGluY2x1ZGUgcGFja2FnZS5qc29uIGF0IHRoZSByb290LlxuICAgICAgOiByb290UEogPyB0cnVlXG5cbiAgICAgIC8vIG90aGVyd2lzZSwgZm9sbG93IGlnbm9yZS13YWxrJ3MgbG9naWNcbiAgICAgIDogc3VwZXIuZmlsdGVyRW50cnkoZW50cnksIHBhcnRpYWwpXG4gICAgKVxuICB9XG5cbiAgZmlsdGVyRW50cmllcyAoKSB7XG4gICAgaWYgKHRoaXMuaWdub3JlUnVsZXNbJ3BhY2thZ2UuanNvbiddKVxuICAgICAgdGhpcy5pZ25vcmVSdWxlc1snLmdpdGlnbm9yZSddID0gdGhpcy5pZ25vcmVSdWxlc1snLm5wbWlnbm9yZSddID0gbnVsbFxuICAgIGVsc2UgaWYgKHRoaXMuaWdub3JlUnVsZXNbJy5ucG1pZ25vcmUnXSlcbiAgICAgIHRoaXMuaWdub3JlUnVsZXNbJy5naXRpZ25vcmUnXSA9IG51bGxcbiAgICB0aGlzLmZpbHRlckVudHJpZXMgPSBzdXBlci5maWx0ZXJFbnRyaWVzXG4gICAgc3VwZXIuZmlsdGVyRW50cmllcygpXG4gIH1cblxuICBhZGRJZ25vcmVGaWxlIChmaWxlLCB0aGVuKSB7XG4gICAgY29uc3QgaWcgPSBwYXRoLnJlc29sdmUodGhpcy5wYXRoLCBmaWxlKVxuICAgIGlmICh0aGlzLnBhY2thZ2VKc29uQ2FjaGUuaGFzKGlnKSlcbiAgICAgIHRoaXMub25QYWNrYWdlSnNvbihpZywgdGhpcy5wYWNrYWdlSnNvbkNhY2hlLmdldChpZyksIHRoZW4pXG4gICAgZWxzZVxuICAgICAgc3VwZXIuYWRkSWdub3JlRmlsZShmaWxlLCB0aGVuKVxuICB9XG5cbiAgb25QYWNrYWdlSnNvbiAoaWcsIHBrZywgdGhlbikge1xuICAgIHRoaXMucGFja2FnZUpzb25DYWNoZS5zZXQoaWcsIHBrZylcblxuICAgIC8vIGlmIHRoZXJlJ3MgYSBiaW4sIGJyb3dzZXIgb3IgbWFpbiwgbWFrZSBzdXJlIHdlIGRvbid0IGlnbm9yZSBpdFxuICAgIC8vIGFsc28sIGRvbid0IGlnbm9yZSB0aGUgcGFja2FnZS5qc29uIGl0c2VsZiFcbiAgICAvL1xuICAgIC8vIFdlaXJkIHNpZGUtZWZmZWN0IG9mIHRoaXM6IGEgcmVhZG1lIChldGMpIGZpbGUgd2lsbCBiZSBpbmNsdWRlZFxuICAgIC8vIGlmIGl0IGV4aXN0cyBhbnl3aGVyZSB3aXRoaW4gYSBmb2xkZXIgd2l0aCBhIHBhY2thZ2UuanNvbiBmaWxlLlxuICAgIC8vIFRoZSBvcmlnaW5hbCBpbnRlbnQgd2FzIG9ubHkgdG8gaW5jbHVkZSB0aGVzZSBmaWxlcyBpbiB0aGUgcm9vdCxcbiAgICAvLyBidXQgbm93IHVzZXJzIGluIHRoZSB3aWxkIGFyZSBkZXBlbmRlbnQgb24gdGhhdCBiZWhhdmlvciBmb3JcbiAgICAvLyBsb2NhbGl6ZWQgZG9jdW1lbnRhdGlvbiBhbmQgb3RoZXIgdXNlIGNhc2VzLiAgQWRkaW5nIGEgYC9gIHRvXG4gICAgLy8gdGhlc2UgcnVsZXMsIHdoaWxlIHRlbXB0aW5nIGFuZCBhcmd1YWJseSBtb3JlIFwiY29ycmVjdFwiLCBpcyBhXG4gICAgLy8gYnJlYWtpbmcgY2hhbmdlLlxuICAgIGNvbnN0IHJ1bGVzID0gW1xuICAgICAgcGtnLmJyb3dzZXIgPyAnIScgKyBwa2cuYnJvd3NlciA6ICcnLFxuICAgICAgcGtnLm1haW4gPyAnIScgKyBwa2cubWFpbiA6ICcnLFxuICAgICAgJyFwYWNrYWdlLmpzb24nLFxuICAgICAgJyFucG0tc2hyaW5rd3JhcC5qc29uJyxcbiAgICAgICchQChyZWFkbWV8Y29weWluZ3xsaWNlbnNlfGxpY2VuY2V8bm90aWNlfGNoYW5nZXN8Y2hhbmdlbG9nfGhpc3RvcnkpeywuKltefiRdfSdcbiAgICBdXG4gICAgaWYgKHBrZy5iaW4pIHtcbiAgICAgIC8vIGFsd2F5cyBhbiBvYmplY3QsIGJlY2F1c2Ugbm9ybWFsaXplZCBhbHJlYWR5XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBwa2cuYmluKVxuICAgICAgICBydWxlcy5wdXNoKCchJyArIHBrZy5iaW5ba2V5XSlcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gcnVsZXMuZmlsdGVyKGYgPT4gZikuam9pbignXFxuJykgKyAnXFxuJ1xuICAgIHN1cGVyLm9uUmVhZElnbm9yZUZpbGUocGFja2FnZU5lY2Vzc2FyeVJ1bGVzLCBkYXRhLCBfPT5fKVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGtnLmZpbGVzKSlcbiAgICAgIHN1cGVyLm9uUmVhZElnbm9yZUZpbGUoJ3BhY2thZ2UuanNvbicsICcqXFxuJyArIHBrZy5maWxlcy5tYXAoXG4gICAgICAgIGYgPT4gJyEnICsgZiArICdcXG4hJyArIGYucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLyoqJ1xuICAgICAgKS5qb2luKCdcXG4nKSArICdcXG4nLCB0aGVuKVxuICAgIGVsc2VcbiAgICAgIHRoZW4oKVxuICB9XG5cbiAgLy8gb3ZlcnJpZGUgcGFyZW50IHN0YXQgZnVuY3Rpb24gdG8gY29tcGxldGVseSBza2lwIGFueSBmaWxlbmFtZXNcbiAgLy8gdGhhdCB3aWxsIGJyZWFrIHdpbmRvd3MgZW50aXJlbHkuXG4gIC8vIFhYWChpc2FhY3MpIE5leHQgbWFqb3IgdmVyc2lvbiBzaG91bGQgbWFrZSB0aGlzIGFuIGVycm9yIGluc3RlYWQuXG4gIHN0YXQgKGVudHJ5LCBmaWxlLCBkaXIsIHRoZW4pIHtcbiAgICBpZiAobmFtZUlzQmFkRm9yV2luZG93cyhlbnRyeSkpXG4gICAgICB0aGVuKClcbiAgICBlbHNlXG4gICAgICBzdXBlci5zdGF0KGVudHJ5LCBmaWxlLCBkaXIsIHRoZW4pXG4gIH1cblxuICAvLyBvdmVycmlkZSBwYXJlbnQgb25zdGF0IGZ1bmN0aW9uIHRvIG5peCBhbGwgc3ltbGlua3NcbiAgb25zdGF0IChzdCwgZW50cnksIGZpbGUsIGRpciwgdGhlbikge1xuICAgIGlmIChzdC5pc1N5bWJvbGljTGluaygpKVxuICAgICAgdGhlbigpXG4gICAgZWxzZVxuICAgICAgc3VwZXIub25zdGF0KHN0LCBlbnRyeSwgZmlsZSwgZGlyLCB0aGVuKVxuICB9XG5cbiAgb25SZWFkSWdub3JlRmlsZSAoZmlsZSwgZGF0YSwgdGhlbikge1xuICAgIGlmIChmaWxlID09PSAncGFja2FnZS5qc29uJylcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGlnID0gcGF0aC5yZXNvbHZlKHRoaXMucGF0aCwgZmlsZSlcbiAgICAgICAgdGhpcy5vblBhY2thZ2VKc29uKGlnLCBub3JtYWxpemVQYWNrYWdlQmluKEpTT04ucGFyc2UoZGF0YSkpLCB0aGVuKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgLy8gaWdub3JlIHBhY2thZ2UuanNvbiBmaWxlcyB0aGF0IGFyZSBub3QganNvblxuICAgICAgICB0aGVuKClcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICBzdXBlci5vblJlYWRJZ25vcmVGaWxlKGZpbGUsIGRhdGEsIHRoZW4pXG4gIH1cblxuICBzb3J0IChhLCBiKSB7XG4gICAgcmV0dXJuIHNvcnQoYSwgYilcbiAgfVxufVxuXG5jbGFzcyBXYWxrZXIgZXh0ZW5kcyBucG1XYWxrZXIoSWdub3JlV2Fsa2VyKSB7XG4gIHdhbGtlciAoZW50cnksIHRoZW4pIHtcbiAgICBuZXcgV2Fsa2VyKHRoaXMud2Fsa2VyT3B0KGVudHJ5KSkub24oJ2RvbmUnLCB0aGVuKS5zdGFydCgpXG4gIH1cbn1cblxuY2xhc3MgV2Fsa2VyU3luYyBleHRlbmRzIG5wbVdhbGtlcihJZ25vcmVXYWxrZXJTeW5jKSB7XG4gIHdhbGtlciAoZW50cnksIHRoZW4pIHtcbiAgICBuZXcgV2Fsa2VyU3luYyh0aGlzLndhbGtlck9wdChlbnRyeSkpLnN0YXJ0KClcbiAgICB0aGVuKClcbiAgfVxufVxuXG5jb25zdCB3YWxrID0gKG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIGNvbnN0IHAgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgYncgPSBuZXcgQnVuZGxlV2Fsa2VyKG9wdGlvbnMpXG4gICAgYncub24oJ2RvbmUnLCBidW5kbGVkID0+IHtcbiAgICAgIG9wdGlvbnMuYnVuZGxlZCA9IGJ1bmRsZWRcbiAgICAgIG9wdGlvbnMucGFja2FnZUpzb25DYWNoZSA9IGJ3LnBhY2thZ2VKc29uQ2FjaGVcbiAgICAgIG5ldyBXYWxrZXIob3B0aW9ucykub24oJ2RvbmUnLCByZXNvbHZlKS5vbignZXJyb3InLCByZWplY3QpLnN0YXJ0KClcbiAgICB9KVxuICAgIGJ3LnN0YXJ0KClcbiAgfSlcbiAgcmV0dXJuIGNhbGxiYWNrID8gcC50aGVuKHJlcyA9PiBjYWxsYmFjayhudWxsLCByZXMpLCBjYWxsYmFjaykgOiBwXG59XG5cbmNvbnN0IHdhbGtTeW5jID0gb3B0aW9ucyA9PiB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIGNvbnN0IGJ3ID0gbmV3IEJ1bmRsZVdhbGtlclN5bmMob3B0aW9ucykuc3RhcnQoKVxuICBvcHRpb25zLmJ1bmRsZWQgPSBidy5yZXN1bHRcbiAgb3B0aW9ucy5wYWNrYWdlSnNvbkNhY2hlID0gYncucGFja2FnZUpzb25DYWNoZVxuICBjb25zdCB3YWxrZXIgPSBuZXcgV2Fsa2VyU3luYyhvcHRpb25zKVxuICB3YWxrZXIuc3RhcnQoKVxuICByZXR1cm4gd2Fsa2VyLnJlc3VsdFxufVxuXG4vLyBvcHRpbWl6ZSBmb3IgY29tcHJlc3NpYmlsaXR5XG4vLyBleHRuYW1lLCB0aGVuIGJhc2VuYW1lLCB0aGVuIGxvY2FsZSBhbHBoYWJldGljYWxseVxuLy8gaHR0cHM6Ly90d2l0dGVyLmNvbS9pc250aXR2YWNhbnQvc3RhdHVzLzExMzEwOTQ5MTA5MjMyMzEyMzJcbmNvbnN0IHNvcnQgPSAoYSwgYikgPT4ge1xuICBjb25zdCBleHRhID0gcGF0aC5leHRuYW1lKGEpLnRvTG93ZXJDYXNlKClcbiAgY29uc3QgZXh0YiA9IHBhdGguZXh0bmFtZShiKS50b0xvd2VyQ2FzZSgpXG4gIGNvbnN0IGJhc2VhID0gcGF0aC5iYXNlbmFtZShhKS50b0xvd2VyQ2FzZSgpXG4gIGNvbnN0IGJhc2ViID0gcGF0aC5iYXNlbmFtZShiKS50b0xvd2VyQ2FzZSgpXG5cbiAgcmV0dXJuIGV4dGEubG9jYWxlQ29tcGFyZShleHRiKSB8fFxuICAgIGJhc2VhLmxvY2FsZUNvbXBhcmUoYmFzZWIpIHx8XG4gICAgYS5sb2NhbGVDb21wYXJlKGIpXG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSB3YWxrXG53YWxrLnN5bmMgPSB3YWxrU3luY1xud2Fsay5XYWxrZXIgPSBXYWxrZXJcbndhbGsuV2Fsa2VyU3luYyA9IFdhbGtlclN5bmNcbiIsIid1c2Ugc3RyaWN0J1xudmFyIFByb2dyZXNzID0gcmVxdWlyZSgnYXJlLXdlLXRoZXJlLXlldCcpXG52YXIgR2F1Z2UgPSByZXF1aXJlKCdnYXVnZScpXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbnZhciBsb2cgPSBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBuZXcgRUUoKVxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJylcblxudmFyIHNldEJsb2NraW5nID0gcmVxdWlyZSgnc2V0LWJsb2NraW5nJylcbnZhciBjb25zb2xlQ29udHJvbCA9IHJlcXVpcmUoJ2NvbnNvbGUtY29udHJvbC1zdHJpbmdzJylcblxuc2V0QmxvY2tpbmcodHJ1ZSlcbnZhciBzdHJlYW0gPSBwcm9jZXNzLnN0ZGVyclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGxvZywgJ3N0cmVhbScsIHtcbiAgc2V0OiBmdW5jdGlvbiAobmV3U3RyZWFtKSB7XG4gICAgc3RyZWFtID0gbmV3U3RyZWFtXG4gICAgaWYgKHRoaXMuZ2F1Z2UpIHRoaXMuZ2F1Z2Uuc2V0V3JpdGVUbyhzdHJlYW0sIHN0cmVhbSlcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHN0cmVhbVxuICB9XG59KVxuXG4vLyBieSBkZWZhdWx0LCBkZWNpZGUgYmFzZWQgb24gdHR5LW5lc3MuXG52YXIgY29sb3JFbmFibGVkXG5sb2cudXNlQ29sb3IgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjb2xvckVuYWJsZWQgIT0gbnVsbCA/IGNvbG9yRW5hYmxlZCA6IHN0cmVhbS5pc1RUWVxufVxuXG5sb2cuZW5hYmxlQ29sb3IgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbG9yRW5hYmxlZCA9IHRydWVcbiAgdGhpcy5nYXVnZS5zZXRUaGVtZSh7aGFzQ29sb3I6IGNvbG9yRW5hYmxlZCwgaGFzVW5pY29kZTogdW5pY29kZUVuYWJsZWR9KVxufVxubG9nLmRpc2FibGVDb2xvciA9IGZ1bmN0aW9uICgpIHtcbiAgY29sb3JFbmFibGVkID0gZmFsc2VcbiAgdGhpcy5nYXVnZS5zZXRUaGVtZSh7aGFzQ29sb3I6IGNvbG9yRW5hYmxlZCwgaGFzVW5pY29kZTogdW5pY29kZUVuYWJsZWR9KVxufVxuXG4vLyBkZWZhdWx0IGxldmVsXG5sb2cubGV2ZWwgPSAnaW5mbydcblxubG9nLmdhdWdlID0gbmV3IEdhdWdlKHN0cmVhbSwge1xuICBlbmFibGVkOiBmYWxzZSwgLy8gbm8gcHJvZ3Jlc3MgYmFycyB1bmxlc3MgYXNrZWRcbiAgdGhlbWU6IHtoYXNDb2xvcjogbG9nLnVzZUNvbG9yKCl9LFxuICB0ZW1wbGF0ZTogW1xuICAgIHt0eXBlOiAncHJvZ3Jlc3NiYXInLCBsZW5ndGg6IDIwfSxcbiAgICB7dHlwZTogJ2FjdGl2aXR5SW5kaWNhdG9yJywga2VybmluZzogMSwgbGVuZ3RoOiAxfSxcbiAgICB7dHlwZTogJ3NlY3Rpb24nLCBkZWZhdWx0OiAnJ30sXG4gICAgJzonLFxuICAgIHt0eXBlOiAnbG9nbGluZScsIGtlcm5pbmc6IDEsIGRlZmF1bHQ6ICcnfVxuICBdXG59KVxuXG5sb2cudHJhY2tlciA9IG5ldyBQcm9ncmVzcy5UcmFja2VyR3JvdXAoKVxuXG4vLyB3ZSB0cmFjayB0aGlzIHNlcGFyYXRlbHkgYXMgd2UgbWF5IG5lZWQgdG8gdGVtcG9yYXJpbHkgZGlzYWJsZSB0aGVcbi8vIGRpc3BsYXkgb2YgdGhlIHN0YXR1cyBiYXIgZm9yIG91ciBvd24gbG9nZ3kgcHVycG9zZXMuXG5sb2cucHJvZ3Jlc3NFbmFibGVkID0gbG9nLmdhdWdlLmlzRW5hYmxlZCgpXG5cbnZhciB1bmljb2RlRW5hYmxlZFxuXG5sb2cuZW5hYmxlVW5pY29kZSA9IGZ1bmN0aW9uICgpIHtcbiAgdW5pY29kZUVuYWJsZWQgPSB0cnVlXG4gIHRoaXMuZ2F1Z2Uuc2V0VGhlbWUoe2hhc0NvbG9yOiB0aGlzLnVzZUNvbG9yKCksIGhhc1VuaWNvZGU6IHVuaWNvZGVFbmFibGVkfSlcbn1cblxubG9nLmRpc2FibGVVbmljb2RlID0gZnVuY3Rpb24gKCkge1xuICB1bmljb2RlRW5hYmxlZCA9IGZhbHNlXG4gIHRoaXMuZ2F1Z2Uuc2V0VGhlbWUoe2hhc0NvbG9yOiB0aGlzLnVzZUNvbG9yKCksIGhhc1VuaWNvZGU6IHVuaWNvZGVFbmFibGVkfSlcbn1cblxubG9nLnNldEdhdWdlVGhlbWVzZXQgPSBmdW5jdGlvbiAodGhlbWVzKSB7XG4gIHRoaXMuZ2F1Z2Uuc2V0VGhlbWVzZXQodGhlbWVzKVxufVxuXG5sb2cuc2V0R2F1Z2VUZW1wbGF0ZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuICB0aGlzLmdhdWdlLnNldFRlbXBsYXRlKHRlbXBsYXRlKVxufVxuXG5sb2cuZW5hYmxlUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnByb2dyZXNzRW5hYmxlZCkgcmV0dXJuXG4gIHRoaXMucHJvZ3Jlc3NFbmFibGVkID0gdHJ1ZVxuICB0aGlzLnRyYWNrZXIub24oJ2NoYW5nZScsIHRoaXMuc2hvd1Byb2dyZXNzKVxuICBpZiAodGhpcy5fcGF1c2UpIHJldHVyblxuICB0aGlzLmdhdWdlLmVuYWJsZSgpXG59XG5cbmxvZy5kaXNhYmxlUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5wcm9ncmVzc0VuYWJsZWQpIHJldHVyblxuICB0aGlzLnByb2dyZXNzRW5hYmxlZCA9IGZhbHNlXG4gIHRoaXMudHJhY2tlci5yZW1vdmVMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5zaG93UHJvZ3Jlc3MpXG4gIHRoaXMuZ2F1Z2UuZGlzYWJsZSgpXG59XG5cbnZhciB0cmFja2VyQ29uc3RydWN0b3JzID0gWyduZXdHcm91cCcsICduZXdJdGVtJywgJ25ld1N0cmVhbSddXG5cbnZhciBtaXhpbkxvZyA9IGZ1bmN0aW9uICh0cmFja2VyKSB7XG4gIC8vIG1peGluIHRoZSBwdWJsaWMgbWV0aG9kcyBmcm9tIGxvZyBpbnRvIHRoZSB0cmFja2VyXG4gIC8vIChleGNlcHQ6IGNvbmZsaWN0cyBhbmQgb25lJ3Mgd2UgaGFuZGxlIHNwZWNpYWxseSlcbiAgT2JqZWN0LmtleXMobG9nKS5mb3JFYWNoKGZ1bmN0aW9uIChQKSB7XG4gICAgaWYgKFBbMF0gPT09ICdfJykgcmV0dXJuXG4gICAgaWYgKHRyYWNrZXJDb25zdHJ1Y3RvcnMuZmlsdGVyKGZ1bmN0aW9uIChDKSB7IHJldHVybiBDID09PSBQIH0pLmxlbmd0aCkgcmV0dXJuXG4gICAgaWYgKHRyYWNrZXJbUF0pIHJldHVyblxuICAgIGlmICh0eXBlb2YgbG9nW1BdICE9PSAnZnVuY3Rpb24nKSByZXR1cm5cbiAgICB2YXIgZnVuYyA9IGxvZ1tQXVxuICAgIHRyYWNrZXJbUF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShsb2csIGFyZ3VtZW50cylcbiAgICB9XG4gIH0pXG4gIC8vIGlmIHRoZSBuZXcgdHJhY2tlciBpcyBhIGdyb3VwLCBtYWtlIHN1cmUgYW55IHN1YnRyYWNrZXJzIGdldFxuICAvLyBtaXhlZCBpbiB0b29cbiAgaWYgKHRyYWNrZXIgaW5zdGFuY2VvZiBQcm9ncmVzcy5UcmFja2VyR3JvdXApIHtcbiAgICB0cmFja2VyQ29uc3RydWN0b3JzLmZvckVhY2goZnVuY3Rpb24gKEMpIHtcbiAgICAgIHZhciBmdW5jID0gdHJhY2tlcltDXVxuICAgICAgdHJhY2tlcltDXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1peGluTG9nKGZ1bmMuYXBwbHkodHJhY2tlciwgYXJndW1lbnRzKSkgfVxuICAgIH0pXG4gIH1cbiAgcmV0dXJuIHRyYWNrZXJcbn1cblxuLy8gQWRkIHRyYWNrZXIgY29uc3RydWN0b3JzIHRvIHRoZSB0b3AgbGV2ZWwgbG9nIG9iamVjdFxudHJhY2tlckNvbnN0cnVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChDKSB7XG4gIGxvZ1tDXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1peGluTG9nKHRoaXMudHJhY2tlcltDXS5hcHBseSh0aGlzLnRyYWNrZXIsIGFyZ3VtZW50cykpIH1cbn0pXG5cbmxvZy5jbGVhclByb2dyZXNzID0gZnVuY3Rpb24gKGNiKSB7XG4gIGlmICghdGhpcy5wcm9ncmVzc0VuYWJsZWQpIHJldHVybiBjYiAmJiBwcm9jZXNzLm5leHRUaWNrKGNiKVxuICB0aGlzLmdhdWdlLmhpZGUoY2IpXG59XG5cbmxvZy5zaG93UHJvZ3Jlc3MgPSBmdW5jdGlvbiAobmFtZSwgY29tcGxldGVkKSB7XG4gIGlmICghdGhpcy5wcm9ncmVzc0VuYWJsZWQpIHJldHVyblxuICB2YXIgdmFsdWVzID0ge31cbiAgaWYgKG5hbWUpIHZhbHVlcy5zZWN0aW9uID0gbmFtZVxuICB2YXIgbGFzdCA9IGxvZy5yZWNvcmRbbG9nLnJlY29yZC5sZW5ndGggLSAxXVxuICBpZiAobGFzdCkge1xuICAgIHZhbHVlcy5zdWJzZWN0aW9uID0gbGFzdC5wcmVmaXhcbiAgICB2YXIgZGlzcCA9IGxvZy5kaXNwW2xhc3QubGV2ZWxdIHx8IGxhc3QubGV2ZWxcbiAgICB2YXIgbG9nbGluZSA9IHRoaXMuX2Zvcm1hdChkaXNwLCBsb2cuc3R5bGVbbGFzdC5sZXZlbF0pXG4gICAgaWYgKGxhc3QucHJlZml4KSBsb2dsaW5lICs9ICcgJyArIHRoaXMuX2Zvcm1hdChsYXN0LnByZWZpeCwgdGhpcy5wcmVmaXhTdHlsZSlcbiAgICBsb2dsaW5lICs9ICcgJyArIGxhc3QubWVzc2FnZS5zcGxpdCgvXFxyP1xcbi8pWzBdXG4gICAgdmFsdWVzLmxvZ2xpbmUgPSBsb2dsaW5lXG4gIH1cbiAgdmFsdWVzLmNvbXBsZXRlZCA9IGNvbXBsZXRlZCB8fCB0aGlzLnRyYWNrZXIuY29tcGxldGVkKClcbiAgdGhpcy5nYXVnZS5zaG93KHZhbHVlcylcbn0uYmluZChsb2cpIC8vIGJpbmQgZm9yIHVzZSBpbiB0cmFja2VyJ3Mgb24tY2hhbmdlIGxpc3RlbmVyXG5cbi8vIHRlbXBvcmFyaWx5IHN0b3AgZW1pdHRpbmcsIGJ1dCBkb24ndCBkcm9wXG5sb2cucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX3BhdXNlZCA9IHRydWVcbiAgaWYgKHRoaXMucHJvZ3Jlc3NFbmFibGVkKSB0aGlzLmdhdWdlLmRpc2FibGUoKVxufVxuXG5sb2cucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuX3BhdXNlZCkgcmV0dXJuXG4gIHRoaXMuX3BhdXNlZCA9IGZhbHNlXG5cbiAgdmFyIGIgPSB0aGlzLl9idWZmZXJcbiAgdGhpcy5fYnVmZmVyID0gW11cbiAgYi5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgdGhpcy5lbWl0TG9nKG0pXG4gIH0sIHRoaXMpXG4gIGlmICh0aGlzLnByb2dyZXNzRW5hYmxlZCkgdGhpcy5nYXVnZS5lbmFibGUoKVxufVxuXG5sb2cuX2J1ZmZlciA9IFtdXG5cbnZhciBpZCA9IDBcbmxvZy5yZWNvcmQgPSBbXVxubG9nLm1heFJlY29yZFNpemUgPSAxMDAwMFxubG9nLmxvZyA9IGZ1bmN0aW9uIChsdmwsIHByZWZpeCwgbWVzc2FnZSkge1xuICB2YXIgbCA9IHRoaXMubGV2ZWxzW2x2bF1cbiAgaWYgKGwgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKHV0aWwuZm9ybWF0KFxuICAgICAgJ1VuZGVmaW5lZCBsb2cgbGV2ZWw6ICVqJywgbHZsKSkpXG4gIH1cblxuICB2YXIgYSA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMilcbiAgdmFyIHN0YWNrID0gbnVsbFxuICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBhcmcgPSBhW2kgLSAyXSA9IGFyZ3VtZW50c1tpXVxuXG4gICAgLy8gcmVzb2x2ZSBzdGFjayB0cmFjZXMgdG8gYSBwbGFpbiBzdHJpbmcuXG4gICAgaWYgKHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAmJlxuICAgICAgICAoYXJnIGluc3RhbmNlb2YgRXJyb3IpICYmIGFyZy5zdGFjaykge1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJnLCAnc3RhY2snLCB7XG4gICAgICAgIHZhbHVlOiBzdGFjayA9IGFyZy5zdGFjayArICcnLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSlcbiAgICB9XG4gIH1cbiAgaWYgKHN0YWNrKSBhLnVuc2hpZnQoc3RhY2sgKyAnXFxuJylcbiAgbWVzc2FnZSA9IHV0aWwuZm9ybWF0LmFwcGx5KHV0aWwsIGEpXG5cbiAgdmFyIG0gPSB7IGlkOiBpZCsrLFxuICAgICAgICAgICAgbGV2ZWw6IGx2bCxcbiAgICAgICAgICAgIHByZWZpeDogU3RyaW5nKHByZWZpeCB8fCAnJyksXG4gICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgbWVzc2FnZVJhdzogYSB9XG5cbiAgdGhpcy5lbWl0KCdsb2cnLCBtKVxuICB0aGlzLmVtaXQoJ2xvZy4nICsgbHZsLCBtKVxuICBpZiAobS5wcmVmaXgpIHRoaXMuZW1pdChtLnByZWZpeCwgbSlcblxuICB0aGlzLnJlY29yZC5wdXNoKG0pXG4gIHZhciBtcnMgPSB0aGlzLm1heFJlY29yZFNpemVcbiAgdmFyIG4gPSB0aGlzLnJlY29yZC5sZW5ndGggLSBtcnNcbiAgaWYgKG4gPiBtcnMgLyAxMCkge1xuICAgIHZhciBuZXdTaXplID0gTWF0aC5mbG9vcihtcnMgKiAwLjkpXG4gICAgdGhpcy5yZWNvcmQgPSB0aGlzLnJlY29yZC5zbGljZSgtMSAqIG5ld1NpemUpXG4gIH1cblxuICB0aGlzLmVtaXRMb2cobSlcbn0uYmluZChsb2cpXG5cbmxvZy5lbWl0TG9nID0gZnVuY3Rpb24gKG0pIHtcbiAgaWYgKHRoaXMuX3BhdXNlZCkge1xuICAgIHRoaXMuX2J1ZmZlci5wdXNoKG0pXG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHRoaXMucHJvZ3Jlc3NFbmFibGVkKSB0aGlzLmdhdWdlLnB1bHNlKG0ucHJlZml4KVxuICB2YXIgbCA9IHRoaXMubGV2ZWxzW20ubGV2ZWxdXG4gIGlmIChsID09PSB1bmRlZmluZWQpIHJldHVyblxuICBpZiAobCA8IHRoaXMubGV2ZWxzW3RoaXMubGV2ZWxdKSByZXR1cm5cbiAgaWYgKGwgPiAwICYmICFpc0Zpbml0ZShsKSkgcmV0dXJuXG5cbiAgLy8gSWYgJ2Rpc3AnIGlzIG51bGwgb3IgdW5kZWZpbmVkLCB1c2UgdGhlIGx2bCBhcyBhIGRlZmF1bHRcbiAgLy8gQWxsb3dzOiAnJywgMCBhcyB2YWxpZCBkaXNwXG4gIHZhciBkaXNwID0gbG9nLmRpc3BbbS5sZXZlbF0gIT0gbnVsbCA/IGxvZy5kaXNwW20ubGV2ZWxdIDogbS5sZXZlbFxuICB0aGlzLmNsZWFyUHJvZ3Jlc3MoKVxuICBtLm1lc3NhZ2Uuc3BsaXQoL1xccj9cXG4vKS5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgaWYgKHRoaXMuaGVhZGluZykge1xuICAgICAgdGhpcy53cml0ZSh0aGlzLmhlYWRpbmcsIHRoaXMuaGVhZGluZ1N0eWxlKVxuICAgICAgdGhpcy53cml0ZSgnICcpXG4gICAgfVxuICAgIHRoaXMud3JpdGUoZGlzcCwgbG9nLnN0eWxlW20ubGV2ZWxdKVxuICAgIHZhciBwID0gbS5wcmVmaXggfHwgJydcbiAgICBpZiAocCkgdGhpcy53cml0ZSgnICcpXG4gICAgdGhpcy53cml0ZShwLCB0aGlzLnByZWZpeFN0eWxlKVxuICAgIHRoaXMud3JpdGUoJyAnICsgbGluZSArICdcXG4nKVxuICB9LCB0aGlzKVxuICB0aGlzLnNob3dQcm9ncmVzcygpXG59XG5cbmxvZy5fZm9ybWF0ID0gZnVuY3Rpb24gKG1zZywgc3R5bGUpIHtcbiAgaWYgKCFzdHJlYW0pIHJldHVyblxuXG4gIHZhciBvdXRwdXQgPSAnJ1xuICBpZiAodGhpcy51c2VDb2xvcigpKSB7XG4gICAgc3R5bGUgPSBzdHlsZSB8fCB7fVxuICAgIHZhciBzZXR0aW5ncyA9IFtdXG4gICAgaWYgKHN0eWxlLmZnKSBzZXR0aW5ncy5wdXNoKHN0eWxlLmZnKVxuICAgIGlmIChzdHlsZS5iZykgc2V0dGluZ3MucHVzaCgnYmcnICsgc3R5bGUuYmdbMF0udG9VcHBlckNhc2UoKSArIHN0eWxlLmJnLnNsaWNlKDEpKVxuICAgIGlmIChzdHlsZS5ib2xkKSBzZXR0aW5ncy5wdXNoKCdib2xkJylcbiAgICBpZiAoc3R5bGUudW5kZXJsaW5lKSBzZXR0aW5ncy5wdXNoKCd1bmRlcmxpbmUnKVxuICAgIGlmIChzdHlsZS5pbnZlcnNlKSBzZXR0aW5ncy5wdXNoKCdpbnZlcnNlJylcbiAgICBpZiAoc2V0dGluZ3MubGVuZ3RoKSBvdXRwdXQgKz0gY29uc29sZUNvbnRyb2wuY29sb3Ioc2V0dGluZ3MpXG4gICAgaWYgKHN0eWxlLmJlZXApIG91dHB1dCArPSBjb25zb2xlQ29udHJvbC5iZWVwKClcbiAgfVxuICBvdXRwdXQgKz0gbXNnXG4gIGlmICh0aGlzLnVzZUNvbG9yKCkpIHtcbiAgICBvdXRwdXQgKz0gY29uc29sZUNvbnRyb2wuY29sb3IoJ3Jlc2V0JylcbiAgfVxuICByZXR1cm4gb3V0cHV0XG59XG5cbmxvZy53cml0ZSA9IGZ1bmN0aW9uIChtc2csIHN0eWxlKSB7XG4gIGlmICghc3RyZWFtKSByZXR1cm5cblxuICBzdHJlYW0ud3JpdGUodGhpcy5fZm9ybWF0KG1zZywgc3R5bGUpKVxufVxuXG5sb2cuYWRkTGV2ZWwgPSBmdW5jdGlvbiAobHZsLCBuLCBzdHlsZSwgZGlzcCkge1xuICAvLyBJZiAnZGlzcCcgaXMgbnVsbCBvciB1bmRlZmluZWQsIHVzZSB0aGUgbHZsIGFzIGEgZGVmYXVsdFxuICBpZiAoZGlzcCA9PSBudWxsKSBkaXNwID0gbHZsXG4gIHRoaXMubGV2ZWxzW2x2bF0gPSBuXG4gIHRoaXMuc3R5bGVbbHZsXSA9IHN0eWxlXG4gIGlmICghdGhpc1tsdmxdKSB7XG4gICAgdGhpc1tsdmxdID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGEgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCArIDEpXG4gICAgICBhWzBdID0gbHZsXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhW2kgKyAxXSA9IGFyZ3VtZW50c1tpXVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubG9nLmFwcGx5KHRoaXMsIGEpXG4gICAgfS5iaW5kKHRoaXMpXG4gIH1cbiAgdGhpcy5kaXNwW2x2bF0gPSBkaXNwXG59XG5cbmxvZy5wcmVmaXhTdHlsZSA9IHsgZmc6ICdtYWdlbnRhJyB9XG5sb2cuaGVhZGluZ1N0eWxlID0geyBmZzogJ3doaXRlJywgYmc6ICdibGFjaycgfVxuXG5sb2cuc3R5bGUgPSB7fVxubG9nLmxldmVscyA9IHt9XG5sb2cuZGlzcCA9IHt9XG5sb2cuYWRkTGV2ZWwoJ3NpbGx5JywgLUluZmluaXR5LCB7IGludmVyc2U6IHRydWUgfSwgJ3NpbGwnKVxubG9nLmFkZExldmVsKCd2ZXJib3NlJywgMTAwMCwgeyBmZzogJ2JsdWUnLCBiZzogJ2JsYWNrJyB9LCAndmVyYicpXG5sb2cuYWRkTGV2ZWwoJ2luZm8nLCAyMDAwLCB7IGZnOiAnZ3JlZW4nIH0pXG5sb2cuYWRkTGV2ZWwoJ3RpbWluZycsIDI1MDAsIHsgZmc6ICdncmVlbicsIGJnOiAnYmxhY2snIH0pXG5sb2cuYWRkTGV2ZWwoJ2h0dHAnLCAzMDAwLCB7IGZnOiAnZ3JlZW4nLCBiZzogJ2JsYWNrJyB9KVxubG9nLmFkZExldmVsKCdub3RpY2UnLCAzNTAwLCB7IGZnOiAnYmx1ZScsIGJnOiAnYmxhY2snIH0pXG5sb2cuYWRkTGV2ZWwoJ3dhcm4nLCA0MDAwLCB7IGZnOiAnYmxhY2snLCBiZzogJ3llbGxvdycgfSwgJ1dBUk4nKVxubG9nLmFkZExldmVsKCdlcnJvcicsIDUwMDAsIHsgZmc6ICdyZWQnLCBiZzogJ2JsYWNrJyB9LCAnRVJSIScpXG5sb2cuYWRkTGV2ZWwoJ3NpbGVudCcsIEluZmluaXR5KVxuXG4vLyBhbGxvdyAnZXJyb3InIHByZWZpeFxubG9nLm9uKCdlcnJvcicsIGZ1bmN0aW9uICgpIHt9KVxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIG9zID0gcmVxdWlyZSgnb3MnKTtcblxuZnVuY3Rpb24gaG9tZWRpcigpIHtcblx0dmFyIGVudiA9IHByb2Nlc3MuZW52O1xuXHR2YXIgaG9tZSA9IGVudi5IT01FO1xuXHR2YXIgdXNlciA9IGVudi5MT0dOQU1FIHx8IGVudi5VU0VSIHx8IGVudi5MTkFNRSB8fCBlbnYuVVNFUk5BTUU7XG5cblx0aWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcblx0XHRyZXR1cm4gZW52LlVTRVJQUk9GSUxFIHx8IGVudi5IT01FRFJJVkUgKyBlbnYuSE9NRVBBVEggfHwgaG9tZSB8fCBudWxsO1xuXHR9XG5cblx0aWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nKSB7XG5cdFx0cmV0dXJuIGhvbWUgfHwgKHVzZXIgPyAnL1VzZXJzLycgKyB1c2VyIDogbnVsbCk7XG5cdH1cblxuXHRpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2xpbnV4Jykge1xuXHRcdHJldHVybiBob21lIHx8IChwcm9jZXNzLmdldHVpZCgpID09PSAwID8gJy9yb290JyA6ICh1c2VyID8gJy9ob21lLycgKyB1c2VyIDogbnVsbCkpO1xuXHR9XG5cblx0cmV0dXJuIGhvbWUgfHwgbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygb3MuaG9tZWRpciA9PT0gJ2Z1bmN0aW9uJyA/IG9zLmhvbWVkaXIgOiBob21lZGlyO1xuIiwidmFyIGlzV2luZG93cyA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMidcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG52YXIgZXhlYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjXG52YXIgb3NUbXBkaXIgPSByZXF1aXJlKCdvcy10bXBkaXInKVxudmFyIG9zSG9tZWRpciA9IHJlcXVpcmUoJ29zLWhvbWVkaXInKVxuXG4vLyBsb29raW5nIHVwIGVudnMgaXMgYSBiaXQgY29zdGx5LlxuLy8gQWxzbywgc29tZXRpbWVzIHdlIHdhbnQgdG8gaGF2ZSBhIGZhbGxiYWNrXG4vLyBQYXNzIGluIGEgY2FsbGJhY2sgdG8gd2FpdCBmb3IgdGhlIGZhbGxiYWNrIG9uIGZhaWx1cmVzXG4vLyBBZnRlciB0aGUgZmlyc3QgbG9va3VwLCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSB0aGluZy5cbmZ1bmN0aW9uIG1lbW8gKGtleSwgbG9va3VwLCBmYWxsYmFjaykge1xuICB2YXIgZmVsbCA9IGZhbHNlXG4gIHZhciBmYWxsaW5nID0gZmFsc2VcbiAgZXhwb3J0c1trZXldID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgdmFyIHZhbCA9IGxvb2t1cCgpXG4gICAgaWYgKCF2YWwgJiYgIWZlbGwgJiYgIWZhbGxpbmcgJiYgZmFsbGJhY2spIHtcbiAgICAgIGZlbGwgPSB0cnVlXG4gICAgICBmYWxsaW5nID0gdHJ1ZVxuICAgICAgZXhlYyhmYWxsYmFjaywgZnVuY3Rpb24gKGVyLCBvdXRwdXQsIHN0ZGVycikge1xuICAgICAgICBmYWxsaW5nID0gZmFsc2VcbiAgICAgICAgaWYgKGVyKSByZXR1cm4gLy8gb2ggd2VsbCwgd2UgdHJpZWRcbiAgICAgICAgdmFsID0gb3V0cHV0LnRyaW0oKVxuICAgICAgfSlcbiAgICB9XG4gICAgZXhwb3J0c1trZXldID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICBpZiAoY2IpIHByb2Nlc3MubmV4dFRpY2soY2IuYmluZChudWxsLCBudWxsLCB2YWwpKVxuICAgICAgcmV0dXJuIHZhbFxuICAgIH1cbiAgICBpZiAoY2IgJiYgIWZhbGxpbmcpIHByb2Nlc3MubmV4dFRpY2soY2IuYmluZChudWxsLCBudWxsLCB2YWwpKVxuICAgIHJldHVybiB2YWxcbiAgfVxufVxuXG5tZW1vKCd1c2VyJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKCBpc1dpbmRvd3NcbiAgICAgICAgID8gcHJvY2Vzcy5lbnYuVVNFUkRPTUFJTiArICdcXFxcJyArIHByb2Nlc3MuZW52LlVTRVJOQU1FXG4gICAgICAgICA6IHByb2Nlc3MuZW52LlVTRVJcbiAgICAgICAgIClcbn0sICd3aG9hbWknKVxuXG5tZW1vKCdwcm9tcHQnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBpc1dpbmRvd3MgPyBwcm9jZXNzLmVudi5QUk9NUFQgOiBwcm9jZXNzLmVudi5QUzFcbn0pXG5cbm1lbW8oJ2hvc3RuYW1lJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaXNXaW5kb3dzID8gcHJvY2Vzcy5lbnYuQ09NUFVURVJOQU1FIDogcHJvY2Vzcy5lbnYuSE9TVE5BTUVcbn0sICdob3N0bmFtZScpXG5cbm1lbW8oJ3RtcGRpcicsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG9zVG1wZGlyKClcbn0pXG5cbm1lbW8oJ2hvbWUnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBvc0hvbWVkaXIoKVxufSlcblxubWVtbygncGF0aCcsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIChwcm9jZXNzLmVudi5QQVRIIHx8XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuUGF0aCB8fFxuICAgICAgICAgIHByb2Nlc3MuZW52LnBhdGgpLnNwbGl0KGlzV2luZG93cyA/ICc7JyA6ICc6Jylcbn0pXG5cbm1lbW8oJ2VkaXRvcicsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52LkVESVRPUiB8fFxuICAgICAgICAgcHJvY2Vzcy5lbnYuVklTVUFMIHx8XG4gICAgICAgICAoaXNXaW5kb3dzID8gJ25vdGVwYWQuZXhlJyA6ICd2aScpXG59KVxuXG5tZW1vKCdzaGVsbCcsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGlzV2luZG93cyA/IHByb2Nlc3MuZW52LkNvbVNwZWMgfHwgJ2NtZCdcbiAgICAgICAgIDogcHJvY2Vzcy5lbnYuU0hFTEwgfHwgJ2Jhc2gnXG59KVxuIiwidmFyIGNjICAgPSByZXF1aXJlKCcuL2xpYi91dGlscycpXG52YXIgam9pbiA9IHJlcXVpcmUoJ3BhdGgnKS5qb2luXG52YXIgZGVlcEV4dGVuZCA9IHJlcXVpcmUoJ2RlZXAtZXh0ZW5kJylcbnZhciBldGMgPSAnL2V0YydcbnZhciB3aW4gPSBwcm9jZXNzLnBsYXRmb3JtID09PSBcIndpbjMyXCJcbnZhciBob21lID0gd2luXG4gICAgICAgICAgID8gcHJvY2Vzcy5lbnYuVVNFUlBST0ZJTEVcbiAgICAgICAgICAgOiBwcm9jZXNzLmVudi5IT01FXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUsIGRlZmF1bHRzLCBhcmd2LCBwYXJzZSkge1xuICBpZignc3RyaW5nJyAhPT0gdHlwZW9mIG5hbWUpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdyYyhuYW1lKTogbmFtZSAqbXVzdCogYmUgc3RyaW5nJylcbiAgaWYoIWFyZ3YpXG4gICAgYXJndiA9IHJlcXVpcmUoJ21pbmltaXN0JykocHJvY2Vzcy5hcmd2LnNsaWNlKDIpKVxuICBkZWZhdWx0cyA9IChcbiAgICAgICdzdHJpbmcnID09PSB0eXBlb2YgZGVmYXVsdHNcbiAgICA/IGNjLmpzb24oZGVmYXVsdHMpIDogZGVmYXVsdHNcbiAgICApIHx8IHt9XG5cbiAgcGFyc2UgPSBwYXJzZSB8fCBjYy5wYXJzZVxuXG4gIHZhciBlbnYgPSBjYy5lbnYobmFtZSArICdfJylcblxuICB2YXIgY29uZmlncyA9IFtkZWZhdWx0c11cbiAgdmFyIGNvbmZpZ0ZpbGVzID0gW11cbiAgZnVuY3Rpb24gYWRkQ29uZmlnRmlsZSAoZmlsZSkge1xuICAgIGlmIChjb25maWdGaWxlcy5pbmRleE9mKGZpbGUpID49IDApIHJldHVyblxuICAgIHZhciBmaWxlQ29uZmlnID0gY2MuZmlsZShmaWxlKVxuICAgIGlmIChmaWxlQ29uZmlnKSB7XG4gICAgICBjb25maWdzLnB1c2gocGFyc2UoZmlsZUNvbmZpZykpXG4gICAgICBjb25maWdGaWxlcy5wdXNoKGZpbGUpXG4gICAgfVxuICB9XG5cbiAgLy8gd2hpY2ggZmlsZXMgZG8gd2UgbG9vayBhdD9cbiAgaWYgKCF3aW4pXG4gICBbam9pbihldGMsIG5hbWUsICdjb25maWcnKSxcbiAgICBqb2luKGV0YywgbmFtZSArICdyYycpXS5mb3JFYWNoKGFkZENvbmZpZ0ZpbGUpXG4gIGlmIChob21lKVxuICAgW2pvaW4oaG9tZSwgJy5jb25maWcnLCBuYW1lLCAnY29uZmlnJyksXG4gICAgam9pbihob21lLCAnLmNvbmZpZycsIG5hbWUpLFxuICAgIGpvaW4oaG9tZSwgJy4nICsgbmFtZSwgJ2NvbmZpZycpLFxuICAgIGpvaW4oaG9tZSwgJy4nICsgbmFtZSArICdyYycpXS5mb3JFYWNoKGFkZENvbmZpZ0ZpbGUpXG4gIGFkZENvbmZpZ0ZpbGUoY2MuZmluZCgnLicrbmFtZSsncmMnKSlcbiAgaWYgKGVudi5jb25maWcpIGFkZENvbmZpZ0ZpbGUoZW52LmNvbmZpZylcbiAgaWYgKGFyZ3YuY29uZmlnKSBhZGRDb25maWdGaWxlKGFyZ3YuY29uZmlnKVxuXG4gIHJldHVybiBkZWVwRXh0ZW5kLmFwcGx5KG51bGwsIGNvbmZpZ3MuY29uY2F0KFtcbiAgICBlbnYsXG4gICAgYXJndixcbiAgICBjb25maWdGaWxlcy5sZW5ndGggPyB7Y29uZmlnczogY29uZmlnRmlsZXMsIGNvbmZpZzogY29uZmlnRmlsZXNbY29uZmlnRmlsZXMubGVuZ3RoIC0gMV19IDogdW5kZWZpbmVkLFxuICBdKSlcbn1cbiIsIid1c2Ugc3RyaWN0JztcbnZhciBmcyAgID0gcmVxdWlyZSgnZnMnKVxudmFyIGluaSAgPSByZXF1aXJlKCdpbmknKVxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJylcbnZhciBzdHJpcEpzb25Db21tZW50cyA9IHJlcXVpcmUoJ3N0cmlwLWpzb24tY29tbWVudHMnKVxuXG52YXIgcGFyc2UgPSBleHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcblxuICAvL2lmIGl0IGVuZHMgaW4gLmpzb24gb3Igc3RhcnRzIHdpdGggeyB0aGVuIGl0IG11c3QgYmUganNvbi5cbiAgLy9tdXN0IGJlIGRvbmUgdGhpcyB3YXksIGJlY2F1c2UgaW5pIGFjY2VwdHMgZXZlcnl0aGluZy5cbiAgLy9jYW4ndCBqdXN0IHRyeSBhbmQgcGFyc2UgaXQgYW5kIGxldCBpdCB0aHJvdyBpZiBpdCdzIG5vdCBpbmkuXG4gIC8vZXZlcnl0aGluZyBpcyBpbmkuIGV2ZW4ganNvbiB3aXRoIGEgc3ludGF4IGVycm9yLlxuXG4gIGlmKC9eXFxzKnsvLnRlc3QoY29udGVudCkpXG4gICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyaXBKc29uQ29tbWVudHMoY29udGVudCkpXG4gIHJldHVybiBpbmkucGFyc2UoY29udGVudClcblxufVxuXG52YXIgZmlsZSA9IGV4cG9ydHMuZmlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykuZmlsdGVyKGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIGFyZyAhPSBudWxsIH0pXG5cbiAgLy9wYXRoLmpvaW4gYnJlYWtzIGlmIGl0J3MgYSBub3QgYSBzdHJpbmcsIHNvIGp1c3Qgc2tpcCB0aGlzLlxuICBmb3IodmFyIGkgaW4gYXJncylcbiAgICBpZignc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbaV0pXG4gICAgICByZXR1cm5cblxuICB2YXIgZmlsZSA9IHBhdGguam9pbi5hcHBseShudWxsLCBhcmdzKVxuICB2YXIgY29udGVudFxuICB0cnkge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoZmlsZSwndXRmLTgnKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm5cbiAgfVxufVxuXG52YXIganNvbiA9IGV4cG9ydHMuanNvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNvbnRlbnQgPSBmaWxlLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgcmV0dXJuIGNvbnRlbnQgPyBwYXJzZShjb250ZW50KSA6IG51bGxcbn1cblxudmFyIGVudiA9IGV4cG9ydHMuZW52ID0gZnVuY3Rpb24gKHByZWZpeCwgZW52KSB7XG4gIGVudiA9IGVudiB8fCBwcm9jZXNzLmVudlxuICB2YXIgb2JqID0ge31cbiAgdmFyIGwgPSBwcmVmaXgubGVuZ3RoXG4gIGZvcih2YXIgayBpbiBlbnYpIHtcbiAgICBpZihrLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihwcmVmaXgudG9Mb3dlckNhc2UoKSkgPT09IDApIHtcblxuICAgICAgdmFyIGtleXBhdGggPSBrLnN1YnN0cmluZyhsKS5zcGxpdCgnX18nKVxuXG4gICAgICAvLyBUcmltIGVtcHR5IHN0cmluZ3MgZnJvbSBrZXlwYXRoIGFycmF5XG4gICAgICB2YXIgX2VtcHR5U3RyaW5nSW5kZXhcbiAgICAgIHdoaWxlICgoX2VtcHR5U3RyaW5nSW5kZXg9a2V5cGF0aC5pbmRleE9mKCcnKSkgPiAtMSkge1xuICAgICAgICBrZXlwYXRoLnNwbGljZShfZW1wdHlTdHJpbmdJbmRleCwgMSlcbiAgICAgIH1cblxuICAgICAgdmFyIGN1cnNvciA9IG9ialxuICAgICAga2V5cGF0aC5mb3JFYWNoKGZ1bmN0aW9uIF9idWlsZFN1Yk9iaihfc3Via2V5LGkpe1xuXG4gICAgICAgIC8vIChjaGVjayBmb3IgX3N1YmtleSBmaXJzdCBzbyB3ZSBpZ25vcmUgZW1wdHkgc3RyaW5ncylcbiAgICAgICAgLy8gKGNoZWNrIGZvciBjdXJzb3IgdG8gYXZvaWQgYXNzaWdubWVudCB0byBwcmltaXRpdmUgb2JqZWN0cylcbiAgICAgICAgaWYgKCFfc3Via2V5IHx8IHR5cGVvZiBjdXJzb3IgIT09ICdvYmplY3QnKVxuICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGxhc3Qga2V5LCBqdXN0IHN0dWZmIHRoZSB2YWx1ZSBpbiB0aGVyZVxuICAgICAgICAvLyBBc3NpZ25zIGFjdHVhbCB2YWx1ZSBmcm9tIGVudiB2YXJpYWJsZSB0byBmaW5hbCBrZXlcbiAgICAgICAgLy8gKHVubGVzcyBpdCdzIGp1c3QgYW4gZW1wdHkgc3RyaW5nLSBpbiB0aGF0IGNhc2UgdXNlIHRoZSBsYXN0IHZhbGlkIGtleSlcbiAgICAgICAgaWYgKGkgPT09IGtleXBhdGgubGVuZ3RoLTEpXG4gICAgICAgICAgY3Vyc29yW19zdWJrZXldID0gZW52W2tdXG5cblxuICAgICAgICAvLyBCdWlsZCBzdWItb2JqZWN0IGlmIG5vdGhpbmcgYWxyZWFkeSBleGlzdHMgYXQgdGhlIGtleXBhdGhcbiAgICAgICAgaWYgKGN1cnNvcltfc3Via2V5XSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgIGN1cnNvcltfc3Via2V5XSA9IHt9XG5cbiAgICAgICAgLy8gSW5jcmVtZW50IGN1cnNvciB1c2VkIHRvIHRyYWNrIHRoZSBvYmplY3QgYXQgdGhlIGN1cnJlbnQgZGVwdGhcbiAgICAgICAgY3Vyc29yID0gY3Vyc29yW19zdWJrZXldXG5cbiAgICAgIH0pXG5cbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBvYmpcbn1cblxudmFyIGZpbmQgPSBleHBvcnRzLmZpbmQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByZWwgPSBwYXRoLmpvaW4uYXBwbHkobnVsbCwgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuXG4gIGZ1bmN0aW9uIGZpbmQoc3RhcnQsIHJlbCkge1xuICAgIHZhciBmaWxlID0gcGF0aC5qb2luKHN0YXJ0LCByZWwpXG4gICAgdHJ5IHtcbiAgICAgIGZzLnN0YXRTeW5jKGZpbGUpXG4gICAgICByZXR1cm4gZmlsZVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYocGF0aC5kaXJuYW1lKHN0YXJ0KSAhPT0gc3RhcnQpIC8vIHJvb3RcbiAgICAgICAgcmV0dXJuIGZpbmQocGF0aC5kaXJuYW1lKHN0YXJ0KSwgcmVsKVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmluZChwcm9jZXNzLmN3ZCgpLCByZWwpXG59XG5cblxuIiwiOyhmdW5jdGlvbiAoc2F4KSB7IC8vIHdyYXBwZXIgZm9yIG5vbi1ub2RlIGVudnNcbiAgc2F4LnBhcnNlciA9IGZ1bmN0aW9uIChzdHJpY3QsIG9wdCkgeyByZXR1cm4gbmV3IFNBWFBhcnNlcihzdHJpY3QsIG9wdCkgfVxuICBzYXguU0FYUGFyc2VyID0gU0FYUGFyc2VyXG4gIHNheC5TQVhTdHJlYW0gPSBTQVhTdHJlYW1cbiAgc2F4LmNyZWF0ZVN0cmVhbSA9IGNyZWF0ZVN0cmVhbVxuXG4gIC8vIFdoZW4gd2UgcGFzcyB0aGUgTUFYX0JVRkZFUl9MRU5HVEggcG9zaXRpb24sIHN0YXJ0IGNoZWNraW5nIGZvciBidWZmZXIgb3ZlcnJ1bnMuXG4gIC8vIFdoZW4gd2UgY2hlY2ssIHNjaGVkdWxlIHRoZSBuZXh0IGNoZWNrIGZvciBNQVhfQlVGRkVSX0xFTkdUSCAtIChtYXgoYnVmZmVyIGxlbmd0aHMpKSxcbiAgLy8gc2luY2UgdGhhdCdzIHRoZSBlYXJsaWVzdCB0aGF0IGEgYnVmZmVyIG92ZXJydW4gY291bGQgb2NjdXIuICBUaGlzIHdheSwgY2hlY2tzIGFyZVxuICAvLyBhcyByYXJlIGFzIHJlcXVpcmVkLCBidXQgYXMgb2Z0ZW4gYXMgbmVjZXNzYXJ5IHRvIGVuc3VyZSBuZXZlciBjcm9zc2luZyB0aGlzIGJvdW5kLlxuICAvLyBGdXJ0aGVybW9yZSwgYnVmZmVycyBhcmUgb25seSB0ZXN0ZWQgYXQgbW9zdCBvbmNlIHBlciB3cml0ZSgpLCBzbyBwYXNzaW5nIGEgdmVyeVxuICAvLyBsYXJnZSBzdHJpbmcgaW50byB3cml0ZSgpIG1pZ2h0IGhhdmUgdW5kZXNpcmFibGUgZWZmZWN0cywgYnV0IHRoaXMgaXMgbWFuYWdlYWJsZSBieVxuICAvLyB0aGUgY2FsbGVyLCBzbyBpdCBpcyBhc3N1bWVkIHRvIGJlIHNhZmUuICBUaHVzLCBhIGNhbGwgdG8gd3JpdGUoKSBtYXksIGluIHRoZSBleHRyZW1lXG4gIC8vIGVkZ2UgY2FzZSwgcmVzdWx0IGluIGNyZWF0aW5nIGF0IG1vc3Qgb25lIGNvbXBsZXRlIGNvcHkgb2YgdGhlIHN0cmluZyBwYXNzZWQgaW4uXG4gIC8vIFNldCB0byBJbmZpbml0eSB0byBoYXZlIHVubGltaXRlZCBidWZmZXJzLlxuICBzYXguTUFYX0JVRkZFUl9MRU5HVEggPSA2NCAqIDEwMjRcblxuICB2YXIgYnVmZmVycyA9IFtcbiAgICAnY29tbWVudCcsICdzZ21sRGVjbCcsICd0ZXh0Tm9kZScsICd0YWdOYW1lJywgJ2RvY3R5cGUnLFxuICAgICdwcm9jSW5zdE5hbWUnLCAncHJvY0luc3RCb2R5JywgJ2VudGl0eScsICdhdHRyaWJOYW1lJyxcbiAgICAnYXR0cmliVmFsdWUnLCAnY2RhdGEnLCAnc2NyaXB0J1xuICBdXG5cbiAgc2F4LkVWRU5UUyA9IFtcbiAgICAndGV4dCcsXG4gICAgJ3Byb2Nlc3NpbmdpbnN0cnVjdGlvbicsXG4gICAgJ3NnbWxkZWNsYXJhdGlvbicsXG4gICAgJ2RvY3R5cGUnLFxuICAgICdjb21tZW50JyxcbiAgICAnb3BlbnRhZ3N0YXJ0JyxcbiAgICAnYXR0cmlidXRlJyxcbiAgICAnb3BlbnRhZycsXG4gICAgJ2Nsb3NldGFnJyxcbiAgICAnb3BlbmNkYXRhJyxcbiAgICAnY2RhdGEnLFxuICAgICdjbG9zZWNkYXRhJyxcbiAgICAnZXJyb3InLFxuICAgICdlbmQnLFxuICAgICdyZWFkeScsXG4gICAgJ3NjcmlwdCcsXG4gICAgJ29wZW5uYW1lc3BhY2UnLFxuICAgICdjbG9zZW5hbWVzcGFjZSdcbiAgXVxuXG4gIGZ1bmN0aW9uIFNBWFBhcnNlciAoc3RyaWN0LCBvcHQpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0FYUGFyc2VyKSkge1xuICAgICAgcmV0dXJuIG5ldyBTQVhQYXJzZXIoc3RyaWN0LCBvcHQpXG4gICAgfVxuXG4gICAgdmFyIHBhcnNlciA9IHRoaXNcbiAgICBjbGVhckJ1ZmZlcnMocGFyc2VyKVxuICAgIHBhcnNlci5xID0gcGFyc2VyLmMgPSAnJ1xuICAgIHBhcnNlci5idWZmZXJDaGVja1Bvc2l0aW9uID0gc2F4Lk1BWF9CVUZGRVJfTEVOR1RIXG4gICAgcGFyc2VyLm9wdCA9IG9wdCB8fCB7fVxuICAgIHBhcnNlci5vcHQubG93ZXJjYXNlID0gcGFyc2VyLm9wdC5sb3dlcmNhc2UgfHwgcGFyc2VyLm9wdC5sb3dlcmNhc2V0YWdzXG4gICAgcGFyc2VyLmxvb3NlQ2FzZSA9IHBhcnNlci5vcHQubG93ZXJjYXNlID8gJ3RvTG93ZXJDYXNlJyA6ICd0b1VwcGVyQ2FzZSdcbiAgICBwYXJzZXIudGFncyA9IFtdXG4gICAgcGFyc2VyLmNsb3NlZCA9IHBhcnNlci5jbG9zZWRSb290ID0gcGFyc2VyLnNhd1Jvb3QgPSBmYWxzZVxuICAgIHBhcnNlci50YWcgPSBwYXJzZXIuZXJyb3IgPSBudWxsXG4gICAgcGFyc2VyLnN0cmljdCA9ICEhc3RyaWN0XG4gICAgcGFyc2VyLm5vc2NyaXB0ID0gISEoc3RyaWN0IHx8IHBhcnNlci5vcHQubm9zY3JpcHQpXG4gICAgcGFyc2VyLnN0YXRlID0gUy5CRUdJTlxuICAgIHBhcnNlci5zdHJpY3RFbnRpdGllcyA9IHBhcnNlci5vcHQuc3RyaWN0RW50aXRpZXNcbiAgICBwYXJzZXIuRU5USVRJRVMgPSBwYXJzZXIuc3RyaWN0RW50aXRpZXMgPyBPYmplY3QuY3JlYXRlKHNheC5YTUxfRU5USVRJRVMpIDogT2JqZWN0LmNyZWF0ZShzYXguRU5USVRJRVMpXG4gICAgcGFyc2VyLmF0dHJpYkxpc3QgPSBbXVxuXG4gICAgLy8gbmFtZXNwYWNlcyBmb3JtIGEgcHJvdG90eXBlIGNoYWluLlxuICAgIC8vIGl0IGFsd2F5cyBwb2ludHMgYXQgdGhlIGN1cnJlbnQgdGFnLFxuICAgIC8vIHdoaWNoIHByb3RvcyB0byBpdHMgcGFyZW50IHRhZy5cbiAgICBpZiAocGFyc2VyLm9wdC54bWxucykge1xuICAgICAgcGFyc2VyLm5zID0gT2JqZWN0LmNyZWF0ZShyb290TlMpXG4gICAgfVxuXG4gICAgLy8gbW9zdGx5IGp1c3QgZm9yIGVycm9yIHJlcG9ydGluZ1xuICAgIHBhcnNlci50cmFja1Bvc2l0aW9uID0gcGFyc2VyLm9wdC5wb3NpdGlvbiAhPT0gZmFsc2VcbiAgICBpZiAocGFyc2VyLnRyYWNrUG9zaXRpb24pIHtcbiAgICAgIHBhcnNlci5wb3NpdGlvbiA9IHBhcnNlci5saW5lID0gcGFyc2VyLmNvbHVtbiA9IDBcbiAgICB9XG4gICAgZW1pdChwYXJzZXIsICdvbnJlYWR5JylcbiAgfVxuXG4gIGlmICghT2JqZWN0LmNyZWF0ZSkge1xuICAgIE9iamVjdC5jcmVhdGUgPSBmdW5jdGlvbiAobykge1xuICAgICAgZnVuY3Rpb24gRiAoKSB7fVxuICAgICAgRi5wcm90b3R5cGUgPSBvXG4gICAgICB2YXIgbmV3ZiA9IG5ldyBGKClcbiAgICAgIHJldHVybiBuZXdmXG4gICAgfVxuICB9XG5cbiAgaWYgKCFPYmplY3Qua2V5cykge1xuICAgIE9iamVjdC5rZXlzID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBhID0gW11cbiAgICAgIGZvciAodmFyIGkgaW4gbykgaWYgKG8uaGFzT3duUHJvcGVydHkoaSkpIGEucHVzaChpKVxuICAgICAgcmV0dXJuIGFcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0J1ZmZlckxlbmd0aCAocGFyc2VyKSB7XG4gICAgdmFyIG1heEFsbG93ZWQgPSBNYXRoLm1heChzYXguTUFYX0JVRkZFUl9MRU5HVEgsIDEwKVxuICAgIHZhciBtYXhBY3R1YWwgPSAwXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBidWZmZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGxlbiA9IHBhcnNlcltidWZmZXJzW2ldXS5sZW5ndGhcbiAgICAgIGlmIChsZW4gPiBtYXhBbGxvd2VkKSB7XG4gICAgICAgIC8vIFRleHQvY2RhdGEgbm9kZXMgY2FuIGdldCBiaWcsIGFuZCBzaW5jZSB0aGV5J3JlIGJ1ZmZlcmVkLFxuICAgICAgICAvLyB3ZSBjYW4gZ2V0IGhlcmUgdW5kZXIgbm9ybWFsIGNvbmRpdGlvbnMuXG4gICAgICAgIC8vIEF2b2lkIGlzc3VlcyBieSBlbWl0dGluZyB0aGUgdGV4dCBub2RlIG5vdyxcbiAgICAgICAgLy8gc28gYXQgbGVhc3QgaXQgd29uJ3QgZ2V0IGFueSBiaWdnZXIuXG4gICAgICAgIHN3aXRjaCAoYnVmZmVyc1tpXSkge1xuICAgICAgICAgIGNhc2UgJ3RleHROb2RlJzpcbiAgICAgICAgICAgIGNsb3NlVGV4dChwYXJzZXIpXG4gICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgY2FzZSAnY2RhdGEnOlxuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jZGF0YScsIHBhcnNlci5jZGF0YSlcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSA9ICcnXG4gICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgY2FzZSAnc2NyaXB0JzpcbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uc2NyaXB0JywgcGFyc2VyLnNjcmlwdClcbiAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgPSAnJ1xuICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBlcnJvcihwYXJzZXIsICdNYXggYnVmZmVyIGxlbmd0aCBleGNlZWRlZDogJyArIGJ1ZmZlcnNbaV0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1heEFjdHVhbCA9IE1hdGgubWF4KG1heEFjdHVhbCwgbGVuKVxuICAgIH1cbiAgICAvLyBzY2hlZHVsZSB0aGUgbmV4dCBjaGVjayBmb3IgdGhlIGVhcmxpZXN0IHBvc3NpYmxlIGJ1ZmZlciBvdmVycnVuLlxuICAgIHZhciBtID0gc2F4Lk1BWF9CVUZGRVJfTEVOR1RIIC0gbWF4QWN0dWFsXG4gICAgcGFyc2VyLmJ1ZmZlckNoZWNrUG9zaXRpb24gPSBtICsgcGFyc2VyLnBvc2l0aW9uXG4gIH1cblxuICBmdW5jdGlvbiBjbGVhckJ1ZmZlcnMgKHBhcnNlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYnVmZmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHBhcnNlcltidWZmZXJzW2ldXSA9ICcnXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2hCdWZmZXJzIChwYXJzZXIpIHtcbiAgICBjbG9zZVRleHQocGFyc2VyKVxuICAgIGlmIChwYXJzZXIuY2RhdGEgIT09ICcnKSB7XG4gICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmNkYXRhJywgcGFyc2VyLmNkYXRhKVxuICAgICAgcGFyc2VyLmNkYXRhID0gJydcbiAgICB9XG4gICAgaWYgKHBhcnNlci5zY3JpcHQgIT09ICcnKSB7XG4gICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbnNjcmlwdCcsIHBhcnNlci5zY3JpcHQpXG4gICAgICBwYXJzZXIuc2NyaXB0ID0gJydcbiAgICB9XG4gIH1cblxuICBTQVhQYXJzZXIucHJvdG90eXBlID0ge1xuICAgIGVuZDogZnVuY3Rpb24gKCkgeyBlbmQodGhpcykgfSxcbiAgICB3cml0ZTogd3JpdGUsXG4gICAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7IHRoaXMuZXJyb3IgPSBudWxsOyByZXR1cm4gdGhpcyB9LFxuICAgIGNsb3NlOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLndyaXRlKG51bGwpIH0sXG4gICAgZmx1c2g6IGZ1bmN0aW9uICgpIHsgZmx1c2hCdWZmZXJzKHRoaXMpIH1cbiAgfVxuXG4gIHZhciBTdHJlYW1cbiAgdHJ5IHtcbiAgICBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKS5TdHJlYW1cbiAgfSBjYXRjaCAoZXgpIHtcbiAgICBTdHJlYW0gPSBmdW5jdGlvbiAoKSB7fVxuICB9XG5cbiAgdmFyIHN0cmVhbVdyYXBzID0gc2F4LkVWRU5UUy5maWx0ZXIoZnVuY3Rpb24gKGV2KSB7XG4gICAgcmV0dXJuIGV2ICE9PSAnZXJyb3InICYmIGV2ICE9PSAnZW5kJ1xuICB9KVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmVhbSAoc3RyaWN0LCBvcHQpIHtcbiAgICByZXR1cm4gbmV3IFNBWFN0cmVhbShzdHJpY3QsIG9wdClcbiAgfVxuXG4gIGZ1bmN0aW9uIFNBWFN0cmVhbSAoc3RyaWN0LCBvcHQpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0FYU3RyZWFtKSkge1xuICAgICAgcmV0dXJuIG5ldyBTQVhTdHJlYW0oc3RyaWN0LCBvcHQpXG4gICAgfVxuXG4gICAgU3RyZWFtLmFwcGx5KHRoaXMpXG5cbiAgICB0aGlzLl9wYXJzZXIgPSBuZXcgU0FYUGFyc2VyKHN0cmljdCwgb3B0KVxuICAgIHRoaXMud3JpdGFibGUgPSB0cnVlXG4gICAgdGhpcy5yZWFkYWJsZSA9IHRydWVcblxuICAgIHZhciBtZSA9IHRoaXNcblxuICAgIHRoaXMuX3BhcnNlci5vbmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG1lLmVtaXQoJ2VuZCcpXG4gICAgfVxuXG4gICAgdGhpcy5fcGFyc2VyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICAgIG1lLmVtaXQoJ2Vycm9yJywgZXIpXG5cbiAgICAgIC8vIGlmIGRpZG4ndCB0aHJvdywgdGhlbiBtZWFucyBlcnJvciB3YXMgaGFuZGxlZC5cbiAgICAgIC8vIGdvIGFoZWFkIGFuZCBjbGVhciBlcnJvciwgc28gd2UgY2FuIHdyaXRlIGFnYWluLlxuICAgICAgbWUuX3BhcnNlci5lcnJvciA9IG51bGxcbiAgICB9XG5cbiAgICB0aGlzLl9kZWNvZGVyID0gbnVsbFxuXG4gICAgc3RyZWFtV3JhcHMuZm9yRWFjaChmdW5jdGlvbiAoZXYpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZSwgJ29uJyArIGV2LCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBtZS5fcGFyc2VyWydvbicgKyBldl1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoaCkge1xuICAgICAgICAgIGlmICghaCkge1xuICAgICAgICAgICAgbWUucmVtb3ZlQWxsTGlzdGVuZXJzKGV2KVxuICAgICAgICAgICAgbWUuX3BhcnNlclsnb24nICsgZXZdID0gaFxuICAgICAgICAgICAgcmV0dXJuIGhcbiAgICAgICAgICB9XG4gICAgICAgICAgbWUub24oZXYsIGgpXG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIFNBWFN0cmVhbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN0cmVhbS5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IFNBWFN0cmVhbVxuICAgIH1cbiAgfSlcblxuICBTQVhTdHJlYW0ucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgdHlwZW9mIEJ1ZmZlci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICBpZiAoIXRoaXMuX2RlY29kZXIpIHtcbiAgICAgICAgdmFyIFNEID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXInKS5TdHJpbmdEZWNvZGVyXG4gICAgICAgIHRoaXMuX2RlY29kZXIgPSBuZXcgU0QoJ3V0ZjgnKVxuICAgICAgfVxuICAgICAgZGF0YSA9IHRoaXMuX2RlY29kZXIud3JpdGUoZGF0YSlcbiAgICB9XG5cbiAgICB0aGlzLl9wYXJzZXIud3JpdGUoZGF0YS50b1N0cmluZygpKVxuICAgIHRoaXMuZW1pdCgnZGF0YScsIGRhdGEpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIFNBWFN0cmVhbS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgdGhpcy53cml0ZShjaHVuaylcbiAgICB9XG4gICAgdGhpcy5fcGFyc2VyLmVuZCgpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIFNBWFN0cmVhbS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGhhbmRsZXIpIHtcbiAgICB2YXIgbWUgPSB0aGlzXG4gICAgaWYgKCFtZS5fcGFyc2VyWydvbicgKyBldl0gJiYgc3RyZWFtV3JhcHMuaW5kZXhPZihldikgIT09IC0xKSB7XG4gICAgICBtZS5fcGFyc2VyWydvbicgKyBldl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IFthcmd1bWVudHNbMF1dIDogQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgICAgICBhcmdzLnNwbGljZSgwLCAwLCBldilcbiAgICAgICAgbWUuZW1pdC5hcHBseShtZSwgYXJncylcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKG1lLCBldiwgaGFuZGxlcilcbiAgfVxuXG4gIC8vIHRoaXMgcmVhbGx5IG5lZWRzIHRvIGJlIHJlcGxhY2VkIHdpdGggY2hhcmFjdGVyIGNsYXNzZXMuXG4gIC8vIFhNTCBhbGxvd3MgYWxsIG1hbm5lciBvZiByaWRpY3Vsb3VzIG51bWJlcnMgYW5kIGRpZ2l0cy5cbiAgdmFyIENEQVRBID0gJ1tDREFUQVsnXG4gIHZhciBET0NUWVBFID0gJ0RPQ1RZUEUnXG4gIHZhciBYTUxfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZSdcbiAgdmFyIFhNTE5TX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zLydcbiAgdmFyIHJvb3ROUyA9IHsgeG1sOiBYTUxfTkFNRVNQQUNFLCB4bWxuczogWE1MTlNfTkFNRVNQQUNFIH1cblxuICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9SRUMteG1sLyNOVC1OYW1lU3RhcnRDaGFyXG4gIC8vIFRoaXMgaW1wbGVtZW50YXRpb24gd29ya3Mgb24gc3RyaW5ncywgYSBzaW5nbGUgY2hhcmFjdGVyIGF0IGEgdGltZVxuICAvLyBhcyBzdWNoLCBpdCBjYW5ub3QgZXZlciBzdXBwb3J0IGFzdHJhbC1wbGFuZSBjaGFyYWN0ZXJzICgxMDAwMC1FRkZGRilcbiAgLy8gd2l0aG91dCBhIHNpZ25pZmljYW50IGJyZWFraW5nIGNoYW5nZSB0byBlaXRoZXIgdGhpcyAgcGFyc2VyLCBvciB0aGVcbiAgLy8gSmF2YVNjcmlwdCBsYW5ndWFnZS4gIEltcGxlbWVudGF0aW9uIG9mIGFuIGVtb2ppLWNhcGFibGUgeG1sIHBhcnNlclxuICAvLyBpcyBsZWZ0IGFzIGFuIGV4ZXJjaXNlIGZvciB0aGUgcmVhZGVyLlxuICB2YXIgbmFtZVN0YXJ0ID0gL1s6X0EtWmEtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRF0vXG5cbiAgdmFyIG5hbWVCb2R5ID0gL1s6X0EtWmEtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRFxcdTAwQjdcXHUwMzAwLVxcdTAzNkZcXHUyMDNGLVxcdTIwNDAuXFxkLV0vXG5cbiAgdmFyIGVudGl0eVN0YXJ0ID0gL1sjOl9BLVphLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRdL1xuICB2YXIgZW50aXR5Qm9keSA9IC9bIzpfQS1aYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXFx1MDBCN1xcdTAzMDAtXFx1MDM2RlxcdTIwM0YtXFx1MjA0MC5cXGQtXS9cblxuICBmdW5jdGlvbiBpc1doaXRlc3BhY2UgKGMpIHtcbiAgICByZXR1cm4gYyA9PT0gJyAnIHx8IGMgPT09ICdcXG4nIHx8IGMgPT09ICdcXHInIHx8IGMgPT09ICdcXHQnXG4gIH1cblxuICBmdW5jdGlvbiBpc1F1b3RlIChjKSB7XG4gICAgcmV0dXJuIGMgPT09ICdcIicgfHwgYyA9PT0gJ1xcJydcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQXR0cmliRW5kIChjKSB7XG4gICAgcmV0dXJuIGMgPT09ICc+JyB8fCBpc1doaXRlc3BhY2UoYylcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTWF0Y2ggKHJlZ2V4LCBjKSB7XG4gICAgcmV0dXJuIHJlZ2V4LnRlc3QoYylcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdE1hdGNoIChyZWdleCwgYykge1xuICAgIHJldHVybiAhaXNNYXRjaChyZWdleCwgYylcbiAgfVxuXG4gIHZhciBTID0gMFxuICBzYXguU1RBVEUgPSB7XG4gICAgQkVHSU46IFMrKywgLy8gbGVhZGluZyBieXRlIG9yZGVyIG1hcmsgb3Igd2hpdGVzcGFjZVxuICAgIEJFR0lOX1dISVRFU1BBQ0U6IFMrKywgLy8gbGVhZGluZyB3aGl0ZXNwYWNlXG4gICAgVEVYVDogUysrLCAvLyBnZW5lcmFsIHN0dWZmXG4gICAgVEVYVF9FTlRJVFk6IFMrKywgLy8gJmFtcCBhbmQgc3VjaC5cbiAgICBPUEVOX1dBS0E6IFMrKywgLy8gPFxuICAgIFNHTUxfREVDTDogUysrLCAvLyA8IUJMQVJHXG4gICAgU0dNTF9ERUNMX1FVT1RFRDogUysrLCAvLyA8IUJMQVJHIGZvbyBcImJhclxuICAgIERPQ1RZUEU6IFMrKywgLy8gPCFET0NUWVBFXG4gICAgRE9DVFlQRV9RVU9URUQ6IFMrKywgLy8gPCFET0NUWVBFIFwiLy9ibGFoXG4gICAgRE9DVFlQRV9EVEQ6IFMrKywgLy8gPCFET0NUWVBFIFwiLy9ibGFoXCIgWyAuLi5cbiAgICBET0NUWVBFX0RURF9RVU9URUQ6IFMrKywgLy8gPCFET0NUWVBFIFwiLy9ibGFoXCIgWyBcImZvb1xuICAgIENPTU1FTlRfU1RBUlRJTkc6IFMrKywgLy8gPCEtXG4gICAgQ09NTUVOVDogUysrLCAvLyA8IS0tXG4gICAgQ09NTUVOVF9FTkRJTkc6IFMrKywgLy8gPCEtLSBibGFoIC1cbiAgICBDT01NRU5UX0VOREVEOiBTKyssIC8vIDwhLS0gYmxhaCAtLVxuICAgIENEQVRBOiBTKyssIC8vIDwhW0NEQVRBWyBzb21ldGhpbmdcbiAgICBDREFUQV9FTkRJTkc6IFMrKywgLy8gXVxuICAgIENEQVRBX0VORElOR18yOiBTKyssIC8vIF1dXG4gICAgUFJPQ19JTlNUOiBTKyssIC8vIDw/aGlcbiAgICBQUk9DX0lOU1RfQk9EWTogUysrLCAvLyA8P2hpIHRoZXJlXG4gICAgUFJPQ19JTlNUX0VORElORzogUysrLCAvLyA8P2hpIFwidGhlcmVcIiA/XG4gICAgT1BFTl9UQUc6IFMrKywgLy8gPHN0cm9uZ1xuICAgIE9QRU5fVEFHX1NMQVNIOiBTKyssIC8vIDxzdHJvbmcgL1xuICAgIEFUVFJJQjogUysrLCAvLyA8YVxuICAgIEFUVFJJQl9OQU1FOiBTKyssIC8vIDxhIGZvb1xuICAgIEFUVFJJQl9OQU1FX1NBV19XSElURTogUysrLCAvLyA8YSBmb28gX1xuICAgIEFUVFJJQl9WQUxVRTogUysrLCAvLyA8YSBmb289XG4gICAgQVRUUklCX1ZBTFVFX1FVT1RFRDogUysrLCAvLyA8YSBmb289XCJiYXJcbiAgICBBVFRSSUJfVkFMVUVfQ0xPU0VEOiBTKyssIC8vIDxhIGZvbz1cImJhclwiXG4gICAgQVRUUklCX1ZBTFVFX1VOUVVPVEVEOiBTKyssIC8vIDxhIGZvbz1iYXJcbiAgICBBVFRSSUJfVkFMVUVfRU5USVRZX1E6IFMrKywgLy8gPGZvbyBiYXI9XCImcXVvdDtcIlxuICAgIEFUVFJJQl9WQUxVRV9FTlRJVFlfVTogUysrLCAvLyA8Zm9vIGJhcj0mcXVvdFxuICAgIENMT1NFX1RBRzogUysrLCAvLyA8L2FcbiAgICBDTE9TRV9UQUdfU0FXX1dISVRFOiBTKyssIC8vIDwvYSAgID5cbiAgICBTQ1JJUFQ6IFMrKywgLy8gPHNjcmlwdD4gLi4uXG4gICAgU0NSSVBUX0VORElORzogUysrIC8vIDxzY3JpcHQ+IC4uLiA8XG4gIH1cblxuICBzYXguWE1MX0VOVElUSUVTID0ge1xuICAgICdhbXAnOiAnJicsXG4gICAgJ2d0JzogJz4nLFxuICAgICdsdCc6ICc8JyxcbiAgICAncXVvdCc6ICdcIicsXG4gICAgJ2Fwb3MnOiBcIidcIlxuICB9XG5cbiAgc2F4LkVOVElUSUVTID0ge1xuICAgICdhbXAnOiAnJicsXG4gICAgJ2d0JzogJz4nLFxuICAgICdsdCc6ICc8JyxcbiAgICAncXVvdCc6ICdcIicsXG4gICAgJ2Fwb3MnOiBcIidcIixcbiAgICAnQUVsaWcnOiAxOTgsXG4gICAgJ0FhY3V0ZSc6IDE5MyxcbiAgICAnQWNpcmMnOiAxOTQsXG4gICAgJ0FncmF2ZSc6IDE5MixcbiAgICAnQXJpbmcnOiAxOTcsXG4gICAgJ0F0aWxkZSc6IDE5NSxcbiAgICAnQXVtbCc6IDE5NixcbiAgICAnQ2NlZGlsJzogMTk5LFxuICAgICdFVEgnOiAyMDgsXG4gICAgJ0VhY3V0ZSc6IDIwMSxcbiAgICAnRWNpcmMnOiAyMDIsXG4gICAgJ0VncmF2ZSc6IDIwMCxcbiAgICAnRXVtbCc6IDIwMyxcbiAgICAnSWFjdXRlJzogMjA1LFxuICAgICdJY2lyYyc6IDIwNixcbiAgICAnSWdyYXZlJzogMjA0LFxuICAgICdJdW1sJzogMjA3LFxuICAgICdOdGlsZGUnOiAyMDksXG4gICAgJ09hY3V0ZSc6IDIxMSxcbiAgICAnT2NpcmMnOiAyMTIsXG4gICAgJ09ncmF2ZSc6IDIxMCxcbiAgICAnT3NsYXNoJzogMjE2LFxuICAgICdPdGlsZGUnOiAyMTMsXG4gICAgJ091bWwnOiAyMTQsXG4gICAgJ1RIT1JOJzogMjIyLFxuICAgICdVYWN1dGUnOiAyMTgsXG4gICAgJ1VjaXJjJzogMjE5LFxuICAgICdVZ3JhdmUnOiAyMTcsXG4gICAgJ1V1bWwnOiAyMjAsXG4gICAgJ1lhY3V0ZSc6IDIyMSxcbiAgICAnYWFjdXRlJzogMjI1LFxuICAgICdhY2lyYyc6IDIyNixcbiAgICAnYWVsaWcnOiAyMzAsXG4gICAgJ2FncmF2ZSc6IDIyNCxcbiAgICAnYXJpbmcnOiAyMjksXG4gICAgJ2F0aWxkZSc6IDIyNyxcbiAgICAnYXVtbCc6IDIyOCxcbiAgICAnY2NlZGlsJzogMjMxLFxuICAgICdlYWN1dGUnOiAyMzMsXG4gICAgJ2VjaXJjJzogMjM0LFxuICAgICdlZ3JhdmUnOiAyMzIsXG4gICAgJ2V0aCc6IDI0MCxcbiAgICAnZXVtbCc6IDIzNSxcbiAgICAnaWFjdXRlJzogMjM3LFxuICAgICdpY2lyYyc6IDIzOCxcbiAgICAnaWdyYXZlJzogMjM2LFxuICAgICdpdW1sJzogMjM5LFxuICAgICdudGlsZGUnOiAyNDEsXG4gICAgJ29hY3V0ZSc6IDI0MyxcbiAgICAnb2NpcmMnOiAyNDQsXG4gICAgJ29ncmF2ZSc6IDI0MixcbiAgICAnb3NsYXNoJzogMjQ4LFxuICAgICdvdGlsZGUnOiAyNDUsXG4gICAgJ291bWwnOiAyNDYsXG4gICAgJ3N6bGlnJzogMjIzLFxuICAgICd0aG9ybic6IDI1NCxcbiAgICAndWFjdXRlJzogMjUwLFxuICAgICd1Y2lyYyc6IDI1MSxcbiAgICAndWdyYXZlJzogMjQ5LFxuICAgICd1dW1sJzogMjUyLFxuICAgICd5YWN1dGUnOiAyNTMsXG4gICAgJ3l1bWwnOiAyNTUsXG4gICAgJ2NvcHknOiAxNjksXG4gICAgJ3JlZyc6IDE3NCxcbiAgICAnbmJzcCc6IDE2MCxcbiAgICAnaWV4Y2wnOiAxNjEsXG4gICAgJ2NlbnQnOiAxNjIsXG4gICAgJ3BvdW5kJzogMTYzLFxuICAgICdjdXJyZW4nOiAxNjQsXG4gICAgJ3llbic6IDE2NSxcbiAgICAnYnJ2YmFyJzogMTY2LFxuICAgICdzZWN0JzogMTY3LFxuICAgICd1bWwnOiAxNjgsXG4gICAgJ29yZGYnOiAxNzAsXG4gICAgJ2xhcXVvJzogMTcxLFxuICAgICdub3QnOiAxNzIsXG4gICAgJ3NoeSc6IDE3MyxcbiAgICAnbWFjcic6IDE3NSxcbiAgICAnZGVnJzogMTc2LFxuICAgICdwbHVzbW4nOiAxNzcsXG4gICAgJ3N1cDEnOiAxODUsXG4gICAgJ3N1cDInOiAxNzgsXG4gICAgJ3N1cDMnOiAxNzksXG4gICAgJ2FjdXRlJzogMTgwLFxuICAgICdtaWNybyc6IDE4MSxcbiAgICAncGFyYSc6IDE4MixcbiAgICAnbWlkZG90JzogMTgzLFxuICAgICdjZWRpbCc6IDE4NCxcbiAgICAnb3JkbSc6IDE4NixcbiAgICAncmFxdW8nOiAxODcsXG4gICAgJ2ZyYWMxNCc6IDE4OCxcbiAgICAnZnJhYzEyJzogMTg5LFxuICAgICdmcmFjMzQnOiAxOTAsXG4gICAgJ2lxdWVzdCc6IDE5MSxcbiAgICAndGltZXMnOiAyMTUsXG4gICAgJ2RpdmlkZSc6IDI0NyxcbiAgICAnT0VsaWcnOiAzMzgsXG4gICAgJ29lbGlnJzogMzM5LFxuICAgICdTY2Fyb24nOiAzNTIsXG4gICAgJ3NjYXJvbic6IDM1MyxcbiAgICAnWXVtbCc6IDM3NixcbiAgICAnZm5vZic6IDQwMixcbiAgICAnY2lyYyc6IDcxMCxcbiAgICAndGlsZGUnOiA3MzIsXG4gICAgJ0FscGhhJzogOTEzLFxuICAgICdCZXRhJzogOTE0LFxuICAgICdHYW1tYSc6IDkxNSxcbiAgICAnRGVsdGEnOiA5MTYsXG4gICAgJ0Vwc2lsb24nOiA5MTcsXG4gICAgJ1pldGEnOiA5MTgsXG4gICAgJ0V0YSc6IDkxOSxcbiAgICAnVGhldGEnOiA5MjAsXG4gICAgJ0lvdGEnOiA5MjEsXG4gICAgJ0thcHBhJzogOTIyLFxuICAgICdMYW1iZGEnOiA5MjMsXG4gICAgJ011JzogOTI0LFxuICAgICdOdSc6IDkyNSxcbiAgICAnWGknOiA5MjYsXG4gICAgJ09taWNyb24nOiA5MjcsXG4gICAgJ1BpJzogOTI4LFxuICAgICdSaG8nOiA5MjksXG4gICAgJ1NpZ21hJzogOTMxLFxuICAgICdUYXUnOiA5MzIsXG4gICAgJ1Vwc2lsb24nOiA5MzMsXG4gICAgJ1BoaSc6IDkzNCxcbiAgICAnQ2hpJzogOTM1LFxuICAgICdQc2knOiA5MzYsXG4gICAgJ09tZWdhJzogOTM3LFxuICAgICdhbHBoYSc6IDk0NSxcbiAgICAnYmV0YSc6IDk0NixcbiAgICAnZ2FtbWEnOiA5NDcsXG4gICAgJ2RlbHRhJzogOTQ4LFxuICAgICdlcHNpbG9uJzogOTQ5LFxuICAgICd6ZXRhJzogOTUwLFxuICAgICdldGEnOiA5NTEsXG4gICAgJ3RoZXRhJzogOTUyLFxuICAgICdpb3RhJzogOTUzLFxuICAgICdrYXBwYSc6IDk1NCxcbiAgICAnbGFtYmRhJzogOTU1LFxuICAgICdtdSc6IDk1NixcbiAgICAnbnUnOiA5NTcsXG4gICAgJ3hpJzogOTU4LFxuICAgICdvbWljcm9uJzogOTU5LFxuICAgICdwaSc6IDk2MCxcbiAgICAncmhvJzogOTYxLFxuICAgICdzaWdtYWYnOiA5NjIsXG4gICAgJ3NpZ21hJzogOTYzLFxuICAgICd0YXUnOiA5NjQsXG4gICAgJ3Vwc2lsb24nOiA5NjUsXG4gICAgJ3BoaSc6IDk2NixcbiAgICAnY2hpJzogOTY3LFxuICAgICdwc2knOiA5NjgsXG4gICAgJ29tZWdhJzogOTY5LFxuICAgICd0aGV0YXN5bSc6IDk3NyxcbiAgICAndXBzaWgnOiA5NzgsXG4gICAgJ3Bpdic6IDk4MixcbiAgICAnZW5zcCc6IDgxOTQsXG4gICAgJ2Vtc3AnOiA4MTk1LFxuICAgICd0aGluc3AnOiA4MjAxLFxuICAgICd6d25qJzogODIwNCxcbiAgICAnendqJzogODIwNSxcbiAgICAnbHJtJzogODIwNixcbiAgICAncmxtJzogODIwNyxcbiAgICAnbmRhc2gnOiA4MjExLFxuICAgICdtZGFzaCc6IDgyMTIsXG4gICAgJ2xzcXVvJzogODIxNixcbiAgICAncnNxdW8nOiA4MjE3LFxuICAgICdzYnF1byc6IDgyMTgsXG4gICAgJ2xkcXVvJzogODIyMCxcbiAgICAncmRxdW8nOiA4MjIxLFxuICAgICdiZHF1byc6IDgyMjIsXG4gICAgJ2RhZ2dlcic6IDgyMjQsXG4gICAgJ0RhZ2dlcic6IDgyMjUsXG4gICAgJ2J1bGwnOiA4MjI2LFxuICAgICdoZWxsaXAnOiA4MjMwLFxuICAgICdwZXJtaWwnOiA4MjQwLFxuICAgICdwcmltZSc6IDgyNDIsXG4gICAgJ1ByaW1lJzogODI0MyxcbiAgICAnbHNhcXVvJzogODI0OSxcbiAgICAncnNhcXVvJzogODI1MCxcbiAgICAnb2xpbmUnOiA4MjU0LFxuICAgICdmcmFzbCc6IDgyNjAsXG4gICAgJ2V1cm8nOiA4MzY0LFxuICAgICdpbWFnZSc6IDg0NjUsXG4gICAgJ3dlaWVycCc6IDg0NzIsXG4gICAgJ3JlYWwnOiA4NDc2LFxuICAgICd0cmFkZSc6IDg0ODIsXG4gICAgJ2FsZWZzeW0nOiA4NTAxLFxuICAgICdsYXJyJzogODU5MixcbiAgICAndWFycic6IDg1OTMsXG4gICAgJ3JhcnInOiA4NTk0LFxuICAgICdkYXJyJzogODU5NSxcbiAgICAnaGFycic6IDg1OTYsXG4gICAgJ2NyYXJyJzogODYyOSxcbiAgICAnbEFycic6IDg2NTYsXG4gICAgJ3VBcnInOiA4NjU3LFxuICAgICdyQXJyJzogODY1OCxcbiAgICAnZEFycic6IDg2NTksXG4gICAgJ2hBcnInOiA4NjYwLFxuICAgICdmb3JhbGwnOiA4NzA0LFxuICAgICdwYXJ0JzogODcwNixcbiAgICAnZXhpc3QnOiA4NzA3LFxuICAgICdlbXB0eSc6IDg3MDksXG4gICAgJ25hYmxhJzogODcxMSxcbiAgICAnaXNpbic6IDg3MTIsXG4gICAgJ25vdGluJzogODcxMyxcbiAgICAnbmknOiA4NzE1LFxuICAgICdwcm9kJzogODcxOSxcbiAgICAnc3VtJzogODcyMSxcbiAgICAnbWludXMnOiA4NzIyLFxuICAgICdsb3dhc3QnOiA4NzI3LFxuICAgICdyYWRpYyc6IDg3MzAsXG4gICAgJ3Byb3AnOiA4NzMzLFxuICAgICdpbmZpbic6IDg3MzQsXG4gICAgJ2FuZyc6IDg3MzYsXG4gICAgJ2FuZCc6IDg3NDMsXG4gICAgJ29yJzogODc0NCxcbiAgICAnY2FwJzogODc0NSxcbiAgICAnY3VwJzogODc0NixcbiAgICAnaW50JzogODc0NyxcbiAgICAndGhlcmU0JzogODc1NixcbiAgICAnc2ltJzogODc2NCxcbiAgICAnY29uZyc6IDg3NzMsXG4gICAgJ2FzeW1wJzogODc3NixcbiAgICAnbmUnOiA4ODAwLFxuICAgICdlcXVpdic6IDg4MDEsXG4gICAgJ2xlJzogODgwNCxcbiAgICAnZ2UnOiA4ODA1LFxuICAgICdzdWInOiA4ODM0LFxuICAgICdzdXAnOiA4ODM1LFxuICAgICduc3ViJzogODgzNixcbiAgICAnc3ViZSc6IDg4MzgsXG4gICAgJ3N1cGUnOiA4ODM5LFxuICAgICdvcGx1cyc6IDg4NTMsXG4gICAgJ290aW1lcyc6IDg4NTUsXG4gICAgJ3BlcnAnOiA4ODY5LFxuICAgICdzZG90JzogODkwMSxcbiAgICAnbGNlaWwnOiA4OTY4LFxuICAgICdyY2VpbCc6IDg5NjksXG4gICAgJ2xmbG9vcic6IDg5NzAsXG4gICAgJ3JmbG9vcic6IDg5NzEsXG4gICAgJ2xhbmcnOiA5MDAxLFxuICAgICdyYW5nJzogOTAwMixcbiAgICAnbG96JzogOTY3NCxcbiAgICAnc3BhZGVzJzogOTgyNCxcbiAgICAnY2x1YnMnOiA5ODI3LFxuICAgICdoZWFydHMnOiA5ODI5LFxuICAgICdkaWFtcyc6IDk4MzBcbiAgfVxuXG4gIE9iamVjdC5rZXlzKHNheC5FTlRJVElFUykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGUgPSBzYXguRU5USVRJRVNba2V5XVxuICAgIHZhciBzID0gdHlwZW9mIGUgPT09ICdudW1iZXInID8gU3RyaW5nLmZyb21DaGFyQ29kZShlKSA6IGVcbiAgICBzYXguRU5USVRJRVNba2V5XSA9IHNcbiAgfSlcblxuICBmb3IgKHZhciBzIGluIHNheC5TVEFURSkge1xuICAgIHNheC5TVEFURVtzYXguU1RBVEVbc11dID0gc1xuICB9XG5cbiAgLy8gc2hvcnRoYW5kXG4gIFMgPSBzYXguU1RBVEVcblxuICBmdW5jdGlvbiBlbWl0IChwYXJzZXIsIGV2ZW50LCBkYXRhKSB7XG4gICAgcGFyc2VyW2V2ZW50XSAmJiBwYXJzZXJbZXZlbnRdKGRhdGEpXG4gIH1cblxuICBmdW5jdGlvbiBlbWl0Tm9kZSAocGFyc2VyLCBub2RlVHlwZSwgZGF0YSkge1xuICAgIGlmIChwYXJzZXIudGV4dE5vZGUpIGNsb3NlVGV4dChwYXJzZXIpXG4gICAgZW1pdChwYXJzZXIsIG5vZGVUeXBlLCBkYXRhKVxuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2VUZXh0IChwYXJzZXIpIHtcbiAgICBwYXJzZXIudGV4dE5vZGUgPSB0ZXh0b3B0cyhwYXJzZXIub3B0LCBwYXJzZXIudGV4dE5vZGUpXG4gICAgaWYgKHBhcnNlci50ZXh0Tm9kZSkgZW1pdChwYXJzZXIsICdvbnRleHQnLCBwYXJzZXIudGV4dE5vZGUpXG4gICAgcGFyc2VyLnRleHROb2RlID0gJydcbiAgfVxuXG4gIGZ1bmN0aW9uIHRleHRvcHRzIChvcHQsIHRleHQpIHtcbiAgICBpZiAob3B0LnRyaW0pIHRleHQgPSB0ZXh0LnRyaW0oKVxuICAgIGlmIChvcHQubm9ybWFsaXplKSB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHMrL2csICcgJylcbiAgICByZXR1cm4gdGV4dFxuICB9XG5cbiAgZnVuY3Rpb24gZXJyb3IgKHBhcnNlciwgZXIpIHtcbiAgICBjbG9zZVRleHQocGFyc2VyKVxuICAgIGlmIChwYXJzZXIudHJhY2tQb3NpdGlvbikge1xuICAgICAgZXIgKz0gJ1xcbkxpbmU6ICcgKyBwYXJzZXIubGluZSArXG4gICAgICAgICdcXG5Db2x1bW46ICcgKyBwYXJzZXIuY29sdW1uICtcbiAgICAgICAgJ1xcbkNoYXI6ICcgKyBwYXJzZXIuY1xuICAgIH1cbiAgICBlciA9IG5ldyBFcnJvcihlcilcbiAgICBwYXJzZXIuZXJyb3IgPSBlclxuICAgIGVtaXQocGFyc2VyLCAnb25lcnJvcicsIGVyKVxuICAgIHJldHVybiBwYXJzZXJcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZCAocGFyc2VyKSB7XG4gICAgaWYgKHBhcnNlci5zYXdSb290ICYmICFwYXJzZXIuY2xvc2VkUm9vdCkgc3RyaWN0RmFpbChwYXJzZXIsICdVbmNsb3NlZCByb290IHRhZycpXG4gICAgaWYgKChwYXJzZXIuc3RhdGUgIT09IFMuQkVHSU4pICYmXG4gICAgICAocGFyc2VyLnN0YXRlICE9PSBTLkJFR0lOX1dISVRFU1BBQ0UpICYmXG4gICAgICAocGFyc2VyLnN0YXRlICE9PSBTLlRFWFQpKSB7XG4gICAgICBlcnJvcihwYXJzZXIsICdVbmV4cGVjdGVkIGVuZCcpXG4gICAgfVxuICAgIGNsb3NlVGV4dChwYXJzZXIpXG4gICAgcGFyc2VyLmMgPSAnJ1xuICAgIHBhcnNlci5jbG9zZWQgPSB0cnVlXG4gICAgZW1pdChwYXJzZXIsICdvbmVuZCcpXG4gICAgU0FYUGFyc2VyLmNhbGwocGFyc2VyLCBwYXJzZXIuc3RyaWN0LCBwYXJzZXIub3B0KVxuICAgIHJldHVybiBwYXJzZXJcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmljdEZhaWwgKHBhcnNlciwgbWVzc2FnZSkge1xuICAgIGlmICh0eXBlb2YgcGFyc2VyICE9PSAnb2JqZWN0JyB8fCAhKHBhcnNlciBpbnN0YW5jZW9mIFNBWFBhcnNlcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGNhbGwgdG8gc3RyaWN0RmFpbCcpXG4gICAgfVxuICAgIGlmIChwYXJzZXIuc3RyaWN0KSB7XG4gICAgICBlcnJvcihwYXJzZXIsIG1lc3NhZ2UpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbmV3VGFnIChwYXJzZXIpIHtcbiAgICBpZiAoIXBhcnNlci5zdHJpY3QpIHBhcnNlci50YWdOYW1lID0gcGFyc2VyLnRhZ05hbWVbcGFyc2VyLmxvb3NlQ2FzZV0oKVxuICAgIHZhciBwYXJlbnQgPSBwYXJzZXIudGFnc1twYXJzZXIudGFncy5sZW5ndGggLSAxXSB8fCBwYXJzZXJcbiAgICB2YXIgdGFnID0gcGFyc2VyLnRhZyA9IHsgbmFtZTogcGFyc2VyLnRhZ05hbWUsIGF0dHJpYnV0ZXM6IHt9IH1cblxuICAgIC8vIHdpbGwgYmUgb3ZlcnJpZGRlbiBpZiB0YWcgY29udGFpbHMgYW4geG1sbnM9XCJmb29cIiBvciB4bWxuczpmb289XCJiYXJcIlxuICAgIGlmIChwYXJzZXIub3B0LnhtbG5zKSB7XG4gICAgICB0YWcubnMgPSBwYXJlbnQubnNcbiAgICB9XG4gICAgcGFyc2VyLmF0dHJpYkxpc3QubGVuZ3RoID0gMFxuICAgIGVtaXROb2RlKHBhcnNlciwgJ29ub3BlbnRhZ3N0YXJ0JywgdGFnKVxuICB9XG5cbiAgZnVuY3Rpb24gcW5hbWUgKG5hbWUsIGF0dHJpYnV0ZSkge1xuICAgIHZhciBpID0gbmFtZS5pbmRleE9mKCc6JylcbiAgICB2YXIgcXVhbE5hbWUgPSBpIDwgMCA/IFsgJycsIG5hbWUgXSA6IG5hbWUuc3BsaXQoJzonKVxuICAgIHZhciBwcmVmaXggPSBxdWFsTmFtZVswXVxuICAgIHZhciBsb2NhbCA9IHF1YWxOYW1lWzFdXG5cbiAgICAvLyA8eCBcInhtbG5zXCI9XCJodHRwOi8vZm9vXCI+XG4gICAgaWYgKGF0dHJpYnV0ZSAmJiBuYW1lID09PSAneG1sbnMnKSB7XG4gICAgICBwcmVmaXggPSAneG1sbnMnXG4gICAgICBsb2NhbCA9ICcnXG4gICAgfVxuXG4gICAgcmV0dXJuIHsgcHJlZml4OiBwcmVmaXgsIGxvY2FsOiBsb2NhbCB9XG4gIH1cblxuICBmdW5jdGlvbiBhdHRyaWIgKHBhcnNlcikge1xuICAgIGlmICghcGFyc2VyLnN0cmljdCkge1xuICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBwYXJzZXIuYXR0cmliTmFtZVtwYXJzZXIubG9vc2VDYXNlXSgpXG4gICAgfVxuXG4gICAgaWYgKHBhcnNlci5hdHRyaWJMaXN0LmluZGV4T2YocGFyc2VyLmF0dHJpYk5hbWUpICE9PSAtMSB8fFxuICAgICAgcGFyc2VyLnRhZy5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KHBhcnNlci5hdHRyaWJOYW1lKSkge1xuICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBwYXJzZXIuYXR0cmliVmFsdWUgPSAnJ1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHBhcnNlci5vcHQueG1sbnMpIHtcbiAgICAgIHZhciBxbiA9IHFuYW1lKHBhcnNlci5hdHRyaWJOYW1lLCB0cnVlKVxuICAgICAgdmFyIHByZWZpeCA9IHFuLnByZWZpeFxuICAgICAgdmFyIGxvY2FsID0gcW4ubG9jYWxcblxuICAgICAgaWYgKHByZWZpeCA9PT0gJ3htbG5zJykge1xuICAgICAgICAvLyBuYW1lc3BhY2UgYmluZGluZyBhdHRyaWJ1dGUuIHB1c2ggdGhlIGJpbmRpbmcgaW50byBzY29wZVxuICAgICAgICBpZiAobG9jYWwgPT09ICd4bWwnICYmIHBhcnNlci5hdHRyaWJWYWx1ZSAhPT0gWE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLFxuICAgICAgICAgICAgJ3htbDogcHJlZml4IG11c3QgYmUgYm91bmQgdG8gJyArIFhNTF9OQU1FU1BBQ0UgKyAnXFxuJyArXG4gICAgICAgICAgICAnQWN0dWFsOiAnICsgcGFyc2VyLmF0dHJpYlZhbHVlKVxuICAgICAgICB9IGVsc2UgaWYgKGxvY2FsID09PSAneG1sbnMnICYmIHBhcnNlci5hdHRyaWJWYWx1ZSAhPT0gWE1MTlNfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsXG4gICAgICAgICAgICAneG1sbnM6IHByZWZpeCBtdXN0IGJlIGJvdW5kIHRvICcgKyBYTUxOU19OQU1FU1BBQ0UgKyAnXFxuJyArXG4gICAgICAgICAgICAnQWN0dWFsOiAnICsgcGFyc2VyLmF0dHJpYlZhbHVlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0YWcgPSBwYXJzZXIudGFnXG4gICAgICAgICAgdmFyIHBhcmVudCA9IHBhcnNlci50YWdzW3BhcnNlci50YWdzLmxlbmd0aCAtIDFdIHx8IHBhcnNlclxuICAgICAgICAgIGlmICh0YWcubnMgPT09IHBhcmVudC5ucykge1xuICAgICAgICAgICAgdGFnLm5zID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQubnMpXG4gICAgICAgICAgfVxuICAgICAgICAgIHRhZy5uc1tsb2NhbF0gPSBwYXJzZXIuYXR0cmliVmFsdWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBkZWZlciBvbmF0dHJpYnV0ZSBldmVudHMgdW50aWwgYWxsIGF0dHJpYnV0ZXMgaGF2ZSBiZWVuIHNlZW5cbiAgICAgIC8vIHNvIGFueSBuZXcgYmluZGluZ3MgY2FuIHRha2UgZWZmZWN0LiBwcmVzZXJ2ZSBhdHRyaWJ1dGUgb3JkZXJcbiAgICAgIC8vIHNvIGRlZmVycmVkIGV2ZW50cyBjYW4gYmUgZW1pdHRlZCBpbiBkb2N1bWVudCBvcmRlclxuICAgICAgcGFyc2VyLmF0dHJpYkxpc3QucHVzaChbcGFyc2VyLmF0dHJpYk5hbWUsIHBhcnNlci5hdHRyaWJWYWx1ZV0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluIG5vbi14bWxucyBtb2RlLCB3ZSBjYW4gZW1pdCB0aGUgZXZlbnQgcmlnaHQgYXdheVxuICAgICAgcGFyc2VyLnRhZy5hdHRyaWJ1dGVzW3BhcnNlci5hdHRyaWJOYW1lXSA9IHBhcnNlci5hdHRyaWJWYWx1ZVxuICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25hdHRyaWJ1dGUnLCB7XG4gICAgICAgIG5hbWU6IHBhcnNlci5hdHRyaWJOYW1lLFxuICAgICAgICB2YWx1ZTogcGFyc2VyLmF0dHJpYlZhbHVlXG4gICAgICB9KVxuICAgIH1cblxuICAgIHBhcnNlci5hdHRyaWJOYW1lID0gcGFyc2VyLmF0dHJpYlZhbHVlID0gJydcbiAgfVxuXG4gIGZ1bmN0aW9uIG9wZW5UYWcgKHBhcnNlciwgc2VsZkNsb3NpbmcpIHtcbiAgICBpZiAocGFyc2VyLm9wdC54bWxucykge1xuICAgICAgLy8gZW1pdCBuYW1lc3BhY2UgYmluZGluZyBldmVudHNcbiAgICAgIHZhciB0YWcgPSBwYXJzZXIudGFnXG5cbiAgICAgIC8vIGFkZCBuYW1lc3BhY2UgaW5mbyB0byB0YWdcbiAgICAgIHZhciBxbiA9IHFuYW1lKHBhcnNlci50YWdOYW1lKVxuICAgICAgdGFnLnByZWZpeCA9IHFuLnByZWZpeFxuICAgICAgdGFnLmxvY2FsID0gcW4ubG9jYWxcbiAgICAgIHRhZy51cmkgPSB0YWcubnNbcW4ucHJlZml4XSB8fCAnJ1xuXG4gICAgICBpZiAodGFnLnByZWZpeCAmJiAhdGFnLnVyaSkge1xuICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1VuYm91bmQgbmFtZXNwYWNlIHByZWZpeDogJyArXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkocGFyc2VyLnRhZ05hbWUpKVxuICAgICAgICB0YWcudXJpID0gcW4ucHJlZml4XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJlbnQgPSBwYXJzZXIudGFnc1twYXJzZXIudGFncy5sZW5ndGggLSAxXSB8fCBwYXJzZXJcbiAgICAgIGlmICh0YWcubnMgJiYgcGFyZW50Lm5zICE9PSB0YWcubnMpIHtcbiAgICAgICAgT2JqZWN0LmtleXModGFnLm5zKS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25vcGVubmFtZXNwYWNlJywge1xuICAgICAgICAgICAgcHJlZml4OiBwLFxuICAgICAgICAgICAgdXJpOiB0YWcubnNbcF1cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICAvLyBoYW5kbGUgZGVmZXJyZWQgb25hdHRyaWJ1dGUgZXZlbnRzXG4gICAgICAvLyBOb3RlOiBkbyBub3QgYXBwbHkgZGVmYXVsdCBucyB0byBhdHRyaWJ1dGVzOlxuICAgICAgLy8gICBodHRwOi8vd3d3LnczLm9yZy9UUi9SRUMteG1sLW5hbWVzLyNkZWZhdWx0aW5nXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBhcnNlci5hdHRyaWJMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgbnYgPSBwYXJzZXIuYXR0cmliTGlzdFtpXVxuICAgICAgICB2YXIgbmFtZSA9IG52WzBdXG4gICAgICAgIHZhciB2YWx1ZSA9IG52WzFdXG4gICAgICAgIHZhciBxdWFsTmFtZSA9IHFuYW1lKG5hbWUsIHRydWUpXG4gICAgICAgIHZhciBwcmVmaXggPSBxdWFsTmFtZS5wcmVmaXhcbiAgICAgICAgdmFyIGxvY2FsID0gcXVhbE5hbWUubG9jYWxcbiAgICAgICAgdmFyIHVyaSA9IHByZWZpeCA9PT0gJycgPyAnJyA6ICh0YWcubnNbcHJlZml4XSB8fCAnJylcbiAgICAgICAgdmFyIGEgPSB7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgICAgbG9jYWw6IGxvY2FsLFxuICAgICAgICAgIHVyaTogdXJpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGVyZSdzIGFueSBhdHRyaWJ1dGVzIHdpdGggYW4gdW5kZWZpbmVkIG5hbWVzcGFjZSxcbiAgICAgICAgLy8gdGhlbiBmYWlsIG9uIHRoZW0gbm93LlxuICAgICAgICBpZiAocHJlZml4ICYmIHByZWZpeCAhPT0gJ3htbG5zJyAmJiAhdXJpKSB7XG4gICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdVbmJvdW5kIG5hbWVzcGFjZSBwcmVmaXg6ICcgK1xuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkocHJlZml4KSlcbiAgICAgICAgICBhLnVyaSA9IHByZWZpeFxuICAgICAgICB9XG4gICAgICAgIHBhcnNlci50YWcuYXR0cmlidXRlc1tuYW1lXSA9IGFcbiAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25hdHRyaWJ1dGUnLCBhKVxuICAgICAgfVxuICAgICAgcGFyc2VyLmF0dHJpYkxpc3QubGVuZ3RoID0gMFxuICAgIH1cblxuICAgIHBhcnNlci50YWcuaXNTZWxmQ2xvc2luZyA9ICEhc2VsZkNsb3NpbmdcblxuICAgIC8vIHByb2Nlc3MgdGhlIHRhZ1xuICAgIHBhcnNlci5zYXdSb290ID0gdHJ1ZVxuICAgIHBhcnNlci50YWdzLnB1c2gocGFyc2VyLnRhZylcbiAgICBlbWl0Tm9kZShwYXJzZXIsICdvbm9wZW50YWcnLCBwYXJzZXIudGFnKVxuICAgIGlmICghc2VsZkNsb3NpbmcpIHtcbiAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3IgPHNjcmlwdD4gaW4gbm9uLXN0cmljdCBtb2RlLlxuICAgICAgaWYgKCFwYXJzZXIubm9zY3JpcHQgJiYgcGFyc2VyLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3NjcmlwdCcpIHtcbiAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TQ1JJUFRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICAgICAgfVxuICAgICAgcGFyc2VyLnRhZyA9IG51bGxcbiAgICAgIHBhcnNlci50YWdOYW1lID0gJydcbiAgICB9XG4gICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBwYXJzZXIuYXR0cmliVmFsdWUgPSAnJ1xuICAgIHBhcnNlci5hdHRyaWJMaXN0Lmxlbmd0aCA9IDBcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlVGFnIChwYXJzZXIpIHtcbiAgICBpZiAoIXBhcnNlci50YWdOYW1lKSB7XG4gICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1dlaXJkIGVtcHR5IGNsb3NlIHRhZy4nKVxuICAgICAgcGFyc2VyLnRleHROb2RlICs9ICc8Lz4nXG4gICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChwYXJzZXIuc2NyaXB0KSB7XG4gICAgICBpZiAocGFyc2VyLnRhZ05hbWUgIT09ICdzY3JpcHQnKSB7XG4gICAgICAgIHBhcnNlci5zY3JpcHQgKz0gJzwvJyArIHBhcnNlci50YWdOYW1lICsgJz4nXG4gICAgICAgIHBhcnNlci50YWdOYW1lID0gJydcbiAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TQ1JJUFRcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbnNjcmlwdCcsIHBhcnNlci5zY3JpcHQpXG4gICAgICBwYXJzZXIuc2NyaXB0ID0gJydcbiAgICB9XG5cbiAgICAvLyBmaXJzdCBtYWtlIHN1cmUgdGhhdCB0aGUgY2xvc2luZyB0YWcgYWN0dWFsbHkgZXhpc3RzLlxuICAgIC8vIDxhPjxiPjwvYz48L2I+PC9hPiB3aWxsIGNsb3NlIGV2ZXJ5dGhpbmcsIG90aGVyd2lzZS5cbiAgICB2YXIgdCA9IHBhcnNlci50YWdzLmxlbmd0aFxuICAgIHZhciB0YWdOYW1lID0gcGFyc2VyLnRhZ05hbWVcbiAgICBpZiAoIXBhcnNlci5zdHJpY3QpIHtcbiAgICAgIHRhZ05hbWUgPSB0YWdOYW1lW3BhcnNlci5sb29zZUNhc2VdKClcbiAgICB9XG4gICAgdmFyIGNsb3NlVG8gPSB0YWdOYW1lXG4gICAgd2hpbGUgKHQtLSkge1xuICAgICAgdmFyIGNsb3NlID0gcGFyc2VyLnRhZ3NbdF1cbiAgICAgIGlmIChjbG9zZS5uYW1lICE9PSBjbG9zZVRvKSB7XG4gICAgICAgIC8vIGZhaWwgdGhlIGZpcnN0IHRpbWUgaW4gc3RyaWN0IG1vZGVcbiAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdVbmV4cGVjdGVkIGNsb3NlIHRhZycpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRpZG4ndCBmaW5kIGl0LiAgd2UgYWxyZWFkeSBmYWlsZWQgZm9yIHN0cmljdCwgc28ganVzdCBhYm9ydC5cbiAgICBpZiAodCA8IDApIHtcbiAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnVW5tYXRjaGVkIGNsb3NpbmcgdGFnOiAnICsgcGFyc2VyLnRhZ05hbWUpXG4gICAgICBwYXJzZXIudGV4dE5vZGUgKz0gJzwvJyArIHBhcnNlci50YWdOYW1lICsgJz4nXG4gICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBwYXJzZXIudGFnTmFtZSA9IHRhZ05hbWVcbiAgICB2YXIgcyA9IHBhcnNlci50YWdzLmxlbmd0aFxuICAgIHdoaWxlIChzLS0gPiB0KSB7XG4gICAgICB2YXIgdGFnID0gcGFyc2VyLnRhZyA9IHBhcnNlci50YWdzLnBvcCgpXG4gICAgICBwYXJzZXIudGFnTmFtZSA9IHBhcnNlci50YWcubmFtZVxuICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jbG9zZXRhZycsIHBhcnNlci50YWdOYW1lKVxuXG4gICAgICB2YXIgeCA9IHt9XG4gICAgICBmb3IgKHZhciBpIGluIHRhZy5ucykge1xuICAgICAgICB4W2ldID0gdGFnLm5zW2ldXG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJlbnQgPSBwYXJzZXIudGFnc1twYXJzZXIudGFncy5sZW5ndGggLSAxXSB8fCBwYXJzZXJcbiAgICAgIGlmIChwYXJzZXIub3B0LnhtbG5zICYmIHRhZy5ucyAhPT0gcGFyZW50Lm5zKSB7XG4gICAgICAgIC8vIHJlbW92ZSBuYW1lc3BhY2UgYmluZGluZ3MgaW50cm9kdWNlZCBieSB0YWdcbiAgICAgICAgT2JqZWN0LmtleXModGFnLm5zKS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgdmFyIG4gPSB0YWcubnNbcF1cbiAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmNsb3NlbmFtZXNwYWNlJywgeyBwcmVmaXg6IHAsIHVyaTogbiB9KVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodCA9PT0gMCkgcGFyc2VyLmNsb3NlZFJvb3QgPSB0cnVlXG4gICAgcGFyc2VyLnRhZ05hbWUgPSBwYXJzZXIuYXR0cmliVmFsdWUgPSBwYXJzZXIuYXR0cmliTmFtZSA9ICcnXG4gICAgcGFyc2VyLmF0dHJpYkxpc3QubGVuZ3RoID0gMFxuICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFbnRpdHkgKHBhcnNlcikge1xuICAgIHZhciBlbnRpdHkgPSBwYXJzZXIuZW50aXR5XG4gICAgdmFyIGVudGl0eUxDID0gZW50aXR5LnRvTG93ZXJDYXNlKClcbiAgICB2YXIgbnVtXG4gICAgdmFyIG51bVN0ciA9ICcnXG5cbiAgICBpZiAocGFyc2VyLkVOVElUSUVTW2VudGl0eV0pIHtcbiAgICAgIHJldHVybiBwYXJzZXIuRU5USVRJRVNbZW50aXR5XVxuICAgIH1cbiAgICBpZiAocGFyc2VyLkVOVElUSUVTW2VudGl0eUxDXSkge1xuICAgICAgcmV0dXJuIHBhcnNlci5FTlRJVElFU1tlbnRpdHlMQ11cbiAgICB9XG4gICAgZW50aXR5ID0gZW50aXR5TENcbiAgICBpZiAoZW50aXR5LmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICBpZiAoZW50aXR5LmNoYXJBdCgxKSA9PT0gJ3gnKSB7XG4gICAgICAgIGVudGl0eSA9IGVudGl0eS5zbGljZSgyKVxuICAgICAgICBudW0gPSBwYXJzZUludChlbnRpdHksIDE2KVxuICAgICAgICBudW1TdHIgPSBudW0udG9TdHJpbmcoMTYpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnRpdHkgPSBlbnRpdHkuc2xpY2UoMSlcbiAgICAgICAgbnVtID0gcGFyc2VJbnQoZW50aXR5LCAxMClcbiAgICAgICAgbnVtU3RyID0gbnVtLnRvU3RyaW5nKDEwKVxuICAgICAgfVxuICAgIH1cbiAgICBlbnRpdHkgPSBlbnRpdHkucmVwbGFjZSgvXjArLywgJycpXG4gICAgaWYgKGlzTmFOKG51bSkgfHwgbnVtU3RyLnRvTG93ZXJDYXNlKCkgIT09IGVudGl0eSkge1xuICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIGNoYXJhY3RlciBlbnRpdHknKVxuICAgICAgcmV0dXJuICcmJyArIHBhcnNlci5lbnRpdHkgKyAnOydcbiAgICB9XG5cbiAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQobnVtKVxuICB9XG5cbiAgZnVuY3Rpb24gYmVnaW5XaGl0ZVNwYWNlIChwYXJzZXIsIGMpIHtcbiAgICBpZiAoYyA9PT0gJzwnKSB7XG4gICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fV0FLQVxuICAgICAgcGFyc2VyLnN0YXJ0VGFnUG9zaXRpb24gPSBwYXJzZXIucG9zaXRpb25cbiAgICB9IGVsc2UgaWYgKCFpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgIC8vIGhhdmUgdG8gcHJvY2VzcyB0aGlzIGFzIGEgdGV4dCBub2RlLlxuICAgICAgLy8gd2VpcmQsIGJ1dCBoYXBwZW5zLlxuICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdOb24td2hpdGVzcGFjZSBiZWZvcmUgZmlyc3QgdGFnLicpXG4gICAgICBwYXJzZXIudGV4dE5vZGUgPSBjXG4gICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGFyQXQgKGNodW5rLCBpKSB7XG4gICAgdmFyIHJlc3VsdCA9ICcnXG4gICAgaWYgKGkgPCBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdCA9IGNodW5rLmNoYXJBdChpKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBmdW5jdGlvbiB3cml0ZSAoY2h1bmspIHtcbiAgICB2YXIgcGFyc2VyID0gdGhpc1xuICAgIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLmVycm9yXG4gICAgfVxuICAgIGlmIChwYXJzZXIuY2xvc2VkKSB7XG4gICAgICByZXR1cm4gZXJyb3IocGFyc2VyLFxuICAgICAgICAnQ2Fubm90IHdyaXRlIGFmdGVyIGNsb3NlLiBBc3NpZ24gYW4gb25yZWFkeSBoYW5kbGVyLicpXG4gICAgfVxuICAgIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVuZChwYXJzZXIpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdvYmplY3QnKSB7XG4gICAgICBjaHVuayA9IGNodW5rLnRvU3RyaW5nKClcbiAgICB9XG4gICAgdmFyIGkgPSAwXG4gICAgdmFyIGMgPSAnJ1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjID0gY2hhckF0KGNodW5rLCBpKyspXG4gICAgICBwYXJzZXIuYyA9IGNcblxuICAgICAgaWYgKCFjKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJzZXIudHJhY2tQb3NpdGlvbikge1xuICAgICAgICBwYXJzZXIucG9zaXRpb24rK1xuICAgICAgICBpZiAoYyA9PT0gJ1xcbicpIHtcbiAgICAgICAgICBwYXJzZXIubGluZSsrXG4gICAgICAgICAgcGFyc2VyLmNvbHVtbiA9IDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJzZXIuY29sdW1uKytcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHBhcnNlci5zdGF0ZSkge1xuICAgICAgICBjYXNlIFMuQkVHSU46XG4gICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5CRUdJTl9XSElURVNQQUNFXG4gICAgICAgICAgaWYgKGMgPT09ICdcXHVGRUZGJykge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgYmVnaW5XaGl0ZVNwYWNlKHBhcnNlciwgYylcbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5CRUdJTl9XSElURVNQQUNFOlxuICAgICAgICAgIGJlZ2luV2hpdGVTcGFjZShwYXJzZXIsIGMpXG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuVEVYVDpcbiAgICAgICAgICBpZiAocGFyc2VyLnNhd1Jvb3QgJiYgIXBhcnNlci5jbG9zZWRSb290KSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRpID0gaSAtIDFcbiAgICAgICAgICAgIHdoaWxlIChjICYmIGMgIT09ICc8JyAmJiBjICE9PSAnJicpIHtcbiAgICAgICAgICAgICAgYyA9IGNoYXJBdChjaHVuaywgaSsrKVxuICAgICAgICAgICAgICBpZiAoYyAmJiBwYXJzZXIudHJhY2tQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHBhcnNlci5wb3NpdGlvbisrXG4gICAgICAgICAgICAgICAgaWYgKGMgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICBwYXJzZXIubGluZSsrXG4gICAgICAgICAgICAgICAgICBwYXJzZXIuY29sdW1uID0gMFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwYXJzZXIuY29sdW1uKytcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlci50ZXh0Tm9kZSArPSBjaHVuay5zdWJzdHJpbmcoc3RhcnRpLCBpIC0gMSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGMgPT09ICc8JyAmJiAhKHBhcnNlci5zYXdSb290ICYmIHBhcnNlci5jbG9zZWRSb290ICYmICFwYXJzZXIuc3RyaWN0KSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5PUEVOX1dBS0FcbiAgICAgICAgICAgIHBhcnNlci5zdGFydFRhZ1Bvc2l0aW9uID0gcGFyc2VyLnBvc2l0aW9uXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaXNXaGl0ZXNwYWNlKGMpICYmICghcGFyc2VyLnNhd1Jvb3QgfHwgcGFyc2VyLmNsb3NlZFJvb3QpKSB7XG4gICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnVGV4dCBkYXRhIG91dHNpZGUgb2Ygcm9vdCBub2RlLicpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA9PT0gJyYnKSB7XG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVF9FTlRJVFlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcnNlci50ZXh0Tm9kZSArPSBjXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlNDUklQVDpcbiAgICAgICAgICAvLyBvbmx5IG5vbi1zdHJpY3RcbiAgICAgICAgICBpZiAoYyA9PT0gJzwnKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNDUklQVF9FTkRJTkdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnNjcmlwdCArPSBjXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlNDUklQVF9FTkRJTkc6XG4gICAgICAgICAgaWYgKGMgPT09ICcvJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DTE9TRV9UQUdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnNjcmlwdCArPSAnPCcgKyBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNDUklQVFxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5PUEVOX1dBS0E6XG4gICAgICAgICAgLy8gZWl0aGVyIGEgLywgPywgISwgb3IgdGV4dCBpcyBjb21pbmcgbmV4dC5cbiAgICAgICAgICBpZiAoYyA9PT0gJyEnKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNHTUxfREVDTFxuICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsID0gJydcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgLy8gd2FpdCBmb3IgaXQuLi5cbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTWF0Y2gobmFtZVN0YXJ0LCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5PUEVOX1RBR1xuICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgPSBjXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnLycpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0xPU0VfVEFHXG4gICAgICAgICAgICBwYXJzZXIudGFnTmFtZSA9ICcnXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnPycpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuUFJPQ19JTlNUXG4gICAgICAgICAgICBwYXJzZXIucHJvY0luc3ROYW1lID0gcGFyc2VyLnByb2NJbnN0Qm9keSA9ICcnXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnVW5lbmNvZGVkIDwnKVxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgd2FzIHNvbWUgd2hpdGVzcGFjZSwgdGhlbiBhZGQgdGhhdCBpbi5cbiAgICAgICAgICAgIGlmIChwYXJzZXIuc3RhcnRUYWdQb3NpdGlvbiArIDEgPCBwYXJzZXIucG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgdmFyIHBhZCA9IHBhcnNlci5wb3NpdGlvbiAtIHBhcnNlci5zdGFydFRhZ1Bvc2l0aW9uXG4gICAgICAgICAgICAgIGMgPSBuZXcgQXJyYXkocGFkKS5qb2luKCcgJykgKyBjXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZXIudGV4dE5vZGUgKz0gJzwnICsgY1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlNHTUxfREVDTDpcbiAgICAgICAgICBpZiAoKHBhcnNlci5zZ21sRGVjbCArIGMpLnRvVXBwZXJDYXNlKCkgPT09IENEQVRBKSB7XG4gICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbm9wZW5jZGF0YScpXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNEQVRBXG4gICAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLmNkYXRhID0gJydcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhcnNlci5zZ21sRGVjbCArIGMgPT09ICctLScpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ09NTUVOVFxuICAgICAgICAgICAgcGFyc2VyLmNvbW1lbnQgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsID0gJydcbiAgICAgICAgICB9IGVsc2UgaWYgKChwYXJzZXIuc2dtbERlY2wgKyBjKS50b1VwcGVyQ2FzZSgpID09PSBET0NUWVBFKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkRPQ1RZUEVcbiAgICAgICAgICAgIGlmIChwYXJzZXIuZG9jdHlwZSB8fCBwYXJzZXIuc2F3Um9vdCkge1xuICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlcixcbiAgICAgICAgICAgICAgICAnSW5hcHByb3ByaWF0ZWx5IGxvY2F0ZWQgZG9jdHlwZSBkZWNsYXJhdGlvbicpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZXIuZG9jdHlwZSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgPSAnJ1xuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbnNnbWxkZWNsYXJhdGlvbicsIHBhcnNlci5zZ21sRGVjbClcbiAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzUXVvdGUoYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0dNTF9ERUNMX1FVT1RFRFxuICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsICs9IGNcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsICs9IGNcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuU0dNTF9ERUNMX1FVT1RFRDpcbiAgICAgICAgICBpZiAoYyA9PT0gcGFyc2VyLnEpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0dNTF9ERUNMXG4gICAgICAgICAgICBwYXJzZXIucSA9ICcnXG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCArPSBjXG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuRE9DVFlQRTpcbiAgICAgICAgICBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uZG9jdHlwZScsIHBhcnNlci5kb2N0eXBlKVxuICAgICAgICAgICAgcGFyc2VyLmRvY3R5cGUgPSB0cnVlIC8vIGp1c3QgcmVtZW1iZXIgdGhhdCB3ZSBzYXcgaXQuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5kb2N0eXBlICs9IGNcbiAgICAgICAgICAgIGlmIChjID09PSAnWycpIHtcbiAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFX0RURFxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1F1b3RlKGMpKSB7XG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRV9RVU9URURcbiAgICAgICAgICAgICAgcGFyc2VyLnEgPSBjXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkRPQ1RZUEVfUVVPVEVEOlxuICAgICAgICAgIHBhcnNlci5kb2N0eXBlICs9IGNcbiAgICAgICAgICBpZiAoYyA9PT0gcGFyc2VyLnEpIHtcbiAgICAgICAgICAgIHBhcnNlci5xID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5ET0NUWVBFX0RURDpcbiAgICAgICAgICBwYXJzZXIuZG9jdHlwZSArPSBjXG4gICAgICAgICAgaWYgKGMgPT09ICddJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFXG4gICAgICAgICAgfSBlbHNlIGlmIChpc1F1b3RlKGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkRPQ1RZUEVfRFREX1FVT1RFRFxuICAgICAgICAgICAgcGFyc2VyLnEgPSBjXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkRPQ1RZUEVfRFREX1FVT1RFRDpcbiAgICAgICAgICBwYXJzZXIuZG9jdHlwZSArPSBjXG4gICAgICAgICAgaWYgKGMgPT09IHBhcnNlci5xKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkRPQ1RZUEVfRFREXG4gICAgICAgICAgICBwYXJzZXIucSA9ICcnXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNPTU1FTlQ6XG4gICAgICAgICAgaWYgKGMgPT09ICctJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DT01NRU5UX0VORElOR1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIuY29tbWVudCArPSBjXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNPTU1FTlRfRU5ESU5HOlxuICAgICAgICAgIGlmIChjID09PSAnLScpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ09NTUVOVF9FTkRFRFxuICAgICAgICAgICAgcGFyc2VyLmNvbW1lbnQgPSB0ZXh0b3B0cyhwYXJzZXIub3B0LCBwYXJzZXIuY29tbWVudClcbiAgICAgICAgICAgIGlmIChwYXJzZXIuY29tbWVudCkge1xuICAgICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmNvbW1lbnQnLCBwYXJzZXIuY29tbWVudClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlci5jb21tZW50ID0gJydcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLmNvbW1lbnQgKz0gJy0nICsgY1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DT01NRU5UXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNPTU1FTlRfRU5ERUQ6XG4gICAgICAgICAgaWYgKGMgIT09ICc+Jykge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdNYWxmb3JtZWQgY29tbWVudCcpXG4gICAgICAgICAgICAvLyBhbGxvdyA8IS0tIGJsYWggLS0gYmxvbyAtLT4gaW4gbm9uLXN0cmljdCBtb2RlLFxuICAgICAgICAgICAgLy8gd2hpY2ggaXMgYSBjb21tZW50IG9mIFwiIGJsYWggLS0gYmxvbyBcIlxuICAgICAgICAgICAgcGFyc2VyLmNvbW1lbnQgKz0gJy0tJyArIGNcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ09NTUVOVFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQ0RBVEE6XG4gICAgICAgICAgaWYgKGMgPT09ICddJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DREFUQV9FTkRJTkdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLmNkYXRhICs9IGNcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQ0RBVEFfRU5ESU5HOlxuICAgICAgICAgIGlmIChjID09PSAnXScpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0RBVEFfRU5ESU5HXzJcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLmNkYXRhICs9ICddJyArIGNcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0RBVEFcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQ0RBVEFfRU5ESU5HXzI6XG4gICAgICAgICAgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgaWYgKHBhcnNlci5jZGF0YSkge1xuICAgICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmNkYXRhJywgcGFyc2VyLmNkYXRhKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jbG9zZWNkYXRhJylcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICddJykge1xuICAgICAgICAgICAgcGFyc2VyLmNkYXRhICs9ICddJ1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIuY2RhdGEgKz0gJ11dJyArIGNcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0RBVEFcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuUFJPQ19JTlNUOlxuICAgICAgICAgIGlmIChjID09PSAnPycpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuUFJPQ19JTlNUX0VORElOR1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlBST0NfSU5TVF9CT0RZXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5wcm9jSW5zdE5hbWUgKz0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5QUk9DX0lOU1RfQk9EWTpcbiAgICAgICAgICBpZiAoIXBhcnNlci5wcm9jSW5zdEJvZHkgJiYgaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJz8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlBST0NfSU5TVF9FTkRJTkdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnByb2NJbnN0Qm9keSArPSBjXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlBST0NfSU5TVF9FTkRJTkc6XG4gICAgICAgICAgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24nLCB7XG4gICAgICAgICAgICAgIG5hbWU6IHBhcnNlci5wcm9jSW5zdE5hbWUsXG4gICAgICAgICAgICAgIGJvZHk6IHBhcnNlci5wcm9jSW5zdEJvZHlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBwYXJzZXIucHJvY0luc3ROYW1lID0gcGFyc2VyLnByb2NJbnN0Qm9keSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnByb2NJbnN0Qm9keSArPSAnPycgKyBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlBST0NfSU5TVF9CT0RZXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLk9QRU5fVEFHOlxuICAgICAgICAgIGlmIChpc01hdGNoKG5hbWVCb2R5LCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgKz0gY1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdUYWcocGFyc2VyKVxuICAgICAgICAgICAgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgICBvcGVuVGFnKHBhcnNlcilcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuT1BFTl9UQUdfU0xBU0hcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIGNoYXJhY3RlciBpbiB0YWcgbmFtZScpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuT1BFTl9UQUdfU0xBU0g6XG4gICAgICAgICAgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIsIHRydWUpXG4gICAgICAgICAgICBjbG9zZVRhZyhwYXJzZXIpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnRm9yd2FyZC1zbGFzaCBpbiBvcGVuaW5nIHRhZyBub3QgZm9sbG93ZWQgYnkgPicpXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQlxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5BVFRSSUI6XG4gICAgICAgICAgLy8gaGF2ZW4ndCByZWFkIHRoZSBhdHRyaWJ1dGUgbmFtZSB5ZXQuXG4gICAgICAgICAgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIpXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnLycpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuT1BFTl9UQUdfU0xBU0hcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTWF0Y2gobmFtZVN0YXJ0LCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBjXG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfTkFNRVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWUnKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5BVFRSSUJfTkFNRTpcbiAgICAgICAgICBpZiAoYyA9PT0gJz0nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRVxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0F0dHJpYnV0ZSB3aXRob3V0IHZhbHVlJylcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSA9IHBhcnNlci5hdHRyaWJOYW1lXG4gICAgICAgICAgICBhdHRyaWIocGFyc2VyKVxuICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIpXG4gICAgICAgICAgfSBlbHNlIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX05BTUVfU0FXX1dISVRFXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01hdGNoKG5hbWVCb2R5LCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgKz0gY1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWUnKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5BVFRSSUJfTkFNRV9TQVdfV0hJVEU6XG4gICAgICAgICAgaWYgKGMgPT09ICc9Jykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfVkFMVUVcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdBdHRyaWJ1dGUgd2l0aG91dCB2YWx1ZScpXG4gICAgICAgICAgICBwYXJzZXIudGFnLmF0dHJpYnV0ZXNbcGFyc2VyLmF0dHJpYk5hbWVdID0gJydcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSA9ICcnXG4gICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmF0dHJpYnV0ZScsIHtcbiAgICAgICAgICAgICAgbmFtZTogcGFyc2VyLmF0dHJpYk5hbWUsXG4gICAgICAgICAgICAgIHZhbHVlOiAnJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gJydcbiAgICAgICAgICAgIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTWF0Y2gobmFtZVN0YXJ0LCBjKSkge1xuICAgICAgICAgICAgICBwYXJzZXIuYXR0cmliTmFtZSA9IGNcbiAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfTkFNRVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lJylcbiAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFOlxuICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChpc1F1b3RlKGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIucSA9IGNcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX1FVT1RFRFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1VucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZScpXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9VTlFVT1RFRFxuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlID0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfUVVPVEVEOlxuICAgICAgICAgIGlmIChjICE9PSBwYXJzZXIucSkge1xuICAgICAgICAgICAgaWYgKGMgPT09ICcmJykge1xuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfUVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlICs9IGNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGF0dHJpYihwYXJzZXIpXG4gICAgICAgICAgcGFyc2VyLnEgPSAnJ1xuICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX0NMT1NFRFxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9DTE9TRUQ6XG4gICAgICAgICAgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIpXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnLycpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuT1BFTl9UQUdfU0xBU0hcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTWF0Y2gobmFtZVN0YXJ0LCBjKSkge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdObyB3aGl0ZXNwYWNlIGJldHdlZW4gYXR0cmlidXRlcycpXG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliTmFtZSA9IGNcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9OQU1FXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBhdHRyaWJ1dGUgbmFtZScpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9VTlFVT1RFRDpcbiAgICAgICAgICBpZiAoIWlzQXR0cmliRW5kKGMpKSB7XG4gICAgICAgICAgICBpZiAoYyA9PT0gJyYnKSB7XG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX0VOVElUWV9VXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUgKz0gY1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgYXR0cmliKHBhcnNlcilcbiAgICAgICAgICBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBvcGVuVGFnKHBhcnNlcilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQ0xPU0VfVEFHOlxuICAgICAgICAgIGlmICghcGFyc2VyLnRhZ05hbWUpIHtcbiAgICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm90TWF0Y2gobmFtZVN0YXJ0LCBjKSkge1xuICAgICAgICAgICAgICBpZiAocGFyc2VyLnNjcmlwdCkge1xuICAgICAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgKz0gJzwvJyArIGNcbiAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNDUklQVFxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCB0YWduYW1lIGluIGNsb3NpbmcgdGFnLicpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcnNlci50YWdOYW1lID0gY1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBjbG9zZVRhZyhwYXJzZXIpXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01hdGNoKG5hbWVCb2R5LCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgKz0gY1xuICAgICAgICAgIH0gZWxzZSBpZiAocGFyc2VyLnNjcmlwdCkge1xuICAgICAgICAgICAgcGFyc2VyLnNjcmlwdCArPSAnPC8nICsgcGFyc2VyLnRhZ05hbWVcbiAgICAgICAgICAgIHBhcnNlci50YWdOYW1lID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0NSSVBUXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCB0YWduYW1lIGluIGNsb3NpbmcgdGFnJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0xPU0VfVEFHX1NBV19XSElURVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5DTE9TRV9UQUdfU0FXX1dISVRFOlxuICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIGNsb3NlVGFnKHBhcnNlcilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIGNoYXJhY3RlcnMgaW4gY2xvc2luZyB0YWcnKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5URVhUX0VOVElUWTpcbiAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfUTpcbiAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfVTpcbiAgICAgICAgICB2YXIgcmV0dXJuU3RhdGVcbiAgICAgICAgICB2YXIgYnVmZmVyXG4gICAgICAgICAgc3dpdGNoIChwYXJzZXIuc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgUy5URVhUX0VOVElUWTpcbiAgICAgICAgICAgICAgcmV0dXJuU3RhdGUgPSBTLlRFWFRcbiAgICAgICAgICAgICAgYnVmZmVyID0gJ3RleHROb2RlJ1xuICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFX0VOVElUWV9ROlxuICAgICAgICAgICAgICByZXR1cm5TdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX1FVT1RFRFxuICAgICAgICAgICAgICBidWZmZXIgPSAnYXR0cmliVmFsdWUnXG4gICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfRU5USVRZX1U6XG4gICAgICAgICAgICAgIHJldHVyblN0YXRlID0gUy5BVFRSSUJfVkFMVUVfVU5RVU9URURcbiAgICAgICAgICAgICAgYnVmZmVyID0gJ2F0dHJpYlZhbHVlJ1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjID09PSAnOycpIHtcbiAgICAgICAgICAgIHBhcnNlcltidWZmZXJdICs9IHBhcnNlRW50aXR5KHBhcnNlcilcbiAgICAgICAgICAgIHBhcnNlci5lbnRpdHkgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gcmV0dXJuU3RhdGVcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTWF0Y2gocGFyc2VyLmVudGl0eS5sZW5ndGggPyBlbnRpdHlCb2R5IDogZW50aXR5U3RhcnQsIGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuZW50aXR5ICs9IGNcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIGNoYXJhY3RlciBpbiBlbnRpdHkgbmFtZScpXG4gICAgICAgICAgICBwYXJzZXJbYnVmZmVyXSArPSAnJicgKyBwYXJzZXIuZW50aXR5ICsgY1xuICAgICAgICAgICAgcGFyc2VyLmVudGl0eSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSByZXR1cm5TdGF0ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocGFyc2VyLCAnVW5rbm93biBzdGF0ZTogJyArIHBhcnNlci5zdGF0ZSlcbiAgICAgIH1cbiAgICB9IC8vIHdoaWxlXG5cbiAgICBpZiAocGFyc2VyLnBvc2l0aW9uID49IHBhcnNlci5idWZmZXJDaGVja1Bvc2l0aW9uKSB7XG4gICAgICBjaGVja0J1ZmZlckxlbmd0aChwYXJzZXIpXG4gICAgfVxuICAgIHJldHVybiBwYXJzZXJcbiAgfVxuXG4gIC8qISBodHRwOi8vbXRocy5iZS9mcm9tY29kZXBvaW50IHYwLjEuMCBieSBAbWF0aGlhcyAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAoIVN0cmluZy5mcm9tQ29kZVBvaW50KSB7XG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlXG4gICAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yXG4gICAgICB2YXIgZnJvbUNvZGVQb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIE1BWF9TSVpFID0gMHg0MDAwXG4gICAgICAgIHZhciBjb2RlVW5pdHMgPSBbXVxuICAgICAgICB2YXIgaGlnaFN1cnJvZ2F0ZVxuICAgICAgICB2YXIgbG93U3Vycm9nYXRlXG4gICAgICAgIHZhciBpbmRleCA9IC0xXG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGNvZGVQb2ludCA9IE51bWJlcihhcmd1bWVudHNbaW5kZXhdKVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFpc0Zpbml0ZShjb2RlUG9pbnQpIHx8IC8vIGBOYU5gLCBgK0luZmluaXR5YCwgb3IgYC1JbmZpbml0eWBcbiAgICAgICAgICAgIGNvZGVQb2ludCA8IDAgfHwgLy8gbm90IGEgdmFsaWQgVW5pY29kZSBjb2RlIHBvaW50XG4gICAgICAgICAgICBjb2RlUG9pbnQgPiAweDEwRkZGRiB8fCAvLyBub3QgYSB2YWxpZCBVbmljb2RlIGNvZGUgcG9pbnRcbiAgICAgICAgICAgIGZsb29yKGNvZGVQb2ludCkgIT09IGNvZGVQb2ludCAvLyBub3QgYW4gaW50ZWdlclxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcignSW52YWxpZCBjb2RlIHBvaW50OiAnICsgY29kZVBvaW50KVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4RkZGRikgeyAvLyBCTVAgY29kZSBwb2ludFxuICAgICAgICAgICAgY29kZVVuaXRzLnB1c2goY29kZVBvaW50KVxuICAgICAgICAgIH0gZWxzZSB7IC8vIEFzdHJhbCBjb2RlIHBvaW50OyBzcGxpdCBpbiBzdXJyb2dhdGUgaGFsdmVzXG4gICAgICAgICAgICAvLyBodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxuICAgICAgICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgICAgICAgIGhpZ2hTdXJyb2dhdGUgPSAoY29kZVBvaW50ID4+IDEwKSArIDB4RDgwMFxuICAgICAgICAgICAgbG93U3Vycm9nYXRlID0gKGNvZGVQb2ludCAlIDB4NDAwKSArIDB4REMwMFxuICAgICAgICAgICAgY29kZVVuaXRzLnB1c2goaGlnaFN1cnJvZ2F0ZSwgbG93U3Vycm9nYXRlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5kZXggKyAxID09PSBsZW5ndGggfHwgY29kZVVuaXRzLmxlbmd0aCA+IE1BWF9TSVpFKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGNvZGVVbml0cylcbiAgICAgICAgICAgIGNvZGVVbml0cy5sZW5ndGggPSAwXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJpbmcsICdmcm9tQ29kZVBvaW50Jywge1xuICAgICAgICAgIHZhbHVlOiBmcm9tQ29kZVBvaW50LFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgU3RyaW5nLmZyb21Db2RlUG9pbnQgPSBmcm9tQ29kZVBvaW50XG4gICAgICB9XG4gICAgfSgpKVxuICB9XG59KSh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLnNheCA9IHt9IDogZXhwb3J0cylcbiIsIid1c2Ugc3RyaWN0J1xuXG4vLyBoaWdoLWxldmVsIGNvbW1hbmRzXG5leHBvcnRzLmMgPSBleHBvcnRzLmNyZWF0ZSA9IHJlcXVpcmUoJy4vbGliL2NyZWF0ZS5qcycpXG5leHBvcnRzLnIgPSBleHBvcnRzLnJlcGxhY2UgPSByZXF1aXJlKCcuL2xpYi9yZXBsYWNlLmpzJylcbmV4cG9ydHMudCA9IGV4cG9ydHMubGlzdCA9IHJlcXVpcmUoJy4vbGliL2xpc3QuanMnKVxuZXhwb3J0cy51ID0gZXhwb3J0cy51cGRhdGUgPSByZXF1aXJlKCcuL2xpYi91cGRhdGUuanMnKVxuZXhwb3J0cy54ID0gZXhwb3J0cy5leHRyYWN0ID0gcmVxdWlyZSgnLi9saWIvZXh0cmFjdC5qcycpXG5cbi8vIGNsYXNzZXNcbmV4cG9ydHMuUGFjayA9IHJlcXVpcmUoJy4vbGliL3BhY2suanMnKVxuZXhwb3J0cy5VbnBhY2sgPSByZXF1aXJlKCcuL2xpYi91bnBhY2suanMnKVxuZXhwb3J0cy5QYXJzZSA9IHJlcXVpcmUoJy4vbGliL3BhcnNlLmpzJylcbmV4cG9ydHMuUmVhZEVudHJ5ID0gcmVxdWlyZSgnLi9saWIvcmVhZC1lbnRyeS5qcycpXG5leHBvcnRzLldyaXRlRW50cnkgPSByZXF1aXJlKCcuL2xpYi93cml0ZS1lbnRyeS5qcycpXG5leHBvcnRzLkhlYWRlciA9IHJlcXVpcmUoJy4vbGliL2hlYWRlci5qcycpXG5leHBvcnRzLlBheCA9IHJlcXVpcmUoJy4vbGliL3BheC5qcycpXG5leHBvcnRzLnR5cGVzID0gcmVxdWlyZSgnLi9saWIvdHlwZXMuanMnKVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8vIEJ1ZmZlciBpbiBub2RlIDQueCA8IDQuNS4wIGRvZXNuJ3QgaGF2ZSB3b3JraW5nIEJ1ZmZlci5mcm9tXG4vLyBvciBCdWZmZXIuYWxsb2MsIGFuZCBCdWZmZXIgaW4gbm9kZSAxMCBkZXByZWNhdGVkIHRoZSBjdG9yLlxuLy8gLk0sIHRoaXMgaXMgZmluZSAuXFxeL00uLlxubGV0IEIgPSBCdWZmZXJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5pZiAoIUIuYWxsb2MpIHtcbiAgQiA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG59XG5tb2R1bGUuZXhwb3J0cyA9IEJcbiIsIid1c2Ugc3RyaWN0J1xuXG4vLyB0YXIgLWNcbmNvbnN0IGhsbyA9IHJlcXVpcmUoJy4vaGlnaC1sZXZlbC1vcHQuanMnKVxuXG5jb25zdCBQYWNrID0gcmVxdWlyZSgnLi9wYWNrLmpzJylcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKVxuY29uc3QgZnNtID0gcmVxdWlyZSgnZnMtbWluaXBhc3MnKVxuY29uc3QgdCA9IHJlcXVpcmUoJy4vbGlzdC5qcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5cbmNvbnN0IGMgPSBtb2R1bGUuZXhwb3J0cyA9IChvcHRfLCBmaWxlcywgY2IpID0+IHtcbiAgaWYgKHR5cGVvZiBmaWxlcyA9PT0gJ2Z1bmN0aW9uJylcbiAgICBjYiA9IGZpbGVzXG5cbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0XykpXG4gICAgZmlsZXMgPSBvcHRfLCBvcHRfID0ge31cblxuICBpZiAoIWZpbGVzIHx8ICFBcnJheS5pc0FycmF5KGZpbGVzKSB8fCAhZmlsZXMubGVuZ3RoKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vIGZpbGVzIG9yIGRpcmVjdG9yaWVzIHNwZWNpZmllZCcpXG5cbiAgZmlsZXMgPSBBcnJheS5mcm9tKGZpbGVzKVxuXG4gIGNvbnN0IG9wdCA9IGhsbyhvcHRfKVxuXG4gIGlmIChvcHQuc3luYyAmJiB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FsbGJhY2sgbm90IHN1cHBvcnRlZCBmb3Igc3luYyB0YXIgZnVuY3Rpb25zJylcblxuICBpZiAoIW9wdC5maWxlICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBvbmx5IHN1cHBvcnRlZCB3aXRoIGZpbGUgb3B0aW9uJylcblxuICByZXR1cm4gb3B0LmZpbGUgJiYgb3B0LnN5bmMgPyBjcmVhdGVGaWxlU3luYyhvcHQsIGZpbGVzKVxuICAgIDogb3B0LmZpbGUgPyBjcmVhdGVGaWxlKG9wdCwgZmlsZXMsIGNiKVxuICAgIDogb3B0LnN5bmMgPyBjcmVhdGVTeW5jKG9wdCwgZmlsZXMpXG4gICAgOiBjcmVhdGUob3B0LCBmaWxlcylcbn1cblxuY29uc3QgY3JlYXRlRmlsZVN5bmMgPSAob3B0LCBmaWxlcykgPT4ge1xuICBjb25zdCBwID0gbmV3IFBhY2suU3luYyhvcHQpXG4gIGNvbnN0IHN0cmVhbSA9IG5ldyBmc20uV3JpdGVTdHJlYW1TeW5jKG9wdC5maWxlLCB7XG4gICAgbW9kZTogb3B0Lm1vZGUgfHwgMG82NjZcbiAgfSlcbiAgcC5waXBlKHN0cmVhbSlcbiAgYWRkRmlsZXNTeW5jKHAsIGZpbGVzKVxufVxuXG5jb25zdCBjcmVhdGVGaWxlID0gKG9wdCwgZmlsZXMsIGNiKSA9PiB7XG4gIGNvbnN0IHAgPSBuZXcgUGFjayhvcHQpXG4gIGNvbnN0IHN0cmVhbSA9IG5ldyBmc20uV3JpdGVTdHJlYW0ob3B0LmZpbGUsIHtcbiAgICBtb2RlOiBvcHQubW9kZSB8fCAwbzY2NlxuICB9KVxuICBwLnBpcGUoc3RyZWFtKVxuXG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICBzdHJlYW0ub24oJ2Vycm9yJywgcmVqKVxuICAgIHN0cmVhbS5vbignY2xvc2UnLCByZXMpXG4gICAgcC5vbignZXJyb3InLCByZWopXG4gIH0pXG5cbiAgYWRkRmlsZXNBc3luYyhwLCBmaWxlcylcblxuICByZXR1cm4gY2IgPyBwcm9taXNlLnRoZW4oY2IsIGNiKSA6IHByb21pc2Vcbn1cblxuY29uc3QgYWRkRmlsZXNTeW5jID0gKHAsIGZpbGVzKSA9PiB7XG4gIGZpbGVzLmZvckVhY2goZmlsZSA9PiB7XG4gICAgaWYgKGZpbGUuY2hhckF0KDApID09PSAnQCcpXG4gICAgICB0KHtcbiAgICAgICAgZmlsZTogcGF0aC5yZXNvbHZlKHAuY3dkLCBmaWxlLnN1YnN0cigxKSksXG4gICAgICAgIHN5bmM6IHRydWUsXG4gICAgICAgIG5vUmVzdW1lOiB0cnVlLFxuICAgICAgICBvbmVudHJ5OiBlbnRyeSA9PiBwLmFkZChlbnRyeSlcbiAgICAgIH0pXG4gICAgZWxzZVxuICAgICAgcC5hZGQoZmlsZSlcbiAgfSlcbiAgcC5lbmQoKVxufVxuXG5jb25zdCBhZGRGaWxlc0FzeW5jID0gKHAsIGZpbGVzKSA9PiB7XG4gIHdoaWxlIChmaWxlcy5sZW5ndGgpIHtcbiAgICBjb25zdCBmaWxlID0gZmlsZXMuc2hpZnQoKVxuICAgIGlmIChmaWxlLmNoYXJBdCgwKSA9PT0gJ0AnKVxuICAgICAgcmV0dXJuIHQoe1xuICAgICAgICBmaWxlOiBwYXRoLnJlc29sdmUocC5jd2QsIGZpbGUuc3Vic3RyKDEpKSxcbiAgICAgICAgbm9SZXN1bWU6IHRydWUsXG4gICAgICAgIG9uZW50cnk6IGVudHJ5ID0+IHAuYWRkKGVudHJ5KVxuICAgICAgfSkudGhlbihfID0+IGFkZEZpbGVzQXN5bmMocCwgZmlsZXMpKVxuICAgIGVsc2VcbiAgICAgIHAuYWRkKGZpbGUpXG4gIH1cbiAgcC5lbmQoKVxufVxuXG5jb25zdCBjcmVhdGVTeW5jID0gKG9wdCwgZmlsZXMpID0+IHtcbiAgY29uc3QgcCA9IG5ldyBQYWNrLlN5bmMob3B0KVxuICBhZGRGaWxlc1N5bmMocCwgZmlsZXMpXG4gIHJldHVybiBwXG59XG5cbmNvbnN0IGNyZWF0ZSA9IChvcHQsIGZpbGVzKSA9PiB7XG4gIGNvbnN0IHAgPSBuZXcgUGFjayhvcHQpXG4gIGFkZEZpbGVzQXN5bmMocCwgZmlsZXMpXG4gIHJldHVybiBwXG59XG4iLCIndXNlIHN0cmljdCdcblxuLy8gdGFyIC14XG5jb25zdCBobG8gPSByZXF1aXJlKCcuL2hpZ2gtbGV2ZWwtb3B0LmpzJylcbmNvbnN0IFVucGFjayA9IHJlcXVpcmUoJy4vdW5wYWNrLmpzJylcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKVxuY29uc3QgZnNtID0gcmVxdWlyZSgnZnMtbWluaXBhc3MnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuXG5jb25zdCB4ID0gbW9kdWxlLmV4cG9ydHMgPSAob3B0XywgZmlsZXMsIGNiKSA9PiB7XG4gIGlmICh0eXBlb2Ygb3B0XyA9PT0gJ2Z1bmN0aW9uJylcbiAgICBjYiA9IG9wdF8sIGZpbGVzID0gbnVsbCwgb3B0XyA9IHt9XG4gIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob3B0XykpXG4gICAgZmlsZXMgPSBvcHRfLCBvcHRfID0ge31cblxuICBpZiAodHlwZW9mIGZpbGVzID09PSAnZnVuY3Rpb24nKVxuICAgIGNiID0gZmlsZXMsIGZpbGVzID0gbnVsbFxuXG4gIGlmICghZmlsZXMpXG4gICAgZmlsZXMgPSBbXVxuICBlbHNlXG4gICAgZmlsZXMgPSBBcnJheS5mcm9tKGZpbGVzKVxuXG4gIGNvbnN0IG9wdCA9IGhsbyhvcHRfKVxuXG4gIGlmIChvcHQuc3luYyAmJiB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FsbGJhY2sgbm90IHN1cHBvcnRlZCBmb3Igc3luYyB0YXIgZnVuY3Rpb25zJylcblxuICBpZiAoIW9wdC5maWxlICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBvbmx5IHN1cHBvcnRlZCB3aXRoIGZpbGUgb3B0aW9uJylcblxuICBpZiAoZmlsZXMubGVuZ3RoKVxuICAgIGZpbGVzRmlsdGVyKG9wdCwgZmlsZXMpXG5cbiAgcmV0dXJuIG9wdC5maWxlICYmIG9wdC5zeW5jID8gZXh0cmFjdEZpbGVTeW5jKG9wdClcbiAgICA6IG9wdC5maWxlID8gZXh0cmFjdEZpbGUob3B0LCBjYilcbiAgICA6IG9wdC5zeW5jID8gZXh0cmFjdFN5bmMob3B0KVxuICAgIDogZXh0cmFjdChvcHQpXG59XG5cbi8vIGNvbnN0cnVjdCBhIGZpbHRlciB0aGF0IGxpbWl0cyB0aGUgZmlsZSBlbnRyaWVzIGxpc3RlZFxuLy8gaW5jbHVkZSBjaGlsZCBlbnRyaWVzIGlmIGEgZGlyIGlzIGluY2x1ZGVkXG5jb25zdCBmaWxlc0ZpbHRlciA9IChvcHQsIGZpbGVzKSA9PiB7XG4gIGNvbnN0IG1hcCA9IG5ldyBNYXAoZmlsZXMubWFwKGYgPT4gW2YucmVwbGFjZSgvXFwvKyQvLCAnJyksIHRydWVdKSlcbiAgY29uc3QgZmlsdGVyID0gb3B0LmZpbHRlclxuXG4gIGNvbnN0IG1hcEhhcyA9IChmaWxlLCByKSA9PiB7XG4gICAgY29uc3Qgcm9vdCA9IHIgfHwgcGF0aC5wYXJzZShmaWxlKS5yb290IHx8ICcuJ1xuICAgIGNvbnN0IHJldCA9IGZpbGUgPT09IHJvb3QgPyBmYWxzZVxuICAgICAgOiBtYXAuaGFzKGZpbGUpID8gbWFwLmdldChmaWxlKVxuICAgICAgOiBtYXBIYXMocGF0aC5kaXJuYW1lKGZpbGUpLCByb290KVxuXG4gICAgbWFwLnNldChmaWxlLCByZXQpXG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgb3B0LmZpbHRlciA9IGZpbHRlclxuICAgID8gKGZpbGUsIGVudHJ5KSA9PiBmaWx0ZXIoZmlsZSwgZW50cnkpICYmIG1hcEhhcyhmaWxlLnJlcGxhY2UoL1xcLyskLywgJycpKVxuICAgIDogZmlsZSA9PiBtYXBIYXMoZmlsZS5yZXBsYWNlKC9cXC8rJC8sICcnKSlcbn1cblxuY29uc3QgZXh0cmFjdEZpbGVTeW5jID0gb3B0ID0+IHtcbiAgY29uc3QgdSA9IG5ldyBVbnBhY2suU3luYyhvcHQpXG5cbiAgY29uc3QgZmlsZSA9IG9wdC5maWxlXG4gIGxldCB0aHJldyA9IHRydWVcbiAgbGV0IGZkXG4gIGNvbnN0IHN0YXQgPSBmcy5zdGF0U3luYyhmaWxlKVxuICAvLyBUaGlzIHRyYWRlcyBhIHplcm8tYnl0ZSByZWFkKCkgc3lzY2FsbCBmb3IgYSBzdGF0XG4gIC8vIEhvd2V2ZXIsIGl0IHdpbGwgdXN1YWxseSByZXN1bHQgaW4gbGVzcyBtZW1vcnkgYWxsb2NhdGlvblxuICBjb25zdCByZWFkU2l6ZSA9IG9wdC5tYXhSZWFkU2l6ZSB8fCAxNioxMDI0KjEwMjRcbiAgY29uc3Qgc3RyZWFtID0gbmV3IGZzbS5SZWFkU3RyZWFtU3luYyhmaWxlLCB7XG4gICAgcmVhZFNpemU6IHJlYWRTaXplLFxuICAgIHNpemU6IHN0YXQuc2l6ZVxuICB9KVxuICBzdHJlYW0ucGlwZSh1KVxufVxuXG5jb25zdCBleHRyYWN0RmlsZSA9IChvcHQsIGNiKSA9PiB7XG4gIGNvbnN0IHUgPSBuZXcgVW5wYWNrKG9wdClcbiAgY29uc3QgcmVhZFNpemUgPSBvcHQubWF4UmVhZFNpemUgfHwgMTYqMTAyNCoxMDI0XG5cbiAgY29uc3QgZmlsZSA9IG9wdC5maWxlXG4gIGNvbnN0IHAgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdS5vbignZXJyb3InLCByZWplY3QpXG4gICAgdS5vbignY2xvc2UnLCByZXNvbHZlKVxuXG4gICAgLy8gVGhpcyB0cmFkZXMgYSB6ZXJvLWJ5dGUgcmVhZCgpIHN5c2NhbGwgZm9yIGEgc3RhdFxuICAgIC8vIEhvd2V2ZXIsIGl0IHdpbGwgdXN1YWxseSByZXN1bHQgaW4gbGVzcyBtZW1vcnkgYWxsb2NhdGlvblxuICAgIGZzLnN0YXQoZmlsZSwgKGVyLCBzdGF0KSA9PiB7XG4gICAgICBpZiAoZXIpXG4gICAgICAgIHJlamVjdChlcilcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBuZXcgZnNtLlJlYWRTdHJlYW0oZmlsZSwge1xuICAgICAgICAgIHJlYWRTaXplOiByZWFkU2l6ZSxcbiAgICAgICAgICBzaXplOiBzdGF0LnNpemVcbiAgICAgICAgfSlcbiAgICAgICAgc3RyZWFtLm9uKCdlcnJvcicsIHJlamVjdClcbiAgICAgICAgc3RyZWFtLnBpcGUodSlcbiAgICAgIH1cbiAgICB9KVxuICB9KVxuICByZXR1cm4gY2IgPyBwLnRoZW4oY2IsIGNiKSA6IHBcbn1cblxuY29uc3QgZXh0cmFjdFN5bmMgPSBvcHQgPT4ge1xuICByZXR1cm4gbmV3IFVucGFjay5TeW5jKG9wdClcbn1cblxuY29uc3QgZXh0cmFjdCA9IG9wdCA9PiB7XG4gIHJldHVybiBuZXcgVW5wYWNrKG9wdClcbn1cbiIsIid1c2Ugc3RyaWN0J1xuLy8gcGFyc2UgYSA1MTItYnl0ZSBoZWFkZXIgYmxvY2sgdG8gYSBkYXRhIG9iamVjdCwgb3IgdmljZS12ZXJzYVxuLy8gZW5jb2RlIHJldHVybnMgYHRydWVgIGlmIGEgcGF4IGV4dGVuZGVkIGhlYWRlciBpcyBuZWVkZWQsIGJlY2F1c2Vcbi8vIHRoZSBkYXRhIGNvdWxkIG5vdCBiZSBmYWl0aGZ1bGx5IGVuY29kZWQgaW4gYSBzaW1wbGUgaGVhZGVyLlxuLy8gKEFsc28sIGNoZWNrIGhlYWRlci5uZWVkUGF4IHRvIHNlZSBpZiBpdCBuZWVkcyBhIHBheCBoZWFkZXIuKVxuXG5jb25zdCBCdWZmZXIgPSByZXF1aXJlKCcuL2J1ZmZlci5qcycpXG5jb25zdCB0eXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMuanMnKVxuY29uc3QgcGF0aE1vZHVsZSA9IHJlcXVpcmUoJ3BhdGgnKS5wb3NpeFxuY29uc3QgbGFyZ2UgPSByZXF1aXJlKCcuL2xhcmdlLW51bWJlcnMuanMnKVxuXG5jb25zdCBTTFVSUCA9IFN5bWJvbCgnc2x1cnAnKVxuY29uc3QgVFlQRSA9IFN5bWJvbCgndHlwZScpXG5cbmNsYXNzIEhlYWRlciB7XG4gIGNvbnN0cnVjdG9yIChkYXRhLCBvZmYsIGV4LCBnZXgpIHtcbiAgICB0aGlzLmNrc3VtVmFsaWQgPSBmYWxzZVxuICAgIHRoaXMubmVlZFBheCA9IGZhbHNlXG4gICAgdGhpcy5udWxsQmxvY2sgPSBmYWxzZVxuXG4gICAgdGhpcy5ibG9jayA9IG51bGxcbiAgICB0aGlzLnBhdGggPSBudWxsXG4gICAgdGhpcy5tb2RlID0gbnVsbFxuICAgIHRoaXMudWlkID0gbnVsbFxuICAgIHRoaXMuZ2lkID0gbnVsbFxuICAgIHRoaXMuc2l6ZSA9IG51bGxcbiAgICB0aGlzLm10aW1lID0gbnVsbFxuICAgIHRoaXMuY2tzdW0gPSBudWxsXG4gICAgdGhpc1tUWVBFXSA9ICcwJ1xuICAgIHRoaXMubGlua3BhdGggPSBudWxsXG4gICAgdGhpcy51bmFtZSA9IG51bGxcbiAgICB0aGlzLmduYW1lID0gbnVsbFxuICAgIHRoaXMuZGV2bWFqID0gMFxuICAgIHRoaXMuZGV2bWluID0gMFxuICAgIHRoaXMuYXRpbWUgPSBudWxsXG4gICAgdGhpcy5jdGltZSA9IG51bGxcblxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpXG4gICAgICB0aGlzLmRlY29kZShkYXRhLCBvZmYgfHwgMCwgZXgsIGdleClcbiAgICBlbHNlIGlmIChkYXRhKVxuICAgICAgdGhpcy5zZXQoZGF0YSlcbiAgfVxuXG4gIGRlY29kZSAoYnVmLCBvZmYsIGV4LCBnZXgpIHtcbiAgICBpZiAoIW9mZilcbiAgICAgIG9mZiA9IDBcblxuICAgIGlmICghYnVmIHx8ICEoYnVmLmxlbmd0aCA+PSBvZmYgKyA1MTIpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCduZWVkIDUxMiBieXRlcyBmb3IgaGVhZGVyJylcblxuICAgIHRoaXMucGF0aCA9IGRlY1N0cmluZyhidWYsIG9mZiwgMTAwKVxuICAgIHRoaXMubW9kZSA9IGRlY051bWJlcihidWYsIG9mZiArIDEwMCwgOClcbiAgICB0aGlzLnVpZCA9IGRlY051bWJlcihidWYsIG9mZiArIDEwOCwgOClcbiAgICB0aGlzLmdpZCA9IGRlY051bWJlcihidWYsIG9mZiArIDExNiwgOClcbiAgICB0aGlzLnNpemUgPSBkZWNOdW1iZXIoYnVmLCBvZmYgKyAxMjQsIDEyKVxuICAgIHRoaXMubXRpbWUgPSBkZWNEYXRlKGJ1Ziwgb2ZmICsgMTM2LCAxMilcbiAgICB0aGlzLmNrc3VtID0gZGVjTnVtYmVyKGJ1Ziwgb2ZmICsgMTQ4LCAxMilcblxuICAgIC8vIGlmIHdlIGhhdmUgZXh0ZW5kZWQgb3IgZ2xvYmFsIGV4dGVuZGVkIGhlYWRlcnMsIGFwcGx5IHRoZW0gbm93XG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ucG0vbm9kZS10YXIvcHVsbC8xODdcbiAgICB0aGlzW1NMVVJQXShleClcbiAgICB0aGlzW1NMVVJQXShnZXgsIHRydWUpXG5cbiAgICAvLyBvbGQgdGFyIHZlcnNpb25zIG1hcmtlZCBkaXJzIGFzIGEgZmlsZSB3aXRoIGEgdHJhaWxpbmcgL1xuICAgIHRoaXNbVFlQRV0gPSBkZWNTdHJpbmcoYnVmLCBvZmYgKyAxNTYsIDEpXG4gICAgaWYgKHRoaXNbVFlQRV0gPT09ICcnKVxuICAgICAgdGhpc1tUWVBFXSA9ICcwJ1xuICAgIGlmICh0aGlzW1RZUEVdID09PSAnMCcgJiYgdGhpcy5wYXRoLnN1YnN0cigtMSkgPT09ICcvJylcbiAgICAgIHRoaXNbVFlQRV0gPSAnNSdcblxuICAgIC8vIHRhciBpbXBsZW1lbnRhdGlvbnMgc29tZXRpbWVzIGluY29ycmVjdGx5IHB1dCB0aGUgc3RhdChkaXIpLnNpemVcbiAgICAvLyBhcyB0aGUgc2l6ZSBpbiB0aGUgdGFyYmFsbCwgZXZlbiB0aG91Z2ggRGlyZWN0b3J5IGVudHJpZXMgYXJlXG4gICAgLy8gbm90IGFibGUgdG8gaGF2ZSBhbnkgYm9keSBhdCBhbGwuICBJbiB0aGUgdmVyeSByYXJlIGNoYW5jZSB0aGF0XG4gICAgLy8gaXQgYWN0dWFsbHkgRE9FUyBoYXZlIGEgYm9keSwgd2Ugd2VyZW4ndCBnb2luZyB0byBkbyBhbnl0aGluZyB3aXRoXG4gICAgLy8gaXQgYW55d2F5LCBhbmQgaXQnbGwganVzdCBiZSBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCBoZWFkZXIuXG4gICAgaWYgKHRoaXNbVFlQRV0gPT09ICc1JylcbiAgICAgIHRoaXMuc2l6ZSA9IDBcblxuICAgIHRoaXMubGlua3BhdGggPSBkZWNTdHJpbmcoYnVmLCBvZmYgKyAxNTcsIDEwMClcbiAgICBpZiAoYnVmLnNsaWNlKG9mZiArIDI1Nywgb2ZmICsgMjY1KS50b1N0cmluZygpID09PSAndXN0YXJcXHUwMDAwMDAnKSB7XG4gICAgICB0aGlzLnVuYW1lID0gZGVjU3RyaW5nKGJ1Ziwgb2ZmICsgMjY1LCAzMilcbiAgICAgIHRoaXMuZ25hbWUgPSBkZWNTdHJpbmcoYnVmLCBvZmYgKyAyOTcsIDMyKVxuICAgICAgdGhpcy5kZXZtYWogPSBkZWNOdW1iZXIoYnVmLCBvZmYgKyAzMjksIDgpXG4gICAgICB0aGlzLmRldm1pbiA9IGRlY051bWJlcihidWYsIG9mZiArIDMzNywgOClcbiAgICAgIGlmIChidWZbb2ZmICsgNDc1XSAhPT0gMCkge1xuICAgICAgICAvLyBkZWZpbml0ZWx5IGEgcHJlZml4LCBkZWZpbml0ZWx5ID4xMzAgY2hhcnMuXG4gICAgICAgIGNvbnN0IHByZWZpeCA9IGRlY1N0cmluZyhidWYsIG9mZiArIDM0NSwgMTU1KVxuICAgICAgICB0aGlzLnBhdGggPSBwcmVmaXggKyAnLycgKyB0aGlzLnBhdGhcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IGRlY1N0cmluZyhidWYsIG9mZiArIDM0NSwgMTMwKVxuICAgICAgICBpZiAocHJlZml4KVxuICAgICAgICAgIHRoaXMucGF0aCA9IHByZWZpeCArICcvJyArIHRoaXMucGF0aFxuICAgICAgICB0aGlzLmF0aW1lID0gZGVjRGF0ZShidWYsIG9mZiArIDQ3NiwgMTIpXG4gICAgICAgIHRoaXMuY3RpbWUgPSBkZWNEYXRlKGJ1Ziwgb2ZmICsgNDg4LCAxMilcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgc3VtID0gOCAqIDB4MjBcbiAgICBmb3IgKGxldCBpID0gb2ZmOyBpIDwgb2ZmICsgMTQ4OyBpKyspIHtcbiAgICAgIHN1bSArPSBidWZbaV1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IG9mZiArIDE1NjsgaSA8IG9mZiArIDUxMjsgaSsrKSB7XG4gICAgICBzdW0gKz0gYnVmW2ldXG4gICAgfVxuICAgIHRoaXMuY2tzdW1WYWxpZCA9IHN1bSA9PT0gdGhpcy5ja3N1bVxuICAgIGlmICh0aGlzLmNrc3VtID09PSBudWxsICYmIHN1bSA9PT0gOCAqIDB4MjApXG4gICAgICB0aGlzLm51bGxCbG9jayA9IHRydWVcbiAgfVxuXG4gIFtTTFVSUF0gKGV4LCBnbG9iYWwpIHtcbiAgICBmb3IgKGxldCBrIGluIGV4KSB7XG4gICAgICAvLyB3ZSBzbHVycCBpbiBldmVyeXRoaW5nIGV4Y2VwdCBmb3IgdGhlIHBhdGggYXR0cmlidXRlIGluXG4gICAgICAvLyBhIGdsb2JhbCBleHRlbmRlZCBoZWFkZXIsIGJlY2F1c2UgdGhhdCdzIHdlaXJkLlxuICAgICAgaWYgKGV4W2tdICE9PSBudWxsICYmIGV4W2tdICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAhKGdsb2JhbCAmJiBrID09PSAncGF0aCcpKVxuICAgICAgICB0aGlzW2tdID0gZXhba11cbiAgICB9XG4gIH1cblxuICBlbmNvZGUgKGJ1Ziwgb2ZmKSB7XG4gICAgaWYgKCFidWYpIHtcbiAgICAgIGJ1ZiA9IHRoaXMuYmxvY2sgPSBCdWZmZXIuYWxsb2MoNTEyKVxuICAgICAgb2ZmID0gMFxuICAgIH1cblxuICAgIGlmICghb2ZmKVxuICAgICAgb2ZmID0gMFxuXG4gICAgaWYgKCEoYnVmLmxlbmd0aCA+PSBvZmYgKyA1MTIpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCduZWVkIDUxMiBieXRlcyBmb3IgaGVhZGVyJylcblxuICAgIGNvbnN0IHByZWZpeFNpemUgPSB0aGlzLmN0aW1lIHx8IHRoaXMuYXRpbWUgPyAxMzAgOiAxNTVcbiAgICBjb25zdCBzcGxpdCA9IHNwbGl0UHJlZml4KHRoaXMucGF0aCB8fCAnJywgcHJlZml4U2l6ZSlcbiAgICBjb25zdCBwYXRoID0gc3BsaXRbMF1cbiAgICBjb25zdCBwcmVmaXggPSBzcGxpdFsxXVxuICAgIHRoaXMubmVlZFBheCA9IHNwbGl0WzJdXG5cbiAgICB0aGlzLm5lZWRQYXggPSBlbmNTdHJpbmcoYnVmLCBvZmYsIDEwMCwgcGF0aCkgfHwgdGhpcy5uZWVkUGF4XG4gICAgdGhpcy5uZWVkUGF4ID0gZW5jTnVtYmVyKGJ1Ziwgb2ZmICsgMTAwLCA4LCB0aGlzLm1vZGUpIHx8IHRoaXMubmVlZFBheFxuICAgIHRoaXMubmVlZFBheCA9IGVuY051bWJlcihidWYsIG9mZiArIDEwOCwgOCwgdGhpcy51aWQpIHx8IHRoaXMubmVlZFBheFxuICAgIHRoaXMubmVlZFBheCA9IGVuY051bWJlcihidWYsIG9mZiArIDExNiwgOCwgdGhpcy5naWQpIHx8IHRoaXMubmVlZFBheFxuICAgIHRoaXMubmVlZFBheCA9IGVuY051bWJlcihidWYsIG9mZiArIDEyNCwgMTIsIHRoaXMuc2l6ZSkgfHwgdGhpcy5uZWVkUGF4XG4gICAgdGhpcy5uZWVkUGF4ID0gZW5jRGF0ZShidWYsIG9mZiArIDEzNiwgMTIsIHRoaXMubXRpbWUpIHx8IHRoaXMubmVlZFBheFxuICAgIGJ1ZltvZmYgKyAxNTZdID0gdGhpc1tUWVBFXS5jaGFyQ29kZUF0KDApXG4gICAgdGhpcy5uZWVkUGF4ID0gZW5jU3RyaW5nKGJ1Ziwgb2ZmICsgMTU3LCAxMDAsIHRoaXMubGlua3BhdGgpIHx8IHRoaXMubmVlZFBheFxuICAgIGJ1Zi53cml0ZSgndXN0YXJcXHUwMDAwMDAnLCBvZmYgKyAyNTcsIDgpXG4gICAgdGhpcy5uZWVkUGF4ID0gZW5jU3RyaW5nKGJ1Ziwgb2ZmICsgMjY1LCAzMiwgdGhpcy51bmFtZSkgfHwgdGhpcy5uZWVkUGF4XG4gICAgdGhpcy5uZWVkUGF4ID0gZW5jU3RyaW5nKGJ1Ziwgb2ZmICsgMjk3LCAzMiwgdGhpcy5nbmFtZSkgfHwgdGhpcy5uZWVkUGF4XG4gICAgdGhpcy5uZWVkUGF4ID0gZW5jTnVtYmVyKGJ1Ziwgb2ZmICsgMzI5LCA4LCB0aGlzLmRldm1haikgfHwgdGhpcy5uZWVkUGF4XG4gICAgdGhpcy5uZWVkUGF4ID0gZW5jTnVtYmVyKGJ1Ziwgb2ZmICsgMzM3LCA4LCB0aGlzLmRldm1pbikgfHwgdGhpcy5uZWVkUGF4XG4gICAgdGhpcy5uZWVkUGF4ID0gZW5jU3RyaW5nKGJ1Ziwgb2ZmICsgMzQ1LCBwcmVmaXhTaXplLCBwcmVmaXgpIHx8IHRoaXMubmVlZFBheFxuICAgIGlmIChidWZbb2ZmICsgNDc1XSAhPT0gMClcbiAgICAgIHRoaXMubmVlZFBheCA9IGVuY1N0cmluZyhidWYsIG9mZiArIDM0NSwgMTU1LCBwcmVmaXgpIHx8IHRoaXMubmVlZFBheFxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5uZWVkUGF4ID0gZW5jU3RyaW5nKGJ1Ziwgb2ZmICsgMzQ1LCAxMzAsIHByZWZpeCkgfHwgdGhpcy5uZWVkUGF4XG4gICAgICB0aGlzLm5lZWRQYXggPSBlbmNEYXRlKGJ1Ziwgb2ZmICsgNDc2LCAxMiwgdGhpcy5hdGltZSkgfHwgdGhpcy5uZWVkUGF4XG4gICAgICB0aGlzLm5lZWRQYXggPSBlbmNEYXRlKGJ1Ziwgb2ZmICsgNDg4LCAxMiwgdGhpcy5jdGltZSkgfHwgdGhpcy5uZWVkUGF4XG4gICAgfVxuXG4gICAgbGV0IHN1bSA9IDggKiAweDIwXG4gICAgZm9yIChsZXQgaSA9IG9mZjsgaSA8IG9mZiArIDE0ODsgaSsrKSB7XG4gICAgICBzdW0gKz0gYnVmW2ldXG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBvZmYgKyAxNTY7IGkgPCBvZmYgKyA1MTI7IGkrKykge1xuICAgICAgc3VtICs9IGJ1ZltpXVxuICAgIH1cbiAgICB0aGlzLmNrc3VtID0gc3VtXG4gICAgZW5jTnVtYmVyKGJ1Ziwgb2ZmICsgMTQ4LCA4LCB0aGlzLmNrc3VtKVxuICAgIHRoaXMuY2tzdW1WYWxpZCA9IHRydWVcblxuICAgIHJldHVybiB0aGlzLm5lZWRQYXhcbiAgfVxuXG4gIHNldCAoZGF0YSkge1xuICAgIGZvciAobGV0IGkgaW4gZGF0YSkge1xuICAgICAgaWYgKGRhdGFbaV0gIT09IG51bGwgJiYgZGF0YVtpXSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICB0aGlzW2ldID0gZGF0YVtpXVxuICAgIH1cbiAgfVxuXG4gIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gdHlwZXMubmFtZS5nZXQodGhpc1tUWVBFXSkgfHwgdGhpc1tUWVBFXVxuICB9XG5cbiAgZ2V0IHR5cGVLZXkgKCkge1xuICAgIHJldHVybiB0aGlzW1RZUEVdXG4gIH1cblxuICBzZXQgdHlwZSAodHlwZSkge1xuICAgIGlmICh0eXBlcy5jb2RlLmhhcyh0eXBlKSlcbiAgICAgIHRoaXNbVFlQRV0gPSB0eXBlcy5jb2RlLmdldCh0eXBlKVxuICAgIGVsc2VcbiAgICAgIHRoaXNbVFlQRV0gPSB0eXBlXG4gIH1cbn1cblxuY29uc3Qgc3BsaXRQcmVmaXggPSAocCwgcHJlZml4U2l6ZSkgPT4ge1xuICBjb25zdCBwYXRoU2l6ZSA9IDEwMFxuICBsZXQgcHAgPSBwXG4gIGxldCBwcmVmaXggPSAnJ1xuICBsZXQgcmV0XG4gIGNvbnN0IHJvb3QgPSBwYXRoTW9kdWxlLnBhcnNlKHApLnJvb3QgfHwgJy4nXG5cbiAgaWYgKEJ1ZmZlci5ieXRlTGVuZ3RoKHBwKSA8IHBhdGhTaXplKVxuICAgIHJldCA9IFtwcCwgcHJlZml4LCBmYWxzZV1cbiAgZWxzZSB7XG4gICAgLy8gZmlyc3Qgc2V0IHByZWZpeCB0byB0aGUgZGlyLCBhbmQgcGF0aCB0byB0aGUgYmFzZVxuICAgIHByZWZpeCA9IHBhdGhNb2R1bGUuZGlybmFtZShwcClcbiAgICBwcCA9IHBhdGhNb2R1bGUuYmFzZW5hbWUocHApXG5cbiAgICBkbyB7XG4gICAgICAvLyBib3RoIGZpdCFcbiAgICAgIGlmIChCdWZmZXIuYnl0ZUxlbmd0aChwcCkgPD0gcGF0aFNpemUgJiZcbiAgICAgICAgICBCdWZmZXIuYnl0ZUxlbmd0aChwcmVmaXgpIDw9IHByZWZpeFNpemUpXG4gICAgICAgIHJldCA9IFtwcCwgcHJlZml4LCBmYWxzZV1cblxuICAgICAgLy8gcHJlZml4IGZpdHMgaW4gcHJlZml4LCBidXQgcGF0aCBkb2Vzbid0IGZpdCBpbiBwYXRoXG4gICAgICBlbHNlIGlmIChCdWZmZXIuYnl0ZUxlbmd0aChwcCkgPiBwYXRoU2l6ZSAmJlxuICAgICAgICAgIEJ1ZmZlci5ieXRlTGVuZ3RoKHByZWZpeCkgPD0gcHJlZml4U2l6ZSlcbiAgICAgICAgcmV0ID0gW3BwLnN1YnN0cigwLCBwYXRoU2l6ZSAtIDEpLCBwcmVmaXgsIHRydWVdXG5cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBtYWtlIHBhdGggdGFrZSBhIGJpdCBmcm9tIHByZWZpeFxuICAgICAgICBwcCA9IHBhdGhNb2R1bGUuam9pbihwYXRoTW9kdWxlLmJhc2VuYW1lKHByZWZpeCksIHBwKVxuICAgICAgICBwcmVmaXggPSBwYXRoTW9kdWxlLmRpcm5hbWUocHJlZml4KVxuICAgICAgfVxuICAgIH0gd2hpbGUgKHByZWZpeCAhPT0gcm9vdCAmJiAhcmV0KVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZm91bmQgbm8gcmVzb2x1dGlvbiwganVzdCB0cnVuY2F0ZVxuICAgIGlmICghcmV0KVxuICAgICAgcmV0ID0gW3Auc3Vic3RyKDAsIHBhdGhTaXplIC0gMSksICcnLCB0cnVlXVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuY29uc3QgZGVjU3RyaW5nID0gKGJ1Ziwgb2ZmLCBzaXplKSA9PlxuICBidWYuc2xpY2Uob2ZmLCBvZmYgKyBzaXplKS50b1N0cmluZygndXRmOCcpLnJlcGxhY2UoL1xcMC4qLywgJycpXG5cbmNvbnN0IGRlY0RhdGUgPSAoYnVmLCBvZmYsIHNpemUpID0+XG4gIG51bVRvRGF0ZShkZWNOdW1iZXIoYnVmLCBvZmYsIHNpemUpKVxuXG5jb25zdCBudW1Ub0RhdGUgPSBudW0gPT4gbnVtID09PSBudWxsID8gbnVsbCA6IG5ldyBEYXRlKG51bSAqIDEwMDApXG5cbmNvbnN0IGRlY051bWJlciA9IChidWYsIG9mZiwgc2l6ZSkgPT5cbiAgYnVmW29mZl0gJiAweDgwID8gbGFyZ2UucGFyc2UoYnVmLnNsaWNlKG9mZiwgb2ZmICsgc2l6ZSkpXG4gICAgOiBkZWNTbWFsbE51bWJlcihidWYsIG9mZiwgc2l6ZSlcblxuY29uc3QgbmFuTnVsbCA9IHZhbHVlID0+IGlzTmFOKHZhbHVlKSA/IG51bGwgOiB2YWx1ZVxuXG5jb25zdCBkZWNTbWFsbE51bWJlciA9IChidWYsIG9mZiwgc2l6ZSkgPT5cbiAgbmFuTnVsbChwYXJzZUludChcbiAgICBidWYuc2xpY2Uob2ZmLCBvZmYgKyBzaXplKVxuICAgICAgLnRvU3RyaW5nKCd1dGY4JykucmVwbGFjZSgvXFwwLiokLywgJycpLnRyaW0oKSwgOCkpXG5cbi8vIHRoZSBtYXhpbXVtIGVuY29kYWJsZSBhcyBhIG51bGwtdGVybWluYXRlZCBvY3RhbCwgYnkgZmllbGQgc2l6ZVxuY29uc3QgTUFYTlVNID0ge1xuICAxMjogMG83Nzc3Nzc3Nzc3NyxcbiAgOCA6IDBvNzc3Nzc3N1xufVxuXG5jb25zdCBlbmNOdW1iZXIgPSAoYnVmLCBvZmYsIHNpemUsIG51bWJlcikgPT5cbiAgbnVtYmVyID09PSBudWxsID8gZmFsc2UgOlxuICBudW1iZXIgPiBNQVhOVU1bc2l6ZV0gfHwgbnVtYmVyIDwgMFxuICAgID8gKGxhcmdlLmVuY29kZShudW1iZXIsIGJ1Zi5zbGljZShvZmYsIG9mZiArIHNpemUpKSwgdHJ1ZSlcbiAgICA6IChlbmNTbWFsbE51bWJlcihidWYsIG9mZiwgc2l6ZSwgbnVtYmVyKSwgZmFsc2UpXG5cbmNvbnN0IGVuY1NtYWxsTnVtYmVyID0gKGJ1Ziwgb2ZmLCBzaXplLCBudW1iZXIpID0+XG4gIGJ1Zi53cml0ZShvY3RhbFN0cmluZyhudW1iZXIsIHNpemUpLCBvZmYsIHNpemUsICdhc2NpaScpXG5cbmNvbnN0IG9jdGFsU3RyaW5nID0gKG51bWJlciwgc2l6ZSkgPT5cbiAgcGFkT2N0YWwoTWF0aC5mbG9vcihudW1iZXIpLnRvU3RyaW5nKDgpLCBzaXplKVxuXG5jb25zdCBwYWRPY3RhbCA9IChzdHJpbmcsIHNpemUpID0+XG4gIChzdHJpbmcubGVuZ3RoID09PSBzaXplIC0gMSA/IHN0cmluZ1xuICA6IG5ldyBBcnJheShzaXplIC0gc3RyaW5nLmxlbmd0aCAtIDEpLmpvaW4oJzAnKSArIHN0cmluZyArICcgJykgKyAnXFwwJ1xuXG5jb25zdCBlbmNEYXRlID0gKGJ1Ziwgb2ZmLCBzaXplLCBkYXRlKSA9PlxuICBkYXRlID09PSBudWxsID8gZmFsc2UgOlxuICBlbmNOdW1iZXIoYnVmLCBvZmYsIHNpemUsIGRhdGUuZ2V0VGltZSgpIC8gMTAwMClcblxuLy8gZW5vdWdoIHRvIGZpbGwgdGhlIGxvbmdlc3Qgc3RyaW5nIHdlJ3ZlIGdvdFxuY29uc3QgTlVMTFMgPSBuZXcgQXJyYXkoMTU2KS5qb2luKCdcXDAnKVxuLy8gcGFkIHdpdGggbnVsbHMsIHJldHVybiB0cnVlIGlmIGl0J3MgbG9uZ2VyIG9yIG5vbi1hc2NpaVxuY29uc3QgZW5jU3RyaW5nID0gKGJ1Ziwgb2ZmLCBzaXplLCBzdHJpbmcpID0+XG4gIHN0cmluZyA9PT0gbnVsbCA/IGZhbHNlIDpcbiAgKGJ1Zi53cml0ZShzdHJpbmcgKyBOVUxMUywgb2ZmLCBzaXplLCAndXRmOCcpLFxuICAgc3RyaW5nLmxlbmd0aCAhPT0gQnVmZmVyLmJ5dGVMZW5ndGgoc3RyaW5nKSB8fCBzdHJpbmcubGVuZ3RoID4gc2l6ZSlcblxubW9kdWxlLmV4cG9ydHMgPSBIZWFkZXJcbiIsIid1c2Ugc3RyaWN0J1xuXG4vLyB0dXJuIHRhcigxKSBzdHlsZSBhcmdzIGxpa2UgYENgIGludG8gdGhlIG1vcmUgdmVyYm9zZSB0aGluZ3MgbGlrZSBgY3dkYFxuXG5jb25zdCBhcmdtYXAgPSBuZXcgTWFwKFtcbiAgWydDJywgJ2N3ZCddLFxuICBbJ2YnLCAnZmlsZSddLFxuICBbJ3onLCAnZ3ppcCddLFxuICBbJ1AnLCAncHJlc2VydmVQYXRocyddLFxuICBbJ1UnLCAndW5saW5rJ10sXG4gIFsnc3RyaXAtY29tcG9uZW50cycsICdzdHJpcCddLFxuICBbJ3N0cmlwQ29tcG9uZW50cycsICdzdHJpcCddLFxuICBbJ2tlZXAtbmV3ZXInLCAnbmV3ZXInXSxcbiAgWydrZWVwTmV3ZXInLCAnbmV3ZXInXSxcbiAgWydrZWVwLW5ld2VyLWZpbGVzJywgJ25ld2VyJ10sXG4gIFsna2VlcE5ld2VyRmlsZXMnLCAnbmV3ZXInXSxcbiAgWydrJywgJ2tlZXAnXSxcbiAgWydrZWVwLWV4aXN0aW5nJywgJ2tlZXAnXSxcbiAgWydrZWVwRXhpc3RpbmcnLCAna2VlcCddLFxuICBbJ20nLCAnbm9NdGltZSddLFxuICBbJ25vLW10aW1lJywgJ25vTXRpbWUnXSxcbiAgWydwJywgJ3ByZXNlcnZlT3duZXInXSxcbiAgWydMJywgJ2ZvbGxvdyddLFxuICBbJ2gnLCAnZm9sbG93J11cbl0pXG5cbmNvbnN0IHBhcnNlID0gbW9kdWxlLmV4cG9ydHMgPSBvcHQgPT4gb3B0ID8gT2JqZWN0LmtleXMob3B0KS5tYXAoayA9PiBbXG4gIGFyZ21hcC5oYXMoaykgPyBhcmdtYXAuZ2V0KGspIDogaywgb3B0W2tdXG5dKS5yZWR1Y2UoKHNldCwga3YpID0+IChzZXRba3ZbMF1dID0ga3ZbMV0sIHNldCksIE9iamVjdC5jcmVhdGUobnVsbCkpIDoge31cbiIsIid1c2Ugc3RyaWN0J1xuLy8gVGFyIGNhbiBlbmNvZGUgbGFyZ2UgYW5kIG5lZ2F0aXZlIG51bWJlcnMgdXNpbmcgYSBsZWFkaW5nIGJ5dGUgb2Zcbi8vIDB4ZmYgZm9yIG5lZ2F0aXZlLCBhbmQgMHg4MCBmb3IgcG9zaXRpdmUuXG5cbmNvbnN0IGVuY29kZSA9IGV4cG9ydHMuZW5jb2RlID0gKG51bSwgYnVmKSA9PiB7XG4gIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobnVtKSlcbiAgICAvLyBUaGUgbnVtYmVyIGlzIHNvIGxhcmdlIHRoYXQgamF2YXNjcmlwdCBjYW5ub3QgcmVwcmVzZW50IGl0IHdpdGggaW50ZWdlclxuICAgIC8vIHByZWNpc2lvbi5cbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2Nhbm5vdCBlbmNvZGUgbnVtYmVyIG91dHNpZGUgb2YgamF2YXNjcmlwdCBzYWZlIGludGVnZXIgcmFuZ2UnKVxuICBlbHNlIGlmIChudW0gPCAwKVxuICAgIGVuY29kZU5lZ2F0aXZlKG51bSwgYnVmKVxuICBlbHNlXG4gICAgZW5jb2RlUG9zaXRpdmUobnVtLCBidWYpXG4gIHJldHVybiBidWZcbn1cblxuY29uc3QgZW5jb2RlUG9zaXRpdmUgPSAobnVtLCBidWYpID0+IHtcbiAgYnVmWzBdID0gMHg4MFxuXG4gIGZvciAodmFyIGkgPSBidWYubGVuZ3RoOyBpID4gMTsgaS0tKSB7XG4gICAgYnVmW2ktMV0gPSBudW0gJiAweGZmXG4gICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyAweDEwMClcbiAgfVxufVxuXG5jb25zdCBlbmNvZGVOZWdhdGl2ZSA9IChudW0sIGJ1ZikgPT4ge1xuICBidWZbMF0gPSAweGZmXG4gIHZhciBmbGlwcGVkID0gZmFsc2VcbiAgbnVtID0gbnVtICogLTFcbiAgZm9yICh2YXIgaSA9IGJ1Zi5sZW5ndGg7IGkgPiAxOyBpLS0pIHtcbiAgICB2YXIgYnl0ZSA9IG51bSAmIDB4ZmZcbiAgICBudW0gPSBNYXRoLmZsb29yKG51bSAvIDB4MTAwKVxuICAgIGlmIChmbGlwcGVkKVxuICAgICAgYnVmW2ktMV0gPSBvbmVzQ29tcChieXRlKVxuICAgIGVsc2UgaWYgKGJ5dGUgPT09IDApXG4gICAgICBidWZbaS0xXSA9IDBcbiAgICBlbHNlIHtcbiAgICAgIGZsaXBwZWQgPSB0cnVlXG4gICAgICBidWZbaS0xXSA9IHR3b3NDb21wKGJ5dGUpXG4gICAgfVxuICB9XG59XG5cbmNvbnN0IHBhcnNlID0gZXhwb3J0cy5wYXJzZSA9IChidWYpID0+IHtcbiAgdmFyIHBvc3QgPSBidWZbYnVmLmxlbmd0aCAtIDFdXG4gIHZhciBwcmUgPSBidWZbMF1cbiAgdmFyIHZhbHVlO1xuICBpZiAocHJlID09PSAweDgwKVxuICAgIHZhbHVlID0gcG9zKGJ1Zi5zbGljZSgxLCBidWYubGVuZ3RoKSlcbiAgZWxzZSBpZiAocHJlID09PSAweGZmKVxuICAgIHZhbHVlID0gdHdvcyhidWYpXG4gIGVsc2VcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2ludmFsaWQgYmFzZTI1NiBlbmNvZGluZycpXG5cbiAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSkpXG4gICAgLy8gVGhlIG51bWJlciBpcyBzbyBsYXJnZSB0aGF0IGphdmFzY3JpcHQgY2Fubm90IHJlcHJlc2VudCBpdCB3aXRoIGludGVnZXJcbiAgICAvLyBwcmVjaXNpb24uXG4gICAgdGhyb3cgVHlwZUVycm9yKCdwYXJzZWQgbnVtYmVyIG91dHNpZGUgb2YgamF2YXNjcmlwdCBzYWZlIGludGVnZXIgcmFuZ2UnKVxuXG4gIHJldHVybiB2YWx1ZVxufVxuXG5jb25zdCB0d29zID0gKGJ1ZikgPT4ge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICB2YXIgc3VtID0gMFxuICB2YXIgZmxpcHBlZCA9IGZhbHNlXG4gIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID4gLTE7IGktLSkge1xuICAgIHZhciBieXRlID0gYnVmW2ldXG4gICAgdmFyIGZcbiAgICBpZiAoZmxpcHBlZClcbiAgICAgIGYgPSBvbmVzQ29tcChieXRlKVxuICAgIGVsc2UgaWYgKGJ5dGUgPT09IDApXG4gICAgICBmID0gYnl0ZVxuICAgIGVsc2Uge1xuICAgICAgZmxpcHBlZCA9IHRydWVcbiAgICAgIGYgPSB0d29zQ29tcChieXRlKVxuICAgIH1cbiAgICBpZiAoZiAhPT0gMClcbiAgICAgIHN1bSAtPSBmICogTWF0aC5wb3coMjU2LCBsZW4gLSBpIC0gMSlcbiAgfVxuICByZXR1cm4gc3VtXG59XG5cbmNvbnN0IHBvcyA9IChidWYpID0+IHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgdmFyIHN1bSA9IDBcbiAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPiAtMTsgaS0tKSB7XG4gICAgdmFyIGJ5dGUgPSBidWZbaV1cbiAgICBpZiAoYnl0ZSAhPT0gMClcbiAgICAgIHN1bSArPSBieXRlICogTWF0aC5wb3coMjU2LCBsZW4gLSBpIC0gMSlcbiAgfVxuICByZXR1cm4gc3VtXG59XG5cbmNvbnN0IG9uZXNDb21wID0gYnl0ZSA9PiAoMHhmZiBeIGJ5dGUpICYgMHhmZlxuXG5jb25zdCB0d29zQ29tcCA9IGJ5dGUgPT4gKCgweGZmIF4gYnl0ZSkgKyAxKSAmIDB4ZmZcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBCdWZmZXIgPSByZXF1aXJlKCcuL2J1ZmZlci5qcycpXG5cbi8vIFhYWDogVGhpcyBzaGFyZXMgYSBsb3QgaW4gY29tbW9uIHdpdGggZXh0cmFjdC5qc1xuLy8gbWF5YmUgc29tZSBEUlkgb3Bwb3J0dW5pdHkgaGVyZT9cblxuLy8gdGFyIC10XG5jb25zdCBobG8gPSByZXF1aXJlKCcuL2hpZ2gtbGV2ZWwtb3B0LmpzJylcbmNvbnN0IFBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2UuanMnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCBmc20gPSByZXF1aXJlKCdmcy1taW5pcGFzcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5cbmNvbnN0IHQgPSBtb2R1bGUuZXhwb3J0cyA9IChvcHRfLCBmaWxlcywgY2IpID0+IHtcbiAgaWYgKHR5cGVvZiBvcHRfID09PSAnZnVuY3Rpb24nKVxuICAgIGNiID0gb3B0XywgZmlsZXMgPSBudWxsLCBvcHRfID0ge31cbiAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvcHRfKSlcbiAgICBmaWxlcyA9IG9wdF8sIG9wdF8gPSB7fVxuXG4gIGlmICh0eXBlb2YgZmlsZXMgPT09ICdmdW5jdGlvbicpXG4gICAgY2IgPSBmaWxlcywgZmlsZXMgPSBudWxsXG5cbiAgaWYgKCFmaWxlcylcbiAgICBmaWxlcyA9IFtdXG4gIGVsc2VcbiAgICBmaWxlcyA9IEFycmF5LmZyb20oZmlsZXMpXG5cbiAgY29uc3Qgb3B0ID0gaGxvKG9wdF8pXG5cbiAgaWYgKG9wdC5zeW5jICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBub3Qgc3VwcG9ydGVkIGZvciBzeW5jIHRhciBmdW5jdGlvbnMnKVxuXG4gIGlmICghb3B0LmZpbGUgJiYgdHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhbGxiYWNrIG9ubHkgc3VwcG9ydGVkIHdpdGggZmlsZSBvcHRpb24nKVxuXG4gIGlmIChmaWxlcy5sZW5ndGgpXG4gICAgZmlsZXNGaWx0ZXIob3B0LCBmaWxlcylcblxuICBpZiAoIW9wdC5ub1Jlc3VtZSlcbiAgICBvbmVudHJ5RnVuY3Rpb24ob3B0KVxuXG4gIHJldHVybiBvcHQuZmlsZSAmJiBvcHQuc3luYyA/IGxpc3RGaWxlU3luYyhvcHQpXG4gICAgOiBvcHQuZmlsZSA/IGxpc3RGaWxlKG9wdCwgY2IpXG4gICAgOiBsaXN0KG9wdClcbn1cblxuY29uc3Qgb25lbnRyeUZ1bmN0aW9uID0gb3B0ID0+IHtcbiAgY29uc3Qgb25lbnRyeSA9IG9wdC5vbmVudHJ5XG4gIG9wdC5vbmVudHJ5ID0gb25lbnRyeSA/IGUgPT4ge1xuICAgIG9uZW50cnkoZSlcbiAgICBlLnJlc3VtZSgpXG4gIH0gOiBlID0+IGUucmVzdW1lKClcbn1cblxuLy8gY29uc3RydWN0IGEgZmlsdGVyIHRoYXQgbGltaXRzIHRoZSBmaWxlIGVudHJpZXMgbGlzdGVkXG4vLyBpbmNsdWRlIGNoaWxkIGVudHJpZXMgaWYgYSBkaXIgaXMgaW5jbHVkZWRcbmNvbnN0IGZpbGVzRmlsdGVyID0gKG9wdCwgZmlsZXMpID0+IHtcbiAgY29uc3QgbWFwID0gbmV3IE1hcChmaWxlcy5tYXAoZiA9PiBbZi5yZXBsYWNlKC9cXC8rJC8sICcnKSwgdHJ1ZV0pKVxuICBjb25zdCBmaWx0ZXIgPSBvcHQuZmlsdGVyXG5cbiAgY29uc3QgbWFwSGFzID0gKGZpbGUsIHIpID0+IHtcbiAgICBjb25zdCByb290ID0gciB8fCBwYXRoLnBhcnNlKGZpbGUpLnJvb3QgfHwgJy4nXG4gICAgY29uc3QgcmV0ID0gZmlsZSA9PT0gcm9vdCA/IGZhbHNlXG4gICAgICA6IG1hcC5oYXMoZmlsZSkgPyBtYXAuZ2V0KGZpbGUpXG4gICAgICA6IG1hcEhhcyhwYXRoLmRpcm5hbWUoZmlsZSksIHJvb3QpXG5cbiAgICBtYXAuc2V0KGZpbGUsIHJldClcbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBvcHQuZmlsdGVyID0gZmlsdGVyXG4gICAgPyAoZmlsZSwgZW50cnkpID0+IGZpbHRlcihmaWxlLCBlbnRyeSkgJiYgbWFwSGFzKGZpbGUucmVwbGFjZSgvXFwvKyQvLCAnJykpXG4gICAgOiBmaWxlID0+IG1hcEhhcyhmaWxlLnJlcGxhY2UoL1xcLyskLywgJycpKVxufVxuXG5jb25zdCBsaXN0RmlsZVN5bmMgPSBvcHQgPT4ge1xuICBjb25zdCBwID0gbGlzdChvcHQpXG4gIGNvbnN0IGZpbGUgPSBvcHQuZmlsZVxuICBsZXQgdGhyZXcgPSB0cnVlXG4gIGxldCBmZFxuICB0cnkge1xuICAgIGNvbnN0IHN0YXQgPSBmcy5zdGF0U3luYyhmaWxlKVxuICAgIGNvbnN0IHJlYWRTaXplID0gb3B0Lm1heFJlYWRTaXplIHx8IDE2KjEwMjQqMTAyNFxuICAgIGlmIChzdGF0LnNpemUgPCByZWFkU2l6ZSkge1xuICAgICAgcC5lbmQoZnMucmVhZEZpbGVTeW5jKGZpbGUpKVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcG9zID0gMFxuICAgICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKHJlYWRTaXplKVxuICAgICAgZmQgPSBmcy5vcGVuU3luYyhmaWxlLCAncicpXG4gICAgICB3aGlsZSAocG9zIDwgc3RhdC5zaXplKSB7XG4gICAgICAgIGxldCBieXRlc1JlYWQgPSBmcy5yZWFkU3luYyhmZCwgYnVmLCAwLCByZWFkU2l6ZSwgcG9zKVxuICAgICAgICBwb3MgKz0gYnl0ZXNSZWFkXG4gICAgICAgIHAud3JpdGUoYnVmLnNsaWNlKDAsIGJ5dGVzUmVhZCkpXG4gICAgICB9XG4gICAgICBwLmVuZCgpXG4gICAgfVxuICAgIHRocmV3ID0gZmFsc2VcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAodGhyZXcgJiYgZmQpXG4gICAgICB0cnkgeyBmcy5jbG9zZVN5bmMoZmQpIH0gY2F0Y2ggKGVyKSB7fVxuICB9XG59XG5cbmNvbnN0IGxpc3RGaWxlID0gKG9wdCwgY2IpID0+IHtcbiAgY29uc3QgcGFyc2UgPSBuZXcgUGFyc2VyKG9wdClcbiAgY29uc3QgcmVhZFNpemUgPSBvcHQubWF4UmVhZFNpemUgfHwgMTYqMTAyNCoxMDI0XG5cbiAgY29uc3QgZmlsZSA9IG9wdC5maWxlXG4gIGNvbnN0IHAgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcGFyc2Uub24oJ2Vycm9yJywgcmVqZWN0KVxuICAgIHBhcnNlLm9uKCdlbmQnLCByZXNvbHZlKVxuXG4gICAgZnMuc3RhdChmaWxlLCAoZXIsIHN0YXQpID0+IHtcbiAgICAgIGlmIChlcilcbiAgICAgICAgcmVqZWN0KGVyKVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBmc20uUmVhZFN0cmVhbShmaWxlLCB7XG4gICAgICAgICAgcmVhZFNpemU6IHJlYWRTaXplLFxuICAgICAgICAgIHNpemU6IHN0YXQuc2l6ZVxuICAgICAgICB9KVxuICAgICAgICBzdHJlYW0ub24oJ2Vycm9yJywgcmVqZWN0KVxuICAgICAgICBzdHJlYW0ucGlwZShwYXJzZSlcbiAgICAgIH1cbiAgICB9KVxuICB9KVxuICByZXR1cm4gY2IgPyBwLnRoZW4oY2IsIGNiKSA6IHBcbn1cblxuY29uc3QgbGlzdCA9IG9wdCA9PiBuZXcgUGFyc2VyKG9wdClcbiIsIid1c2Ugc3RyaWN0J1xuLy8gd3JhcHBlciBhcm91bmQgbWtkaXJwIGZvciB0YXIncyBuZWVkcy5cblxuLy8gVE9ETzogVGhpcyBzaG91bGQgcHJvYmFibHkgYmUgYSBjbGFzcywgbm90IGZ1bmN0aW9uYWxseVxuLy8gcGFzc2luZyBhcm91bmQgc3RhdGUgaW4gYSBnYXppbGxpb24gYXJncy5cblxuY29uc3QgbWtkaXJwID0gcmVxdWlyZSgnbWtkaXJwJylcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgY2hvd25yID0gcmVxdWlyZSgnY2hvd25yJylcblxuY2xhc3MgU3ltbGlua0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAoc3ltbGluaywgcGF0aCkge1xuICAgIHN1cGVyKCdDYW5ub3QgZXh0cmFjdCB0aHJvdWdoIHN5bWJvbGljIGxpbmsnKVxuICAgIHRoaXMucGF0aCA9IHBhdGhcbiAgICB0aGlzLnN5bWxpbmsgPSBzeW1saW5rXG4gIH1cblxuICBnZXQgbmFtZSAoKSB7XG4gICAgcmV0dXJuICdTeWxpbmtFcnJvcidcbiAgfVxufVxuXG5jbGFzcyBDd2RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IgKHBhdGgsIGNvZGUpIHtcbiAgICBzdXBlcihjb2RlICsgJzogQ2Fubm90IGNkIGludG8gXFwnJyArIHBhdGggKyAnXFwnJylcbiAgICB0aGlzLnBhdGggPSBwYXRoXG4gICAgdGhpcy5jb2RlID0gY29kZVxuICB9XG5cbiAgZ2V0IG5hbWUgKCkge1xuICAgIHJldHVybiAnQ3dkRXJyb3InXG4gIH1cbn1cblxuY29uc3QgbWtkaXIgPSBtb2R1bGUuZXhwb3J0cyA9IChkaXIsIG9wdCwgY2IpID0+IHtcbiAgLy8gaWYgdGhlcmUncyBhbnkgb3ZlcmxhcCBiZXR3ZWVuIG1hc2sgYW5kIG1vZGUsXG4gIC8vIHRoZW4gd2UnbGwgbmVlZCBhbiBleHBsaWNpdCBjaG1vZFxuICBjb25zdCB1bWFzayA9IG9wdC51bWFza1xuICBjb25zdCBtb2RlID0gb3B0Lm1vZGUgfCAwbzA3MDBcbiAgY29uc3QgbmVlZENobW9kID0gKG1vZGUgJiB1bWFzaykgIT09IDBcblxuICBjb25zdCB1aWQgPSBvcHQudWlkXG4gIGNvbnN0IGdpZCA9IG9wdC5naWRcbiAgY29uc3QgZG9DaG93biA9IHR5cGVvZiB1aWQgPT09ICdudW1iZXInICYmXG4gICAgdHlwZW9mIGdpZCA9PT0gJ251bWJlcicgJiZcbiAgICAoIHVpZCAhPT0gb3B0LnByb2Nlc3NVaWQgfHwgZ2lkICE9PSBvcHQucHJvY2Vzc0dpZCApXG5cbiAgY29uc3QgcHJlc2VydmUgPSBvcHQucHJlc2VydmVcbiAgY29uc3QgdW5saW5rID0gb3B0LnVubGlua1xuICBjb25zdCBjYWNoZSA9IG9wdC5jYWNoZVxuICBjb25zdCBjd2QgPSBvcHQuY3dkXG5cbiAgY29uc3QgZG9uZSA9IChlciwgY3JlYXRlZCkgPT4ge1xuICAgIGlmIChlcilcbiAgICAgIGNiKGVyKVxuICAgIGVsc2Uge1xuICAgICAgY2FjaGUuc2V0KGRpciwgdHJ1ZSlcbiAgICAgIGlmIChjcmVhdGVkICYmIGRvQ2hvd24pXG4gICAgICAgIGNob3ducihjcmVhdGVkLCB1aWQsIGdpZCwgZXIgPT4gZG9uZShlcikpXG4gICAgICBlbHNlIGlmIChuZWVkQ2htb2QpXG4gICAgICAgIGZzLmNobW9kKGRpciwgbW9kZSwgY2IpXG4gICAgICBlbHNlXG4gICAgICAgIGNiKClcbiAgICB9XG4gIH1cblxuICBpZiAoY2FjaGUgJiYgY2FjaGUuZ2V0KGRpcikgPT09IHRydWUpXG4gICAgcmV0dXJuIGRvbmUoKVxuXG4gIGlmIChkaXIgPT09IGN3ZClcbiAgICByZXR1cm4gZnMuc3RhdChkaXIsIChlciwgc3QpID0+IHtcbiAgICAgIGlmIChlciB8fCAhc3QuaXNEaXJlY3RvcnkoKSlcbiAgICAgICAgZXIgPSBuZXcgQ3dkRXJyb3IoZGlyLCBlciAmJiBlci5jb2RlIHx8ICdFTk9URElSJylcbiAgICAgIGRvbmUoZXIpXG4gICAgfSlcblxuICBpZiAocHJlc2VydmUpXG4gICAgcmV0dXJuIG1rZGlycChkaXIsIG1vZGUsIGRvbmUpXG5cbiAgY29uc3Qgc3ViID0gcGF0aC5yZWxhdGl2ZShjd2QsIGRpcilcbiAgY29uc3QgcGFydHMgPSBzdWIuc3BsaXQoL1xcL3xcXFxcLylcbiAgbWtkaXJfKGN3ZCwgcGFydHMsIG1vZGUsIGNhY2hlLCB1bmxpbmssIGN3ZCwgbnVsbCwgZG9uZSlcbn1cblxuY29uc3QgbWtkaXJfID0gKGJhc2UsIHBhcnRzLCBtb2RlLCBjYWNoZSwgdW5saW5rLCBjd2QsIGNyZWF0ZWQsIGNiKSA9PiB7XG4gIGlmICghcGFydHMubGVuZ3RoKVxuICAgIHJldHVybiBjYihudWxsLCBjcmVhdGVkKVxuICBjb25zdCBwID0gcGFydHMuc2hpZnQoKVxuICBjb25zdCBwYXJ0ID0gYmFzZSArICcvJyArIHBcbiAgaWYgKGNhY2hlLmdldChwYXJ0KSlcbiAgICByZXR1cm4gbWtkaXJfKHBhcnQsIHBhcnRzLCBtb2RlLCBjYWNoZSwgdW5saW5rLCBjd2QsIGNyZWF0ZWQsIGNiKVxuICBmcy5ta2RpcihwYXJ0LCBtb2RlLCBvbm1rZGlyKHBhcnQsIHBhcnRzLCBtb2RlLCBjYWNoZSwgdW5saW5rLCBjd2QsIGNyZWF0ZWQsIGNiKSlcbn1cblxuY29uc3Qgb25ta2RpciA9IChwYXJ0LCBwYXJ0cywgbW9kZSwgY2FjaGUsIHVubGluaywgY3dkLCBjcmVhdGVkLCBjYikgPT4gZXIgPT4ge1xuICBpZiAoZXIpIHtcbiAgICBpZiAoZXIucGF0aCAmJiBwYXRoLmRpcm5hbWUoZXIucGF0aCkgPT09IGN3ZCAmJlxuICAgICAgICAoZXIuY29kZSA9PT0gJ0VOT1RESVInIHx8IGVyLmNvZGUgPT09ICdFTk9FTlQnKSlcbiAgICAgIHJldHVybiBjYihuZXcgQ3dkRXJyb3IoY3dkLCBlci5jb2RlKSlcblxuICAgIGZzLmxzdGF0KHBhcnQsIChzdGF0RXIsIHN0KSA9PiB7XG4gICAgICBpZiAoc3RhdEVyKVxuICAgICAgICBjYihzdGF0RXIpXG4gICAgICBlbHNlIGlmIChzdC5pc0RpcmVjdG9yeSgpKVxuICAgICAgICBta2Rpcl8ocGFydCwgcGFydHMsIG1vZGUsIGNhY2hlLCB1bmxpbmssIGN3ZCwgY3JlYXRlZCwgY2IpXG4gICAgICBlbHNlIGlmICh1bmxpbmspXG4gICAgICAgIGZzLnVubGluayhwYXJ0LCBlciA9PiB7XG4gICAgICAgICAgaWYgKGVyKVxuICAgICAgICAgICAgcmV0dXJuIGNiKGVyKVxuICAgICAgICAgIGZzLm1rZGlyKHBhcnQsIG1vZGUsIG9ubWtkaXIocGFydCwgcGFydHMsIG1vZGUsIGNhY2hlLCB1bmxpbmssIGN3ZCwgY3JlYXRlZCwgY2IpKVxuICAgICAgICB9KVxuICAgICAgZWxzZSBpZiAoc3QuaXNTeW1ib2xpY0xpbmsoKSlcbiAgICAgICAgcmV0dXJuIGNiKG5ldyBTeW1saW5rRXJyb3IocGFydCwgcGFydCArICcvJyArIHBhcnRzLmpvaW4oJy8nKSkpXG4gICAgICBlbHNlXG4gICAgICAgIGNiKGVyKVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgY3JlYXRlZCA9IGNyZWF0ZWQgfHwgcGFydFxuICAgIG1rZGlyXyhwYXJ0LCBwYXJ0cywgbW9kZSwgY2FjaGUsIHVubGluaywgY3dkLCBjcmVhdGVkLCBjYilcbiAgfVxufVxuXG5jb25zdCBta2RpclN5bmMgPSBtb2R1bGUuZXhwb3J0cy5zeW5jID0gKGRpciwgb3B0KSA9PiB7XG4gIC8vIGlmIHRoZXJlJ3MgYW55IG92ZXJsYXAgYmV0d2VlbiBtYXNrIGFuZCBtb2RlLFxuICAvLyB0aGVuIHdlJ2xsIG5lZWQgYW4gZXhwbGljaXQgY2htb2RcbiAgY29uc3QgdW1hc2sgPSBvcHQudW1hc2tcbiAgY29uc3QgbW9kZSA9IG9wdC5tb2RlIHwgMG8wNzAwXG4gIGNvbnN0IG5lZWRDaG1vZCA9IChtb2RlICYgdW1hc2spICE9PSAwXG5cbiAgY29uc3QgdWlkID0gb3B0LnVpZFxuICBjb25zdCBnaWQgPSBvcHQuZ2lkXG4gIGNvbnN0IGRvQ2hvd24gPSB0eXBlb2YgdWlkID09PSAnbnVtYmVyJyAmJlxuICAgIHR5cGVvZiBnaWQgPT09ICdudW1iZXInICYmXG4gICAgKCB1aWQgIT09IG9wdC5wcm9jZXNzVWlkIHx8IGdpZCAhPT0gb3B0LnByb2Nlc3NHaWQgKVxuXG4gIGNvbnN0IHByZXNlcnZlID0gb3B0LnByZXNlcnZlXG4gIGNvbnN0IHVubGluayA9IG9wdC51bmxpbmtcbiAgY29uc3QgY2FjaGUgPSBvcHQuY2FjaGVcbiAgY29uc3QgY3dkID0gb3B0LmN3ZFxuXG4gIGNvbnN0IGRvbmUgPSAoY3JlYXRlZCkgPT4ge1xuICAgIGNhY2hlLnNldChkaXIsIHRydWUpXG4gICAgaWYgKGNyZWF0ZWQgJiYgZG9DaG93bilcbiAgICAgIGNob3duci5zeW5jKGNyZWF0ZWQsIHVpZCwgZ2lkKVxuICAgIGlmIChuZWVkQ2htb2QpXG4gICAgICBmcy5jaG1vZFN5bmMoZGlyLCBtb2RlKVxuICB9XG5cbiAgaWYgKGNhY2hlICYmIGNhY2hlLmdldChkaXIpID09PSB0cnVlKVxuICAgIHJldHVybiBkb25lKClcblxuICBpZiAoZGlyID09PSBjd2QpIHtcbiAgICBsZXQgb2sgPSBmYWxzZVxuICAgIGxldCBjb2RlID0gJ0VOT1RESVInXG4gICAgdHJ5IHtcbiAgICAgIG9rID0gZnMuc3RhdFN5bmMoZGlyKS5pc0RpcmVjdG9yeSgpXG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIGNvZGUgPSBlci5jb2RlXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICghb2spXG4gICAgICAgIHRocm93IG5ldyBDd2RFcnJvcihkaXIsIGNvZGUpXG4gICAgfVxuICAgIGRvbmUoKVxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHByZXNlcnZlKVxuICAgIHJldHVybiBkb25lKG1rZGlycC5zeW5jKGRpciwgbW9kZSkpXG5cbiAgY29uc3Qgc3ViID0gcGF0aC5yZWxhdGl2ZShjd2QsIGRpcilcbiAgY29uc3QgcGFydHMgPSBzdWIuc3BsaXQoL1xcL3xcXFxcLylcbiAgbGV0IGNyZWF0ZWQgPSBudWxsXG4gIGZvciAobGV0IHAgPSBwYXJ0cy5zaGlmdCgpLCBwYXJ0ID0gY3dkO1xuICAgICAgIHAgJiYgKHBhcnQgKz0gJy8nICsgcCk7XG4gICAgICAgcCA9IHBhcnRzLnNoaWZ0KCkpIHtcblxuICAgIGlmIChjYWNoZS5nZXQocGFydCkpXG4gICAgICBjb250aW51ZVxuXG4gICAgdHJ5IHtcbiAgICAgIGZzLm1rZGlyU3luYyhwYXJ0LCBtb2RlKVxuICAgICAgY3JlYXRlZCA9IGNyZWF0ZWQgfHwgcGFydFxuICAgICAgY2FjaGUuc2V0KHBhcnQsIHRydWUpXG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIGlmIChlci5wYXRoICYmIHBhdGguZGlybmFtZShlci5wYXRoKSA9PT0gY3dkICYmXG4gICAgICAgICAgKGVyLmNvZGUgPT09ICdFTk9URElSJyB8fCBlci5jb2RlID09PSAnRU5PRU5UJykpXG4gICAgICAgIHJldHVybiBuZXcgQ3dkRXJyb3IoY3dkLCBlci5jb2RlKVxuXG4gICAgICBjb25zdCBzdCA9IGZzLmxzdGF0U3luYyhwYXJ0KVxuICAgICAgaWYgKHN0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgY2FjaGUuc2V0KHBhcnQsIHRydWUpXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2UgaWYgKHVubGluaykge1xuICAgICAgICBmcy51bmxpbmtTeW5jKHBhcnQpXG4gICAgICAgIGZzLm1rZGlyU3luYyhwYXJ0LCBtb2RlKVxuICAgICAgICBjcmVhdGVkID0gY3JlYXRlZCB8fCBwYXJ0XG4gICAgICAgIGNhY2hlLnNldChwYXJ0LCB0cnVlKVxuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIGlmIChzdC5pc1N5bWJvbGljTGluaygpKVxuICAgICAgICByZXR1cm4gbmV3IFN5bWxpbmtFcnJvcihwYXJ0LCBwYXJ0ICsgJy8nICsgcGFydHMuam9pbignLycpKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkb25lKGNyZWF0ZWQpXG59XG4iLCIndXNlIHN0cmljdCdcbm1vZHVsZS5leHBvcnRzID0gKG1vZGUsIGlzRGlyKSA9PiB7XG4gIG1vZGUgJj0gMG83Nzc3XG4gIC8vIGlmIGRpcnMgYXJlIHJlYWRhYmxlLCB0aGVuIHRoZXkgc2hvdWxkIGJlIGxpc3RhYmxlXG4gIGlmIChpc0Rpcikge1xuICAgIGlmIChtb2RlICYgMG80MDApXG4gICAgICBtb2RlIHw9IDBvMTAwXG4gICAgaWYgKG1vZGUgJiAwbzQwKVxuICAgICAgbW9kZSB8PSAwbzEwXG4gICAgaWYgKG1vZGUgJiAwbzQpXG4gICAgICBtb2RlIHw9IDBvMVxuICB9XG4gIHJldHVybiBtb2RlXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgQnVmZmVyID0gcmVxdWlyZSgnLi9idWZmZXIuanMnKVxuXG4vLyBBIHJlYWRhYmxlIHRhciBzdHJlYW0gY3JlYXRvclxuLy8gVGVjaG5pY2FsbHksIHRoaXMgaXMgYSB0cmFuc2Zvcm0gc3RyZWFtIHRoYXQgeW91IHdyaXRlIHBhdGhzIGludG8sXG4vLyBhbmQgdGFyIGZvcm1hdCBjb21lcyBvdXQgb2YuXG4vLyBUaGUgYGFkZCgpYCBtZXRob2QgaXMgbGlrZSBgd3JpdGUoKWAgYnV0IHJldHVybnMgdGhpcyxcbi8vIGFuZCBlbmQoKSByZXR1cm4gYHRoaXNgIGFzIHdlbGwsIHNvIHlvdSBjYW5cbi8vIGRvIGBuZXcgUGFjayhvcHQpLmFkZCgnZmlsZXMnKS5hZGQoJ2RpcicpLmVuZCgpLnBpcGUob3V0cHV0KVxuLy8gWW91IGNvdWxkIGFsc28gZG8gc29tZXRoaW5nIGxpa2U6XG4vLyBzdHJlYW1PZlBhdGhzKCkucGlwZShuZXcgUGFjaygpKS5waXBlKG5ldyBmcy5Xcml0ZVN0cmVhbSgnb3V0LnRhcicpKVxuXG5jbGFzcyBQYWNrSm9iIHtcbiAgY29uc3RydWN0b3IgKHBhdGgsIGFic29sdXRlKSB7XG4gICAgdGhpcy5wYXRoID0gcGF0aCB8fCAnLi8nXG4gICAgdGhpcy5hYnNvbHV0ZSA9IGFic29sdXRlXG4gICAgdGhpcy5lbnRyeSA9IG51bGxcbiAgICB0aGlzLnN0YXQgPSBudWxsXG4gICAgdGhpcy5yZWFkZGlyID0gbnVsbFxuICAgIHRoaXMucGVuZGluZyA9IGZhbHNlXG4gICAgdGhpcy5pZ25vcmUgPSBmYWxzZVxuICAgIHRoaXMucGlwZWQgPSBmYWxzZVxuICB9XG59XG5cbmNvbnN0IE1pbmlQYXNzID0gcmVxdWlyZSgnbWluaXBhc3MnKVxuY29uc3QgemxpYiA9IHJlcXVpcmUoJ21pbml6bGliJylcbmNvbnN0IFJlYWRFbnRyeSA9IHJlcXVpcmUoJy4vcmVhZC1lbnRyeS5qcycpXG5jb25zdCBXcml0ZUVudHJ5ID0gcmVxdWlyZSgnLi93cml0ZS1lbnRyeS5qcycpXG5jb25zdCBXcml0ZUVudHJ5U3luYyA9IFdyaXRlRW50cnkuU3luY1xuY29uc3QgV3JpdGVFbnRyeVRhciA9IFdyaXRlRW50cnkuVGFyXG5jb25zdCBZYWxsaXN0ID0gcmVxdWlyZSgneWFsbGlzdCcpXG5jb25zdCBFT0YgPSBCdWZmZXIuYWxsb2MoMTAyNClcbmNvbnN0IE9OU1RBVCA9IFN5bWJvbCgnb25TdGF0JylcbmNvbnN0IEVOREVEID0gU3ltYm9sKCdlbmRlZCcpXG5jb25zdCBRVUVVRSA9IFN5bWJvbCgncXVldWUnKVxuY29uc3QgQ1VSUkVOVCA9IFN5bWJvbCgnY3VycmVudCcpXG5jb25zdCBQUk9DRVNTID0gU3ltYm9sKCdwcm9jZXNzJylcbmNvbnN0IFBST0NFU1NJTkcgPSBTeW1ib2woJ3Byb2Nlc3NpbmcnKVxuY29uc3QgUFJPQ0VTU0pPQiA9IFN5bWJvbCgncHJvY2Vzc0pvYicpXG5jb25zdCBKT0JTID0gU3ltYm9sKCdqb2JzJylcbmNvbnN0IEpPQkRPTkUgPSBTeW1ib2woJ2pvYkRvbmUnKVxuY29uc3QgQURERlNFTlRSWSA9IFN5bWJvbCgnYWRkRlNFbnRyeScpXG5jb25zdCBBRERUQVJFTlRSWSA9IFN5bWJvbCgnYWRkVGFyRW50cnknKVxuY29uc3QgU1RBVCA9IFN5bWJvbCgnc3RhdCcpXG5jb25zdCBSRUFERElSID0gU3ltYm9sKCdyZWFkZGlyJylcbmNvbnN0IE9OUkVBRERJUiA9IFN5bWJvbCgnb25yZWFkZGlyJylcbmNvbnN0IFBJUEUgPSBTeW1ib2woJ3BpcGUnKVxuY29uc3QgRU5UUlkgPSBTeW1ib2woJ2VudHJ5JylcbmNvbnN0IEVOVFJZT1BUID0gU3ltYm9sKCdlbnRyeU9wdCcpXG5jb25zdCBXUklURUVOVFJZQ0xBU1MgPSBTeW1ib2woJ3dyaXRlRW50cnlDbGFzcycpXG5jb25zdCBXUklURSA9IFN5bWJvbCgnd3JpdGUnKVxuY29uc3QgT05EUkFJTiA9IFN5bWJvbCgnb25kcmFpbicpXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3Qgd2FybmVyID0gcmVxdWlyZSgnLi93YXJuLW1peGluLmpzJylcblxuY29uc3QgUGFjayA9IHdhcm5lcihjbGFzcyBQYWNrIGV4dGVuZHMgTWluaVBhc3Mge1xuICBjb25zdHJ1Y3RvciAob3B0KSB7XG4gICAgc3VwZXIob3B0KVxuICAgIG9wdCA9IG9wdCB8fCBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgdGhpcy5vcHQgPSBvcHRcbiAgICB0aGlzLmN3ZCA9IG9wdC5jd2QgfHwgcHJvY2Vzcy5jd2QoKVxuICAgIHRoaXMubWF4UmVhZFNpemUgPSBvcHQubWF4UmVhZFNpemVcbiAgICB0aGlzLnByZXNlcnZlUGF0aHMgPSAhIW9wdC5wcmVzZXJ2ZVBhdGhzXG4gICAgdGhpcy5zdHJpY3QgPSAhIW9wdC5zdHJpY3RcbiAgICB0aGlzLm5vUGF4ID0gISFvcHQubm9QYXhcbiAgICB0aGlzLnByZWZpeCA9IChvcHQucHJlZml4IHx8ICcnKS5yZXBsYWNlKC8oXFxcXHxcXC8pKyQvLCAnJylcbiAgICB0aGlzLmxpbmtDYWNoZSA9IG9wdC5saW5rQ2FjaGUgfHwgbmV3IE1hcCgpXG4gICAgdGhpcy5zdGF0Q2FjaGUgPSBvcHQuc3RhdENhY2hlIHx8IG5ldyBNYXAoKVxuICAgIHRoaXMucmVhZGRpckNhY2hlID0gb3B0LnJlYWRkaXJDYWNoZSB8fCBuZXcgTWFwKClcblxuICAgIHRoaXNbV1JJVEVFTlRSWUNMQVNTXSA9IFdyaXRlRW50cnlcbiAgICBpZiAodHlwZW9mIG9wdC5vbndhcm4gPT09ICdmdW5jdGlvbicpXG4gICAgICB0aGlzLm9uKCd3YXJuJywgb3B0Lm9ud2FybilcblxuICAgIHRoaXMuemlwID0gbnVsbFxuICAgIGlmIChvcHQuZ3ppcCkge1xuICAgICAgaWYgKHR5cGVvZiBvcHQuZ3ppcCAhPT0gJ29iamVjdCcpXG4gICAgICAgIG9wdC5nemlwID0ge31cbiAgICAgIHRoaXMuemlwID0gbmV3IHpsaWIuR3ppcChvcHQuZ3ppcClcbiAgICAgIHRoaXMuemlwLm9uKCdkYXRhJywgY2h1bmsgPT4gc3VwZXIud3JpdGUoY2h1bmspKVxuICAgICAgdGhpcy56aXAub24oJ2VuZCcsIF8gPT4gc3VwZXIuZW5kKCkpXG4gICAgICB0aGlzLnppcC5vbignZHJhaW4nLCBfID0+IHRoaXNbT05EUkFJTl0oKSlcbiAgICAgIHRoaXMub24oJ3Jlc3VtZScsIF8gPT4gdGhpcy56aXAucmVzdW1lKCkpXG4gICAgfSBlbHNlXG4gICAgICB0aGlzLm9uKCdkcmFpbicsIHRoaXNbT05EUkFJTl0pXG5cbiAgICB0aGlzLnBvcnRhYmxlID0gISFvcHQucG9ydGFibGVcbiAgICB0aGlzLm5vRGlyUmVjdXJzZSA9ICEhb3B0Lm5vRGlyUmVjdXJzZVxuICAgIHRoaXMuZm9sbG93ID0gISFvcHQuZm9sbG93XG4gICAgdGhpcy5ub010aW1lID0gISFvcHQubm9NdGltZVxuICAgIHRoaXMubXRpbWUgPSBvcHQubXRpbWUgfHwgbnVsbFxuXG4gICAgdGhpcy5maWx0ZXIgPSB0eXBlb2Ygb3B0LmZpbHRlciA9PT0gJ2Z1bmN0aW9uJyA/IG9wdC5maWx0ZXIgOiBfID0+IHRydWVcblxuICAgIHRoaXNbUVVFVUVdID0gbmV3IFlhbGxpc3RcbiAgICB0aGlzW0pPQlNdID0gMFxuICAgIHRoaXMuam9icyA9ICtvcHQuam9icyB8fCA0XG4gICAgdGhpc1tQUk9DRVNTSU5HXSA9IGZhbHNlXG4gICAgdGhpc1tFTkRFRF0gPSBmYWxzZVxuICB9XG5cbiAgW1dSSVRFXSAoY2h1bmspIHtcbiAgICByZXR1cm4gc3VwZXIud3JpdGUoY2h1bmspXG4gIH1cblxuICBhZGQgKHBhdGgpIHtcbiAgICB0aGlzLndyaXRlKHBhdGgpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGVuZCAocGF0aCkge1xuICAgIGlmIChwYXRoKVxuICAgICAgdGhpcy53cml0ZShwYXRoKVxuICAgIHRoaXNbRU5ERURdID0gdHJ1ZVxuICAgIHRoaXNbUFJPQ0VTU10oKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB3cml0ZSAocGF0aCkge1xuICAgIGlmICh0aGlzW0VOREVEXSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJylcblxuICAgIGlmIChwYXRoIGluc3RhbmNlb2YgUmVhZEVudHJ5KVxuICAgICAgdGhpc1tBRERUQVJFTlRSWV0ocGF0aClcbiAgICBlbHNlXG4gICAgICB0aGlzW0FEREZTRU5UUlldKHBhdGgpXG4gICAgcmV0dXJuIHRoaXMuZmxvd2luZ1xuICB9XG5cbiAgW0FERFRBUkVOVFJZXSAocCkge1xuICAgIGNvbnN0IGFic29sdXRlID0gcGF0aC5yZXNvbHZlKHRoaXMuY3dkLCBwLnBhdGgpXG4gICAgaWYgKHRoaXMucHJlZml4KVxuICAgICAgcC5wYXRoID0gdGhpcy5wcmVmaXggKyAnLycgKyBwLnBhdGgucmVwbGFjZSgvXlxcLihcXC8rfCQpLywgJycpXG5cbiAgICAvLyBpbiB0aGlzIGNhc2UsIHdlIGRvbid0IGhhdmUgdG8gd2FpdCBmb3IgdGhlIHN0YXRcbiAgICBpZiAoIXRoaXMuZmlsdGVyKHAucGF0aCwgcCkpXG4gICAgICBwLnJlc3VtZSgpXG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBqb2IgPSBuZXcgUGFja0pvYihwLnBhdGgsIGFic29sdXRlLCBmYWxzZSlcbiAgICAgIGpvYi5lbnRyeSA9IG5ldyBXcml0ZUVudHJ5VGFyKHAsIHRoaXNbRU5UUllPUFRdKGpvYikpXG4gICAgICBqb2IuZW50cnkub24oJ2VuZCcsIF8gPT4gdGhpc1tKT0JET05FXShqb2IpKVxuICAgICAgdGhpc1tKT0JTXSArPSAxXG4gICAgICB0aGlzW1FVRVVFXS5wdXNoKGpvYilcbiAgICB9XG5cbiAgICB0aGlzW1BST0NFU1NdKClcbiAgfVxuXG4gIFtBRERGU0VOVFJZXSAocCkge1xuICAgIGNvbnN0IGFic29sdXRlID0gcGF0aC5yZXNvbHZlKHRoaXMuY3dkLCBwKVxuICAgIGlmICh0aGlzLnByZWZpeClcbiAgICAgIHAgPSB0aGlzLnByZWZpeCArICcvJyArIHAucmVwbGFjZSgvXlxcLihcXC8rfCQpLywgJycpXG5cbiAgICB0aGlzW1FVRVVFXS5wdXNoKG5ldyBQYWNrSm9iKHAsIGFic29sdXRlKSlcbiAgICB0aGlzW1BST0NFU1NdKClcbiAgfVxuXG4gIFtTVEFUXSAoam9iKSB7XG4gICAgam9iLnBlbmRpbmcgPSB0cnVlXG4gICAgdGhpc1tKT0JTXSArPSAxXG4gICAgY29uc3Qgc3RhdCA9IHRoaXMuZm9sbG93ID8gJ3N0YXQnIDogJ2xzdGF0J1xuICAgIGZzW3N0YXRdKGpvYi5hYnNvbHV0ZSwgKGVyLCBzdGF0KSA9PiB7XG4gICAgICBqb2IucGVuZGluZyA9IGZhbHNlXG4gICAgICB0aGlzW0pPQlNdIC09IDFcbiAgICAgIGlmIChlcilcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKVxuICAgICAgZWxzZVxuICAgICAgICB0aGlzW09OU1RBVF0oam9iLCBzdGF0KVxuICAgIH0pXG4gIH1cblxuICBbT05TVEFUXSAoam9iLCBzdGF0KSB7XG4gICAgdGhpcy5zdGF0Q2FjaGUuc2V0KGpvYi5hYnNvbHV0ZSwgc3RhdClcbiAgICBqb2Iuc3RhdCA9IHN0YXRcblxuICAgIC8vIG5vdyB3ZSBoYXZlIHRoZSBzdGF0LCB3ZSBjYW4gZmlsdGVyIGl0LlxuICAgIGlmICghdGhpcy5maWx0ZXIoam9iLnBhdGgsIHN0YXQpKVxuICAgICAgam9iLmlnbm9yZSA9IHRydWVcblxuICAgIHRoaXNbUFJPQ0VTU10oKVxuICB9XG5cbiAgW1JFQURESVJdIChqb2IpIHtcbiAgICBqb2IucGVuZGluZyA9IHRydWVcbiAgICB0aGlzW0pPQlNdICs9IDFcbiAgICBmcy5yZWFkZGlyKGpvYi5hYnNvbHV0ZSwgKGVyLCBlbnRyaWVzKSA9PiB7XG4gICAgICBqb2IucGVuZGluZyA9IGZhbHNlXG4gICAgICB0aGlzW0pPQlNdIC09IDFcbiAgICAgIGlmIChlcilcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBlcilcbiAgICAgIHRoaXNbT05SRUFERElSXShqb2IsIGVudHJpZXMpXG4gICAgfSlcbiAgfVxuXG4gIFtPTlJFQURESVJdIChqb2IsIGVudHJpZXMpIHtcbiAgICB0aGlzLnJlYWRkaXJDYWNoZS5zZXQoam9iLmFic29sdXRlLCBlbnRyaWVzKVxuICAgIGpvYi5yZWFkZGlyID0gZW50cmllc1xuICAgIHRoaXNbUFJPQ0VTU10oKVxuICB9XG5cbiAgW1BST0NFU1NdICgpIHtcbiAgICBpZiAodGhpc1tQUk9DRVNTSU5HXSlcbiAgICAgIHJldHVyblxuXG4gICAgdGhpc1tQUk9DRVNTSU5HXSA9IHRydWVcbiAgICBmb3IgKGxldCB3ID0gdGhpc1tRVUVVRV0uaGVhZDtcbiAgICAgICAgIHcgIT09IG51bGwgJiYgdGhpc1tKT0JTXSA8IHRoaXMuam9icztcbiAgICAgICAgIHcgPSB3Lm5leHQpIHtcbiAgICAgIHRoaXNbUFJPQ0VTU0pPQl0ody52YWx1ZSlcbiAgICAgIGlmICh3LnZhbHVlLmlnbm9yZSkge1xuICAgICAgICBjb25zdCBwID0gdy5uZXh0XG4gICAgICAgIHRoaXNbUVVFVUVdLnJlbW92ZU5vZGUodylcbiAgICAgICAgdy5uZXh0ID0gcFxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXNbUFJPQ0VTU0lOR10gPSBmYWxzZVxuXG4gICAgaWYgKHRoaXNbRU5ERURdICYmICF0aGlzW1FVRVVFXS5sZW5ndGggJiYgdGhpc1tKT0JTXSA9PT0gMCkge1xuICAgICAgaWYgKHRoaXMuemlwKVxuICAgICAgICB0aGlzLnppcC5lbmQoRU9GKVxuICAgICAgZWxzZSB7XG4gICAgICAgIHN1cGVyLndyaXRlKEVPRilcbiAgICAgICAgc3VwZXIuZW5kKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXQgW0NVUlJFTlRdICgpIHtcbiAgICByZXR1cm4gdGhpc1tRVUVVRV0gJiYgdGhpc1tRVUVVRV0uaGVhZCAmJiB0aGlzW1FVRVVFXS5oZWFkLnZhbHVlXG4gIH1cblxuICBbSk9CRE9ORV0gKGpvYikge1xuICAgIHRoaXNbUVVFVUVdLnNoaWZ0KClcbiAgICB0aGlzW0pPQlNdIC09IDFcbiAgICB0aGlzW1BST0NFU1NdKClcbiAgfVxuXG4gIFtQUk9DRVNTSk9CXSAoam9iKSB7XG4gICAgaWYgKGpvYi5wZW5kaW5nKVxuICAgICAgcmV0dXJuXG5cbiAgICBpZiAoam9iLmVudHJ5KSB7XG4gICAgICBpZiAoam9iID09PSB0aGlzW0NVUlJFTlRdICYmICFqb2IucGlwZWQpXG4gICAgICAgIHRoaXNbUElQRV0oam9iKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCFqb2Iuc3RhdCkge1xuICAgICAgaWYgKHRoaXMuc3RhdENhY2hlLmhhcyhqb2IuYWJzb2x1dGUpKVxuICAgICAgICB0aGlzW09OU1RBVF0oam9iLCB0aGlzLnN0YXRDYWNoZS5nZXQoam9iLmFic29sdXRlKSlcbiAgICAgIGVsc2VcbiAgICAgICAgdGhpc1tTVEFUXShqb2IpXG4gICAgfVxuICAgIGlmICgham9iLnN0YXQpXG4gICAgICByZXR1cm5cblxuICAgIC8vIGZpbHRlcmVkIG91dCFcbiAgICBpZiAoam9iLmlnbm9yZSlcbiAgICAgIHJldHVyblxuXG4gICAgaWYgKCF0aGlzLm5vRGlyUmVjdXJzZSAmJiBqb2Iuc3RhdC5pc0RpcmVjdG9yeSgpICYmICFqb2IucmVhZGRpcikge1xuICAgICAgaWYgKHRoaXMucmVhZGRpckNhY2hlLmhhcyhqb2IuYWJzb2x1dGUpKVxuICAgICAgICB0aGlzW09OUkVBRERJUl0oam9iLCB0aGlzLnJlYWRkaXJDYWNoZS5nZXQoam9iLmFic29sdXRlKSlcbiAgICAgIGVsc2VcbiAgICAgICAgdGhpc1tSRUFERElSXShqb2IpXG4gICAgICBpZiAoIWpvYi5yZWFkZGlyKVxuICAgICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3ZSBrbm93IGl0IGRvZXNuJ3QgaGF2ZSBhbiBlbnRyeSwgYmVjYXVzZSB0aGF0IGdvdCBjaGVja2VkIGFib3ZlXG4gICAgam9iLmVudHJ5ID0gdGhpc1tFTlRSWV0oam9iKVxuICAgIGlmICgham9iLmVudHJ5KSB7XG4gICAgICBqb2IuaWdub3JlID0gdHJ1ZVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGpvYiA9PT0gdGhpc1tDVVJSRU5UXSAmJiAham9iLnBpcGVkKVxuICAgICAgdGhpc1tQSVBFXShqb2IpXG4gIH1cblxuICBbRU5UUllPUFRdIChqb2IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb253YXJuOiAobXNnLCBkYXRhKSA9PiB7XG4gICAgICAgIHRoaXMud2Fybihtc2csIGRhdGEpXG4gICAgICB9LFxuICAgICAgbm9QYXg6IHRoaXMubm9QYXgsXG4gICAgICBjd2Q6IHRoaXMuY3dkLFxuICAgICAgYWJzb2x1dGU6IGpvYi5hYnNvbHV0ZSxcbiAgICAgIHByZXNlcnZlUGF0aHM6IHRoaXMucHJlc2VydmVQYXRocyxcbiAgICAgIG1heFJlYWRTaXplOiB0aGlzLm1heFJlYWRTaXplLFxuICAgICAgc3RyaWN0OiB0aGlzLnN0cmljdCxcbiAgICAgIHBvcnRhYmxlOiB0aGlzLnBvcnRhYmxlLFxuICAgICAgbGlua0NhY2hlOiB0aGlzLmxpbmtDYWNoZSxcbiAgICAgIHN0YXRDYWNoZTogdGhpcy5zdGF0Q2FjaGUsXG4gICAgICBub010aW1lOiB0aGlzLm5vTXRpbWUsXG4gICAgICBtdGltZTogdGhpcy5tdGltZVxuICAgIH1cbiAgfVxuXG4gIFtFTlRSWV0gKGpvYikge1xuICAgIHRoaXNbSk9CU10gKz0gMVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXNbV1JJVEVFTlRSWUNMQVNTXShqb2IucGF0aCwgdGhpc1tFTlRSWU9QVF0oam9iKSlcbiAgICAgICAgLm9uKCdlbmQnLCAoKSA9PiB0aGlzW0pPQkRPTkVdKGpvYikpXG4gICAgICAgIC5vbignZXJyb3InLCBlciA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgfVxuICB9XG5cbiAgW09ORFJBSU5dICgpIHtcbiAgICBpZiAodGhpc1tDVVJSRU5UXSAmJiB0aGlzW0NVUlJFTlRdLmVudHJ5KVxuICAgICAgdGhpc1tDVVJSRU5UXS5lbnRyeS5yZXN1bWUoKVxuICB9XG5cbiAgLy8gbGlrZSAucGlwZSgpIGJ1dCB1c2luZyBzdXBlciwgYmVjYXVzZSBvdXIgd3JpdGUoKSBpcyBzcGVjaWFsXG4gIFtQSVBFXSAoam9iKSB7XG4gICAgam9iLnBpcGVkID0gdHJ1ZVxuXG4gICAgaWYgKGpvYi5yZWFkZGlyKVxuICAgICAgam9iLnJlYWRkaXIuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLnByZWZpeCA/XG4gICAgICAgICAgam9iLnBhdGguc2xpY2UodGhpcy5wcmVmaXgubGVuZ3RoICsgMSkgfHwgJy4vJ1xuICAgICAgICAgIDogam9iLnBhdGhcblxuICAgICAgICBjb25zdCBiYXNlID0gcCA9PT0gJy4vJyA/ICcnIDogcC5yZXBsYWNlKC9cXC8qJC8sICcvJylcbiAgICAgICAgdGhpc1tBRERGU0VOVFJZXShiYXNlICsgZW50cnkpXG4gICAgICB9KVxuXG4gICAgY29uc3Qgc291cmNlID0gam9iLmVudHJ5XG4gICAgY29uc3QgemlwID0gdGhpcy56aXBcblxuICAgIGlmICh6aXApXG4gICAgICBzb3VyY2Uub24oJ2RhdGEnLCBjaHVuayA9PiB7XG4gICAgICAgIGlmICghemlwLndyaXRlKGNodW5rKSlcbiAgICAgICAgICBzb3VyY2UucGF1c2UoKVxuICAgICAgfSlcbiAgICBlbHNlXG4gICAgICBzb3VyY2Uub24oJ2RhdGEnLCBjaHVuayA9PiB7XG4gICAgICAgIGlmICghc3VwZXIud3JpdGUoY2h1bmspKVxuICAgICAgICAgIHNvdXJjZS5wYXVzZSgpXG4gICAgICB9KVxuICB9XG5cbiAgcGF1c2UgKCkge1xuICAgIGlmICh0aGlzLnppcClcbiAgICAgIHRoaXMuemlwLnBhdXNlKClcbiAgICByZXR1cm4gc3VwZXIucGF1c2UoKVxuICB9XG59KVxuXG5jbGFzcyBQYWNrU3luYyBleHRlbmRzIFBhY2sge1xuICBjb25zdHJ1Y3RvciAob3B0KSB7XG4gICAgc3VwZXIob3B0KVxuICAgIHRoaXNbV1JJVEVFTlRSWUNMQVNTXSA9IFdyaXRlRW50cnlTeW5jXG4gIH1cblxuICAvLyBwYXVzZS9yZXN1bWUgYXJlIG5vLW9wcyBpbiBzeW5jIHN0cmVhbXMuXG4gIHBhdXNlICgpIHt9XG4gIHJlc3VtZSAoKSB7fVxuXG4gIFtTVEFUXSAoam9iKSB7XG4gICAgY29uc3Qgc3RhdCA9IHRoaXMuZm9sbG93ID8gJ3N0YXRTeW5jJyA6ICdsc3RhdFN5bmMnXG4gICAgdGhpc1tPTlNUQVRdKGpvYiwgZnNbc3RhdF0oam9iLmFic29sdXRlKSlcbiAgfVxuXG4gIFtSRUFERElSXSAoam9iLCBzdGF0KSB7XG4gICAgdGhpc1tPTlJFQURESVJdKGpvYiwgZnMucmVhZGRpclN5bmMoam9iLmFic29sdXRlKSlcbiAgfVxuXG4gIC8vIGdvdHRhIGdldCBpdCBhbGwgaW4gdGhpcyB0aWNrXG4gIFtQSVBFXSAoam9iKSB7XG4gICAgY29uc3Qgc291cmNlID0gam9iLmVudHJ5XG4gICAgY29uc3QgemlwID0gdGhpcy56aXBcblxuICAgIGlmIChqb2IucmVhZGRpcilcbiAgICAgIGpvYi5yZWFkZGlyLmZvckVhY2goZW50cnkgPT4ge1xuICAgICAgICBjb25zdCBwID0gdGhpcy5wcmVmaXggP1xuICAgICAgICAgIGpvYi5wYXRoLnNsaWNlKHRoaXMucHJlZml4Lmxlbmd0aCArIDEpIHx8ICcuLydcbiAgICAgICAgICA6IGpvYi5wYXRoXG5cbiAgICAgICAgY29uc3QgYmFzZSA9IHAgPT09ICcuLycgPyAnJyA6IHAucmVwbGFjZSgvXFwvKiQvLCAnLycpXG4gICAgICAgIHRoaXNbQURERlNFTlRSWV0oYmFzZSArIGVudHJ5KVxuICAgICAgfSlcblxuICAgIGlmICh6aXApXG4gICAgICBzb3VyY2Uub24oJ2RhdGEnLCBjaHVuayA9PiB7XG4gICAgICAgIHppcC53cml0ZShjaHVuaylcbiAgICAgIH0pXG4gICAgZWxzZVxuICAgICAgc291cmNlLm9uKCdkYXRhJywgY2h1bmsgPT4ge1xuICAgICAgICBzdXBlcltXUklURV0oY2h1bmspXG4gICAgICB9KVxuICB9XG59XG5cblBhY2suU3luYyA9IFBhY2tTeW5jXG5cbm1vZHVsZS5leHBvcnRzID0gUGFja1xuIiwiJ3VzZSBzdHJpY3QnXG5cbi8vIHRoaXNbQlVGRkVSXSBpcyB0aGUgcmVtYWluZGVyIG9mIGEgY2h1bmsgaWYgd2UncmUgd2FpdGluZyBmb3Jcbi8vIHRoZSBmdWxsIDUxMiBieXRlcyBvZiBhIGhlYWRlciB0byBjb21lIGluLiAgV2Ugd2lsbCBCdWZmZXIuY29uY2F0KClcbi8vIGl0IHRvIHRoZSBuZXh0IHdyaXRlKCksIHdoaWNoIGlzIGEgbWVtIGNvcHksIGJ1dCBhIHNtYWxsIG9uZS5cbi8vXG4vLyB0aGlzW1FVRVVFXSBpcyBhIFlhbGxpc3Qgb2YgZW50cmllcyB0aGF0IGhhdmVuJ3QgYmVlbiBlbWl0dGVkXG4vLyB5ZXQgdGhpcyBjYW4gb25seSBnZXQgZmlsbGVkIHVwIGlmIHRoZSB1c2VyIGtlZXBzIHdyaXRlKClpbmcgYWZ0ZXJcbi8vIGEgd3JpdGUoKSByZXR1cm5zIGZhbHNlLCBvciBkb2VzIGEgd3JpdGUoKSB3aXRoIG1vcmUgdGhhbiBvbmUgZW50cnlcbi8vXG4vLyBXZSBkb24ndCBidWZmZXIgY2h1bmtzLCB3ZSBhbHdheXMgcGFyc2UgdGhlbSBhbmQgZWl0aGVyIGNyZWF0ZSBhblxuLy8gZW50cnksIG9yIHB1c2ggaXQgaW50byB0aGUgYWN0aXZlIGVudHJ5LiAgVGhlIFJlYWRFbnRyeSBjbGFzcyBrbm93c1xuLy8gdG8gdGhyb3cgZGF0YSBhd2F5IGlmIC5pZ25vcmU9dHJ1ZVxuLy9cbi8vIFNoaWZ0IGVudHJ5IG9mZiB0aGUgYnVmZmVyIHdoZW4gaXQgZW1pdHMgJ2VuZCcsIGFuZCBlbWl0ICdlbnRyeScgZm9yXG4vLyB0aGUgbmV4dCBvbmUgaW4gdGhlIGxpc3QuXG4vL1xuLy8gQXQgYW55IHRpbWUsIHdlJ3JlIHB1c2hpbmcgYm9keSBjaHVua3MgaW50byB0aGUgZW50cnkgYXQgV1JJVEVFTlRSWSxcbi8vIGFuZCB3YWl0aW5nIGZvciAnZW5kJyBvbiB0aGUgZW50cnkgYXQgUkVBREVOVFJZXG4vL1xuLy8gaWdub3JlZCBlbnRyaWVzIGdldCAucmVzdW1lKCkgY2FsbGVkIG9uIHRoZW0gc3RyYWlnaHQgYXdheVxuXG5jb25zdCB3YXJuZXIgPSByZXF1aXJlKCcuL3dhcm4tbWl4aW4uanMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgSGVhZGVyID0gcmVxdWlyZSgnLi9oZWFkZXIuanMnKVxuY29uc3QgRUUgPSByZXF1aXJlKCdldmVudHMnKVxuY29uc3QgWWFsbGlzdCA9IHJlcXVpcmUoJ3lhbGxpc3QnKVxuY29uc3QgbWF4TWV0YUVudHJ5U2l6ZSA9IDEwMjQgKiAxMDI0XG5jb25zdCBFbnRyeSA9IHJlcXVpcmUoJy4vcmVhZC1lbnRyeS5qcycpXG5jb25zdCBQYXggPSByZXF1aXJlKCcuL3BheC5qcycpXG5jb25zdCB6bGliID0gcmVxdWlyZSgnbWluaXpsaWInKVxuY29uc3QgQnVmZmVyID0gcmVxdWlyZSgnLi9idWZmZXIuanMnKVxuXG5jb25zdCBnemlwSGVhZGVyID0gQnVmZmVyLmZyb20oWzB4MWYsIDB4OGJdKVxuY29uc3QgU1RBVEUgPSBTeW1ib2woJ3N0YXRlJylcbmNvbnN0IFdSSVRFRU5UUlkgPSBTeW1ib2woJ3dyaXRlRW50cnknKVxuY29uc3QgUkVBREVOVFJZID0gU3ltYm9sKCdyZWFkRW50cnknKVxuY29uc3QgTkVYVEVOVFJZID0gU3ltYm9sKCduZXh0RW50cnknKVxuY29uc3QgUFJPQ0VTU0VOVFJZID0gU3ltYm9sKCdwcm9jZXNzRW50cnknKVxuY29uc3QgRVggPSBTeW1ib2woJ2V4dGVuZGVkSGVhZGVyJylcbmNvbnN0IEdFWCA9IFN5bWJvbCgnZ2xvYmFsRXh0ZW5kZWRIZWFkZXInKVxuY29uc3QgTUVUQSA9IFN5bWJvbCgnbWV0YScpXG5jb25zdCBFTUlUTUVUQSA9IFN5bWJvbCgnZW1pdE1ldGEnKVxuY29uc3QgQlVGRkVSID0gU3ltYm9sKCdidWZmZXInKVxuY29uc3QgUVVFVUUgPSBTeW1ib2woJ3F1ZXVlJylcbmNvbnN0IEVOREVEID0gU3ltYm9sKCdlbmRlZCcpXG5jb25zdCBFTUlUVEVERU5EID0gU3ltYm9sKCdlbWl0dGVkRW5kJylcbmNvbnN0IEVNSVQgPSBTeW1ib2woJ2VtaXQnKVxuY29uc3QgVU5aSVAgPSBTeW1ib2woJ3VuemlwJylcbmNvbnN0IENPTlNVTUVDSFVOSyA9IFN5bWJvbCgnY29uc3VtZUNodW5rJylcbmNvbnN0IENPTlNVTUVDSFVOS1NVQiA9IFN5bWJvbCgnY29uc3VtZUNodW5rU3ViJylcbmNvbnN0IENPTlNVTUVCT0RZID0gU3ltYm9sKCdjb25zdW1lQm9keScpXG5jb25zdCBDT05TVU1FTUVUQSA9IFN5bWJvbCgnY29uc3VtZU1ldGEnKVxuY29uc3QgQ09OU1VNRUhFQURFUiA9IFN5bWJvbCgnY29uc3VtZUhlYWRlcicpXG5jb25zdCBDT05TVU1JTkcgPSBTeW1ib2woJ2NvbnN1bWluZycpXG5jb25zdCBCVUZGRVJDT05DQVQgPSBTeW1ib2woJ2J1ZmZlckNvbmNhdCcpXG5jb25zdCBNQVlCRUVORCA9IFN5bWJvbCgnbWF5YmVFbmQnKVxuY29uc3QgV1JJVElORyA9IFN5bWJvbCgnd3JpdGluZycpXG5jb25zdCBBQk9SVEVEID0gU3ltYm9sKCdhYm9ydGVkJylcbmNvbnN0IERPTkUgPSBTeW1ib2woJ29uRG9uZScpXG5cbmNvbnN0IG5vb3AgPSBfID0+IHRydWVcblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuZXIoY2xhc3MgUGFyc2VyIGV4dGVuZHMgRUUge1xuICBjb25zdHJ1Y3RvciAob3B0KSB7XG4gICAgb3B0ID0gb3B0IHx8IHt9XG4gICAgc3VwZXIob3B0KVxuXG4gICAgaWYgKG9wdC5vbmRvbmUpXG4gICAgICB0aGlzLm9uKERPTkUsIG9wdC5vbmRvbmUpXG4gICAgZWxzZVxuICAgICAgdGhpcy5vbihET05FLCBfID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KCdwcmVmaW5pc2gnKVxuICAgICAgICB0aGlzLmVtaXQoJ2ZpbmlzaCcpXG4gICAgICAgIHRoaXMuZW1pdCgnZW5kJylcbiAgICAgICAgdGhpcy5lbWl0KCdjbG9zZScpXG4gICAgICB9KVxuXG4gICAgdGhpcy5zdHJpY3QgPSAhIW9wdC5zdHJpY3RcbiAgICB0aGlzLm1heE1ldGFFbnRyeVNpemUgPSBvcHQubWF4TWV0YUVudHJ5U2l6ZSB8fCBtYXhNZXRhRW50cnlTaXplXG4gICAgdGhpcy5maWx0ZXIgPSB0eXBlb2Ygb3B0LmZpbHRlciA9PT0gJ2Z1bmN0aW9uJyA/IG9wdC5maWx0ZXIgOiBub29wXG5cbiAgICAvLyBoYXZlIHRvIHNldCB0aGlzIHNvIHRoYXQgc3RyZWFtcyBhcmUgb2sgcGlwaW5nIGludG8gaXRcbiAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZVxuICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZVxuXG4gICAgdGhpc1tRVUVVRV0gPSBuZXcgWWFsbGlzdCgpXG4gICAgdGhpc1tCVUZGRVJdID0gbnVsbFxuICAgIHRoaXNbUkVBREVOVFJZXSA9IG51bGxcbiAgICB0aGlzW1dSSVRFRU5UUlldID0gbnVsbFxuICAgIHRoaXNbU1RBVEVdID0gJ2JlZ2luJ1xuICAgIHRoaXNbTUVUQV0gPSAnJ1xuICAgIHRoaXNbRVhdID0gbnVsbFxuICAgIHRoaXNbR0VYXSA9IG51bGxcbiAgICB0aGlzW0VOREVEXSA9IGZhbHNlXG4gICAgdGhpc1tVTlpJUF0gPSBudWxsXG4gICAgdGhpc1tBQk9SVEVEXSA9IGZhbHNlXG4gICAgaWYgKHR5cGVvZiBvcHQub253YXJuID09PSAnZnVuY3Rpb24nKVxuICAgICAgdGhpcy5vbignd2FybicsIG9wdC5vbndhcm4pXG4gICAgaWYgKHR5cGVvZiBvcHQub25lbnRyeSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRoaXMub24oJ2VudHJ5Jywgb3B0Lm9uZW50cnkpXG4gIH1cblxuICBbQ09OU1VNRUhFQURFUl0gKGNodW5rLCBwb3NpdGlvbikge1xuICAgIGxldCBoZWFkZXJcbiAgICB0cnkge1xuICAgICAgaGVhZGVyID0gbmV3IEhlYWRlcihjaHVuaywgcG9zaXRpb24sIHRoaXNbRVhdLCB0aGlzW0dFWF0pXG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLndhcm4oJ2ludmFsaWQgZW50cnknLCBlcilcbiAgICB9XG5cbiAgICBpZiAoaGVhZGVyLm51bGxCbG9jaylcbiAgICAgIHRoaXNbRU1JVF0oJ251bGxCbG9jaycpXG4gICAgZWxzZSBpZiAoIWhlYWRlci5ja3N1bVZhbGlkKVxuICAgICAgdGhpcy53YXJuKCdpbnZhbGlkIGVudHJ5JywgaGVhZGVyKVxuICAgIGVsc2UgaWYgKCFoZWFkZXIucGF0aClcbiAgICAgIHRoaXMud2FybignaW52YWxpZDogcGF0aCBpcyByZXF1aXJlZCcsIGhlYWRlcilcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBoZWFkZXIudHlwZVxuICAgICAgaWYgKC9eKFN5bWJvbGljKT9MaW5rJC8udGVzdCh0eXBlKSAmJiAhaGVhZGVyLmxpbmtwYXRoKVxuICAgICAgICB0aGlzLndhcm4oJ2ludmFsaWQ6IGxpbmtwYXRoIHJlcXVpcmVkJywgaGVhZGVyKVxuICAgICAgZWxzZSBpZiAoIS9eKFN5bWJvbGljKT9MaW5rJC8udGVzdCh0eXBlKSAmJiBoZWFkZXIubGlua3BhdGgpXG4gICAgICAgIHRoaXMud2FybignaW52YWxpZDogbGlua3BhdGggZm9yYmlkZGVuJywgaGVhZGVyKVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gdGhpc1tXUklURUVOVFJZXSA9IG5ldyBFbnRyeShoZWFkZXIsIHRoaXNbRVhdLCB0aGlzW0dFWF0pXG5cbiAgICAgICAgaWYgKGVudHJ5Lm1ldGEpIHtcbiAgICAgICAgICBpZiAoZW50cnkuc2l6ZSA+IHRoaXMubWF4TWV0YUVudHJ5U2l6ZSkge1xuICAgICAgICAgICAgZW50cnkuaWdub3JlID0gdHJ1ZVxuICAgICAgICAgICAgdGhpc1tFTUlUXSgnaWdub3JlZEVudHJ5JywgZW50cnkpXG4gICAgICAgICAgICB0aGlzW1NUQVRFXSA9ICdpZ25vcmUnXG4gICAgICAgICAgfSBlbHNlIGlmIChlbnRyeS5zaXplID4gMCkge1xuICAgICAgICAgICAgdGhpc1tNRVRBXSA9ICcnXG4gICAgICAgICAgICBlbnRyeS5vbignZGF0YScsIGMgPT4gdGhpc1tNRVRBXSArPSBjKVxuICAgICAgICAgICAgdGhpc1tTVEFURV0gPSAnbWV0YSdcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICB0aGlzW0VYXSA9IG51bGxcbiAgICAgICAgICBlbnRyeS5pZ25vcmUgPSBlbnRyeS5pZ25vcmUgfHwgIXRoaXMuZmlsdGVyKGVudHJ5LnBhdGgsIGVudHJ5KVxuICAgICAgICAgIGlmIChlbnRyeS5pZ25vcmUpIHtcbiAgICAgICAgICAgIHRoaXNbRU1JVF0oJ2lnbm9yZWRFbnRyeScsIGVudHJ5KVxuICAgICAgICAgICAgdGhpc1tTVEFURV0gPSBlbnRyeS5yZW1haW4gPyAnaWdub3JlJyA6ICdiZWdpbidcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGVudHJ5LnJlbWFpbilcbiAgICAgICAgICAgICAgdGhpc1tTVEFURV0gPSAnYm9keSdcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzW1NUQVRFXSA9ICdiZWdpbidcbiAgICAgICAgICAgICAgZW50cnkuZW5kKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzW1JFQURFTlRSWV0pIHtcbiAgICAgICAgICAgICAgdGhpc1tRVUVVRV0ucHVzaChlbnRyeSlcbiAgICAgICAgICAgICAgdGhpc1tORVhURU5UUlldKClcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICB0aGlzW1FVRVVFXS5wdXNoKGVudHJ5KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIFtQUk9DRVNTRU5UUlldIChlbnRyeSkge1xuICAgIGxldCBnbyA9IHRydWVcblxuICAgIGlmICghZW50cnkpIHtcbiAgICAgIHRoaXNbUkVBREVOVFJZXSA9IG51bGxcbiAgICAgIGdvID0gZmFsc2VcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZW50cnkpKVxuICAgICAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGVudHJ5KVxuICAgIGVsc2Uge1xuICAgICAgdGhpc1tSRUFERU5UUlldID0gZW50cnlcbiAgICAgIHRoaXMuZW1pdCgnZW50cnknLCBlbnRyeSlcbiAgICAgIGlmICghZW50cnkuZW1pdHRlZEVuZCkge1xuICAgICAgICBlbnRyeS5vbignZW5kJywgXyA9PiB0aGlzW05FWFRFTlRSWV0oKSlcbiAgICAgICAgZ28gPSBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBnb1xuICB9XG5cbiAgW05FWFRFTlRSWV0gKCkge1xuICAgIGRvIHt9IHdoaWxlICh0aGlzW1BST0NFU1NFTlRSWV0odGhpc1tRVUVVRV0uc2hpZnQoKSkpXG5cbiAgICBpZiAoIXRoaXNbUVVFVUVdLmxlbmd0aCkge1xuICAgICAgLy8gQXQgdGhpcyBwb2ludCwgdGhlcmUncyBub3RoaW5nIGluIHRoZSBxdWV1ZSwgYnV0IHdlIG1heSBoYXZlIGFuXG4gICAgICAvLyBlbnRyeSB3aGljaCBpcyBiZWluZyBjb25zdW1lZCAocmVhZEVudHJ5KS5cbiAgICAgIC8vIElmIHdlIGRvbid0LCB0aGVuIHdlIGRlZmluaXRlbHkgY2FuIGhhbmRsZSBtb3JlIGRhdGEuXG4gICAgICAvLyBJZiB3ZSBkbywgYW5kIGVpdGhlciBpdCdzIGZsb3dpbmcsIG9yIGl0IGhhcyBuZXZlciBoYWQgYW55IGRhdGFcbiAgICAgIC8vIHdyaXR0ZW4gdG8gaXQsIHRoZW4gaXQgbmVlZHMgbW9yZS5cbiAgICAgIC8vIFRoZSBvbmx5IG90aGVyIHBvc3NpYmlsaXR5IGlzIHRoYXQgaXQgaGFzIHJldHVybmVkIGZhbHNlIGZyb20gYVxuICAgICAgLy8gd3JpdGUoKSBjYWxsLCBzbyB3ZSB3YWl0IGZvciB0aGUgbmV4dCBkcmFpbiB0byBjb250aW51ZS5cbiAgICAgIGNvbnN0IHJlID0gdGhpc1tSRUFERU5UUlldXG4gICAgICBjb25zdCBkcmFpbk5vdyA9ICFyZSB8fCByZS5mbG93aW5nIHx8IHJlLnNpemUgPT09IHJlLnJlbWFpblxuICAgICAgaWYgKGRyYWluTm93KSB7XG4gICAgICAgIGlmICghdGhpc1tXUklUSU5HXSlcbiAgICAgICAgICB0aGlzLmVtaXQoJ2RyYWluJylcbiAgICAgIH0gZWxzZVxuICAgICAgICByZS5vbmNlKCdkcmFpbicsIF8gPT4gdGhpcy5lbWl0KCdkcmFpbicpKVxuICAgICB9XG4gIH1cblxuICBbQ09OU1VNRUJPRFldIChjaHVuaywgcG9zaXRpb24pIHtcbiAgICAvLyB3cml0ZSB1cCB0byBidXQgbm8gIG1vcmUgdGhhbiB3cml0ZUVudHJ5LmJsb2NrUmVtYWluXG4gICAgY29uc3QgZW50cnkgPSB0aGlzW1dSSVRFRU5UUlldXG4gICAgY29uc3QgYnIgPSBlbnRyeS5ibG9ja1JlbWFpblxuICAgIGNvbnN0IGMgPSAoYnIgPj0gY2h1bmsubGVuZ3RoICYmIHBvc2l0aW9uID09PSAwKSA/IGNodW5rXG4gICAgICA6IGNodW5rLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIGJyKVxuXG4gICAgZW50cnkud3JpdGUoYylcblxuICAgIGlmICghZW50cnkuYmxvY2tSZW1haW4pIHtcbiAgICAgIHRoaXNbU1RBVEVdID0gJ2JlZ2luJ1xuICAgICAgdGhpc1tXUklURUVOVFJZXSA9IG51bGxcbiAgICAgIGVudHJ5LmVuZCgpXG4gICAgfVxuXG4gICAgcmV0dXJuIGMubGVuZ3RoXG4gIH1cblxuICBbQ09OU1VNRU1FVEFdIChjaHVuaywgcG9zaXRpb24pIHtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXNbV1JJVEVFTlRSWV1cbiAgICBjb25zdCByZXQgPSB0aGlzW0NPTlNVTUVCT0RZXShjaHVuaywgcG9zaXRpb24pXG5cbiAgICAvLyBpZiB3ZSBmaW5pc2hlZCwgdGhlbiB0aGUgZW50cnkgaXMgcmVzZXRcbiAgICBpZiAoIXRoaXNbV1JJVEVFTlRSWV0pXG4gICAgICB0aGlzW0VNSVRNRVRBXShlbnRyeSlcblxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIFtFTUlUXSAoZXYsIGRhdGEsIGV4dHJhKSB7XG4gICAgaWYgKCF0aGlzW1FVRVVFXS5sZW5ndGggJiYgIXRoaXNbUkVBREVOVFJZXSlcbiAgICAgIHRoaXMuZW1pdChldiwgZGF0YSwgZXh0cmEpXG4gICAgZWxzZVxuICAgICAgdGhpc1tRVUVVRV0ucHVzaChbZXYsIGRhdGEsIGV4dHJhXSlcbiAgfVxuXG4gIFtFTUlUTUVUQV0gKGVudHJ5KSB7XG4gICAgdGhpc1tFTUlUXSgnbWV0YScsIHRoaXNbTUVUQV0pXG4gICAgc3dpdGNoIChlbnRyeS50eXBlKSB7XG4gICAgICBjYXNlICdFeHRlbmRlZEhlYWRlcic6XG4gICAgICBjYXNlICdPbGRFeHRlbmRlZEhlYWRlcic6XG4gICAgICAgIHRoaXNbRVhdID0gUGF4LnBhcnNlKHRoaXNbTUVUQV0sIHRoaXNbRVhdLCBmYWxzZSlcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAnR2xvYmFsRXh0ZW5kZWRIZWFkZXInOlxuICAgICAgICB0aGlzW0dFWF0gPSBQYXgucGFyc2UodGhpc1tNRVRBXSwgdGhpc1tHRVhdLCB0cnVlKVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlICdOZXh0RmlsZUhhc0xvbmdQYXRoJzpcbiAgICAgIGNhc2UgJ09sZEdudUxvbmdQYXRoJzpcbiAgICAgICAgdGhpc1tFWF0gPSB0aGlzW0VYXSB8fCBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgICAgIHRoaXNbRVhdLnBhdGggPSB0aGlzW01FVEFdLnJlcGxhY2UoL1xcMC4qLywgJycpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgJ05leHRGaWxlSGFzTG9uZ0xpbmtwYXRoJzpcbiAgICAgICAgdGhpc1tFWF0gPSB0aGlzW0VYXSB8fCBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgICAgIHRoaXNbRVhdLmxpbmtwYXRoID0gdGhpc1tNRVRBXS5yZXBsYWNlKC9cXDAuKi8sICcnKVxuICAgICAgICBicmVha1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIG1ldGE6ICcgKyBlbnRyeS50eXBlKVxuICAgIH1cbiAgfVxuXG4gIGFib3J0IChtc2csIGVycm9yKSB7XG4gICAgdGhpc1tBQk9SVEVEXSA9IHRydWVcbiAgICB0aGlzLndhcm4obXNnLCBlcnJvcilcbiAgICB0aGlzLmVtaXQoJ2Fib3J0JywgZXJyb3IpXG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKVxuICB9XG5cbiAgd3JpdGUgKGNodW5rKSB7XG4gICAgaWYgKHRoaXNbQUJPUlRFRF0pXG4gICAgICByZXR1cm5cblxuICAgIC8vIGZpcnN0IHdyaXRlLCBtaWdodCBiZSBnemlwcGVkXG4gICAgaWYgKHRoaXNbVU5aSVBdID09PSBudWxsICYmIGNodW5rKSB7XG4gICAgICBpZiAodGhpc1tCVUZGRVJdKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmNvbmNhdChbdGhpc1tCVUZGRVJdLCBjaHVua10pXG4gICAgICAgIHRoaXNbQlVGRkVSXSA9IG51bGxcbiAgICAgIH1cbiAgICAgIGlmIChjaHVuay5sZW5ndGggPCBnemlwSGVhZGVyLmxlbmd0aCkge1xuICAgICAgICB0aGlzW0JVRkZFUl0gPSBjaHVua1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IHRoaXNbVU5aSVBdID09PSBudWxsICYmIGkgPCBnemlwSGVhZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjaHVua1tpXSAhPT0gZ3ppcEhlYWRlcltpXSlcbiAgICAgICAgICB0aGlzW1VOWklQXSA9IGZhbHNlXG4gICAgICB9XG4gICAgICBpZiAodGhpc1tVTlpJUF0gPT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgZW5kZWQgPSB0aGlzW0VOREVEXVxuICAgICAgICB0aGlzW0VOREVEXSA9IGZhbHNlXG4gICAgICAgIHRoaXNbVU5aSVBdID0gbmV3IHpsaWIuVW56aXAoKVxuICAgICAgICB0aGlzW1VOWklQXS5vbignZGF0YScsIGNodW5rID0+IHRoaXNbQ09OU1VNRUNIVU5LXShjaHVuaykpXG4gICAgICAgIHRoaXNbVU5aSVBdLm9uKCdlcnJvcicsIGVyID0+XG4gICAgICAgICAgdGhpcy5hYm9ydChlci5tZXNzYWdlLCBlcikpXG4gICAgICAgIHRoaXNbVU5aSVBdLm9uKCdlbmQnLCBfID0+IHtcbiAgICAgICAgICB0aGlzW0VOREVEXSA9IHRydWVcbiAgICAgICAgICB0aGlzW0NPTlNVTUVDSFVOS10oKVxuICAgICAgICB9KVxuICAgICAgICB0aGlzW1dSSVRJTkddID0gdHJ1ZVxuICAgICAgICBjb25zdCByZXQgPSB0aGlzW1VOWklQXVtlbmRlZCA/ICdlbmQnIDogJ3dyaXRlJyBdKGNodW5rKVxuICAgICAgICB0aGlzW1dSSVRJTkddID0gZmFsc2VcbiAgICAgICAgcmV0dXJuIHJldFxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXNbV1JJVElOR10gPSB0cnVlXG4gICAgaWYgKHRoaXNbVU5aSVBdKVxuICAgICAgdGhpc1tVTlpJUF0ud3JpdGUoY2h1bmspXG4gICAgZWxzZVxuICAgICAgdGhpc1tDT05TVU1FQ0hVTktdKGNodW5rKVxuICAgIHRoaXNbV1JJVElOR10gPSBmYWxzZVxuXG4gICAgLy8gcmV0dXJuIGZhbHNlIGlmIHRoZXJlJ3MgYSBxdWV1ZSwgb3IgaWYgdGhlIGN1cnJlbnQgZW50cnkgaXNuJ3QgZmxvd2luZ1xuICAgIGNvbnN0IHJldCA9XG4gICAgICB0aGlzW1FVRVVFXS5sZW5ndGggPyBmYWxzZSA6XG4gICAgICB0aGlzW1JFQURFTlRSWV0gPyB0aGlzW1JFQURFTlRSWV0uZmxvd2luZyA6XG4gICAgICB0cnVlXG5cbiAgICAvLyBpZiB3ZSBoYXZlIG5vIHF1ZXVlLCB0aGVuIHRoYXQgbWVhbnMgYSBjbG9nZ2VkIFJFQURFTlRSWVxuICAgIGlmICghcmV0ICYmICF0aGlzW1FVRVVFXS5sZW5ndGgpXG4gICAgICB0aGlzW1JFQURFTlRSWV0ub25jZSgnZHJhaW4nLCBfID0+IHRoaXMuZW1pdCgnZHJhaW4nKSlcblxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIFtCVUZGRVJDT05DQVRdIChjKSB7XG4gICAgaWYgKGMgJiYgIXRoaXNbQUJPUlRFRF0pXG4gICAgICB0aGlzW0JVRkZFUl0gPSB0aGlzW0JVRkZFUl0gPyBCdWZmZXIuY29uY2F0KFt0aGlzW0JVRkZFUl0sIGNdKSA6IGNcbiAgfVxuXG4gIFtNQVlCRUVORF0gKCkge1xuICAgIGlmICh0aGlzW0VOREVEXSAmJlxuICAgICAgICAhdGhpc1tFTUlUVEVERU5EXSAmJlxuICAgICAgICAhdGhpc1tBQk9SVEVEXSAmJlxuICAgICAgICAhdGhpc1tDT05TVU1JTkddKSB7XG4gICAgICB0aGlzW0VNSVRURURFTkRdID0gdHJ1ZVxuICAgICAgY29uc3QgZW50cnkgPSB0aGlzW1dSSVRFRU5UUlldXG4gICAgICBpZiAoZW50cnkgJiYgZW50cnkuYmxvY2tSZW1haW4pIHtcbiAgICAgICAgY29uc3QgaGF2ZSA9IHRoaXNbQlVGRkVSXSA/IHRoaXNbQlVGRkVSXS5sZW5ndGggOiAwXG4gICAgICAgIHRoaXMud2FybignVHJ1bmNhdGVkIGlucHV0IChuZWVkZWQgJyArIGVudHJ5LmJsb2NrUmVtYWluICtcbiAgICAgICAgICAgICAgICAgICcgbW9yZSBieXRlcywgb25seSAnICsgaGF2ZSArICcgYXZhaWxhYmxlKScsIGVudHJ5KVxuICAgICAgICBpZiAodGhpc1tCVUZGRVJdKVxuICAgICAgICAgIGVudHJ5LndyaXRlKHRoaXNbQlVGRkVSXSlcbiAgICAgICAgZW50cnkuZW5kKClcbiAgICAgIH1cbiAgICAgIHRoaXNbRU1JVF0oRE9ORSlcbiAgICB9XG4gIH1cblxuICBbQ09OU1VNRUNIVU5LXSAoY2h1bmspIHtcbiAgICBpZiAodGhpc1tDT05TVU1JTkddKSB7XG4gICAgICB0aGlzW0JVRkZFUkNPTkNBVF0oY2h1bmspXG4gICAgfSBlbHNlIGlmICghY2h1bmsgJiYgIXRoaXNbQlVGRkVSXSkge1xuICAgICAgdGhpc1tNQVlCRUVORF0oKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW0NPTlNVTUlOR10gPSB0cnVlXG4gICAgICBpZiAodGhpc1tCVUZGRVJdKSB7XG4gICAgICAgIHRoaXNbQlVGRkVSQ09OQ0FUXShjaHVuaylcbiAgICAgICAgY29uc3QgYyA9IHRoaXNbQlVGRkVSXVxuICAgICAgICB0aGlzW0JVRkZFUl0gPSBudWxsXG4gICAgICAgIHRoaXNbQ09OU1VNRUNIVU5LU1VCXShjKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1tDT05TVU1FQ0hVTktTVUJdKGNodW5rKVxuICAgICAgfVxuXG4gICAgICB3aGlsZSAodGhpc1tCVUZGRVJdICYmIHRoaXNbQlVGRkVSXS5sZW5ndGggPj0gNTEyICYmICF0aGlzW0FCT1JURURdKSB7XG4gICAgICAgIGNvbnN0IGMgPSB0aGlzW0JVRkZFUl1cbiAgICAgICAgdGhpc1tCVUZGRVJdID0gbnVsbFxuICAgICAgICB0aGlzW0NPTlNVTUVDSFVOS1NVQl0oYylcbiAgICAgIH1cbiAgICAgIHRoaXNbQ09OU1VNSU5HXSA9IGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzW0JVRkZFUl0gfHwgdGhpc1tFTkRFRF0pXG4gICAgICB0aGlzW01BWUJFRU5EXSgpXG4gIH1cblxuICBbQ09OU1VNRUNIVU5LU1VCXSAoY2h1bmspIHtcbiAgICAvLyB3ZSBrbm93IHRoYXQgd2UgYXJlIGluIENPTlNVTUlORyBtb2RlLCBzbyBhbnl0aGluZyB3cml0dGVuIGdvZXMgaW50b1xuICAgIC8vIHRoZSBidWZmZXIuICBBZHZhbmNlIHRoZSBwb3NpdGlvbiBhbmQgcHV0IGFueSByZW1haW5kZXIgaW4gdGhlIGJ1ZmZlci5cbiAgICBsZXQgcG9zaXRpb24gPSAwXG4gICAgbGV0IGxlbmd0aCA9IGNodW5rLmxlbmd0aFxuICAgIHdoaWxlIChwb3NpdGlvbiArIDUxMiA8PSBsZW5ndGggJiYgIXRoaXNbQUJPUlRFRF0pIHtcbiAgICAgIHN3aXRjaCAodGhpc1tTVEFURV0pIHtcbiAgICAgICAgY2FzZSAnYmVnaW4nOlxuICAgICAgICAgIHRoaXNbQ09OU1VNRUhFQURFUl0oY2h1bmssIHBvc2l0aW9uKVxuICAgICAgICAgIHBvc2l0aW9uICs9IDUxMlxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAnaWdub3JlJzpcbiAgICAgICAgY2FzZSAnYm9keSc6XG4gICAgICAgICAgcG9zaXRpb24gKz0gdGhpc1tDT05TVU1FQk9EWV0oY2h1bmssIHBvc2l0aW9uKVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAnbWV0YSc6XG4gICAgICAgICAgcG9zaXRpb24gKz0gdGhpc1tDT05TVU1FTUVUQV0oY2h1bmssIHBvc2l0aW9uKVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc3RhdGU6ICcgKyB0aGlzW1NUQVRFXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCBsZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzW0JVRkZFUl0pXG4gICAgICAgIHRoaXNbQlVGRkVSXSA9IEJ1ZmZlci5jb25jYXQoW2NodW5rLnNsaWNlKHBvc2l0aW9uKSwgdGhpc1tCVUZGRVJdXSlcbiAgICAgIGVsc2VcbiAgICAgICAgdGhpc1tCVUZGRVJdID0gY2h1bmsuc2xpY2UocG9zaXRpb24pXG4gICAgfVxuICB9XG5cbiAgZW5kIChjaHVuaykge1xuICAgIGlmICghdGhpc1tBQk9SVEVEXSkge1xuICAgICAgaWYgKHRoaXNbVU5aSVBdKVxuICAgICAgICB0aGlzW1VOWklQXS5lbmQoY2h1bmspXG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpc1tFTkRFRF0gPSB0cnVlXG4gICAgICAgIHRoaXMud3JpdGUoY2h1bmspXG4gICAgICB9XG4gICAgfVxuICB9XG59KVxuIiwiJ3VzZSBzdHJpY3QnXG5jb25zdCBCdWZmZXIgPSByZXF1aXJlKCcuL2J1ZmZlci5qcycpXG5jb25zdCBIZWFkZXIgPSByZXF1aXJlKCcuL2hlYWRlci5qcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5cbmNsYXNzIFBheCB7XG4gIGNvbnN0cnVjdG9yIChvYmosIGdsb2JhbCkge1xuICAgIHRoaXMuYXRpbWUgPSBvYmouYXRpbWUgfHwgbnVsbFxuICAgIHRoaXMuY2hhcnNldCA9IG9iai5jaGFyc2V0IHx8IG51bGxcbiAgICB0aGlzLmNvbW1lbnQgPSBvYmouY29tbWVudCB8fCBudWxsXG4gICAgdGhpcy5jdGltZSA9IG9iai5jdGltZSB8fCBudWxsXG4gICAgdGhpcy5naWQgPSBvYmouZ2lkIHx8IG51bGxcbiAgICB0aGlzLmduYW1lID0gb2JqLmduYW1lIHx8IG51bGxcbiAgICB0aGlzLmxpbmtwYXRoID0gb2JqLmxpbmtwYXRoIHx8IG51bGxcbiAgICB0aGlzLm10aW1lID0gb2JqLm10aW1lIHx8IG51bGxcbiAgICB0aGlzLnBhdGggPSBvYmoucGF0aCB8fCBudWxsXG4gICAgdGhpcy5zaXplID0gb2JqLnNpemUgfHwgbnVsbFxuICAgIHRoaXMudWlkID0gb2JqLnVpZCB8fCBudWxsXG4gICAgdGhpcy51bmFtZSA9IG9iai51bmFtZSB8fCBudWxsXG4gICAgdGhpcy5kZXYgPSBvYmouZGV2IHx8IG51bGxcbiAgICB0aGlzLmlubyA9IG9iai5pbm8gfHwgbnVsbFxuICAgIHRoaXMubmxpbmsgPSBvYmoubmxpbmsgfHwgbnVsbFxuICAgIHRoaXMuZ2xvYmFsID0gZ2xvYmFsIHx8IGZhbHNlXG4gIH1cblxuICBlbmNvZGUgKCkge1xuICAgIGNvbnN0IGJvZHkgPSB0aGlzLmVuY29kZUJvZHkoKVxuICAgIGlmIChib2R5ID09PSAnJylcbiAgICAgIHJldHVybiBudWxsXG5cbiAgICBjb25zdCBib2R5TGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgoYm9keSlcbiAgICAvLyByb3VuZCB1cCB0byA1MTIgYnl0ZXNcbiAgICAvLyBhZGQgNTEyIGZvciBoZWFkZXJcbiAgICBjb25zdCBidWZMZW4gPSA1MTIgKiBNYXRoLmNlaWwoMSArIGJvZHlMZW4gLyA1MTIpXG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJ1ZkxlbilcblxuICAgIC8vIDAtZmlsbCB0aGUgaGVhZGVyIHNlY3Rpb24sIGl0IG1pZ2h0IG5vdCBoaXQgZXZlcnkgZmllbGRcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDUxMjsgaSsrKSB7XG4gICAgICBidWZbaV0gPSAwXG4gICAgfVxuXG4gICAgbmV3IEhlYWRlcih7XG4gICAgICAvLyBYWFggc3BsaXQgdGhlIHBhdGhcbiAgICAgIC8vIHRoZW4gdGhlIHBhdGggc2hvdWxkIGJlIFBheEhlYWRlciArIGJhc2VuYW1lLCBidXQgbGVzcyB0aGFuIDk5LFxuICAgICAgLy8gcHJlcGVuZCB3aXRoIHRoZSBkaXJuYW1lXG4gICAgICBwYXRoOiAoJ1BheEhlYWRlci8nICsgcGF0aC5iYXNlbmFtZSh0aGlzLnBhdGgpKS5zbGljZSgwLCA5OSksXG4gICAgICBtb2RlOiB0aGlzLm1vZGUgfHwgMG82NDQsXG4gICAgICB1aWQ6IHRoaXMudWlkIHx8IG51bGwsXG4gICAgICBnaWQ6IHRoaXMuZ2lkIHx8IG51bGwsXG4gICAgICBzaXplOiBib2R5TGVuLFxuICAgICAgbXRpbWU6IHRoaXMubXRpbWUgfHwgbnVsbCxcbiAgICAgIHR5cGU6IHRoaXMuZ2xvYmFsID8gJ0dsb2JhbEV4dGVuZGVkSGVhZGVyJyA6ICdFeHRlbmRlZEhlYWRlcicsXG4gICAgICBsaW5rcGF0aDogJycsXG4gICAgICB1bmFtZTogdGhpcy51bmFtZSB8fCAnJyxcbiAgICAgIGduYW1lOiB0aGlzLmduYW1lIHx8ICcnLFxuICAgICAgZGV2bWFqOiAwLFxuICAgICAgZGV2bWluOiAwLFxuICAgICAgYXRpbWU6IHRoaXMuYXRpbWUgfHwgbnVsbCxcbiAgICAgIGN0aW1lOiB0aGlzLmN0aW1lIHx8IG51bGxcbiAgICB9KS5lbmNvZGUoYnVmKVxuXG4gICAgYnVmLndyaXRlKGJvZHksIDUxMiwgYm9keUxlbiwgJ3V0ZjgnKVxuXG4gICAgLy8gbnVsbCBwYWQgYWZ0ZXIgdGhlIGJvZHlcbiAgICBmb3IgKGxldCBpID0gYm9keUxlbiArIDUxMjsgaSA8IGJ1Zi5sZW5ndGg7IGkrKykge1xuICAgICAgYnVmW2ldID0gMFxuICAgIH1cblxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGVuY29kZUJvZHkgKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmVuY29kZUZpZWxkKCdwYXRoJykgK1xuICAgICAgdGhpcy5lbmNvZGVGaWVsZCgnY3RpbWUnKSArXG4gICAgICB0aGlzLmVuY29kZUZpZWxkKCdhdGltZScpICtcbiAgICAgIHRoaXMuZW5jb2RlRmllbGQoJ2RldicpICtcbiAgICAgIHRoaXMuZW5jb2RlRmllbGQoJ2lubycpICtcbiAgICAgIHRoaXMuZW5jb2RlRmllbGQoJ25saW5rJykgK1xuICAgICAgdGhpcy5lbmNvZGVGaWVsZCgnY2hhcnNldCcpICtcbiAgICAgIHRoaXMuZW5jb2RlRmllbGQoJ2NvbW1lbnQnKSArXG4gICAgICB0aGlzLmVuY29kZUZpZWxkKCdnaWQnKSArXG4gICAgICB0aGlzLmVuY29kZUZpZWxkKCdnbmFtZScpICtcbiAgICAgIHRoaXMuZW5jb2RlRmllbGQoJ2xpbmtwYXRoJykgK1xuICAgICAgdGhpcy5lbmNvZGVGaWVsZCgnbXRpbWUnKSArXG4gICAgICB0aGlzLmVuY29kZUZpZWxkKCdzaXplJykgK1xuICAgICAgdGhpcy5lbmNvZGVGaWVsZCgndWlkJykgK1xuICAgICAgdGhpcy5lbmNvZGVGaWVsZCgndW5hbWUnKVxuICAgIClcbiAgfVxuXG4gIGVuY29kZUZpZWxkIChmaWVsZCkge1xuICAgIGlmICh0aGlzW2ZpZWxkXSA9PT0gbnVsbCB8fCB0aGlzW2ZpZWxkXSA9PT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuICcnXG4gICAgY29uc3QgdiA9IHRoaXNbZmllbGRdIGluc3RhbmNlb2YgRGF0ZSA/IHRoaXNbZmllbGRdLmdldFRpbWUoKSAvIDEwMDBcbiAgICAgIDogdGhpc1tmaWVsZF1cbiAgICBjb25zdCBzID0gJyAnICtcbiAgICAgIChmaWVsZCA9PT0gJ2RldicgfHwgZmllbGQgPT09ICdpbm8nIHx8IGZpZWxkID09PSAnbmxpbmsnXG4gICAgICAgPyAnU0NISUxZLicgOiAnJykgK1xuICAgICAgZmllbGQgKyAnPScgKyB2ICsgJ1xcbidcbiAgICBjb25zdCBieXRlTGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgocylcbiAgICAvLyB0aGUgZGlnaXRzIGluY2x1ZGVzIHRoZSBsZW5ndGggb2YgdGhlIGRpZ2l0cyBpbiBhc2NpaSBiYXNlLTEwXG4gICAgLy8gc28gaWYgaXQncyA5IGNoYXJhY3RlcnMsIHRoZW4gYWRkaW5nIDEgZm9yIHRoZSA5IG1ha2VzIGl0IDEwXG4gICAgLy8gd2hpY2ggbWFrZXMgaXQgMTEgY2hhcnMuXG4gICAgbGV0IGRpZ2l0cyA9IE1hdGguZmxvb3IoTWF0aC5sb2coYnl0ZUxlbikgLyBNYXRoLmxvZygxMCkpICsgMVxuICAgIGlmIChieXRlTGVuICsgZGlnaXRzID49IE1hdGgucG93KDEwLCBkaWdpdHMpKVxuICAgICAgZGlnaXRzICs9IDFcbiAgICBjb25zdCBsZW4gPSBkaWdpdHMgKyBieXRlTGVuXG4gICAgcmV0dXJuIGxlbiArIHNcbiAgfVxufVxuXG5QYXgucGFyc2UgPSAoc3RyaW5nLCBleCwgZykgPT4gbmV3IFBheChtZXJnZShwYXJzZUtWKHN0cmluZyksIGV4KSwgZylcblxuY29uc3QgbWVyZ2UgPSAoYSwgYikgPT5cbiAgYiA/IE9iamVjdC5rZXlzKGEpLnJlZHVjZSgocywgaykgPT4gKHNba10gPSBhW2tdLCBzKSwgYikgOiBhXG5cbmNvbnN0IHBhcnNlS1YgPSBzdHJpbmcgPT5cbiAgc3RyaW5nXG4gICAgLnJlcGxhY2UoL1xcbiQvLCAnJylcbiAgICAuc3BsaXQoJ1xcbicpXG4gICAgLnJlZHVjZShwYXJzZUtWTGluZSwgT2JqZWN0LmNyZWF0ZShudWxsKSlcblxuY29uc3QgcGFyc2VLVkxpbmUgPSAoc2V0LCBsaW5lKSA9PiB7XG4gIGNvbnN0IG4gPSBwYXJzZUludChsaW5lLCAxMClcblxuICAvLyBYWFggVmFsdWVzIHdpdGggXFxuIGluIHRoZW0gd2lsbCBmYWlsIHRoaXMuXG4gIC8vIFJlZmFjdG9yIHRvIG5vdCBiZSBhIG5haXZlIGxpbmUtYnktbGluZSBwYXJzZS5cbiAgaWYgKG4gIT09IEJ1ZmZlci5ieXRlTGVuZ3RoKGxpbmUpICsgMSlcbiAgICByZXR1cm4gc2V0XG5cbiAgbGluZSA9IGxpbmUuc3Vic3RyKChuICsgJyAnKS5sZW5ndGgpXG4gIGNvbnN0IGt2ID0gbGluZS5zcGxpdCgnPScpXG4gIGNvbnN0IGsgPSBrdi5zaGlmdCgpLnJlcGxhY2UoL15TQ0hJTFlcXC4oZGV2fGlub3xubGluaykvLCAnJDEnKVxuICBpZiAoIWspXG4gICAgcmV0dXJuIHNldFxuXG4gIGNvbnN0IHYgPSBrdi5qb2luKCc9JylcbiAgc2V0W2tdID0gL14oW0EtWl0rXFwuKT8oW21hY118YmlydGh8Y3JlYXRpb24pdGltZSQvLnRlc3QoaylcbiAgICA/ICBuZXcgRGF0ZSh2ICogMTAwMClcbiAgICA6IC9eWzAtOV0rJC8udGVzdCh2KSA/ICt2XG4gICAgOiB2XG4gIHJldHVybiBzZXRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQYXhcbiIsIid1c2Ugc3RyaWN0J1xuY29uc3QgdHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzLmpzJylcbmNvbnN0IE1pbmlQYXNzID0gcmVxdWlyZSgnbWluaXBhc3MnKVxuXG5jb25zdCBTTFVSUCA9IFN5bWJvbCgnc2x1cnAnKVxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBSZWFkRW50cnkgZXh0ZW5kcyBNaW5pUGFzcyB7XG4gIGNvbnN0cnVjdG9yIChoZWFkZXIsIGV4LCBnZXgpIHtcbiAgICBzdXBlcigpXG4gICAgLy8gcmVhZCBlbnRyaWVzIGFsd2F5cyBzdGFydCBsaWZlIHBhdXNlZC4gIHRoaXMgaXMgdG8gYXZvaWQgdGhlXG4gICAgLy8gc2l0dWF0aW9uIHdoZXJlIE1pbmlwYXNzJ3MgYXV0by1lbmRpbmcgZW1wdHkgc3RyZWFtcyByZXN1bHRzXG4gICAgLy8gaW4gYW4gZW50cnkgZW5kaW5nIGJlZm9yZSB3ZSdyZSByZWFkeSBmb3IgaXQuXG4gICAgdGhpcy5wYXVzZSgpXG4gICAgdGhpcy5leHRlbmRlZCA9IGV4XG4gICAgdGhpcy5nbG9iYWxFeHRlbmRlZCA9IGdleFxuICAgIHRoaXMuaGVhZGVyID0gaGVhZGVyXG4gICAgdGhpcy5zdGFydEJsb2NrU2l6ZSA9IDUxMiAqIE1hdGguY2VpbChoZWFkZXIuc2l6ZSAvIDUxMilcbiAgICB0aGlzLmJsb2NrUmVtYWluID0gdGhpcy5zdGFydEJsb2NrU2l6ZVxuICAgIHRoaXMucmVtYWluID0gaGVhZGVyLnNpemVcbiAgICB0aGlzLnR5cGUgPSBoZWFkZXIudHlwZVxuICAgIHRoaXMubWV0YSA9IGZhbHNlXG4gICAgdGhpcy5pZ25vcmUgPSBmYWxzZVxuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlICdGaWxlJzpcbiAgICAgIGNhc2UgJ09sZEZpbGUnOlxuICAgICAgY2FzZSAnTGluayc6XG4gICAgICBjYXNlICdTeW1ib2xpY0xpbmsnOlxuICAgICAgY2FzZSAnQ2hhcmFjdGVyRGV2aWNlJzpcbiAgICAgIGNhc2UgJ0Jsb2NrRGV2aWNlJzpcbiAgICAgIGNhc2UgJ0RpcmVjdG9yeSc6XG4gICAgICBjYXNlICdGSUZPJzpcbiAgICAgIGNhc2UgJ0NvbnRpZ3VvdXNGaWxlJzpcbiAgICAgIGNhc2UgJ0dOVUR1bXBEaXInOlxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlICdOZXh0RmlsZUhhc0xvbmdMaW5rcGF0aCc6XG4gICAgICBjYXNlICdOZXh0RmlsZUhhc0xvbmdQYXRoJzpcbiAgICAgIGNhc2UgJ09sZEdudUxvbmdQYXRoJzpcbiAgICAgIGNhc2UgJ0dsb2JhbEV4dGVuZGVkSGVhZGVyJzpcbiAgICAgIGNhc2UgJ0V4dGVuZGVkSGVhZGVyJzpcbiAgICAgIGNhc2UgJ09sZEV4dGVuZGVkSGVhZGVyJzpcbiAgICAgICAgdGhpcy5tZXRhID0gdHJ1ZVxuICAgICAgICBicmVha1xuXG4gICAgICAvLyBOT1RFOiBnbnV0YXIgYW5kIGJzZHRhciB0cmVhdCB1bnJlY29nbml6ZWQgdHlwZXMgYXMgJ0ZpbGUnXG4gICAgICAvLyBpdCBtYXkgYmUgd29ydGggZG9pbmcgdGhlIHNhbWUsIGJ1dCB3aXRoIGEgd2FybmluZy5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuaWdub3JlID0gdHJ1ZVxuICAgIH1cblxuICAgIHRoaXMucGF0aCA9IGhlYWRlci5wYXRoXG4gICAgdGhpcy5tb2RlID0gaGVhZGVyLm1vZGVcbiAgICBpZiAodGhpcy5tb2RlKVxuICAgICAgdGhpcy5tb2RlID0gdGhpcy5tb2RlICYgMG83Nzc3XG4gICAgdGhpcy51aWQgPSBoZWFkZXIudWlkXG4gICAgdGhpcy5naWQgPSBoZWFkZXIuZ2lkXG4gICAgdGhpcy51bmFtZSA9IGhlYWRlci51bmFtZVxuICAgIHRoaXMuZ25hbWUgPSBoZWFkZXIuZ25hbWVcbiAgICB0aGlzLnNpemUgPSBoZWFkZXIuc2l6ZVxuICAgIHRoaXMubXRpbWUgPSBoZWFkZXIubXRpbWVcbiAgICB0aGlzLmF0aW1lID0gaGVhZGVyLmF0aW1lXG4gICAgdGhpcy5jdGltZSA9IGhlYWRlci5jdGltZVxuICAgIHRoaXMubGlua3BhdGggPSBoZWFkZXIubGlua3BhdGhcbiAgICB0aGlzLnVuYW1lID0gaGVhZGVyLnVuYW1lXG4gICAgdGhpcy5nbmFtZSA9IGhlYWRlci5nbmFtZVxuXG4gICAgaWYgKGV4KSB0aGlzW1NMVVJQXShleClcbiAgICBpZiAoZ2V4KSB0aGlzW1NMVVJQXShnZXgsIHRydWUpXG4gIH1cblxuICB3cml0ZSAoZGF0YSkge1xuICAgIGNvbnN0IHdyaXRlTGVuID0gZGF0YS5sZW5ndGhcbiAgICBpZiAod3JpdGVMZW4gPiB0aGlzLmJsb2NrUmVtYWluKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cml0aW5nIG1vcmUgdG8gZW50cnkgdGhhbiBpcyBhcHByb3ByaWF0ZScpXG5cbiAgICBjb25zdCByID0gdGhpcy5yZW1haW5cbiAgICBjb25zdCBiciA9IHRoaXMuYmxvY2tSZW1haW5cbiAgICB0aGlzLnJlbWFpbiA9IE1hdGgubWF4KDAsIHIgLSB3cml0ZUxlbilcbiAgICB0aGlzLmJsb2NrUmVtYWluID0gTWF0aC5tYXgoMCwgYnIgLSB3cml0ZUxlbilcbiAgICBpZiAodGhpcy5pZ25vcmUpXG4gICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgaWYgKHIgPj0gd3JpdGVMZW4pXG4gICAgICByZXR1cm4gc3VwZXIud3JpdGUoZGF0YSlcblxuICAgIC8vIHIgPCB3cml0ZUxlblxuICAgIHJldHVybiBzdXBlci53cml0ZShkYXRhLnNsaWNlKDAsIHIpKVxuICB9XG5cbiAgW1NMVVJQXSAoZXgsIGdsb2JhbCkge1xuICAgIGZvciAobGV0IGsgaW4gZXgpIHtcbiAgICAgIC8vIHdlIHNsdXJwIGluIGV2ZXJ5dGhpbmcgZXhjZXB0IGZvciB0aGUgcGF0aCBhdHRyaWJ1dGUgaW5cbiAgICAgIC8vIGEgZ2xvYmFsIGV4dGVuZGVkIGhlYWRlciwgYmVjYXVzZSB0aGF0J3Mgd2VpcmQuXG4gICAgICBpZiAoZXhba10gIT09IG51bGwgJiYgZXhba10gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICEoZ2xvYmFsICYmIGsgPT09ICdwYXRoJykpXG4gICAgICAgIHRoaXNba10gPSBleFtrXVxuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5jb25zdCBCdWZmZXIgPSByZXF1aXJlKCcuL2J1ZmZlci5qcycpXG5cbi8vIHRhciAtclxuY29uc3QgaGxvID0gcmVxdWlyZSgnLi9oaWdoLWxldmVsLW9wdC5qcycpXG5jb25zdCBQYWNrID0gcmVxdWlyZSgnLi9wYWNrLmpzJylcbmNvbnN0IFBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZS5qcycpXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJylcbmNvbnN0IGZzbSA9IHJlcXVpcmUoJ2ZzLW1pbmlwYXNzJylcbmNvbnN0IHQgPSByZXF1aXJlKCcuL2xpc3QuanMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuXG4vLyBzdGFydGluZyBhdCB0aGUgaGVhZCBvZiB0aGUgZmlsZSwgcmVhZCBhIEhlYWRlclxuLy8gSWYgdGhlIGNoZWNrc3VtIGlzIGludmFsaWQsIHRoYXQncyBvdXIgcG9zaXRpb24gdG8gc3RhcnQgd3JpdGluZ1xuLy8gSWYgaXQgaXMsIGp1bXAgZm9yd2FyZCBieSB0aGUgc3BlY2lmaWVkIHNpemUgKHJvdW5kIHVwIHRvIDUxMilcbi8vIGFuZCB0cnkgYWdhaW4uXG4vLyBXcml0ZSB0aGUgbmV3IFBhY2sgc3RyZWFtIHN0YXJ0aW5nIHRoZXJlLlxuXG5jb25zdCBIZWFkZXIgPSByZXF1aXJlKCcuL2hlYWRlci5qcycpXG5cbmNvbnN0IHIgPSBtb2R1bGUuZXhwb3J0cyA9IChvcHRfLCBmaWxlcywgY2IpID0+IHtcbiAgY29uc3Qgb3B0ID0gaGxvKG9wdF8pXG5cbiAgaWYgKCFvcHQuZmlsZSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmaWxlIGlzIHJlcXVpcmVkJylcblxuICBpZiAob3B0Lmd6aXApXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2Fubm90IGFwcGVuZCB0byBjb21wcmVzc2VkIGFyY2hpdmVzJylcblxuICBpZiAoIWZpbGVzIHx8ICFBcnJheS5pc0FycmF5KGZpbGVzKSB8fCAhZmlsZXMubGVuZ3RoKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vIGZpbGVzIG9yIGRpcmVjdG9yaWVzIHNwZWNpZmllZCcpXG5cbiAgZmlsZXMgPSBBcnJheS5mcm9tKGZpbGVzKVxuXG4gIHJldHVybiBvcHQuc3luYyA/IHJlcGxhY2VTeW5jKG9wdCwgZmlsZXMpXG4gICAgOiByZXBsYWNlKG9wdCwgZmlsZXMsIGNiKVxufVxuXG5jb25zdCByZXBsYWNlU3luYyA9IChvcHQsIGZpbGVzKSA9PiB7XG4gIGNvbnN0IHAgPSBuZXcgUGFjay5TeW5jKG9wdClcblxuICBsZXQgdGhyZXcgPSB0cnVlXG4gIGxldCBmZFxuICBsZXQgcG9zaXRpb25cblxuICB0cnkge1xuICAgIHRyeSB7XG4gICAgICBmZCA9IGZzLm9wZW5TeW5jKG9wdC5maWxlLCAncisnKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICBpZiAoZXIuY29kZSA9PT0gJ0VOT0VOVCcpXG4gICAgICAgIGZkID0gZnMub3BlblN5bmMob3B0LmZpbGUsICd3KycpXG4gICAgICBlbHNlXG4gICAgICAgIHRocm93IGVyXG4gICAgfVxuXG4gICAgY29uc3Qgc3QgPSBmcy5mc3RhdFN5bmMoZmQpXG4gICAgY29uc3QgaGVhZEJ1ZiA9IEJ1ZmZlci5hbGxvYyg1MTIpXG5cbiAgICBQT1NJVElPTjogZm9yIChwb3NpdGlvbiA9IDA7IHBvc2l0aW9uIDwgc3Quc2l6ZTsgcG9zaXRpb24gKz0gNTEyKSB7XG4gICAgICBmb3IgKGxldCBidWZQb3MgPSAwLCBieXRlcyA9IDA7IGJ1ZlBvcyA8IDUxMjsgYnVmUG9zICs9IGJ5dGVzKSB7XG4gICAgICAgIGJ5dGVzID0gZnMucmVhZFN5bmMoXG4gICAgICAgICAgZmQsIGhlYWRCdWYsIGJ1ZlBvcywgaGVhZEJ1Zi5sZW5ndGggLSBidWZQb3MsIHBvc2l0aW9uICsgYnVmUG9zXG4gICAgICAgIClcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDAgJiYgaGVhZEJ1ZlswXSA9PT0gMHgxZiAmJiBoZWFkQnVmWzFdID09PSAweDhiKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGFwcGVuZCB0byBjb21wcmVzc2VkIGFyY2hpdmVzJylcblxuICAgICAgICBpZiAoIWJ5dGVzKVxuICAgICAgICAgIGJyZWFrIFBPU0lUSU9OXG4gICAgICB9XG5cbiAgICAgIGxldCBoID0gbmV3IEhlYWRlcihoZWFkQnVmKVxuICAgICAgaWYgKCFoLmNrc3VtVmFsaWQpXG4gICAgICAgIGJyZWFrXG4gICAgICBsZXQgZW50cnlCbG9ja1NpemUgPSA1MTIgKiBNYXRoLmNlaWwoaC5zaXplIC8gNTEyKVxuICAgICAgaWYgKHBvc2l0aW9uICsgZW50cnlCbG9ja1NpemUgKyA1MTIgPiBzdC5zaXplKVxuICAgICAgICBicmVha1xuICAgICAgLy8gdGhlIDUxMiBmb3IgdGhlIGhlYWRlciB3ZSBqdXN0IHBhcnNlZCB3aWxsIGJlIGFkZGVkIGFzIHdlbGxcbiAgICAgIC8vIGFsc28ganVtcCBhaGVhZCBhbGwgdGhlIGJsb2NrcyBmb3IgdGhlIGJvZHlcbiAgICAgIHBvc2l0aW9uICs9IGVudHJ5QmxvY2tTaXplXG4gICAgICBpZiAob3B0Lm10aW1lQ2FjaGUpXG4gICAgICAgIG9wdC5tdGltZUNhY2hlLnNldChoLnBhdGgsIGgubXRpbWUpXG4gICAgfVxuICAgIHRocmV3ID0gZmFsc2VcblxuICAgIHN0cmVhbVN5bmMob3B0LCBwLCBwb3NpdGlvbiwgZmQsIGZpbGVzKVxuICB9IGZpbmFsbHkge1xuICAgIGlmICh0aHJldylcbiAgICAgIHRyeSB7IGZzLmNsb3NlU3luYyhmZCkgfSBjYXRjaCAoZXIpIHt9XG4gIH1cbn1cblxuY29uc3Qgc3RyZWFtU3luYyA9IChvcHQsIHAsIHBvc2l0aW9uLCBmZCwgZmlsZXMpID0+IHtcbiAgY29uc3Qgc3RyZWFtID0gbmV3IGZzbS5Xcml0ZVN0cmVhbVN5bmMob3B0LmZpbGUsIHtcbiAgICBmZDogZmQsXG4gICAgc3RhcnQ6IHBvc2l0aW9uXG4gIH0pXG4gIHAucGlwZShzdHJlYW0pXG4gIGFkZEZpbGVzU3luYyhwLCBmaWxlcylcbn1cblxuY29uc3QgcmVwbGFjZSA9IChvcHQsIGZpbGVzLCBjYikgPT4ge1xuICBmaWxlcyA9IEFycmF5LmZyb20oZmlsZXMpXG4gIGNvbnN0IHAgPSBuZXcgUGFjayhvcHQpXG5cbiAgY29uc3QgZ2V0UG9zID0gKGZkLCBzaXplLCBjYl8pID0+IHtcbiAgICBjb25zdCBjYiA9IChlciwgcG9zKSA9PiB7XG4gICAgICBpZiAoZXIpXG4gICAgICAgIGZzLmNsb3NlKGZkLCBfID0+IGNiXyhlcikpXG4gICAgICBlbHNlXG4gICAgICAgIGNiXyhudWxsLCBwb3MpXG4gICAgfVxuXG4gICAgbGV0IHBvc2l0aW9uID0gMFxuICAgIGlmIChzaXplID09PSAwKVxuICAgICAgcmV0dXJuIGNiKG51bGwsIDApXG5cbiAgICBsZXQgYnVmUG9zID0gMFxuICAgIGNvbnN0IGhlYWRCdWYgPSBCdWZmZXIuYWxsb2MoNTEyKVxuICAgIGNvbnN0IG9ucmVhZCA9IChlciwgYnl0ZXMpID0+IHtcbiAgICAgIGlmIChlcilcbiAgICAgICAgcmV0dXJuIGNiKGVyKVxuICAgICAgYnVmUG9zICs9IGJ5dGVzXG4gICAgICBpZiAoYnVmUG9zIDwgNTEyICYmIGJ5dGVzKVxuICAgICAgICByZXR1cm4gZnMucmVhZChcbiAgICAgICAgICBmZCwgaGVhZEJ1ZiwgYnVmUG9zLCBoZWFkQnVmLmxlbmd0aCAtIGJ1ZlBvcyxcbiAgICAgICAgICBwb3NpdGlvbiArIGJ1ZlBvcywgb25yZWFkXG4gICAgICAgIClcblxuICAgICAgaWYgKHBvc2l0aW9uID09PSAwICYmIGhlYWRCdWZbMF0gPT09IDB4MWYgJiYgaGVhZEJ1ZlsxXSA9PT0gMHg4YilcbiAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignY2Fubm90IGFwcGVuZCB0byBjb21wcmVzc2VkIGFyY2hpdmVzJykpXG5cbiAgICAgIC8vIHRydW5jYXRlZCBoZWFkZXJcbiAgICAgIGlmIChidWZQb3MgPCA1MTIpXG4gICAgICAgIHJldHVybiBjYihudWxsLCBwb3NpdGlvbilcblxuICAgICAgY29uc3QgaCA9IG5ldyBIZWFkZXIoaGVhZEJ1ZilcbiAgICAgIGlmICghaC5ja3N1bVZhbGlkKVxuICAgICAgICByZXR1cm4gY2IobnVsbCwgcG9zaXRpb24pXG5cbiAgICAgIGNvbnN0IGVudHJ5QmxvY2tTaXplID0gNTEyICogTWF0aC5jZWlsKGguc2l6ZSAvIDUxMilcbiAgICAgIGlmIChwb3NpdGlvbiArIGVudHJ5QmxvY2tTaXplICsgNTEyID4gc2l6ZSlcbiAgICAgICAgcmV0dXJuIGNiKG51bGwsIHBvc2l0aW9uKVxuXG4gICAgICBwb3NpdGlvbiArPSBlbnRyeUJsb2NrU2l6ZSArIDUxMlxuICAgICAgaWYgKHBvc2l0aW9uID49IHNpemUpXG4gICAgICAgIHJldHVybiBjYihudWxsLCBwb3NpdGlvbilcblxuICAgICAgaWYgKG9wdC5tdGltZUNhY2hlKVxuICAgICAgICBvcHQubXRpbWVDYWNoZS5zZXQoaC5wYXRoLCBoLm10aW1lKVxuICAgICAgYnVmUG9zID0gMFxuICAgICAgZnMucmVhZChmZCwgaGVhZEJ1ZiwgMCwgNTEyLCBwb3NpdGlvbiwgb25yZWFkKVxuICAgIH1cbiAgICBmcy5yZWFkKGZkLCBoZWFkQnVmLCAwLCA1MTIsIHBvc2l0aW9uLCBvbnJlYWQpXG4gIH1cblxuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHAub24oJ2Vycm9yJywgcmVqZWN0KVxuICAgIGxldCBmbGFnID0gJ3IrJ1xuICAgIGNvbnN0IG9ub3BlbiA9IChlciwgZmQpID0+IHtcbiAgICAgIGlmIChlciAmJiBlci5jb2RlID09PSAnRU5PRU5UJyAmJiBmbGFnID09PSAncisnKSB7XG4gICAgICAgIGZsYWcgPSAndysnXG4gICAgICAgIHJldHVybiBmcy5vcGVuKG9wdC5maWxlLCBmbGFnLCBvbm9wZW4pXG4gICAgICB9XG5cbiAgICAgIGlmIChlcilcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcilcblxuICAgICAgZnMuZnN0YXQoZmQsIChlciwgc3QpID0+IHtcbiAgICAgICAgaWYgKGVyKVxuICAgICAgICAgIHJldHVybiByZWplY3QoZXIpXG4gICAgICAgIGdldFBvcyhmZCwgc3Quc2l6ZSwgKGVyLCBwb3NpdGlvbikgPT4ge1xuICAgICAgICAgIGlmIChlcilcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoZXIpXG4gICAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IGZzbS5Xcml0ZVN0cmVhbShvcHQuZmlsZSwge1xuICAgICAgICAgICAgZmQ6IGZkLFxuICAgICAgICAgICAgc3RhcnQ6IHBvc2l0aW9uXG4gICAgICAgICAgfSlcbiAgICAgICAgICBwLnBpcGUoc3RyZWFtKVxuICAgICAgICAgIHN0cmVhbS5vbignZXJyb3InLCByZWplY3QpXG4gICAgICAgICAgc3RyZWFtLm9uKCdjbG9zZScsIHJlc29sdmUpXG4gICAgICAgICAgYWRkRmlsZXNBc3luYyhwLCBmaWxlcylcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuICAgIGZzLm9wZW4ob3B0LmZpbGUsIGZsYWcsIG9ub3BlbilcbiAgfSlcblxuICByZXR1cm4gY2IgPyBwcm9taXNlLnRoZW4oY2IsIGNiKSA6IHByb21pc2Vcbn1cblxuY29uc3QgYWRkRmlsZXNTeW5jID0gKHAsIGZpbGVzKSA9PiB7XG4gIGZpbGVzLmZvckVhY2goZmlsZSA9PiB7XG4gICAgaWYgKGZpbGUuY2hhckF0KDApID09PSAnQCcpXG4gICAgICB0KHtcbiAgICAgICAgZmlsZTogcGF0aC5yZXNvbHZlKHAuY3dkLCBmaWxlLnN1YnN0cigxKSksXG4gICAgICAgIHN5bmM6IHRydWUsXG4gICAgICAgIG5vUmVzdW1lOiB0cnVlLFxuICAgICAgICBvbmVudHJ5OiBlbnRyeSA9PiBwLmFkZChlbnRyeSlcbiAgICAgIH0pXG4gICAgZWxzZVxuICAgICAgcC5hZGQoZmlsZSlcbiAgfSlcbiAgcC5lbmQoKVxufVxuXG5jb25zdCBhZGRGaWxlc0FzeW5jID0gKHAsIGZpbGVzKSA9PiB7XG4gIHdoaWxlIChmaWxlcy5sZW5ndGgpIHtcbiAgICBjb25zdCBmaWxlID0gZmlsZXMuc2hpZnQoKVxuICAgIGlmIChmaWxlLmNoYXJBdCgwKSA9PT0gJ0AnKVxuICAgICAgcmV0dXJuIHQoe1xuICAgICAgICBmaWxlOiBwYXRoLnJlc29sdmUocC5jd2QsIGZpbGUuc3Vic3RyKDEpKSxcbiAgICAgICAgbm9SZXN1bWU6IHRydWUsXG4gICAgICAgIG9uZW50cnk6IGVudHJ5ID0+IHAuYWRkKGVudHJ5KVxuICAgICAgfSkudGhlbihfID0+IGFkZEZpbGVzQXN5bmMocCwgZmlsZXMpKVxuICAgIGVsc2VcbiAgICAgIHAuYWRkKGZpbGUpXG4gIH1cbiAgcC5lbmQoKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG4vLyBtYXAgdHlwZXMgZnJvbSBrZXkgdG8gaHVtYW4tZnJpZW5kbHkgbmFtZVxuZXhwb3J0cy5uYW1lID0gbmV3IE1hcChbXG4gIFsnMCcsICdGaWxlJ10sXG4gIC8vIHNhbWUgYXMgRmlsZVxuICBbJycsICdPbGRGaWxlJ10sXG4gIFsnMScsICdMaW5rJ10sXG4gIFsnMicsICdTeW1ib2xpY0xpbmsnXSxcbiAgLy8gRGV2aWNlcyBhbmQgRklGT3MgYXJlbid0IGZ1bGx5IHN1cHBvcnRlZFxuICAvLyB0aGV5IGFyZSBwYXJzZWQsIGJ1dCBza2lwcGVkIHdoZW4gdW5wYWNraW5nXG4gIFsnMycsICdDaGFyYWN0ZXJEZXZpY2UnXSxcbiAgWyc0JywgJ0Jsb2NrRGV2aWNlJ10sXG4gIFsnNScsICdEaXJlY3RvcnknXSxcbiAgWyc2JywgJ0ZJRk8nXSxcbiAgLy8gc2FtZSBhcyBGaWxlXG4gIFsnNycsICdDb250aWd1b3VzRmlsZSddLFxuICAvLyBwYXggaGVhZGVyc1xuICBbJ2cnLCAnR2xvYmFsRXh0ZW5kZWRIZWFkZXInXSxcbiAgWyd4JywgJ0V4dGVuZGVkSGVhZGVyJ10sXG4gIC8vIHZlbmRvci1zcGVjaWZpYyBzdHVmZlxuICAvLyBza2lwXG4gIFsnQScsICdTb2xhcmlzQUNMJ10sXG4gIC8vIGxpa2UgNSwgYnV0IHdpdGggZGF0YSwgd2hpY2ggc2hvdWxkIGJlIHNraXBwZWRcbiAgWydEJywgJ0dOVUR1bXBEaXInXSxcbiAgLy8gbWV0YWRhdGEgb25seSwgc2tpcFxuICBbJ0knLCAnSW5vZGUnXSxcbiAgLy8gZGF0YSA9IGxpbmsgcGF0aCBvZiBuZXh0IGZpbGVcbiAgWydLJywgJ05leHRGaWxlSGFzTG9uZ0xpbmtwYXRoJ10sXG4gIC8vIGRhdGEgPSBwYXRoIG9mIG5leHQgZmlsZVxuICBbJ0wnLCAnTmV4dEZpbGVIYXNMb25nUGF0aCddLFxuICAvLyBza2lwXG4gIFsnTScsICdDb250aW51YXRpb25GaWxlJ10sXG4gIC8vIGxpa2UgTFxuICBbJ04nLCAnT2xkR251TG9uZ1BhdGgnXSxcbiAgLy8gc2tpcFxuICBbJ1MnLCAnU3BhcnNlRmlsZSddLFxuICAvLyBza2lwXG4gIFsnVicsICdUYXBlVm9sdW1lSGVhZGVyJ10sXG4gIC8vIGxpa2UgeFxuICBbJ1gnLCAnT2xkRXh0ZW5kZWRIZWFkZXInXVxuXSlcblxuLy8gbWFwIHRoZSBvdGhlciBkaXJlY3Rpb25cbmV4cG9ydHMuY29kZSA9IG5ldyBNYXAoQXJyYXkuZnJvbShleHBvcnRzLm5hbWUpLm1hcChrdiA9PiBba3ZbMV0sIGt2WzBdXSkpXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbmNvbnN0IEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG5jb25zdCBQYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlLmpzJylcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKVxuY29uc3QgZnNtID0gcmVxdWlyZSgnZnMtbWluaXBhc3MnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgbWtkaXIgPSByZXF1aXJlKCcuL21rZGlyLmpzJylcbmNvbnN0IG1rZGlyU3luYyA9IG1rZGlyLnN5bmNcbmNvbnN0IHdjID0gcmVxdWlyZSgnLi93aW5jaGFycy5qcycpXG5cbmNvbnN0IE9ORU5UUlkgPSBTeW1ib2woJ29uRW50cnknKVxuY29uc3QgQ0hFQ0tGUyA9IFN5bWJvbCgnY2hlY2tGcycpXG5jb25zdCBJU1JFVVNBQkxFID0gU3ltYm9sKCdpc1JldXNhYmxlJylcbmNvbnN0IE1BS0VGUyA9IFN5bWJvbCgnbWFrZUZzJylcbmNvbnN0IEZJTEUgPSBTeW1ib2woJ2ZpbGUnKVxuY29uc3QgRElSRUNUT1JZID0gU3ltYm9sKCdkaXJlY3RvcnknKVxuY29uc3QgTElOSyA9IFN5bWJvbCgnbGluaycpXG5jb25zdCBTWU1MSU5LID0gU3ltYm9sKCdzeW1saW5rJylcbmNvbnN0IEhBUkRMSU5LID0gU3ltYm9sKCdoYXJkbGluaycpXG5jb25zdCBVTlNVUFBPUlRFRCA9IFN5bWJvbCgndW5zdXBwb3J0ZWQnKVxuY29uc3QgVU5LTk9XTiA9IFN5bWJvbCgndW5rbm93bicpXG5jb25zdCBDSEVDS1BBVEggPSBTeW1ib2woJ2NoZWNrUGF0aCcpXG5jb25zdCBNS0RJUiA9IFN5bWJvbCgnbWtkaXInKVxuY29uc3QgT05FUlJPUiA9IFN5bWJvbCgnb25FcnJvcicpXG5jb25zdCBQRU5ESU5HID0gU3ltYm9sKCdwZW5kaW5nJylcbmNvbnN0IFBFTkQgPSBTeW1ib2woJ3BlbmQnKVxuY29uc3QgVU5QRU5EID0gU3ltYm9sKCd1bnBlbmQnKVxuY29uc3QgRU5ERUQgPSBTeW1ib2woJ2VuZGVkJylcbmNvbnN0IE1BWUJFQ0xPU0UgPSBTeW1ib2woJ21heWJlQ2xvc2UnKVxuY29uc3QgU0tJUCA9IFN5bWJvbCgnc2tpcCcpXG5jb25zdCBET0NIT1dOID0gU3ltYm9sKCdkb0Nob3duJylcbmNvbnN0IFVJRCA9IFN5bWJvbCgndWlkJylcbmNvbnN0IEdJRCA9IFN5bWJvbCgnZ2lkJylcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpXG5cbi8vIFVubGlua3Mgb24gV2luZG93cyBhcmUgbm90IGF0b21pYy5cbi8vXG4vLyBUaGlzIG1lYW5zIHRoYXQgaWYgeW91IGhhdmUgYSBmaWxlIGVudHJ5LCBmb2xsb3dlZCBieSBhbm90aGVyXG4vLyBmaWxlIGVudHJ5IHdpdGggYW4gaWRlbnRpY2FsIG5hbWUsIGFuZCB5b3UgY2Fubm90IHJlLXVzZSB0aGUgZmlsZVxuLy8gKGJlY2F1c2UgaXQncyBhIGhhcmRsaW5rLCBvciBiZWNhdXNlIHVubGluazp0cnVlIGlzIHNldCwgb3IgaXQnc1xuLy8gV2luZG93cywgd2hpY2ggZG9lcyBub3QgaGF2ZSB1c2VmdWwgbmxpbmsgdmFsdWVzKSwgdGhlbiB0aGUgdW5saW5rXG4vLyB3aWxsIGJlIGNvbW1pdHRlZCB0byB0aGUgZGlzayBBRlRFUiB0aGUgbmV3IGZpbGUgaGFzIGJlZW4gd3JpdHRlblxuLy8gb3ZlciB0aGUgb2xkIG9uZSwgZGVsZXRpbmcgdGhlIG5ldyBmaWxlLlxuLy9cbi8vIFRvIHdvcmsgYXJvdW5kIHRoaXMsIG9uIFdpbmRvd3Mgc3lzdGVtcywgd2UgcmVuYW1lIHRoZSBmaWxlIGFuZCB0aGVuXG4vLyBkZWxldGUgdGhlIHJlbmFtZWQgZmlsZS4gIEl0J3MgYSBzbG9wcHkga2x1ZGdlLCBidXQgZnJhbmtseSwgSSBkbyBub3Rcbi8vIGtub3cgb2YgYSBiZXR0ZXIgd2F5IHRvIGRvIHRoaXMsIGdpdmVuIHdpbmRvd3MnIG5vbi1hdG9taWMgdW5saW5rXG4vLyBzZW1hbnRpY3MuXG4vL1xuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbnBtL25vZGUtdGFyL2lzc3Vlcy8xODNcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCB1bmxpbmtGaWxlID0gKHBhdGgsIGNiKSA9PiB7XG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtICE9PSAnd2luMzInKVxuICAgIHJldHVybiBmcy51bmxpbmsocGF0aCwgY2IpXG5cbiAgY29uc3QgbmFtZSA9IHBhdGggKyAnLkRFTEVURS4nICsgY3J5cHRvLnJhbmRvbUJ5dGVzKDE2KS50b1N0cmluZygnaGV4JylcbiAgZnMucmVuYW1lKHBhdGgsIG5hbWUsIGVyID0+IHtcbiAgICBpZiAoZXIpXG4gICAgICByZXR1cm4gY2IoZXIpXG4gICAgZnMudW5saW5rKG5hbWUsIGNiKVxuICB9KVxufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgdW5saW5rRmlsZVN5bmMgPSBwYXRoID0+IHtcbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gIT09ICd3aW4zMicpXG4gICAgcmV0dXJuIGZzLnVubGlua1N5bmMocGF0aClcblxuICBjb25zdCBuYW1lID0gcGF0aCArICcuREVMRVRFLicgKyBjcnlwdG8ucmFuZG9tQnl0ZXMoMTYpLnRvU3RyaW5nKCdoZXgnKVxuICBmcy5yZW5hbWVTeW5jKHBhdGgsIG5hbWUpXG4gIGZzLnVubGlua1N5bmMobmFtZSlcbn1cblxuLy8gdGhpcy5naWQsIGVudHJ5LmdpZCwgdGhpcy5wcm9jZXNzVWlkXG5jb25zdCB1aW50MzIgPSAoYSwgYiwgYykgPT5cbiAgYSA9PT0gYSA+Pj4gMCA/IGFcbiAgOiBiID09PSBiID4+PiAwID8gYlxuICA6IGNcblxuY2xhc3MgVW5wYWNrIGV4dGVuZHMgUGFyc2VyIHtcbiAgY29uc3RydWN0b3IgKG9wdCkge1xuICAgIGlmICghb3B0KVxuICAgICAgb3B0ID0ge31cblxuICAgIG9wdC5vbmRvbmUgPSBfID0+IHtcbiAgICAgIHRoaXNbRU5ERURdID0gdHJ1ZVxuICAgICAgdGhpc1tNQVlCRUNMT1NFXSgpXG4gICAgfVxuXG4gICAgc3VwZXIob3B0KVxuXG4gICAgdGhpcy50cmFuc2Zvcm0gPSB0eXBlb2Ygb3B0LnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdC50cmFuc2Zvcm0gOiBudWxsXG5cbiAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZVxuICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZVxuXG4gICAgdGhpc1tQRU5ESU5HXSA9IDBcbiAgICB0aGlzW0VOREVEXSA9IGZhbHNlXG5cbiAgICB0aGlzLmRpckNhY2hlID0gb3B0LmRpckNhY2hlIHx8IG5ldyBNYXAoKVxuXG4gICAgaWYgKHR5cGVvZiBvcHQudWlkID09PSAnbnVtYmVyJyB8fCB0eXBlb2Ygb3B0LmdpZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIG5lZWQgYm90aCBvciBuZWl0aGVyXG4gICAgICBpZiAodHlwZW9mIG9wdC51aWQgIT09ICdudW1iZXInIHx8IHR5cGVvZiBvcHQuZ2lkICE9PSAnbnVtYmVyJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2Fubm90IHNldCBvd25lciB3aXRob3V0IG51bWJlciB1aWQgYW5kIGdpZCcpXG4gICAgICBpZiAob3B0LnByZXNlcnZlT3duZXIpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ2Nhbm5vdCBwcmVzZXJ2ZSBvd25lciBpbiBhcmNoaXZlIGFuZCBhbHNvIHNldCBvd25lciBleHBsaWNpdGx5JylcbiAgICAgIHRoaXMudWlkID0gb3B0LnVpZFxuICAgICAgdGhpcy5naWQgPSBvcHQuZ2lkXG4gICAgICB0aGlzLnNldE93bmVyID0gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVpZCA9IG51bGxcbiAgICAgIHRoaXMuZ2lkID0gbnVsbFxuICAgICAgdGhpcy5zZXRPd25lciA9IGZhbHNlXG4gICAgfVxuXG4gICAgLy8gZGVmYXVsdCB0cnVlIGZvciByb290XG4gICAgaWYgKG9wdC5wcmVzZXJ2ZU93bmVyID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdC51aWQgIT09ICdudW1iZXInKVxuICAgICAgdGhpcy5wcmVzZXJ2ZU93bmVyID0gcHJvY2Vzcy5nZXR1aWQgJiYgcHJvY2Vzcy5nZXR1aWQoKSA9PT0gMFxuICAgIGVsc2VcbiAgICAgIHRoaXMucHJlc2VydmVPd25lciA9ICEhb3B0LnByZXNlcnZlT3duZXJcblxuICAgIHRoaXMucHJvY2Vzc1VpZCA9ICh0aGlzLnByZXNlcnZlT3duZXIgfHwgdGhpcy5zZXRPd25lcikgJiYgcHJvY2Vzcy5nZXR1aWQgP1xuICAgICAgcHJvY2Vzcy5nZXR1aWQoKSA6IG51bGxcbiAgICB0aGlzLnByb2Nlc3NHaWQgPSAodGhpcy5wcmVzZXJ2ZU93bmVyIHx8IHRoaXMuc2V0T3duZXIpICYmIHByb2Nlc3MuZ2V0Z2lkID9cbiAgICAgIHByb2Nlc3MuZ2V0Z2lkKCkgOiBudWxsXG5cbiAgICAvLyBtb3N0bHkganVzdCBmb3IgdGVzdGluZywgYnV0IHVzZWZ1bCBpbiBzb21lIGNhc2VzLlxuICAgIC8vIEZvcmNpYmx5IHRyaWdnZXIgYSBjaG93biBvbiBldmVyeSBlbnRyeSwgbm8gbWF0dGVyIHdoYXRcbiAgICB0aGlzLmZvcmNlQ2hvd24gPSBvcHQuZm9yY2VDaG93biA9PT0gdHJ1ZVxuXG4gICAgLy8gdHVybiA+PD98IGluIGZpbGVuYW1lcyBpbnRvIDB4ZjAwMC1oaWdoZXIgZW5jb2RlZCBmb3Jtc1xuICAgIHRoaXMud2luMzIgPSAhIW9wdC53aW4zMiB8fCBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInXG5cbiAgICAvLyBkbyBub3QgdW5wYWNrIG92ZXIgZmlsZXMgdGhhdCBhcmUgbmV3ZXIgdGhhbiB3aGF0J3MgaW4gdGhlIGFyY2hpdmVcbiAgICB0aGlzLm5ld2VyID0gISFvcHQubmV3ZXJcblxuICAgIC8vIGRvIG5vdCB1bnBhY2sgb3ZlciBBTlkgZmlsZXNcbiAgICB0aGlzLmtlZXAgPSAhIW9wdC5rZWVwXG5cbiAgICAvLyBkbyBub3Qgc2V0IG10aW1lL2F0aW1lIG9mIGV4dHJhY3RlZCBlbnRyaWVzXG4gICAgdGhpcy5ub010aW1lID0gISFvcHQubm9NdGltZVxuXG4gICAgLy8gYWxsb3cgLi4sIGFic29sdXRlIHBhdGggZW50cmllcywgYW5kIHVucGFja2luZyB0aHJvdWdoIHN5bWxpbmtzXG4gICAgLy8gd2l0aG91dCB0aGlzLCB3YXJuIGFuZCBza2lwIC4uLCByZWxhdGl2aXplIGFic29sdXRlcywgYW5kIGVycm9yXG4gICAgLy8gb24gc3ltbGlua3MgaW4gZXh0cmFjdGlvbiBwYXRoXG4gICAgdGhpcy5wcmVzZXJ2ZVBhdGhzID0gISFvcHQucHJlc2VydmVQYXRoc1xuXG4gICAgLy8gdW5saW5rIGZpbGVzIGFuZCBsaW5rcyBiZWZvcmUgd3JpdGluZy4gVGhpcyBicmVha3MgZXhpc3RpbmcgaGFyZFxuICAgIC8vIGxpbmtzLCBhbmQgcmVtb3ZlcyBzeW1saW5rIGRpcmVjdG9yaWVzIHJhdGhlciB0aGFuIGVycm9yaW5nXG4gICAgdGhpcy51bmxpbmsgPSAhIW9wdC51bmxpbmtcblxuICAgIHRoaXMuY3dkID0gcGF0aC5yZXNvbHZlKG9wdC5jd2QgfHwgcHJvY2Vzcy5jd2QoKSlcbiAgICB0aGlzLnN0cmlwID0gK29wdC5zdHJpcCB8fCAwXG4gICAgdGhpcy5wcm9jZXNzVW1hc2sgPSBwcm9jZXNzLnVtYXNrKClcbiAgICB0aGlzLnVtYXNrID0gdHlwZW9mIG9wdC51bWFzayA9PT0gJ251bWJlcicgPyBvcHQudW1hc2sgOiB0aGlzLnByb2Nlc3NVbWFza1xuICAgIC8vIGRlZmF1bHQgbW9kZSBmb3IgZGlycyBjcmVhdGVkIGFzIHBhcmVudHNcbiAgICB0aGlzLmRtb2RlID0gb3B0LmRtb2RlIHx8ICgwbzA3NzcgJiAofnRoaXMudW1hc2spKVxuICAgIHRoaXMuZm1vZGUgPSBvcHQuZm1vZGUgfHwgKDBvMDY2NiAmICh+dGhpcy51bWFzaykpXG4gICAgdGhpcy5vbignZW50cnknLCBlbnRyeSA9PiB0aGlzW09ORU5UUlldKGVudHJ5KSlcbiAgfVxuXG4gIFtNQVlCRUNMT1NFXSAoKSB7XG4gICAgaWYgKHRoaXNbRU5ERURdICYmIHRoaXNbUEVORElOR10gPT09IDApIHtcbiAgICAgIHRoaXMuZW1pdCgncHJlZmluaXNoJylcbiAgICAgIHRoaXMuZW1pdCgnZmluaXNoJylcbiAgICAgIHRoaXMuZW1pdCgnZW5kJylcbiAgICAgIHRoaXMuZW1pdCgnY2xvc2UnKVxuICAgIH1cbiAgfVxuXG4gIFtDSEVDS1BBVEhdIChlbnRyeSkge1xuICAgIGlmICh0aGlzLnN0cmlwKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IGVudHJ5LnBhdGguc3BsaXQoL1xcL3xcXFxcLylcbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPCB0aGlzLnN0cmlwKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIGVudHJ5LnBhdGggPSBwYXJ0cy5zbGljZSh0aGlzLnN0cmlwKS5qb2luKCcvJylcblxuICAgICAgaWYgKGVudHJ5LnR5cGUgPT09ICdMaW5rJykge1xuICAgICAgICBjb25zdCBsaW5rcGFydHMgPSBlbnRyeS5saW5rcGF0aC5zcGxpdCgvXFwvfFxcXFwvKVxuICAgICAgICBpZiAobGlua3BhcnRzLmxlbmd0aCA+PSB0aGlzLnN0cmlwKVxuICAgICAgICAgIGVudHJ5LmxpbmtwYXRoID0gbGlua3BhcnRzLnNsaWNlKHRoaXMuc3RyaXApLmpvaW4oJy8nKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5wcmVzZXJ2ZVBhdGhzKSB7XG4gICAgICBjb25zdCBwID0gZW50cnkucGF0aFxuICAgICAgaWYgKHAubWF0Y2goLyhefFxcL3xcXFxcKVxcLlxcLihcXFxcfFxcL3wkKS8pKSB7XG4gICAgICAgIHRoaXMud2FybigncGF0aCBjb250YWlucyBcXCcuLlxcJycsIHApXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICAvLyBhYnNvbHV0ZXMgb24gcG9zaXggYXJlIGFsc28gYWJzb2x1dGVzIG9uIHdpbjMyXG4gICAgICAvLyBzbyB3ZSBvbmx5IG5lZWQgdG8gdGVzdCB0aGlzIG9uZSB0byBnZXQgYm90aFxuICAgICAgaWYgKHBhdGgud2luMzIuaXNBYnNvbHV0ZShwKSkge1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXRoLndpbjMyLnBhcnNlKHApXG4gICAgICAgIHRoaXMud2Fybignc3RyaXBwaW5nICcgKyBwYXJzZWQucm9vdCArICcgZnJvbSBhYnNvbHV0ZSBwYXRoJywgcClcbiAgICAgICAgZW50cnkucGF0aCA9IHAuc3Vic3RyKHBhcnNlZC5yb290Lmxlbmd0aClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBvbmx5IGVuY29kZSA6IGNoYXJzIHRoYXQgYXJlbid0IGRyaXZlIGxldHRlciBpbmRpY2F0b3JzXG4gICAgaWYgKHRoaXMud2luMzIpIHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHBhdGgud2luMzIucGFyc2UoZW50cnkucGF0aClcbiAgICAgIGVudHJ5LnBhdGggPSBwYXJzZWQucm9vdCA9PT0gJycgPyB3Yy5lbmNvZGUoZW50cnkucGF0aClcbiAgICAgICAgOiBwYXJzZWQucm9vdCArIHdjLmVuY29kZShlbnRyeS5wYXRoLnN1YnN0cihwYXJzZWQucm9vdC5sZW5ndGgpKVxuICAgIH1cblxuICAgIGlmIChwYXRoLmlzQWJzb2x1dGUoZW50cnkucGF0aCkpXG4gICAgICBlbnRyeS5hYnNvbHV0ZSA9IGVudHJ5LnBhdGhcbiAgICBlbHNlXG4gICAgICBlbnRyeS5hYnNvbHV0ZSA9IHBhdGgucmVzb2x2ZSh0aGlzLmN3ZCwgZW50cnkucGF0aClcblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBbT05FTlRSWV0gKGVudHJ5KSB7XG4gICAgaWYgKCF0aGlzW0NIRUNLUEFUSF0oZW50cnkpKVxuICAgICAgcmV0dXJuIGVudHJ5LnJlc3VtZSgpXG5cbiAgICBhc3NlcnQuZXF1YWwodHlwZW9mIGVudHJ5LmFic29sdXRlLCAnc3RyaW5nJylcblxuICAgIHN3aXRjaCAoZW50cnkudHlwZSkge1xuICAgICAgY2FzZSAnRGlyZWN0b3J5JzpcbiAgICAgIGNhc2UgJ0dOVUR1bXBEaXInOlxuICAgICAgICBpZiAoZW50cnkubW9kZSlcbiAgICAgICAgICBlbnRyeS5tb2RlID0gZW50cnkubW9kZSB8IDBvNzAwXG5cbiAgICAgIGNhc2UgJ0ZpbGUnOlxuICAgICAgY2FzZSAnT2xkRmlsZSc6XG4gICAgICBjYXNlICdDb250aWd1b3VzRmlsZSc6XG4gICAgICBjYXNlICdMaW5rJzpcbiAgICAgIGNhc2UgJ1N5bWJvbGljTGluayc6XG4gICAgICAgIHJldHVybiB0aGlzW0NIRUNLRlNdKGVudHJ5KVxuXG4gICAgICBjYXNlICdDaGFyYWN0ZXJEZXZpY2UnOlxuICAgICAgY2FzZSAnQmxvY2tEZXZpY2UnOlxuICAgICAgY2FzZSAnRklGTyc6XG4gICAgICAgIHJldHVybiB0aGlzW1VOU1VQUE9SVEVEXShlbnRyeSlcbiAgICB9XG4gIH1cblxuICBbT05FUlJPUl0gKGVyLCBlbnRyeSkge1xuICAgIC8vIEN3ZCBoYXMgdG8gZXhpc3QsIG9yIGVsc2Ugbm90aGluZyB3b3Jrcy4gVGhhdCdzIHNlcmlvdXMuXG4gICAgLy8gT3RoZXIgZXJyb3JzIGFyZSB3YXJuaW5ncywgd2hpY2ggcmFpc2UgdGhlIGVycm9yIGluIHN0cmljdFxuICAgIC8vIG1vZGUsIGJ1dCBvdGhlcndpc2UgY29udGludWUgb24uXG4gICAgaWYgKGVyLm5hbWUgPT09ICdDd2RFcnJvcicpXG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgZWxzZSB7XG4gICAgICB0aGlzLndhcm4oZXIubWVzc2FnZSwgZXIpXG4gICAgICB0aGlzW1VOUEVORF0oKVxuICAgICAgZW50cnkucmVzdW1lKClcbiAgICB9XG4gIH1cblxuICBbTUtESVJdIChkaXIsIG1vZGUsIGNiKSB7XG4gICAgbWtkaXIoZGlyLCB7XG4gICAgICB1aWQ6IHRoaXMudWlkLFxuICAgICAgZ2lkOiB0aGlzLmdpZCxcbiAgICAgIHByb2Nlc3NVaWQ6IHRoaXMucHJvY2Vzc1VpZCxcbiAgICAgIHByb2Nlc3NHaWQ6IHRoaXMucHJvY2Vzc0dpZCxcbiAgICAgIHVtYXNrOiB0aGlzLnByb2Nlc3NVbWFzayxcbiAgICAgIHByZXNlcnZlOiB0aGlzLnByZXNlcnZlUGF0aHMsXG4gICAgICB1bmxpbms6IHRoaXMudW5saW5rLFxuICAgICAgY2FjaGU6IHRoaXMuZGlyQ2FjaGUsXG4gICAgICBjd2Q6IHRoaXMuY3dkLFxuICAgICAgbW9kZTogbW9kZVxuICAgIH0sIGNiKVxuICB9XG5cbiAgW0RPQ0hPV05dIChlbnRyeSkge1xuICAgIC8vIGluIHByZXNlcnZlIG93bmVyIG1vZGUsIGNob3duIGlmIHRoZSBlbnRyeSBkb2Vzbid0IG1hdGNoIHByb2Nlc3NcbiAgICAvLyBpbiBzZXQgb3duZXIgbW9kZSwgY2hvd24gaWYgc2V0dGluZyBkb2Vzbid0IG1hdGNoIHByb2Nlc3NcbiAgICByZXR1cm4gdGhpcy5mb3JjZUNob3duIHx8XG4gICAgICB0aGlzLnByZXNlcnZlT3duZXIgJiZcbiAgICAgICggdHlwZW9mIGVudHJ5LnVpZCA9PT0gJ251bWJlcicgJiYgZW50cnkudWlkICE9PSB0aGlzLnByb2Nlc3NVaWQgfHxcbiAgICAgICAgdHlwZW9mIGVudHJ5LmdpZCA9PT0gJ251bWJlcicgJiYgZW50cnkuZ2lkICE9PSB0aGlzLnByb2Nlc3NHaWQgKVxuICAgICAgfHxcbiAgICAgICggdHlwZW9mIHRoaXMudWlkID09PSAnbnVtYmVyJyAmJiB0aGlzLnVpZCAhPT0gdGhpcy5wcm9jZXNzVWlkIHx8XG4gICAgICAgIHR5cGVvZiB0aGlzLmdpZCA9PT0gJ251bWJlcicgJiYgdGhpcy5naWQgIT09IHRoaXMucHJvY2Vzc0dpZCApXG4gIH1cblxuICBbVUlEXSAoZW50cnkpIHtcbiAgICByZXR1cm4gdWludDMyKHRoaXMudWlkLCBlbnRyeS51aWQsIHRoaXMucHJvY2Vzc1VpZClcbiAgfVxuXG4gIFtHSURdIChlbnRyeSkge1xuICAgIHJldHVybiB1aW50MzIodGhpcy5naWQsIGVudHJ5LmdpZCwgdGhpcy5wcm9jZXNzR2lkKVxuICB9XG5cbiAgW0ZJTEVdIChlbnRyeSkge1xuICAgIGNvbnN0IG1vZGUgPSBlbnRyeS5tb2RlICYgMG83Nzc3IHx8IHRoaXMuZm1vZGVcbiAgICBjb25zdCBzdHJlYW0gPSBuZXcgZnNtLldyaXRlU3RyZWFtKGVudHJ5LmFic29sdXRlLCB7XG4gICAgICBtb2RlOiBtb2RlLFxuICAgICAgYXV0b0Nsb3NlOiBmYWxzZVxuICAgIH0pXG4gICAgc3RyZWFtLm9uKCdlcnJvcicsIGVyID0+IHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KSlcblxuICAgIGxldCBhY3Rpb25zID0gMVxuICAgIGNvbnN0IGRvbmUgPSBlciA9PiB7XG4gICAgICBpZiAoZXIpXG4gICAgICAgIHJldHVybiB0aGlzW09ORVJST1JdKGVyLCBlbnRyeSlcblxuICAgICAgaWYgKC0tYWN0aW9ucyA9PT0gMClcbiAgICAgICAgZnMuY2xvc2Uoc3RyZWFtLmZkLCBfID0+IHRoaXNbVU5QRU5EXSgpKVxuICAgIH1cblxuICAgIHN0cmVhbS5vbignZmluaXNoJywgXyA9PiB7XG4gICAgICAvLyBpZiBmdXRpbWVzIGZhaWxzLCB0cnkgdXRpbWVzXG4gICAgICAvLyBpZiB1dGltZXMgZmFpbHMsIGZhaWwgd2l0aCB0aGUgb3JpZ2luYWwgZXJyb3JcbiAgICAgIC8vIHNhbWUgZm9yIGZjaG93bi9jaG93blxuICAgICAgY29uc3QgYWJzID0gZW50cnkuYWJzb2x1dGVcbiAgICAgIGNvbnN0IGZkID0gc3RyZWFtLmZkXG5cbiAgICAgIGlmIChlbnRyeS5tdGltZSAmJiAhdGhpcy5ub010aW1lKSB7XG4gICAgICAgIGFjdGlvbnMrK1xuICAgICAgICBjb25zdCBhdGltZSA9IGVudHJ5LmF0aW1lIHx8IG5ldyBEYXRlKClcbiAgICAgICAgY29uc3QgbXRpbWUgPSBlbnRyeS5tdGltZVxuICAgICAgICBmcy5mdXRpbWVzKGZkLCBhdGltZSwgbXRpbWUsIGVyID0+XG4gICAgICAgICAgZXIgPyBmcy51dGltZXMoYWJzLCBhdGltZSwgbXRpbWUsIGVyMiA9PiBkb25lKGVyMiAmJiBlcikpXG4gICAgICAgICAgOiBkb25lKCkpXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzW0RPQ0hPV05dKGVudHJ5KSkge1xuICAgICAgICBhY3Rpb25zKytcbiAgICAgICAgY29uc3QgdWlkID0gdGhpc1tVSURdKGVudHJ5KVxuICAgICAgICBjb25zdCBnaWQgPSB0aGlzW0dJRF0oZW50cnkpXG4gICAgICAgIGZzLmZjaG93bihmZCwgdWlkLCBnaWQsIGVyID0+XG4gICAgICAgICAgZXIgPyBmcy5jaG93bihhYnMsIHVpZCwgZ2lkLCBlcjIgPT4gZG9uZShlcjIgJiYgZXIpKVxuICAgICAgICAgIDogZG9uZSgpKVxuICAgICAgfVxuXG4gICAgICBkb25lKClcbiAgICB9KVxuXG4gICAgY29uc3QgdHggPSB0aGlzLnRyYW5zZm9ybSA/IHRoaXMudHJhbnNmb3JtKGVudHJ5KSB8fCBlbnRyeSA6IGVudHJ5XG4gICAgaWYgKHR4ICE9PSBlbnRyeSkge1xuICAgICAgdHgub24oJ2Vycm9yJywgZXIgPT4gdGhpc1tPTkVSUk9SXShlciwgZW50cnkpKVxuICAgICAgZW50cnkucGlwZSh0eClcbiAgICB9XG4gICAgdHgucGlwZShzdHJlYW0pXG4gIH1cblxuICBbRElSRUNUT1JZXSAoZW50cnkpIHtcbiAgICBjb25zdCBtb2RlID0gZW50cnkubW9kZSAmIDBvNzc3NyB8fCB0aGlzLmRtb2RlXG4gICAgdGhpc1tNS0RJUl0oZW50cnkuYWJzb2x1dGUsIG1vZGUsIGVyID0+IHtcbiAgICAgIGlmIChlcilcbiAgICAgICAgcmV0dXJuIHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KVxuXG4gICAgICBsZXQgYWN0aW9ucyA9IDFcbiAgICAgIGNvbnN0IGRvbmUgPSBfID0+IHtcbiAgICAgICAgaWYgKC0tYWN0aW9ucyA9PT0gMCkge1xuICAgICAgICAgIHRoaXNbVU5QRU5EXSgpXG4gICAgICAgICAgZW50cnkucmVzdW1lKClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZW50cnkubXRpbWUgJiYgIXRoaXMubm9NdGltZSkge1xuICAgICAgICBhY3Rpb25zKytcbiAgICAgICAgZnMudXRpbWVzKGVudHJ5LmFic29sdXRlLCBlbnRyeS5hdGltZSB8fCBuZXcgRGF0ZSgpLCBlbnRyeS5tdGltZSwgZG9uZSlcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNbRE9DSE9XTl0oZW50cnkpKSB7XG4gICAgICAgIGFjdGlvbnMrK1xuICAgICAgICBmcy5jaG93bihlbnRyeS5hYnNvbHV0ZSwgdGhpc1tVSURdKGVudHJ5KSwgdGhpc1tHSURdKGVudHJ5KSwgZG9uZSlcbiAgICAgIH1cblxuICAgICAgZG9uZSgpXG4gICAgfSlcbiAgfVxuXG4gIFtVTlNVUFBPUlRFRF0gKGVudHJ5KSB7XG4gICAgdGhpcy53YXJuKCd1bnN1cHBvcnRlZCBlbnRyeSB0eXBlOiAnICsgZW50cnkudHlwZSwgZW50cnkpXG4gICAgZW50cnkucmVzdW1lKClcbiAgfVxuXG4gIFtTWU1MSU5LXSAoZW50cnkpIHtcbiAgICB0aGlzW0xJTktdKGVudHJ5LCBlbnRyeS5saW5rcGF0aCwgJ3N5bWxpbmsnKVxuICB9XG5cbiAgW0hBUkRMSU5LXSAoZW50cnkpIHtcbiAgICB0aGlzW0xJTktdKGVudHJ5LCBwYXRoLnJlc29sdmUodGhpcy5jd2QsIGVudHJ5LmxpbmtwYXRoKSwgJ2xpbmsnKVxuICB9XG5cbiAgW1BFTkRdICgpIHtcbiAgICB0aGlzW1BFTkRJTkddKytcbiAgfVxuXG4gIFtVTlBFTkRdICgpIHtcbiAgICB0aGlzW1BFTkRJTkddLS1cbiAgICB0aGlzW01BWUJFQ0xPU0VdKClcbiAgfVxuXG4gIFtTS0lQXSAoZW50cnkpIHtcbiAgICB0aGlzW1VOUEVORF0oKVxuICAgIGVudHJ5LnJlc3VtZSgpXG4gIH1cblxuICAvLyBDaGVjayBpZiB3ZSBjYW4gcmV1c2UgYW4gZXhpc3RpbmcgZmlsZXN5c3RlbSBlbnRyeSBzYWZlbHkgYW5kXG4gIC8vIG92ZXJ3cml0ZSBpdCwgcmF0aGVyIHRoYW4gdW5saW5raW5nIGFuZCByZWNyZWF0aW5nXG4gIC8vIFdpbmRvd3MgZG9lc24ndCByZXBvcnQgYSB1c2VmdWwgbmxpbmssIHNvIHdlIGp1c3QgbmV2ZXIgcmV1c2UgZW50cmllc1xuICBbSVNSRVVTQUJMRV0gKGVudHJ5LCBzdCkge1xuICAgIHJldHVybiBlbnRyeS50eXBlID09PSAnRmlsZScgJiZcbiAgICAgICF0aGlzLnVubGluayAmJlxuICAgICAgc3QuaXNGaWxlKCkgJiZcbiAgICAgIHN0Lm5saW5rIDw9IDEgJiZcbiAgICAgIHByb2Nlc3MucGxhdGZvcm0gIT09ICd3aW4zMidcbiAgfVxuXG4gIC8vIGNoZWNrIGlmIGEgdGhpbmcgaXMgdGhlcmUsIGFuZCBpZiBzbywgdHJ5IHRvIGNsb2JiZXIgaXRcbiAgW0NIRUNLRlNdIChlbnRyeSkge1xuICAgIHRoaXNbUEVORF0oKVxuICAgIHRoaXNbTUtESVJdKHBhdGguZGlybmFtZShlbnRyeS5hYnNvbHV0ZSksIHRoaXMuZG1vZGUsIGVyID0+IHtcbiAgICAgIGlmIChlcilcbiAgICAgICAgcmV0dXJuIHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KVxuICAgICAgZnMubHN0YXQoZW50cnkuYWJzb2x1dGUsIChlciwgc3QpID0+IHtcbiAgICAgICAgaWYgKHN0ICYmICh0aGlzLmtlZXAgfHwgdGhpcy5uZXdlciAmJiBzdC5tdGltZSA+IGVudHJ5Lm10aW1lKSlcbiAgICAgICAgICB0aGlzW1NLSVBdKGVudHJ5KVxuICAgICAgICBlbHNlIGlmIChlciB8fCB0aGlzW0lTUkVVU0FCTEVdKGVudHJ5LCBzdCkpXG4gICAgICAgICAgdGhpc1tNQUtFRlNdKG51bGwsIGVudHJ5KVxuICAgICAgICBlbHNlIGlmIChzdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgaWYgKGVudHJ5LnR5cGUgPT09ICdEaXJlY3RvcnknKSB7XG4gICAgICAgICAgICBpZiAoIWVudHJ5Lm1vZGUgfHwgKHN0Lm1vZGUgJiAwbzc3NzcpID09PSBlbnRyeS5tb2RlKVxuICAgICAgICAgICAgICB0aGlzW01BS0VGU10obnVsbCwgZW50cnkpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGZzLmNobW9kKGVudHJ5LmFic29sdXRlLCBlbnRyeS5tb2RlLCBlciA9PiB0aGlzW01BS0VGU10oZXIsIGVudHJ5KSlcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIGZzLnJtZGlyKGVudHJ5LmFic29sdXRlLCBlciA9PiB0aGlzW01BS0VGU10oZXIsIGVudHJ5KSlcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgdW5saW5rRmlsZShlbnRyeS5hYnNvbHV0ZSwgZXIgPT4gdGhpc1tNQUtFRlNdKGVyLCBlbnRyeSkpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBbTUFLRUZTXSAoZXIsIGVudHJ5KSB7XG4gICAgaWYgKGVyKVxuICAgICAgcmV0dXJuIHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KVxuXG4gICAgc3dpdGNoIChlbnRyeS50eXBlKSB7XG4gICAgICBjYXNlICdGaWxlJzpcbiAgICAgIGNhc2UgJ09sZEZpbGUnOlxuICAgICAgY2FzZSAnQ29udGlndW91c0ZpbGUnOlxuICAgICAgICByZXR1cm4gdGhpc1tGSUxFXShlbnRyeSlcblxuICAgICAgY2FzZSAnTGluayc6XG4gICAgICAgIHJldHVybiB0aGlzW0hBUkRMSU5LXShlbnRyeSlcblxuICAgICAgY2FzZSAnU3ltYm9saWNMaW5rJzpcbiAgICAgICAgcmV0dXJuIHRoaXNbU1lNTElOS10oZW50cnkpXG5cbiAgICAgIGNhc2UgJ0RpcmVjdG9yeSc6XG4gICAgICBjYXNlICdHTlVEdW1wRGlyJzpcbiAgICAgICAgcmV0dXJuIHRoaXNbRElSRUNUT1JZXShlbnRyeSlcbiAgICB9XG4gIH1cblxuICBbTElOS10gKGVudHJ5LCBsaW5rcGF0aCwgbGluaykge1xuICAgIC8vIFhYWDogZ2V0IHRoZSB0eXBlICgnZmlsZScgb3IgJ2RpcicpIGZvciB3aW5kb3dzXG4gICAgZnNbbGlua10obGlua3BhdGgsIGVudHJ5LmFic29sdXRlLCBlciA9PiB7XG4gICAgICBpZiAoZXIpXG4gICAgICAgIHJldHVybiB0aGlzW09ORVJST1JdKGVyLCBlbnRyeSlcbiAgICAgIHRoaXNbVU5QRU5EXSgpXG4gICAgICBlbnRyeS5yZXN1bWUoKVxuICAgIH0pXG4gIH1cbn1cblxuY2xhc3MgVW5wYWNrU3luYyBleHRlbmRzIFVucGFjayB7XG4gIGNvbnN0cnVjdG9yIChvcHQpIHtcbiAgICBzdXBlcihvcHQpXG4gIH1cblxuICBbQ0hFQ0tGU10gKGVudHJ5KSB7XG4gICAgY29uc3QgZXIgPSB0aGlzW01LRElSXShwYXRoLmRpcm5hbWUoZW50cnkuYWJzb2x1dGUpLCB0aGlzLmRtb2RlKVxuICAgIGlmIChlcilcbiAgICAgIHJldHVybiB0aGlzW09ORVJST1JdKGVyLCBlbnRyeSlcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3QgPSBmcy5sc3RhdFN5bmMoZW50cnkuYWJzb2x1dGUpXG4gICAgICBpZiAodGhpcy5rZWVwIHx8IHRoaXMubmV3ZXIgJiYgc3QubXRpbWUgPiBlbnRyeS5tdGltZSlcbiAgICAgICAgcmV0dXJuIHRoaXNbU0tJUF0oZW50cnkpXG4gICAgICBlbHNlIGlmICh0aGlzW0lTUkVVU0FCTEVdKGVudHJ5LCBzdCkpXG4gICAgICAgIHJldHVybiB0aGlzW01BS0VGU10obnVsbCwgZW50cnkpXG4gICAgICBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoc3QuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgaWYgKGVudHJ5LnR5cGUgPT09ICdEaXJlY3RvcnknKSB7XG4gICAgICAgICAgICAgIGlmIChlbnRyeS5tb2RlICYmIChzdC5tb2RlICYgMG83Nzc3KSAhPT0gZW50cnkubW9kZSlcbiAgICAgICAgICAgICAgICBmcy5jaG1vZFN5bmMoZW50cnkuYWJzb2x1dGUsIGVudHJ5Lm1vZGUpXG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgZnMucm1kaXJTeW5jKGVudHJ5LmFic29sdXRlKVxuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgdW5saW5rRmlsZVN5bmMoZW50cnkuYWJzb2x1dGUpXG4gICAgICAgICAgcmV0dXJuIHRoaXNbTUFLRUZTXShudWxsLCBlbnRyeSlcbiAgICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpc1tPTkVSUk9SXShlciwgZW50cnkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcikge1xuICAgICAgcmV0dXJuIHRoaXNbTUFLRUZTXShudWxsLCBlbnRyeSlcbiAgICB9XG4gIH1cblxuICBbRklMRV0gKGVudHJ5KSB7XG4gICAgY29uc3QgbW9kZSA9IGVudHJ5Lm1vZGUgJiAwbzc3NzcgfHwgdGhpcy5mbW9kZVxuXG4gICAgY29uc3Qgb25lciA9IGVyID0+IHtcbiAgICAgIHRyeSB7IGZzLmNsb3NlU3luYyhmZCkgfSBjYXRjaCAoXykge31cbiAgICAgIGlmIChlcilcbiAgICAgICAgdGhpc1tPTkVSUk9SXShlciwgZW50cnkpXG4gICAgfVxuXG4gICAgbGV0IHN0cmVhbVxuICAgIGxldCBmZFxuICAgIHRyeSB7XG4gICAgICBmZCA9IGZzLm9wZW5TeW5jKGVudHJ5LmFic29sdXRlLCAndycsIG1vZGUpXG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIHJldHVybiBvbmVyKGVyKVxuICAgIH1cbiAgICBjb25zdCB0eCA9IHRoaXMudHJhbnNmb3JtID8gdGhpcy50cmFuc2Zvcm0oZW50cnkpIHx8IGVudHJ5IDogZW50cnlcbiAgICBpZiAodHggIT09IGVudHJ5KSB7XG4gICAgICB0eC5vbignZXJyb3InLCBlciA9PiB0aGlzW09ORVJST1JdKGVyLCBlbnRyeSkpXG4gICAgICBlbnRyeS5waXBlKHR4KVxuICAgIH1cblxuICAgIHR4Lm9uKCdkYXRhJywgY2h1bmsgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZnMud3JpdGVTeW5jKGZkLCBjaHVuaywgMCwgY2h1bmsubGVuZ3RoKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgb25lcihlcilcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdHgub24oJ2VuZCcsIF8gPT4ge1xuICAgICAgbGV0IGVyID0gbnVsbFxuICAgICAgLy8gdHJ5IGJvdGgsIGZhbGxpbmcgZnV0aW1lcyBiYWNrIHRvIHV0aW1lc1xuICAgICAgLy8gaWYgZWl0aGVyIGZhaWxzLCBoYW5kbGUgdGhlIGZpcnN0IGVycm9yXG4gICAgICBpZiAoZW50cnkubXRpbWUgJiYgIXRoaXMubm9NdGltZSkge1xuICAgICAgICBjb25zdCBhdGltZSA9IGVudHJ5LmF0aW1lIHx8IG5ldyBEYXRlKClcbiAgICAgICAgY29uc3QgbXRpbWUgPSBlbnRyeS5tdGltZVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZzLmZ1dGltZXNTeW5jKGZkLCBhdGltZSwgbXRpbWUpXG4gICAgICAgIH0gY2F0Y2ggKGZ1dGltZXNlcikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmcy51dGltZXNTeW5jKGVudHJ5LmFic29sdXRlLCBhdGltZSwgbXRpbWUpXG4gICAgICAgICAgfSBjYXRjaCAodXRpbWVzZXIpIHtcbiAgICAgICAgICAgIGVyID0gZnV0aW1lc2VyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzW0RPQ0hPV05dKGVudHJ5KSkge1xuICAgICAgICBjb25zdCB1aWQgPSB0aGlzW1VJRF0oZW50cnkpXG4gICAgICAgIGNvbnN0IGdpZCA9IHRoaXNbR0lEXShlbnRyeSlcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZzLmZjaG93blN5bmMoZmQsIHVpZCwgZ2lkKVxuICAgICAgICB9IGNhdGNoIChmY2hvd25lcikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmcy5jaG93blN5bmMoZW50cnkuYWJzb2x1dGUsIHVpZCwgZ2lkKVxuICAgICAgICAgIH0gY2F0Y2ggKGNob3duZXIpIHtcbiAgICAgICAgICAgIGVyID0gZXIgfHwgZmNob3duZXJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb25lcihlcilcbiAgICB9KVxuICB9XG5cbiAgW0RJUkVDVE9SWV0gKGVudHJ5KSB7XG4gICAgY29uc3QgbW9kZSA9IGVudHJ5Lm1vZGUgJiAwbzc3NzcgfHwgdGhpcy5kbW9kZVxuICAgIGNvbnN0IGVyID0gdGhpc1tNS0RJUl0oZW50cnkuYWJzb2x1dGUsIG1vZGUpXG4gICAgaWYgKGVyKVxuICAgICAgcmV0dXJuIHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KVxuICAgIGlmIChlbnRyeS5tdGltZSAmJiAhdGhpcy5ub010aW1lKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmcy51dGltZXNTeW5jKGVudHJ5LmFic29sdXRlLCBlbnRyeS5hdGltZSB8fCBuZXcgRGF0ZSgpLCBlbnRyeS5tdGltZSlcbiAgICAgIH0gY2F0Y2ggKGVyKSB7fVxuICAgIH1cbiAgICBpZiAodGhpc1tET0NIT1dOXShlbnRyeSkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZzLmNob3duU3luYyhlbnRyeS5hYnNvbHV0ZSwgdGhpc1tVSURdKGVudHJ5KSwgdGhpc1tHSURdKGVudHJ5KSlcbiAgICAgIH0gY2F0Y2ggKGVyKSB7fVxuICAgIH1cbiAgICBlbnRyeS5yZXN1bWUoKVxuICB9XG5cbiAgW01LRElSXSAoZGlyLCBtb2RlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBta2Rpci5zeW5jKGRpciwge1xuICAgICAgICB1aWQ6IHRoaXMudWlkLFxuICAgICAgICBnaWQ6IHRoaXMuZ2lkLFxuICAgICAgICBwcm9jZXNzVWlkOiB0aGlzLnByb2Nlc3NVaWQsXG4gICAgICAgIHByb2Nlc3NHaWQ6IHRoaXMucHJvY2Vzc0dpZCxcbiAgICAgICAgdW1hc2s6IHRoaXMucHJvY2Vzc1VtYXNrLFxuICAgICAgICBwcmVzZXJ2ZTogdGhpcy5wcmVzZXJ2ZVBhdGhzLFxuICAgICAgICB1bmxpbms6IHRoaXMudW5saW5rLFxuICAgICAgICBjYWNoZTogdGhpcy5kaXJDYWNoZSxcbiAgICAgICAgY3dkOiB0aGlzLmN3ZCxcbiAgICAgICAgbW9kZTogbW9kZVxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcikge1xuICAgICAgcmV0dXJuIGVyXG4gICAgfVxuICB9XG5cbiAgW0xJTktdIChlbnRyeSwgbGlua3BhdGgsIGxpbmspIHtcbiAgICB0cnkge1xuICAgICAgZnNbbGluayArICdTeW5jJ10obGlua3BhdGgsIGVudHJ5LmFic29sdXRlKVxuICAgICAgZW50cnkucmVzdW1lKClcbiAgICB9IGNhdGNoIChlcikge1xuICAgICAgcmV0dXJuIHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KVxuICAgIH1cbiAgfVxufVxuXG5VbnBhY2suU3luYyA9IFVucGFja1N5bmNcbm1vZHVsZS5leHBvcnRzID0gVW5wYWNrXG4iLCIndXNlIHN0cmljdCdcblxuLy8gdGFyIC11XG5cbmNvbnN0IGhsbyA9IHJlcXVpcmUoJy4vaGlnaC1sZXZlbC1vcHQuanMnKVxuY29uc3QgciA9IHJlcXVpcmUoJy4vcmVwbGFjZS5qcycpXG4vLyBqdXN0IGNhbGwgdGFyLnIgd2l0aCB0aGUgZmlsdGVyIGFuZCBtdGltZUNhY2hlXG5cbmNvbnN0IHUgPSBtb2R1bGUuZXhwb3J0cyA9IChvcHRfLCBmaWxlcywgY2IpID0+IHtcbiAgY29uc3Qgb3B0ID0gaGxvKG9wdF8pXG5cbiAgaWYgKCFvcHQuZmlsZSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmaWxlIGlzIHJlcXVpcmVkJylcblxuICBpZiAob3B0Lmd6aXApXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2Fubm90IGFwcGVuZCB0byBjb21wcmVzc2VkIGFyY2hpdmVzJylcblxuICBpZiAoIWZpbGVzIHx8ICFBcnJheS5pc0FycmF5KGZpbGVzKSB8fCAhZmlsZXMubGVuZ3RoKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vIGZpbGVzIG9yIGRpcmVjdG9yaWVzIHNwZWNpZmllZCcpXG5cbiAgZmlsZXMgPSBBcnJheS5mcm9tKGZpbGVzKVxuXG4gIG10aW1lRmlsdGVyKG9wdClcbiAgcmV0dXJuIHIob3B0LCBmaWxlcywgY2IpXG59XG5cbmNvbnN0IG10aW1lRmlsdGVyID0gb3B0ID0+IHtcbiAgY29uc3QgZmlsdGVyID0gb3B0LmZpbHRlclxuXG4gIGlmICghb3B0Lm10aW1lQ2FjaGUpXG4gICAgb3B0Lm10aW1lQ2FjaGUgPSBuZXcgTWFwKClcblxuICBvcHQuZmlsdGVyID0gZmlsdGVyID8gKHBhdGgsIHN0YXQpID0+XG4gICAgZmlsdGVyKHBhdGgsIHN0YXQpICYmICEob3B0Lm10aW1lQ2FjaGUuZ2V0KHBhdGgpID4gc3RhdC5tdGltZSlcbiAgICA6IChwYXRoLCBzdGF0KSA9PiAhKG9wdC5tdGltZUNhY2hlLmdldChwYXRoKSA+IHN0YXQubXRpbWUpXG59XG4iLCIndXNlIHN0cmljdCdcbm1vZHVsZS5leHBvcnRzID0gQmFzZSA9PiBjbGFzcyBleHRlbmRzIEJhc2Uge1xuICB3YXJuIChtc2csIGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuc3RyaWN0KVxuICAgICAgdGhpcy5lbWl0KCd3YXJuJywgbXNnLCBkYXRhKVxuICAgIGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBFcnJvcilcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBkYXRhKVxuICAgIGVsc2Uge1xuICAgICAgY29uc3QgZXIgPSBuZXcgRXJyb3IobXNnKVxuICAgICAgZXIuZGF0YSA9IGRhdGFcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcilcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG4vLyBXaGVuIHdyaXRpbmcgZmlsZXMgb24gV2luZG93cywgdHJhbnNsYXRlIHRoZSBjaGFyYWN0ZXJzIHRvIHRoZWlyXG4vLyAweGYwMDAgaGlnaGVyLWVuY29kZWQgdmVyc2lvbnMuXG5cbmNvbnN0IHJhdyA9IFtcbiAgJ3wnLFxuICAnPCcsXG4gICc+JyxcbiAgJz8nLFxuICAnOidcbl1cblxuY29uc3Qgd2luID0gcmF3Lm1hcChjaGFyID0+XG4gIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhmMDAwICsgY2hhci5jaGFyQ29kZUF0KDApKSlcblxuY29uc3QgdG9XaW4gPSBuZXcgTWFwKHJhdy5tYXAoKGNoYXIsIGkpID0+IFtjaGFyLCB3aW5baV1dKSlcbmNvbnN0IHRvUmF3ID0gbmV3IE1hcCh3aW4ubWFwKChjaGFyLCBpKSA9PiBbY2hhciwgcmF3W2ldXSkpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlbmNvZGU6IHMgPT4gcmF3LnJlZHVjZSgocywgYykgPT4gcy5zcGxpdChjKS5qb2luKHRvV2luLmdldChjKSksIHMpLFxuICBkZWNvZGU6IHMgPT4gd2luLnJlZHVjZSgocywgYykgPT4gcy5zcGxpdChjKS5qb2luKHRvUmF3LmdldChjKSksIHMpXG59XG4iLCIndXNlIHN0cmljdCdcbmNvbnN0IEJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyLmpzJylcbmNvbnN0IE1pbmlQYXNzID0gcmVxdWlyZSgnbWluaXBhc3MnKVxuY29uc3QgUGF4ID0gcmVxdWlyZSgnLi9wYXguanMnKVxuY29uc3QgSGVhZGVyID0gcmVxdWlyZSgnLi9oZWFkZXIuanMnKVxuY29uc3QgUmVhZEVudHJ5ID0gcmVxdWlyZSgnLi9yZWFkLWVudHJ5LmpzJylcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuXG5jb25zdCB0eXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMuanMnKVxuY29uc3QgbWF4UmVhZFNpemUgPSAxNiAqIDEwMjQgKiAxMDI0XG5jb25zdCBQUk9DRVNTID0gU3ltYm9sKCdwcm9jZXNzJylcbmNvbnN0IEZJTEUgPSBTeW1ib2woJ2ZpbGUnKVxuY29uc3QgRElSRUNUT1JZID0gU3ltYm9sKCdkaXJlY3RvcnknKVxuY29uc3QgU1lNTElOSyA9IFN5bWJvbCgnc3ltbGluaycpXG5jb25zdCBIQVJETElOSyA9IFN5bWJvbCgnaGFyZGxpbmsnKVxuY29uc3QgSEVBREVSID0gU3ltYm9sKCdoZWFkZXInKVxuY29uc3QgUkVBRCA9IFN5bWJvbCgncmVhZCcpXG5jb25zdCBMU1RBVCA9IFN5bWJvbCgnbHN0YXQnKVxuY29uc3QgT05MU1RBVCA9IFN5bWJvbCgnb25sc3RhdCcpXG5jb25zdCBPTlJFQUQgPSBTeW1ib2woJ29ucmVhZCcpXG5jb25zdCBPTlJFQURMSU5LID0gU3ltYm9sKCdvbnJlYWRsaW5rJylcbmNvbnN0IE9QRU5GSUxFID0gU3ltYm9sKCdvcGVuZmlsZScpXG5jb25zdCBPTk9QRU5GSUxFID0gU3ltYm9sKCdvbm9wZW5maWxlJylcbmNvbnN0IENMT1NFID0gU3ltYm9sKCdjbG9zZScpXG5jb25zdCBNT0RFID0gU3ltYm9sKCdtb2RlJylcbmNvbnN0IHdhcm5lciA9IHJlcXVpcmUoJy4vd2Fybi1taXhpbi5qcycpXG5jb25zdCB3aW5jaGFycyA9IHJlcXVpcmUoJy4vd2luY2hhcnMuanMnKVxuXG5jb25zdCBtb2RlRml4ID0gcmVxdWlyZSgnLi9tb2RlLWZpeC5qcycpXG5cbmNvbnN0IFdyaXRlRW50cnkgPSB3YXJuZXIoY2xhc3MgV3JpdGVFbnRyeSBleHRlbmRzIE1pbmlQYXNzIHtcbiAgY29uc3RydWN0b3IgKHAsIG9wdCkge1xuICAgIG9wdCA9IG9wdCB8fCB7fVxuICAgIHN1cGVyKG9wdClcbiAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGF0aCBpcyByZXF1aXJlZCcpXG4gICAgdGhpcy5wYXRoID0gcFxuICAgIC8vIHN1cHByZXNzIGF0aW1lLCBjdGltZSwgdWlkLCBnaWQsIHVuYW1lLCBnbmFtZVxuICAgIHRoaXMucG9ydGFibGUgPSAhIW9wdC5wb3J0YWJsZVxuICAgIC8vIHVudGlsIG5vZGUgaGFzIGJ1aWx0aW4gcHduYW0gZnVuY3Rpb25zLCB0aGlzJ2xsIGhhdmUgdG8gZG9cbiAgICB0aGlzLm15dWlkID0gcHJvY2Vzcy5nZXR1aWQgJiYgcHJvY2Vzcy5nZXR1aWQoKVxuICAgIHRoaXMubXl1c2VyID0gcHJvY2Vzcy5lbnYuVVNFUiB8fCAnJ1xuICAgIHRoaXMubWF4UmVhZFNpemUgPSBvcHQubWF4UmVhZFNpemUgfHwgbWF4UmVhZFNpemVcbiAgICB0aGlzLmxpbmtDYWNoZSA9IG9wdC5saW5rQ2FjaGUgfHwgbmV3IE1hcCgpXG4gICAgdGhpcy5zdGF0Q2FjaGUgPSBvcHQuc3RhdENhY2hlIHx8IG5ldyBNYXAoKVxuICAgIHRoaXMucHJlc2VydmVQYXRocyA9ICEhb3B0LnByZXNlcnZlUGF0aHNcbiAgICB0aGlzLmN3ZCA9IG9wdC5jd2QgfHwgcHJvY2Vzcy5jd2QoKVxuICAgIHRoaXMuc3RyaWN0ID0gISFvcHQuc3RyaWN0XG4gICAgdGhpcy5ub1BheCA9ICEhb3B0Lm5vUGF4XG4gICAgdGhpcy5ub010aW1lID0gISFvcHQubm9NdGltZVxuICAgIHRoaXMubXRpbWUgPSBvcHQubXRpbWUgfHwgbnVsbFxuXG4gICAgaWYgKHR5cGVvZiBvcHQub253YXJuID09PSAnZnVuY3Rpb24nKVxuICAgICAgdGhpcy5vbignd2FybicsIG9wdC5vbndhcm4pXG5cbiAgICBpZiAoIXRoaXMucHJlc2VydmVQYXRocyAmJiBwYXRoLndpbjMyLmlzQWJzb2x1dGUocCkpIHtcbiAgICAgIC8vIGFic29sdXRlcyBvbiBwb3NpeCBhcmUgYWxzbyBhYnNvbHV0ZXMgb24gd2luMzJcbiAgICAgIC8vIHNvIHdlIG9ubHkgbmVlZCB0byB0ZXN0IHRoaXMgb25lIHRvIGdldCBib3RoXG4gICAgICBjb25zdCBwYXJzZWQgPSBwYXRoLndpbjMyLnBhcnNlKHApXG4gICAgICB0aGlzLndhcm4oJ3N0cmlwcGluZyAnICsgcGFyc2VkLnJvb3QgKyAnIGZyb20gYWJzb2x1dGUgcGF0aCcsIHApXG4gICAgICB0aGlzLnBhdGggPSBwLnN1YnN0cihwYXJzZWQucm9vdC5sZW5ndGgpXG4gICAgfVxuXG4gICAgdGhpcy53aW4zMiA9ICEhb3B0LndpbjMyIHx8IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMidcbiAgICBpZiAodGhpcy53aW4zMikge1xuICAgICAgdGhpcy5wYXRoID0gd2luY2hhcnMuZGVjb2RlKHRoaXMucGF0aC5yZXBsYWNlKC9cXFxcL2csICcvJykpXG4gICAgICBwID0gcC5yZXBsYWNlKC9cXFxcL2csICcvJylcbiAgICB9XG5cbiAgICB0aGlzLmFic29sdXRlID0gb3B0LmFic29sdXRlIHx8IHBhdGgucmVzb2x2ZSh0aGlzLmN3ZCwgcClcblxuICAgIGlmICh0aGlzLnBhdGggPT09ICcnKVxuICAgICAgdGhpcy5wYXRoID0gJy4vJ1xuXG4gICAgaWYgKHRoaXMuc3RhdENhY2hlLmhhcyh0aGlzLmFic29sdXRlKSlcbiAgICAgIHRoaXNbT05MU1RBVF0odGhpcy5zdGF0Q2FjaGUuZ2V0KHRoaXMuYWJzb2x1dGUpKVxuICAgIGVsc2VcbiAgICAgIHRoaXNbTFNUQVRdKClcbiAgfVxuXG4gIFtMU1RBVF0gKCkge1xuICAgIGZzLmxzdGF0KHRoaXMuYWJzb2x1dGUsIChlciwgc3RhdCkgPT4ge1xuICAgICAgaWYgKGVyKVxuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIGVyKVxuICAgICAgdGhpc1tPTkxTVEFUXShzdGF0KVxuICAgIH0pXG4gIH1cblxuICBbT05MU1RBVF0gKHN0YXQpIHtcbiAgICB0aGlzLnN0YXRDYWNoZS5zZXQodGhpcy5hYnNvbHV0ZSwgc3RhdClcbiAgICB0aGlzLnN0YXQgPSBzdGF0XG4gICAgaWYgKCFzdGF0LmlzRmlsZSgpKVxuICAgICAgc3RhdC5zaXplID0gMFxuICAgIHRoaXMudHlwZSA9IGdldFR5cGUoc3RhdClcbiAgICB0aGlzLmVtaXQoJ3N0YXQnLCBzdGF0KVxuICAgIHRoaXNbUFJPQ0VTU10oKVxuICB9XG5cbiAgW1BST0NFU1NdICgpIHtcbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgY2FzZSAnRmlsZSc6IHJldHVybiB0aGlzW0ZJTEVdKClcbiAgICAgIGNhc2UgJ0RpcmVjdG9yeSc6IHJldHVybiB0aGlzW0RJUkVDVE9SWV0oKVxuICAgICAgY2FzZSAnU3ltYm9saWNMaW5rJzogcmV0dXJuIHRoaXNbU1lNTElOS10oKVxuICAgICAgLy8gdW5zdXBwb3J0ZWQgdHlwZXMgYXJlIGlnbm9yZWQuXG4gICAgICBkZWZhdWx0OiByZXR1cm4gdGhpcy5lbmQoKVxuICAgIH1cbiAgfVxuXG4gIFtNT0RFXSAobW9kZSkge1xuICAgIHJldHVybiBtb2RlRml4KG1vZGUsIHRoaXMudHlwZSA9PT0gJ0RpcmVjdG9yeScpXG4gIH1cblxuICBbSEVBREVSXSAoKSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gJ0RpcmVjdG9yeScgJiYgdGhpcy5wb3J0YWJsZSlcbiAgICAgIHRoaXMubm9NdGltZSA9IHRydWVcblxuICAgIHRoaXMuaGVhZGVyID0gbmV3IEhlYWRlcih7XG4gICAgICBwYXRoOiB0aGlzLnBhdGgsXG4gICAgICBsaW5rcGF0aDogdGhpcy5saW5rcGF0aCxcbiAgICAgIC8vIG9ubHkgdGhlIHBlcm1pc3Npb25zIGFuZCBzZXR1aWQvc2V0Z2lkL3N0aWNreSBiaXRmbGFnc1xuICAgICAgLy8gbm90IHRoZSBoaWdoZXItb3JkZXIgYml0cyB0aGF0IHNwZWNpZnkgZmlsZSB0eXBlXG4gICAgICBtb2RlOiB0aGlzW01PREVdKHRoaXMuc3RhdC5tb2RlKSxcbiAgICAgIHVpZDogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLnN0YXQudWlkLFxuICAgICAgZ2lkOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMuc3RhdC5naWQsXG4gICAgICBzaXplOiB0aGlzLnN0YXQuc2l6ZSxcbiAgICAgIG10aW1lOiB0aGlzLm5vTXRpbWUgPyBudWxsIDogdGhpcy5tdGltZSB8fCB0aGlzLnN0YXQubXRpbWUsXG4gICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICB1bmFtZTogdGhpcy5wb3J0YWJsZSA/IG51bGwgOlxuICAgICAgICB0aGlzLnN0YXQudWlkID09PSB0aGlzLm15dWlkID8gdGhpcy5teXVzZXIgOiAnJyxcbiAgICAgIGF0aW1lOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMuc3RhdC5hdGltZSxcbiAgICAgIGN0aW1lOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMuc3RhdC5jdGltZVxuICAgIH0pXG5cbiAgICBpZiAodGhpcy5oZWFkZXIuZW5jb2RlKCkgJiYgIXRoaXMubm9QYXgpXG4gICAgICB0aGlzLndyaXRlKG5ldyBQYXgoe1xuICAgICAgICBhdGltZTogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLmhlYWRlci5hdGltZSxcbiAgICAgICAgY3RpbWU6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy5oZWFkZXIuY3RpbWUsXG4gICAgICAgIGdpZDogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLmhlYWRlci5naWQsXG4gICAgICAgIG10aW1lOiB0aGlzLm5vTXRpbWUgPyBudWxsIDogdGhpcy5tdGltZSB8fCB0aGlzLmhlYWRlci5tdGltZSxcbiAgICAgICAgcGF0aDogdGhpcy5wYXRoLFxuICAgICAgICBsaW5rcGF0aDogdGhpcy5saW5rcGF0aCxcbiAgICAgICAgc2l6ZTogdGhpcy5oZWFkZXIuc2l6ZSxcbiAgICAgICAgdWlkOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMuaGVhZGVyLnVpZCxcbiAgICAgICAgdW5hbWU6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy5oZWFkZXIudW5hbWUsXG4gICAgICAgIGRldjogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLnN0YXQuZGV2LFxuICAgICAgICBpbm86IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy5zdGF0LmlubyxcbiAgICAgICAgbmxpbms6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy5zdGF0Lm5saW5rXG4gICAgICB9KS5lbmNvZGUoKSlcbiAgICB0aGlzLndyaXRlKHRoaXMuaGVhZGVyLmJsb2NrKVxuICB9XG5cbiAgW0RJUkVDVE9SWV0gKCkge1xuICAgIGlmICh0aGlzLnBhdGguc3Vic3RyKC0xKSAhPT0gJy8nKVxuICAgICAgdGhpcy5wYXRoICs9ICcvJ1xuICAgIHRoaXMuc3RhdC5zaXplID0gMFxuICAgIHRoaXNbSEVBREVSXSgpXG4gICAgdGhpcy5lbmQoKVxuICB9XG5cbiAgW1NZTUxJTktdICgpIHtcbiAgICBmcy5yZWFkbGluayh0aGlzLmFic29sdXRlLCAoZXIsIGxpbmtwYXRoKSA9PiB7XG4gICAgICBpZiAoZXIpXG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgICB0aGlzW09OUkVBRExJTktdKGxpbmtwYXRoKVxuICAgIH0pXG4gIH1cblxuICBbT05SRUFETElOS10gKGxpbmtwYXRoKSB7XG4gICAgdGhpcy5saW5rcGF0aCA9IGxpbmtwYXRoXG4gICAgdGhpc1tIRUFERVJdKClcbiAgICB0aGlzLmVuZCgpXG4gIH1cblxuICBbSEFSRExJTktdIChsaW5rcGF0aCkge1xuICAgIHRoaXMudHlwZSA9ICdMaW5rJ1xuICAgIHRoaXMubGlua3BhdGggPSBwYXRoLnJlbGF0aXZlKHRoaXMuY3dkLCBsaW5rcGF0aClcbiAgICB0aGlzLnN0YXQuc2l6ZSA9IDBcbiAgICB0aGlzW0hFQURFUl0oKVxuICAgIHRoaXMuZW5kKClcbiAgfVxuXG4gIFtGSUxFXSAoKSB7XG4gICAgaWYgKHRoaXMuc3RhdC5ubGluayA+IDEpIHtcbiAgICAgIGNvbnN0IGxpbmtLZXkgPSB0aGlzLnN0YXQuZGV2ICsgJzonICsgdGhpcy5zdGF0Lmlub1xuICAgICAgaWYgKHRoaXMubGlua0NhY2hlLmhhcyhsaW5rS2V5KSkge1xuICAgICAgICBjb25zdCBsaW5rcGF0aCA9IHRoaXMubGlua0NhY2hlLmdldChsaW5rS2V5KVxuICAgICAgICBpZiAobGlua3BhdGguaW5kZXhPZih0aGlzLmN3ZCkgPT09IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXNbSEFSRExJTktdKGxpbmtwYXRoKVxuICAgICAgfVxuICAgICAgdGhpcy5saW5rQ2FjaGUuc2V0KGxpbmtLZXksIHRoaXMuYWJzb2x1dGUpXG4gICAgfVxuXG4gICAgdGhpc1tIRUFERVJdKClcbiAgICBpZiAodGhpcy5zdGF0LnNpemUgPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5lbmQoKVxuXG4gICAgdGhpc1tPUEVORklMRV0oKVxuICB9XG5cbiAgW09QRU5GSUxFXSAoKSB7XG4gICAgZnMub3Blbih0aGlzLmFic29sdXRlLCAncicsIChlciwgZmQpID0+IHtcbiAgICAgIGlmIChlcilcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBlcilcbiAgICAgIHRoaXNbT05PUEVORklMRV0oZmQpXG4gICAgfSlcbiAgfVxuXG4gIFtPTk9QRU5GSUxFXSAoZmQpIHtcbiAgICBjb25zdCBibG9ja0xlbiA9IDUxMiAqIE1hdGguY2VpbCh0aGlzLnN0YXQuc2l6ZSAvIDUxMilcbiAgICBjb25zdCBidWZMZW4gPSBNYXRoLm1pbihibG9ja0xlbiwgdGhpcy5tYXhSZWFkU2l6ZSlcbiAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYnVmTGVuKVxuICAgIHRoaXNbUkVBRF0oZmQsIGJ1ZiwgMCwgYnVmLmxlbmd0aCwgMCwgdGhpcy5zdGF0LnNpemUsIGJsb2NrTGVuKVxuICB9XG5cbiAgW1JFQURdIChmZCwgYnVmLCBvZmZzZXQsIGxlbmd0aCwgcG9zLCByZW1haW4sIGJsb2NrUmVtYWluKSB7XG4gICAgZnMucmVhZChmZCwgYnVmLCBvZmZzZXQsIGxlbmd0aCwgcG9zLCAoZXIsIGJ5dGVzUmVhZCkgPT4ge1xuICAgICAgaWYgKGVyKVxuICAgICAgICByZXR1cm4gdGhpc1tDTE9TRV0oZmQsIF8gPT4gdGhpcy5lbWl0KCdlcnJvcicsIGVyKSlcbiAgICAgIHRoaXNbT05SRUFEXShmZCwgYnVmLCBvZmZzZXQsIGxlbmd0aCwgcG9zLCByZW1haW4sIGJsb2NrUmVtYWluLCBieXRlc1JlYWQpXG4gICAgfSlcbiAgfVxuXG4gIFtDTE9TRV0gKGZkLCBjYikge1xuICAgIGZzLmNsb3NlKGZkLCBjYilcbiAgfVxuXG4gIFtPTlJFQURdIChmZCwgYnVmLCBvZmZzZXQsIGxlbmd0aCwgcG9zLCByZW1haW4sIGJsb2NrUmVtYWluLCBieXRlc1JlYWQpIHtcbiAgICBpZiAoYnl0ZXNSZWFkIDw9IDAgJiYgcmVtYWluID4gMCkge1xuICAgICAgY29uc3QgZXIgPSBuZXcgRXJyb3IoJ2VuY291bnRlcmVkIHVuZXhwZWN0ZWQgRU9GJylcbiAgICAgIGVyLnBhdGggPSB0aGlzLmFic29sdXRlXG4gICAgICBlci5zeXNjYWxsID0gJ3JlYWQnXG4gICAgICBlci5jb2RlID0gJ0VPRidcbiAgICAgIHRoaXNbQ0xPU0VdKGZkLCBfID0+IF8pXG4gICAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIGVyKVxuICAgIH1cblxuICAgIGlmIChieXRlc1JlYWQgPiByZW1haW4pIHtcbiAgICAgIGNvbnN0IGVyID0gbmV3IEVycm9yKCdkaWQgbm90IGVuY291bnRlciBleHBlY3RlZCBFT0YnKVxuICAgICAgZXIucGF0aCA9IHRoaXMuYWJzb2x1dGVcbiAgICAgIGVyLnN5c2NhbGwgPSAncmVhZCdcbiAgICAgIGVyLmNvZGUgPSAnRU9GJ1xuICAgICAgdGhpc1tDTE9TRV0oZmQsIF8gPT4gXylcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgfVxuXG4gICAgLy8gbnVsbCBvdXQgdGhlIHJlc3Qgb2YgdGhlIGJ1ZmZlciwgaWYgd2UgY291bGQgZml0IHRoZSBibG9jayBwYWRkaW5nXG4gICAgaWYgKGJ5dGVzUmVhZCA9PT0gcmVtYWluKSB7XG4gICAgICBmb3IgKGxldCBpID0gYnl0ZXNSZWFkOyBpIDwgbGVuZ3RoICYmIGJ5dGVzUmVhZCA8IGJsb2NrUmVtYWluOyBpKyspIHtcbiAgICAgICAgYnVmW2kgKyBvZmZzZXRdID0gMFxuICAgICAgICBieXRlc1JlYWQgKytcbiAgICAgICAgcmVtYWluICsrXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgd3JpdGVCdWYgPSBvZmZzZXQgPT09IDAgJiYgYnl0ZXNSZWFkID09PSBidWYubGVuZ3RoID9cbiAgICAgIGJ1ZiA6IGJ1Zi5zbGljZShvZmZzZXQsIG9mZnNldCArIGJ5dGVzUmVhZClcbiAgICByZW1haW4gLT0gYnl0ZXNSZWFkXG4gICAgYmxvY2tSZW1haW4gLT0gYnl0ZXNSZWFkXG4gICAgcG9zICs9IGJ5dGVzUmVhZFxuICAgIG9mZnNldCArPSBieXRlc1JlYWRcblxuICAgIHRoaXMud3JpdGUod3JpdGVCdWYpXG5cbiAgICBpZiAoIXJlbWFpbikge1xuICAgICAgaWYgKGJsb2NrUmVtYWluKVxuICAgICAgICB0aGlzLndyaXRlKEJ1ZmZlci5hbGxvYyhibG9ja1JlbWFpbikpXG4gICAgICB0aGlzLmVuZCgpXG4gICAgICB0aGlzW0NMT1NFXShmZCwgXyA9PiBfKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKG9mZnNldCA+PSBsZW5ndGgpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gICAgICBvZmZzZXQgPSAwXG4gICAgfVxuICAgIGxlbmd0aCA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgICB0aGlzW1JFQURdKGZkLCBidWYsIG9mZnNldCwgbGVuZ3RoLCBwb3MsIHJlbWFpbiwgYmxvY2tSZW1haW4pXG4gIH1cbn0pXG5cbmNsYXNzIFdyaXRlRW50cnlTeW5jIGV4dGVuZHMgV3JpdGVFbnRyeSB7XG4gIGNvbnN0cnVjdG9yIChwYXRoLCBvcHQpIHtcbiAgICBzdXBlcihwYXRoLCBvcHQpXG4gIH1cblxuICBbTFNUQVRdICgpIHtcbiAgICB0aGlzW09OTFNUQVRdKGZzLmxzdGF0U3luYyh0aGlzLmFic29sdXRlKSlcbiAgfVxuXG4gIFtTWU1MSU5LXSAoKSB7XG4gICAgdGhpc1tPTlJFQURMSU5LXShmcy5yZWFkbGlua1N5bmModGhpcy5hYnNvbHV0ZSkpXG4gIH1cblxuICBbT1BFTkZJTEVdICgpIHtcbiAgICB0aGlzW09OT1BFTkZJTEVdKGZzLm9wZW5TeW5jKHRoaXMuYWJzb2x1dGUsICdyJykpXG4gIH1cblxuICBbUkVBRF0gKGZkLCBidWYsIG9mZnNldCwgbGVuZ3RoLCBwb3MsIHJlbWFpbiwgYmxvY2tSZW1haW4pIHtcbiAgICBsZXQgdGhyZXcgPSB0cnVlXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGJ5dGVzUmVhZCA9IGZzLnJlYWRTeW5jKGZkLCBidWYsIG9mZnNldCwgbGVuZ3RoLCBwb3MpXG4gICAgICB0aGlzW09OUkVBRF0oZmQsIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgsIHBvcywgcmVtYWluLCBibG9ja1JlbWFpbiwgYnl0ZXNSZWFkKVxuICAgICAgdGhyZXcgPSBmYWxzZVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodGhyZXcpXG4gICAgICAgIHRyeSB7IHRoaXNbQ0xPU0VdKGZkKSB9IGNhdGNoIChlcikge31cbiAgICB9XG4gIH1cblxuICBbQ0xPU0VdIChmZCkge1xuICAgIGZzLmNsb3NlU3luYyhmZClcbiAgfVxufVxuXG5jb25zdCBXcml0ZUVudHJ5VGFyID0gd2FybmVyKGNsYXNzIFdyaXRlRW50cnlUYXIgZXh0ZW5kcyBNaW5pUGFzcyB7XG4gIGNvbnN0cnVjdG9yIChyZWFkRW50cnksIG9wdCkge1xuICAgIG9wdCA9IG9wdCB8fCB7fVxuICAgIHN1cGVyKG9wdClcbiAgICB0aGlzLnByZXNlcnZlUGF0aHMgPSAhIW9wdC5wcmVzZXJ2ZVBhdGhzXG4gICAgdGhpcy5wb3J0YWJsZSA9ICEhb3B0LnBvcnRhYmxlXG4gICAgdGhpcy5zdHJpY3QgPSAhIW9wdC5zdHJpY3RcbiAgICB0aGlzLm5vUGF4ID0gISFvcHQubm9QYXhcbiAgICB0aGlzLm5vTXRpbWUgPSAhIW9wdC5ub010aW1lXG5cbiAgICB0aGlzLnJlYWRFbnRyeSA9IHJlYWRFbnRyeVxuICAgIHRoaXMudHlwZSA9IHJlYWRFbnRyeS50eXBlXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gJ0RpcmVjdG9yeScgJiYgdGhpcy5wb3J0YWJsZSlcbiAgICAgIHRoaXMubm9NdGltZSA9IHRydWVcblxuICAgIHRoaXMucGF0aCA9IHJlYWRFbnRyeS5wYXRoXG4gICAgdGhpcy5tb2RlID0gdGhpc1tNT0RFXShyZWFkRW50cnkubW9kZSlcbiAgICB0aGlzLnVpZCA9IHRoaXMucG9ydGFibGUgPyBudWxsIDogcmVhZEVudHJ5LnVpZFxuICAgIHRoaXMuZ2lkID0gdGhpcy5wb3J0YWJsZSA/IG51bGwgOiByZWFkRW50cnkuZ2lkXG4gICAgdGhpcy51bmFtZSA9IHRoaXMucG9ydGFibGUgPyBudWxsIDogcmVhZEVudHJ5LnVuYW1lXG4gICAgdGhpcy5nbmFtZSA9IHRoaXMucG9ydGFibGUgPyBudWxsIDogcmVhZEVudHJ5LmduYW1lXG4gICAgdGhpcy5zaXplID0gcmVhZEVudHJ5LnNpemVcbiAgICB0aGlzLm10aW1lID0gdGhpcy5ub010aW1lID8gbnVsbCA6IG9wdC5tdGltZSB8fCByZWFkRW50cnkubXRpbWVcbiAgICB0aGlzLmF0aW1lID0gdGhpcy5wb3J0YWJsZSA/IG51bGwgOiByZWFkRW50cnkuYXRpbWVcbiAgICB0aGlzLmN0aW1lID0gdGhpcy5wb3J0YWJsZSA/IG51bGwgOiByZWFkRW50cnkuY3RpbWVcbiAgICB0aGlzLmxpbmtwYXRoID0gcmVhZEVudHJ5LmxpbmtwYXRoXG5cbiAgICBpZiAodHlwZW9mIG9wdC5vbndhcm4gPT09ICdmdW5jdGlvbicpXG4gICAgICB0aGlzLm9uKCd3YXJuJywgb3B0Lm9ud2FybilcblxuICAgIGlmIChwYXRoLmlzQWJzb2x1dGUodGhpcy5wYXRoKSAmJiAhdGhpcy5wcmVzZXJ2ZVBhdGhzKSB7XG4gICAgICBjb25zdCBwYXJzZWQgPSBwYXRoLnBhcnNlKHRoaXMucGF0aClcbiAgICAgIHRoaXMud2FybihcbiAgICAgICAgJ3N0cmlwcGluZyAnICsgcGFyc2VkLnJvb3QgKyAnIGZyb20gYWJzb2x1dGUgcGF0aCcsXG4gICAgICAgIHRoaXMucGF0aFxuICAgICAgKVxuICAgICAgdGhpcy5wYXRoID0gdGhpcy5wYXRoLnN1YnN0cihwYXJzZWQucm9vdC5sZW5ndGgpXG4gICAgfVxuXG4gICAgdGhpcy5yZW1haW4gPSByZWFkRW50cnkuc2l6ZVxuICAgIHRoaXMuYmxvY2tSZW1haW4gPSByZWFkRW50cnkuc3RhcnRCbG9ja1NpemVcblxuICAgIHRoaXMuaGVhZGVyID0gbmV3IEhlYWRlcih7XG4gICAgICBwYXRoOiB0aGlzLnBhdGgsXG4gICAgICBsaW5rcGF0aDogdGhpcy5saW5rcGF0aCxcbiAgICAgIC8vIG9ubHkgdGhlIHBlcm1pc3Npb25zIGFuZCBzZXR1aWQvc2V0Z2lkL3N0aWNreSBiaXRmbGFnc1xuICAgICAgLy8gbm90IHRoZSBoaWdoZXItb3JkZXIgYml0cyB0aGF0IHNwZWNpZnkgZmlsZSB0eXBlXG4gICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICB1aWQ6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy51aWQsXG4gICAgICBnaWQ6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy5naWQsXG4gICAgICBzaXplOiB0aGlzLnNpemUsXG4gICAgICBtdGltZTogdGhpcy5ub010aW1lID8gbnVsbCA6IHRoaXMubXRpbWUsXG4gICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICB1bmFtZTogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLnVuYW1lLFxuICAgICAgYXRpbWU6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy5hdGltZSxcbiAgICAgIGN0aW1lOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMuY3RpbWVcbiAgICB9KVxuXG4gICAgaWYgKHRoaXMuaGVhZGVyLmVuY29kZSgpICYmICF0aGlzLm5vUGF4KVxuICAgICAgc3VwZXIud3JpdGUobmV3IFBheCh7XG4gICAgICAgIGF0aW1lOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMuYXRpbWUsXG4gICAgICAgIGN0aW1lOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMuY3RpbWUsXG4gICAgICAgIGdpZDogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLmdpZCxcbiAgICAgICAgbXRpbWU6IHRoaXMubm9NdGltZSA/IG51bGwgOiB0aGlzLm10aW1lLFxuICAgICAgICBwYXRoOiB0aGlzLnBhdGgsXG4gICAgICAgIGxpbmtwYXRoOiB0aGlzLmxpbmtwYXRoLFxuICAgICAgICBzaXplOiB0aGlzLnNpemUsXG4gICAgICAgIHVpZDogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLnVpZCxcbiAgICAgICAgdW5hbWU6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy51bmFtZSxcbiAgICAgICAgZGV2OiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMucmVhZEVudHJ5LmRldixcbiAgICAgICAgaW5vOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMucmVhZEVudHJ5LmlubyxcbiAgICAgICAgbmxpbms6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy5yZWFkRW50cnkubmxpbmtcbiAgICAgIH0pLmVuY29kZSgpKVxuXG4gICAgc3VwZXIud3JpdGUodGhpcy5oZWFkZXIuYmxvY2spXG4gICAgcmVhZEVudHJ5LnBpcGUodGhpcylcbiAgfVxuXG4gIFtNT0RFXSAobW9kZSkge1xuICAgIHJldHVybiBtb2RlRml4KG1vZGUsIHRoaXMudHlwZSA9PT0gJ0RpcmVjdG9yeScpXG4gIH1cblxuICB3cml0ZSAoZGF0YSkge1xuICAgIGNvbnN0IHdyaXRlTGVuID0gZGF0YS5sZW5ndGhcbiAgICBpZiAod3JpdGVMZW4gPiB0aGlzLmJsb2NrUmVtYWluKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cml0aW5nIG1vcmUgdG8gZW50cnkgdGhhbiBpcyBhcHByb3ByaWF0ZScpXG4gICAgdGhpcy5ibG9ja1JlbWFpbiAtPSB3cml0ZUxlblxuICAgIHJldHVybiBzdXBlci53cml0ZShkYXRhKVxuICB9XG5cbiAgZW5kICgpIHtcbiAgICBpZiAodGhpcy5ibG9ja1JlbWFpbilcbiAgICAgIHRoaXMud3JpdGUoQnVmZmVyLmFsbG9jKHRoaXMuYmxvY2tSZW1haW4pKVxuICAgIHJldHVybiBzdXBlci5lbmQoKVxuICB9XG59KVxuXG5Xcml0ZUVudHJ5LlN5bmMgPSBXcml0ZUVudHJ5U3luY1xuV3JpdGVFbnRyeS5UYXIgPSBXcml0ZUVudHJ5VGFyXG5cbmNvbnN0IGdldFR5cGUgPSBzdGF0ID0+XG4gIHN0YXQuaXNGaWxlKCkgPyAnRmlsZSdcbiAgOiBzdGF0LmlzRGlyZWN0b3J5KCkgPyAnRGlyZWN0b3J5J1xuICA6IHN0YXQuaXNTeW1ib2xpY0xpbmsoKSA/ICdTeW1ib2xpY0xpbmsnXG4gIDogJ1Vuc3VwcG9ydGVkJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRlRW50cnlcbiIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVwZGF0ZWRNb2R1bGVzLCByZW5ld2VkTW9kdWxlcykge1xuXHR2YXIgdW5hY2NlcHRlZE1vZHVsZXMgPSB1cGRhdGVkTW9kdWxlcy5maWx0ZXIoZnVuY3Rpb24obW9kdWxlSWQpIHtcblx0XHRyZXR1cm4gcmVuZXdlZE1vZHVsZXMgJiYgcmVuZXdlZE1vZHVsZXMuaW5kZXhPZihtb2R1bGVJZCkgPCAwO1xuXHR9KTtcblx0dmFyIGxvZyA9IHJlcXVpcmUoXCIuL2xvZ1wiKTtcblxuXHRpZiAodW5hY2NlcHRlZE1vZHVsZXMubGVuZ3RoID4gMCkge1xuXHRcdGxvZyhcblx0XHRcdFwid2FybmluZ1wiLFxuXHRcdFx0XCJbSE1SXSBUaGUgZm9sbG93aW5nIG1vZHVsZXMgY291bGRuJ3QgYmUgaG90IHVwZGF0ZWQ6IChUaGV5IHdvdWxkIG5lZWQgYSBmdWxsIHJlbG9hZCEpXCJcblx0XHQpO1xuXHRcdHVuYWNjZXB0ZWRNb2R1bGVzLmZvckVhY2goZnVuY3Rpb24obW9kdWxlSWQpIHtcblx0XHRcdGxvZyhcIndhcm5pbmdcIiwgXCJbSE1SXSAgLSBcIiArIG1vZHVsZUlkKTtcblx0XHR9KTtcblx0fVxuXG5cdGlmICghcmVuZXdlZE1vZHVsZXMgfHwgcmVuZXdlZE1vZHVsZXMubGVuZ3RoID09PSAwKSB7XG5cdFx0bG9nKFwiaW5mb1wiLCBcIltITVJdIE5vdGhpbmcgaG90IHVwZGF0ZWQuXCIpO1xuXHR9IGVsc2Uge1xuXHRcdGxvZyhcImluZm9cIiwgXCJbSE1SXSBVcGRhdGVkIG1vZHVsZXM6XCIpO1xuXHRcdHJlbmV3ZWRNb2R1bGVzLmZvckVhY2goZnVuY3Rpb24obW9kdWxlSWQpIHtcblx0XHRcdGlmICh0eXBlb2YgbW9kdWxlSWQgPT09IFwic3RyaW5nXCIgJiYgbW9kdWxlSWQuaW5kZXhPZihcIiFcIikgIT09IC0xKSB7XG5cdFx0XHRcdHZhciBwYXJ0cyA9IG1vZHVsZUlkLnNwbGl0KFwiIVwiKTtcblx0XHRcdFx0bG9nLmdyb3VwQ29sbGFwc2VkKFwiaW5mb1wiLCBcIltITVJdICAtIFwiICsgcGFydHMucG9wKCkpO1xuXHRcdFx0XHRsb2coXCJpbmZvXCIsIFwiW0hNUl0gIC0gXCIgKyBtb2R1bGVJZCk7XG5cdFx0XHRcdGxvZy5ncm91cEVuZChcImluZm9cIik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsb2coXCJpbmZvXCIsIFwiW0hNUl0gIC0gXCIgKyBtb2R1bGVJZCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0dmFyIG51bWJlcklkcyA9IHJlbmV3ZWRNb2R1bGVzLmV2ZXJ5KGZ1bmN0aW9uKG1vZHVsZUlkKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIG1vZHVsZUlkID09PSBcIm51bWJlclwiO1xuXHRcdH0pO1xuXHRcdGlmIChudW1iZXJJZHMpXG5cdFx0XHRsb2coXG5cdFx0XHRcdFwiaW5mb1wiLFxuXHRcdFx0XHRcIltITVJdIENvbnNpZGVyIHVzaW5nIHRoZSBOYW1lZE1vZHVsZXNQbHVnaW4gZm9yIG1vZHVsZSBuYW1lcy5cIlxuXHRcdFx0KTtcblx0fVxufTtcbiIsInZhciBsb2dMZXZlbCA9IFwiaW5mb1wiO1xuXG5mdW5jdGlvbiBkdW1teSgpIHt9XG5cbmZ1bmN0aW9uIHNob3VsZExvZyhsZXZlbCkge1xuXHR2YXIgc2hvdWxkTG9nID1cblx0XHQobG9nTGV2ZWwgPT09IFwiaW5mb1wiICYmIGxldmVsID09PSBcImluZm9cIikgfHxcblx0XHQoW1wiaW5mb1wiLCBcIndhcm5pbmdcIl0uaW5kZXhPZihsb2dMZXZlbCkgPj0gMCAmJiBsZXZlbCA9PT0gXCJ3YXJuaW5nXCIpIHx8XG5cdFx0KFtcImluZm9cIiwgXCJ3YXJuaW5nXCIsIFwiZXJyb3JcIl0uaW5kZXhPZihsb2dMZXZlbCkgPj0gMCAmJiBsZXZlbCA9PT0gXCJlcnJvclwiKTtcblx0cmV0dXJuIHNob3VsZExvZztcbn1cblxuZnVuY3Rpb24gbG9nR3JvdXAobG9nRm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uKGxldmVsLCBtc2cpIHtcblx0XHRpZiAoc2hvdWxkTG9nKGxldmVsKSkge1xuXHRcdFx0bG9nRm4obXNnKTtcblx0XHR9XG5cdH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGV2ZWwsIG1zZykge1xuXHRpZiAoc2hvdWxkTG9nKGxldmVsKSkge1xuXHRcdGlmIChsZXZlbCA9PT0gXCJpbmZvXCIpIHtcblx0XHRcdGNvbnNvbGUubG9nKG1zZyk7XG5cdFx0fSBlbHNlIGlmIChsZXZlbCA9PT0gXCJ3YXJuaW5nXCIpIHtcblx0XHRcdGNvbnNvbGUud2Fybihtc2cpO1xuXHRcdH0gZWxzZSBpZiAobGV2ZWwgPT09IFwiZXJyb3JcIikge1xuXHRcdFx0Y29uc29sZS5lcnJvcihtc2cpO1xuXHRcdH1cblx0fVxufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zICovXG52YXIgZ3JvdXAgPSBjb25zb2xlLmdyb3VwIHx8IGR1bW15O1xudmFyIGdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZCB8fCBkdW1teTtcbnZhciBncm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQgfHwgZHVtbXk7XG4vKiBlc2xpbnQtZW5hYmxlIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGlucyAqL1xuXG5tb2R1bGUuZXhwb3J0cy5ncm91cCA9IGxvZ0dyb3VwKGdyb3VwKTtcblxubW9kdWxlLmV4cG9ydHMuZ3JvdXBDb2xsYXBzZWQgPSBsb2dHcm91cChncm91cENvbGxhcHNlZCk7XG5cbm1vZHVsZS5leHBvcnRzLmdyb3VwRW5kID0gbG9nR3JvdXAoZ3JvdXBFbmQpO1xuXG5tb2R1bGUuZXhwb3J0cy5zZXRMb2dMZXZlbCA9IGZ1bmN0aW9uKGxldmVsKSB7XG5cdGxvZ0xldmVsID0gbGV2ZWw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mb3JtYXRFcnJvciA9IGZ1bmN0aW9uKGVycikge1xuXHR2YXIgbWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuXHR2YXIgc3RhY2sgPSBlcnIuc3RhY2s7XG5cdGlmICghc3RhY2spIHtcblx0XHRyZXR1cm4gbWVzc2FnZTtcblx0fSBlbHNlIGlmIChzdGFjay5pbmRleE9mKG1lc3NhZ2UpIDwgMCkge1xuXHRcdHJldHVybiBtZXNzYWdlICsgXCJcXG5cIiArIHN0YWNrO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBzdGFjaztcblx0fVxufTtcbiIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vKmdsb2JhbHMgX19yZXNvdXJjZVF1ZXJ5ICovXG5pZiAobW9kdWxlLmhvdCkge1xuXHR2YXIgaG90UG9sbEludGVydmFsID0gK19fcmVzb3VyY2VRdWVyeS5zdWJzdHIoMSkgfHwgMTAgKiA2MCAqIDEwMDA7XG5cdHZhciBsb2cgPSByZXF1aXJlKFwiLi9sb2dcIik7XG5cblx0dmFyIGNoZWNrRm9yVXBkYXRlID0gZnVuY3Rpb24gY2hlY2tGb3JVcGRhdGUoZnJvbVVwZGF0ZSkge1xuXHRcdGlmIChtb2R1bGUuaG90LnN0YXR1cygpID09PSBcImlkbGVcIikge1xuXHRcdFx0bW9kdWxlLmhvdFxuXHRcdFx0XHQuY2hlY2sodHJ1ZSlcblx0XHRcdFx0LnRoZW4oZnVuY3Rpb24odXBkYXRlZE1vZHVsZXMpIHtcblx0XHRcdFx0XHRpZiAoIXVwZGF0ZWRNb2R1bGVzKSB7XG5cdFx0XHRcdFx0XHRpZiAoZnJvbVVwZGF0ZSkgbG9nKFwiaW5mb1wiLCBcIltITVJdIFVwZGF0ZSBhcHBsaWVkLlwiKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVxdWlyZShcIi4vbG9nLWFwcGx5LXJlc3VsdFwiKSh1cGRhdGVkTW9kdWxlcywgdXBkYXRlZE1vZHVsZXMpO1xuXHRcdFx0XHRcdGNoZWNrRm9yVXBkYXRlKHRydWUpO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdFx0dmFyIHN0YXR1cyA9IG1vZHVsZS5ob3Quc3RhdHVzKCk7XG5cdFx0XHRcdFx0aWYgKFtcImFib3J0XCIsIFwiZmFpbFwiXS5pbmRleE9mKHN0YXR1cykgPj0gMCkge1xuXHRcdFx0XHRcdFx0bG9nKFwid2FybmluZ1wiLCBcIltITVJdIENhbm5vdCBhcHBseSB1cGRhdGUuXCIpO1xuXHRcdFx0XHRcdFx0bG9nKFwid2FybmluZ1wiLCBcIltITVJdIFwiICsgbG9nLmZvcm1hdEVycm9yKGVycikpO1xuXHRcdFx0XHRcdFx0bG9nKFwid2FybmluZ1wiLCBcIltITVJdIFlvdSBuZWVkIHRvIHJlc3RhcnQgdGhlIGFwcGxpY2F0aW9uIVwiKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bG9nKFwid2FybmluZ1wiLCBcIltITVJdIFVwZGF0ZSBmYWlsZWQ6IFwiICsgbG9nLmZvcm1hdEVycm9yKGVycikpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xuXHRzZXRJbnRlcnZhbChjaGVja0ZvclVwZGF0ZSwgaG90UG9sbEludGVydmFsKTtcbn0gZWxzZSB7XG5cdHRocm93IG5ldyBFcnJvcihcIltITVJdIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnQgaXMgZGlzYWJsZWQuXCIpO1xufVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgc3RyaW5nV2lkdGggPSByZXF1aXJlKCdzdHJpbmctd2lkdGgnKVxuXG5leHBvcnRzLmNlbnRlciA9IGFsaWduQ2VudGVyXG5leHBvcnRzLmxlZnQgPSBhbGlnbkxlZnRcbmV4cG9ydHMucmlnaHQgPSBhbGlnblJpZ2h0XG5cbi8vIGxvZGFzaCdzIHdheSBvZiBnZW5lcmF0aW5nIHBhZCBjaGFyYWN0ZXJzLlxuXG5mdW5jdGlvbiBjcmVhdGVQYWRkaW5nICh3aWR0aCkge1xuICB2YXIgcmVzdWx0ID0gJydcbiAgdmFyIHN0cmluZyA9ICcgJ1xuICB2YXIgbiA9IHdpZHRoXG4gIGRvIHtcbiAgICBpZiAobiAlIDIpIHtcbiAgICAgIHJlc3VsdCArPSBzdHJpbmc7XG4gICAgfVxuICAgIG4gPSBNYXRoLmZsb29yKG4gLyAyKTtcbiAgICBzdHJpbmcgKz0gc3RyaW5nO1xuICB9IHdoaWxlIChuKTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBhbGlnbkxlZnQgKHN0ciwgd2lkdGgpIHtcbiAgdmFyIHRyaW1tZWQgPSBzdHIudHJpbVJpZ2h0KClcbiAgaWYgKHRyaW1tZWQubGVuZ3RoID09PSAwICYmIHN0ci5sZW5ndGggPj0gd2lkdGgpIHJldHVybiBzdHJcbiAgdmFyIHBhZGRpbmcgPSAnJ1xuICB2YXIgc3RyV2lkdGggPSBzdHJpbmdXaWR0aCh0cmltbWVkKVxuXG4gIGlmIChzdHJXaWR0aCA8IHdpZHRoKSB7XG4gICAgcGFkZGluZyA9IGNyZWF0ZVBhZGRpbmcod2lkdGggLSBzdHJXaWR0aClcbiAgfVxuXG4gIHJldHVybiB0cmltbWVkICsgcGFkZGluZ1xufVxuXG5mdW5jdGlvbiBhbGlnblJpZ2h0IChzdHIsIHdpZHRoKSB7XG4gIHZhciB0cmltbWVkID0gc3RyLnRyaW1MZWZ0KClcbiAgaWYgKHRyaW1tZWQubGVuZ3RoID09PSAwICYmIHN0ci5sZW5ndGggPj0gd2lkdGgpIHJldHVybiBzdHJcbiAgdmFyIHBhZGRpbmcgPSAnJ1xuICB2YXIgc3RyV2lkdGggPSBzdHJpbmdXaWR0aCh0cmltbWVkKVxuXG4gIGlmIChzdHJXaWR0aCA8IHdpZHRoKSB7XG4gICAgcGFkZGluZyA9IGNyZWF0ZVBhZGRpbmcod2lkdGggLSBzdHJXaWR0aClcbiAgfVxuXG4gIHJldHVybiBwYWRkaW5nICsgdHJpbW1lZFxufVxuXG5mdW5jdGlvbiBhbGlnbkNlbnRlciAoc3RyLCB3aWR0aCkge1xuICB2YXIgdHJpbW1lZCA9IHN0ci50cmltKClcbiAgaWYgKHRyaW1tZWQubGVuZ3RoID09PSAwICYmIHN0ci5sZW5ndGggPj0gd2lkdGgpIHJldHVybiBzdHJcbiAgdmFyIHBhZExlZnQgPSAnJ1xuICB2YXIgcGFkUmlnaHQgPSAnJ1xuICB2YXIgc3RyV2lkdGggPSBzdHJpbmdXaWR0aCh0cmltbWVkKVxuXG4gIGlmIChzdHJXaWR0aCA8IHdpZHRoKSB7XG4gICAgdmFyIHBhZExlZnRCeSA9IHBhcnNlSW50KCh3aWR0aCAtIHN0cldpZHRoKSAvIDIsIDEwKSBcbiAgICBwYWRMZWZ0ID0gY3JlYXRlUGFkZGluZyhwYWRMZWZ0QnkpXG4gICAgcGFkUmlnaHQgPSBjcmVhdGVQYWRkaW5nKHdpZHRoIC0gKHN0cldpZHRoICsgcGFkTGVmdEJ5KSlcbiAgfVxuXG4gIHJldHVybiBwYWRMZWZ0ICsgdHJpbW1lZCArIHBhZFJpZ2h0XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0VXNlckZyb21Ub2tlbiA9IHZvaWQgMDtcbnZhciBqc29ud2VidG9rZW5fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwianNvbndlYnRva2VuXCIpKTtcbnZhciB1c2VyX21vZGVsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbW9kZWxzL3VzZXIubW9kZWxcIikpO1xudmFyIFNFQ1JFVEtFWSA9IHByb2Nlc3MuZW52LlNFQ1JFVEtFWSB8fCAnbm90IHNhZmUgdXNlIGVudic7XG5leHBvcnRzLmdldFVzZXJGcm9tVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIXRva2VuKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBwYXlsb2FkID0ganNvbndlYnRva2VuXzEuZGVmYXVsdC52ZXJpZnkodG9rZW4sIFNFQ1JFVEtFWSk7XG4gICAgICAgIHJldHVybiB1c2VyX21vZGVsXzEuZGVmYXVsdC5maW5kQnlJZChwYXlsb2FkLl9pZCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbW9uZ29vc2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibW9uZ29vc2VcIikpO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi9lbnZpcm9ubWVudFwiKTtcbm1vbmdvb3NlXzEuZGVmYXVsdC5jb25uZWN0KGVudmlyb25tZW50XzEuZW52aXJvbm1lbnQuZGF0YWJhc2UudXJpLCBlbnZpcm9ubWVudF8xLmVudmlyb25tZW50LmRhdGFiYXNlLmNvbmZpZyk7XG52YXIgZGIgPSBtb25nb29zZV8xLmRlZmF1bHQuY29ubmVjdGlvbjtcbmRiLm9uY2UoJ29wZW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgY29uc29sZS5sb2coJ01vbmdvREIgQXRsYXMgY29ubmVjdGlvbiBlc3RhYmxpc2hlZCEnKTtcbn0pO1xuZGIub24oJ2Vycm9yJywgZnVuY3Rpb24gKCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ01vbmdvREIgQXRsYXMgY29ubmVjdGlvbiBlcnJvciEnKTtcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBkYjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BdXRoZW50aWNhdGlvbiA9IHZvaWQgMDtcbnZhciBhcG9sbG9fc2VydmVyXzEgPSByZXF1aXJlKFwiYXBvbGxvLXNlcnZlclwiKTtcbnZhciBncmFwaHFsXzEgPSByZXF1aXJlKFwiZ3JhcGhxbFwiKTtcbnZhciBBdXRoZW50aWNhdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEF1dGhlbnRpY2F0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEF1dGhlbnRpY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS52aXNpdEZpZWxkRGVmaW5pdGlvbiA9IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVzb2x2ZXIgPSBmaWVsZC5yZXNvbHZlIHx8IGdyYXBocWxfMS5kZWZhdWx0RmllbGRSZXNvbHZlcjtcbiAgICAgICAgZmllbGQucmVzb2x2ZSA9IGZ1bmN0aW9uIChyb290LCBhcmdzLCBjdHgsIGluZm8pIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN0eC51c2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBhcG9sbG9fc2VydmVyXzEuQXV0aGVudGljYXRpb25FcnJvcignbm90IGF1dGgnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCByZXNvbHZlcihyb290LCBhcmdzLCBjdHgsIGluZm8pXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTsgfTtcbiAgICB9O1xuICAgIHJldHVybiBBdXRoZW50aWNhdGlvbjtcbn0oYXBvbGxvX3NlcnZlcl8xLlNjaGVtYURpcmVjdGl2ZVZpc2l0b3IpKTtcbmV4cG9ydHMuQXV0aGVudGljYXRpb24gPSBBdXRoZW50aWNhdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lbnZpcm9ubWVudCA9IHZvaWQgMDtcbnZhciBkZWZhdWx0UG9ydCA9IDQwMDA7XG5leHBvcnRzLmVudmlyb25tZW50ID0ge1xuICAgIGFwb2xsbzoge1xuICAgICAgICBpbnRyb3NwZWN0aW9uOiBwcm9jZXNzLmVudi5BUE9MTE9fSU5UUk9TUEVDVElPTiA9PT0gJ3RydWUnLFxuICAgICAgICBwbGF5Z3JvdW5kOiBwcm9jZXNzLmVudi5BUE9MTE9fUExBWUdST1VORCA9PT0gJ3RydWUnLFxuICAgIH0sXG4gICAgZGF0YWJhc2U6IHtcbiAgICAgICAgdXJpOiBwcm9jZXNzLmVudi5EQl9VUkkgfHwgJycsXG4gICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICAgdXNlTmV3VXJsUGFyc2VyOiB0cnVlLFxuICAgICAgICAgICAgdXNlQ3JlYXRlSW5kZXg6IHRydWUsXG4gICAgICAgICAgICB1c2VGaW5kQW5kTW9kaWZ5OiBmYWxzZSxcbiAgICAgICAgICAgIHVzZVVuaWZpZWRUb3BvbG9neTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHNlY3JldDogcHJvY2Vzcy5lbnYuU0VDUkVUS0VZIHx8ICdObyBzYXZlZCBzZWNyZXQhJyxcbiAgICBzYWx0Um91bmQ6IHBhcnNlSW50KHByb2Nlc3MuZW52LlNBTFRST1VORCB8fCAnMTAnKSxcbiAgICBwb3J0OiBwcm9jZXNzLmVudi5QT1JUIHx8IGRlZmF1bHRQb3J0LFxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGFwb2xsb19zZXJ2ZXJfMSA9IHJlcXVpcmUoXCJhcG9sbG8tc2VydmVyXCIpO1xudmFyIGdyYXBocWxfc2NhbGFyc18xID0gcmVxdWlyZShcImdyYXBocWwtc2NhbGFyc1wiKTtcbnZhciBhdXRoXzEgPSByZXF1aXJlKFwiLi9hdXRoXCIpO1xudmFyIGRpcmVjdGl2ZXNfMSA9IHJlcXVpcmUoXCIuL2RpcmVjdGl2ZXNcIik7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuL2Vudmlyb25tZW50XCIpO1xudmFyIHJlc29sdmVyc18xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXJzXCIpO1xudmFyIHR5cGVfZGVmc19ncmFwaHFsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdHlwZS1kZWZzLmdyYXBocWxcIikpO1xucmVxdWlyZSgnLi9jb25uZWN0Jyk7XG52YXIgc2VydmVyID0gbmV3IGFwb2xsb19zZXJ2ZXJfMS5BcG9sbG9TZXJ2ZXIoe1xuICAgIHJlc29sdmVyczogcmVzb2x2ZXJzXzEucmVzb2x2ZXJzLFxuICAgIHR5cGVEZWZzOiB0eXBlX2RlZnNfZ3JhcGhxbF8xLmRlZmF1bHQsXG4gICAgc2NoZW1hRGlyZWN0aXZlczoge1xuICAgICAgICBhdXRoZW50aWNhdGlvbjogZGlyZWN0aXZlc18xLkF1dGhlbnRpY2F0aW9uLFxuICAgIH0sXG4gICAgY29udGV4dDogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciByZXEgPSBfYS5yZXE7XG4gICAgICAgIHZhciB0b2tlbiA9IHJlcS5oZWFkZXJzLmF1dGhvcml6YXRpb247XG4gICAgICAgIHZhciB1c2VyID0gYXV0aF8xLmdldFVzZXJGcm9tVG9rZW4odG9rZW4pO1xuICAgICAgICByZXR1cm4geyB1c2VyOiB1c2VyIH07XG4gICAgfSxcbiAgICBtb2Nrczoge1xuICAgICAgICBEYXRlVGltZTogZ3JhcGhxbF9zY2FsYXJzXzEuRGF0ZVRpbWVNb2NrLFxuICAgICAgICBFbWFpbEFkZHJlc3M6IGdyYXBocWxfc2NhbGFyc18xLkVtYWlsQWRkcmVzc01vY2ssXG4gICAgICAgIFBob25lTnVtYmVyOiBncmFwaHFsX3NjYWxhcnNfMS5QaG9uZU51bWJlck1vY2ssXG4gICAgICAgIEN1cnJlbmN5OiBncmFwaHFsX3NjYWxhcnNfMS5DdXJyZW5jeU1vY2ssXG4gICAgICAgIFBvc2l0aXZlSW50OiBncmFwaHFsX3NjYWxhcnNfMS5Qb3NpdGl2ZUludE1vY2ssXG4gICAgfSxcbiAgICBtb2NrRW50aXJlU2NoZW1hOiBmYWxzZSxcbiAgICBpbnRyb3NwZWN0aW9uOiBlbnZpcm9ubWVudF8xLmVudmlyb25tZW50LmFwb2xsby5pbnRyb3NwZWN0aW9uLFxuICAgIHBsYXlncm91bmQ6IGVudmlyb25tZW50XzEuZW52aXJvbm1lbnQuYXBvbGxvLnBsYXlncm91bmQsXG59KTtcbnNlcnZlclxuICAgIC5saXN0ZW4oZW52aXJvbm1lbnRfMS5lbnZpcm9ubWVudC5wb3J0KVxuICAgIC50aGVuKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciB1cmwgPSBfYS51cmw7XG4gICAgcmV0dXJuIGNvbnNvbGUubG9nKFwiU2VydmVyIHJlYWR5IGF0IFwiICsgdXJsICsgXCIuXCIpO1xufSk7XG5pZiAobW9kdWxlLmhvdCkge1xuICAgIG1vZHVsZS5ob3QuYWNjZXB0KCk7XG4gICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnNvbGUubG9nKCdNb2R1bGUgZGlzcG9zZWQuICcpOyB9KTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBtb25nb29zZV8xID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJtb25nb29zZVwiKSk7XG52YXIgRmxpZ2h0U2NoZW1hID0gbmV3IG1vbmdvb3NlXzEuU2NoZW1hKHtcbiAgICBvcmlnaW46IHtcbiAgICAgICAgdHlwZTogbW9uZ29vc2VfMS5TY2hlbWEuVHlwZXMuT2JqZWN0SWQsXG4gICAgICAgIHJlZjogJ1BsYWNlJyxcbiAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgfSxcbiAgICBkZXN0aW5hdGlvbjoge1xuICAgICAgICB0eXBlOiBtb25nb29zZV8xLlNjaGVtYS5UeXBlcy5PYmplY3RJZCxcbiAgICAgICAgcmVmOiAnUGxhY2UnLFxuICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICB9LFxuICAgIGRlcGFydHVyZURhdGU6IHtcbiAgICAgICAgdHlwZTogRGF0ZSxcbiAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgfSxcbiAgICBhcnJpdmFsRGF0ZToge1xuICAgICAgICB0eXBlOiBEYXRlLFxuICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICB9LFxuICAgIGFpcmxpbmU6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICB9LFxuICAgIGN1cnJlbmN5OiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgfSxcbiAgICBwcmljZToge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgIH0sXG59LCB7IHRpbWVzdGFtcHM6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBtb25nb29zZV8xLmRlZmF1bHQubW9kZWwoJ0ZsaWdodCcsIEZsaWdodFNjaGVtYSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbW9uZ29vc2VfMSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwibW9uZ29vc2VcIikpO1xudmFyIFBsYWNlU2NoZW1hID0gbmV3IG1vbmdvb3NlXzEuU2NoZW1hKHtcbiAgICBhaXJwb3J0SWQ6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgIH0sXG4gICAgYWlycG9ydE5hbWU6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgIH0sXG4gICAgbG9jYXRpb246IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgIH0sXG4gICAgY2l0eUlkOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICB9LFxuICAgIGNpdHlOYW1lOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICB9LFxuICAgIGNvdW50cnlJZDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgfSxcbiAgICBjb3VudHJ5TmFtZToge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgfSxcbn0sIHsgdGltZXN0YW1wczogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IG1vbmdvb3NlXzEuZGVmYXVsdC5tb2RlbCgnUGxhY2UnLCBQbGFjZVNjaGVtYSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbW9uZ29vc2VfMSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwibW9uZ29vc2VcIikpO1xudmFyIFRyaXBTY2hlbWEgPSBuZXcgbW9uZ29vc2VfMS5TY2hlbWEoe1xuICAgIGNyZWF0b3I6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICB9LFxuICAgIGJvb2tlZDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICB9LFxuICAgIHN0YXJ0TG9jYXRpb246IHtcbiAgICAgICAgdHlwZTogbW9uZ29vc2VfMS5TY2hlbWEuVHlwZXMuT2JqZWN0SWQsXG4gICAgICAgIHJlZjogJ1BsYWNlJyxcbiAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgfSxcbiAgICBlbmRMb2NhdGlvbjoge1xuICAgICAgICB0eXBlOiBtb25nb29zZV8xLlNjaGVtYS5UeXBlcy5PYmplY3RJZCxcbiAgICAgICAgcmVmOiAnUGxhY2UnLFxuICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICB9LFxuICAgIHN0YXJ0RGF0ZToge1xuICAgICAgICB0eXBlOiBEYXRlLFxuICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICB9LFxuICAgIGRlc3RpbmF0aW9uczogW1xuICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBtb25nb29zZV8xLlNjaGVtYS5UeXBlcy5PYmplY3RJZCxcbiAgICAgICAgICAgIHJlZjogJ1BsYWNlJyxcbiAgICAgICAgfSxcbiAgICBdLFxuICAgIGZsaWdodHM6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogbW9uZ29vc2VfMS5TY2hlbWEuVHlwZXMuT2JqZWN0SWQsXG4gICAgICAgICAgICByZWY6ICdGbGlnaHQnLFxuICAgICAgICB9LFxuICAgIF0sXG4gICAgY3VycmVuY3k6IFN0cmluZyxcbiAgICBwcmljZTogTnVtYmVyLFxufSwgeyB0aW1lc3RhbXBzOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gbW9uZ29vc2VfMS5kZWZhdWx0Lm1vZGVsKCdUcmlwJywgVHJpcFNjaGVtYSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbW9uZ29vc2VfMSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwibW9uZ29vc2VcIikpO1xudmFyIFVzZXJTY2hlbWEgPSBuZXcgbW9uZ29vc2VfMS5TY2hlbWEoe1xuICAgIGVtYWlsOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgIHVuaXF1ZTogdHJ1ZSxcbiAgICB9LFxuICAgIHBhc3N3b3JkOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgfSxcbiAgICBmaXJzdE5hbWU6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICB9LFxuICAgIGxhc3ROYW1lOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgfSxcbiAgICBwaG9uZU51bWJlcjoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgfSxcbiAgICB0cmlwczogW1xuICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBtb25nb29zZV8xLlNjaGVtYS5UeXBlcy5PYmplY3RJZCxcbiAgICAgICAgICAgIHJlZjogJ1RyaXAnLFxuICAgICAgICB9LFxuICAgIF0sXG59LCB7IHRpbWVzdGFtcHM6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBtb25nb29zZV8xLmRlZmF1bHQubW9kZWwoJ1VzZXInLCBVc2VyU2NoZW1hKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBfX3NwcmVhZEFycmF5cyA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheXMpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgICAgcltrXSA9IGFbal07XG4gICAgcmV0dXJuIHI7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXNvbHZlcnMgPSB2b2lkIDA7XG52YXIgZ3JhcGhxbF9zY2FsYXJzXzEgPSByZXF1aXJlKFwiZ3JhcGhxbC1zY2FsYXJzXCIpO1xudmFyIHVzZXJfbW9kZWxfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9tb2RlbHMvdXNlci5tb2RlbFwiKSk7XG52YXIgdHJpcF9tb2RlbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL21vZGVscy90cmlwLm1vZGVsXCIpKTtcbnZhciBwbGFjZV9tb2RlbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL21vZGVscy9wbGFjZS5tb2RlbFwiKSk7XG52YXIgZmxpZ2h0X21vZGVsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbW9kZWxzL2ZsaWdodC5tb2RlbFwiKSk7XG52YXIganNvbndlYnRva2VuXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImpzb253ZWJ0b2tlblwiKSk7XG52YXIgYmNyeXB0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJjcnlwdFwiKSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuL2Vudmlyb25tZW50XCIpO1xuZXhwb3J0cy5yZXNvbHZlcnMgPSB7XG4gICAgUXVlcnk6IHtcbiAgICAgICAgbG9naW46IGZ1bmN0aW9uIChfLCBfYSkge1xuICAgICAgICAgICAgdmFyIGVtYWlsID0gX2EuZW1haWwsIHBhc3N3b3JkID0gX2EucGFzc3dvcmQ7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVzZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCwgdXNlcl9tb2RlbF8xLmRlZmF1bHQuZmluZE9uZSh7IGVtYWlsOiBlbWFpbCB9KS5wb3B1bGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6ICd0cmlwcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsOiB0cmlwX21vZGVsXzEuZGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9wdWxhdGU6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiAnc3RhcnRMb2NhdGlvbiBlbmRMb2NhdGlvbiBkZXN0aW5hdGlvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsOiBwbGFjZV9tb2RlbF8xLmRlZmF1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6ICdmbGlnaHRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbDogZmxpZ2h0X21vZGVsXzEuZGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3B1bGF0ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiAnb3JpZ2luIGRlc3RpbmF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWw6IHBsYWNlX21vZGVsXzEuZGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlciA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVzZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgJ25vIHVzZXInXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlci5wYXNzd29yZCAhPT0gcGFzc3dvcmQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgJ25vIHVzZXInXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyLnRva2VuID0ganNvbndlYnRva2VuXzEuZGVmYXVsdC5zaWduKHsgX2lkOiB1c2VyLl9pZCB9LCBlbnZpcm9ubWVudF8xLmVudmlyb25tZW50LnNlY3JldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB1c2VyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBNdXRhdGlvbjoge1xuICAgICAgICByZWdpc3RlclVzZXI6IGZ1bmN0aW9uIChfLCBfYSkge1xuICAgICAgICAgICAgdmFyIHVzZXJEZXRhaWxzID0gX2EudXNlckRldGFpbHM7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iLCB1c2VyO1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gdXNlckRldGFpbHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBiY3J5cHRfMS5kZWZhdWx0Lmhhc2godXNlckRldGFpbHMucGFzc3dvcmQsIGVudmlyb25tZW50XzEuZW52aXJvbm1lbnQuc2FsdFJvdW5kKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IucGFzc3dvcmQgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCB1c2VyX21vZGVsXzEuZGVmYXVsdC5jcmVhdGUodXNlckRldGFpbHMpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXIudG9rZW4gPSBqc29ud2VidG9rZW5fMS5kZWZhdWx0LnNpZ24oeyBfaWQ6IHVzZXIuX2lkIH0sIGVudmlyb25tZW50XzEuZW52aXJvbm1lbnQuc2VjcmV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHVzZXJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlVXNlcjogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgICAgICB2YXIgdXNlckRldGFpbHMgPSBfYS51c2VyRGV0YWlscztcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdXNlcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCB1c2VyX21vZGVsXzEuZGVmYXVsdC5maW5kT25lQW5kVXBkYXRlKHsgZW1haWw6IHVzZXJEZXRhaWxzLmVtYWlsIH0sIHVzZXJEZXRhaWxzLCB7IG5ldzogdHJ1ZSB9KS5leGVjKCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXIgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB1c2VyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZVRyaXA6IGZ1bmN0aW9uIChfLCBfYSkge1xuICAgICAgICAgICAgdmFyIHRyaXBJbnB1dCA9IF9hLnRyaXBJbnB1dDtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmxpZ2h0cywgaSwgZmxpZ2h0REIsIHRyaXA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxpZ2h0cyA9IF9fc3ByZWFkQXJyYXlzKHRyaXBJbnB1dC5mbGlnaHRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmlwSW5wdXQuZmxpZ2h0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpIDwgZmxpZ2h0cy5sZW5ndGgpKSByZXR1cm4gWzMsIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgZmxpZ2h0X21vZGVsXzEuZGVmYXVsdC5jcmVhdGUoZmxpZ2h0c1tpXSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsaWdodERCID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaXBJbnB1dC5mbGlnaHRzLnB1c2goZmxpZ2h0REIuX2lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMywgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbNCwgdHJpcF9tb2RlbF8xLmRlZmF1bHQuY3JlYXRlKHRyaXBJbnB1dCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaXAgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCB1c2VyX21vZGVsXzEuZGVmYXVsdC5maW5kT25lQW5kVXBkYXRlKHsgX2lkOiB0cmlwLmNyZWF0b3IgfSwgeyAkcHVzaDogeyB0cmlwczogdHJpcC5faWQgfSB9KV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdHJpcF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVUcmlwOiBmdW5jdGlvbiAoXywgX2EpIHtcbiAgICAgICAgICAgIHZhciB0cmlwSW5wdXQgPSBfYS50cmlwSW5wdXQ7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyaXAsIGZsaWdodHMsIGksIGZsaWdodERCLCB1cGRhdGVUcmlwO1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQsIHRyaXBfbW9kZWxfMS5kZWZhdWx0LmZpbmRCeUlkKHRyaXBJbnB1dC5faWQpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmlwID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdHJpcClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmlwIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgZmxpZ2h0X21vZGVsXzEuZGVmYXVsdC5kZWxldGVNYW55KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRpbjogdHJpcC5mbGlnaHRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGlnaHRzID0gdHJpcElucHV0LmZsaWdodHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpcElucHV0LmZsaWdodHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShmbGlnaHRzICYmIGZsaWdodHMubGVuZ3RoID4gMCkpIHJldHVybiBbMywgNl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGkgPCBmbGlnaHRzLmxlbmd0aCkpIHJldHVybiBbMywgNl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBmbGlnaHRfbW9kZWxfMS5kZWZhdWx0LmNyZWF0ZShmbGlnaHRzW2ldKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxpZ2h0REIgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpcElucHV0LmZsaWdodHMucHVzaChmbGlnaHREQi5faWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVUcmlwID0gT2JqZWN0LmFzc2lnbih0cmlwLCB0cmlwSW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdHJpcF9tb2RlbF8xLmRlZmF1bHQuZmluZE9uZUFuZFVwZGF0ZSh7IF9pZDogdHJpcElucHV0Ll9pZCB9LCB1cGRhdGVUcmlwLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLnBvcHVsYXRlKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiAnc3RhcnRMb2NhdGlvbiBlbmRMb2NhdGlvbiBkZXN0aW5hdGlvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsOiBwbGFjZV9tb2RlbF8xLmRlZmF1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6ICdmbGlnaHRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbDogZmxpZ2h0X21vZGVsXzEuZGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3B1bGF0ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiAnb3JpZ2luIGRlc3RpbmF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWw6IHBsYWNlX21vZGVsXzEuZGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OiByZXR1cm4gWzIsIF9iLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBkZWxldGVUcmlwOiBmdW5jdGlvbiAoXywgX2EpIHtcbiAgICAgICAgICAgIHZhciB0cmlwaWQgPSBfYS50cmlwaWQ7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyaXAsIHVzZXIsIGk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCwgdHJpcF9tb2RlbF8xLmRlZmF1bHQuZmluZEJ5SWQodHJpcGlkKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpcCA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRyaXApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHJpcCBub3QgZm91bmQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHVzZXJfbW9kZWxfMS5kZWZhdWx0LmZpbmRCeUlkKHRyaXAuY3JlYXRvcildO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXIgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1c2VyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyaXAgaGFzIG5vIHVzZXIgc210aCB3ZW50IHJlYWxseSB3cm9uZyEnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlci50cmlwcyAmJiB1c2VyLnRyaXBzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHVzZXIudHJpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VyLnRyaXBzW2ldID09PSB0cmlwaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyLnRyaXBzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHVzZXJfbW9kZWxfMS5kZWZhdWx0LmZpbmRCeUlkQW5kVXBkYXRlKHVzZXIuaWQsIHVzZXIpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBmbGlnaHRfbW9kZWxfMS5kZWZhdWx0LmRlbGV0ZU1hbnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2lkOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGluOiB0cmlwLmZsaWdodHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdHJpcF9tb2RlbF8xLmRlZmF1bHQuZmluZEJ5SWRBbmREZWxldGUodHJpcGlkKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdHJ1ZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgRGF0ZVRpbWU6IGdyYXBocWxfc2NhbGFyc18xLkRhdGVUaW1lUmVzb2x2ZXIsXG4gICAgRW1haWxBZGRyZXNzOiBncmFwaHFsX3NjYWxhcnNfMS5FbWFpbEFkZHJlc3NSZXNvbHZlcixcbiAgICBQaG9uZU51bWJlcjogZ3JhcGhxbF9zY2FsYXJzXzEuUGhvbmVOdW1iZXJSZXNvbHZlcixcbiAgICBDdXJyZW5jeTogZ3JhcGhxbF9zY2FsYXJzXzEuQ3VycmVuY3lSZXNvbHZlcixcbiAgICBQb3NpdGl2ZUludDogZ3JhcGhxbF9zY2FsYXJzXzEuUG9zaXRpdmVJbnRSZXNvbHZlcixcbn07XG4iLCJpbXBvcnQgeyBncWwgfSBmcm9tICdhcG9sbG8tc2VydmVyJztcblxuZXhwb3J0IGRlZmF1bHQgZ3FsYFxuICBzY2hlbWEge1xuICAgIHF1ZXJ5OiBRdWVyeVxuICAgIG11dGF0aW9uOiBNdXRhdGlvblxuICB9XG5cbiAgZGlyZWN0aXZlIEBhdXRoZW50aWNhdGlvbiBvbiBGSUVMRF9ERUZJTklUSU9OXG5cbiAgc2NhbGFyIERhdGVUaW1lXG4gIHNjYWxhciBFbWFpbEFkZHJlc3MgXG4gIHNjYWxhciBQaG9uZU51bWJlclxuICBzY2FsYXIgQ3VycmVuY3lcbiAgc2NhbGFyIFBvc2l0aXZlSW50XG5cbiAgdHlwZSBRdWVyeSB7XG4gICAgbG9naW4oXG4gICAgICBlbWFpbDogRW1haWxBZGRyZXNzIVxuICAgICAgcGFzc3dvcmQ6IFN0cmluZyFcbiAgICApOiBVc2VyIVxuICAgIGxvZ291dChcbiAgICAgIGVtYWlsOiBFbWFpbEFkZHJlc3MhXG4gICAgICBwYXNzd29yZDogU3RyaW5nIVxuICAgICk6IFVzZXIhXG4gICAgcGxhY2VzKFxuICAgICAgY2l0eU5hbWVTZWFyY2g6IFN0cmluZyFcbiAgICApOiBbUGxhY2UhXSFcbiAgfVxuXG4gIHR5cGUgTXV0YXRpb24ge1xuICAgIHJlZ2lzdGVyVXNlciggICBcbiAgICAgIHVzZXJEZXRhaWxzOiBVc2VyUmVnaXN0ZXJJbnB1dFxuICAgICk6IFVzZXIhIFxuICAgIHVwZGF0ZVVzZXIoICAgXG4gICAgICB1c2VyRGV0YWlsczogVXNlclVwZGF0ZUlucHV0XG4gICAgKTogVXNlciEgQGF1dGhlbnRpY2F0aW9uXG4gICAgY3JlYXRlVHJpcChcbiAgICAgIHRyaXBJbnB1dDogVHJpcENyZWF0ZUlucHV0XG4gICAgKTogVHJpcCEgQGF1dGhlbnRpY2F0aW9uXG4gICAgdXBkYXRlVHJpcChcbiAgICAgIHRyaXBJbnB1dDogVHJpcFVwZGF0ZUlucHV0XG4gICAgKTogVHJpcCEgQGF1dGhlbnRpY2F0aW9uXG4gICAgZGVsZXRlVHJpcChcbiAgICAgIHRyaXBpZDogU3RyaW5nIVxuICAgICk6IEJvb2xlYW4hIEBhdXRoZW50aWNhdGlvblxuICB9XG5cbiAgdHlwZSBVc2VyIHtcbiAgICBfaWQ6IElEIVxuICAgIGVtYWlsOiBFbWFpbEFkZHJlc3MhXG4gICAgcGFzc3dvcmQ6IFN0cmluZyFcbiAgICBmaXJzdE5hbWU6IFN0cmluZ1xuICAgIGxhc3ROYW1lOiBTdHJpbmchXG4gICAgcGhvbmVOdW1iZXI6IFBob25lTnVtYmVyXG4gICAgdHJpcHM6IFtUcmlwXSFcbiAgICB0b2tlbjogU3RyaW5nXG4gIH1cblxuICB0eXBlIFRyaXAge1xuICAgIF9pZDogSUQhXG4gICAgY3JlYXRvcjogSUQhXG4gICAgYm9va2VkOiBCb29sZWFuIVxuICAgIHN0YXJ0TG9jYXRpb246IFBsYWNlIVxuICAgIGVuZExvY2F0aW9uOiBQbGFjZSFcbiAgICBzdGFydERhdGU6IERhdGVUaW1lIVxuICAgIGRlc3RpbmF0aW9uczogW1BsYWNlIV0hXG4gICAgZmxpZ2h0czogW0ZsaWdodCFdIVxuICAgIGN1cnJlbmN5OiBDdXJyZW5jeSFcbiAgICBwcmljZTogUG9zaXRpdmVJbnQhXG4gIH1cbiAgXG4gIHR5cGUgRmxpZ2h0IHtcbiAgICBfaWQ6IElEIVxuICAgIG9yaWdpbjogUGxhY2UhXG4gICAgZGVzdGluYXRpb246IFBsYWNlIVxuICAgIGRlcGFydHVyZURhdGU6IERhdGVUaW1lIVxuICAgIGFycml2YWxEYXRlOiBEYXRlVGltZSFcbiAgICBhaXJsaW5lOiBTdHJpbmchXG4gICAgY3VycmVuY3k6IEN1cnJlbmN5IVxuICAgIHByaWNlOiBQb3NpdGl2ZUludCFcbiAgfVxuXG4gIHR5cGUgUGxhY2UgeyBcbiAgICBfaWQ6IElEIVxuICAgIGFpcnBvcnRJZDogU3RyaW5nIVxuICAgIGFpcnBvcnROYW1lOiBTdHJpbmchXG4gICAgbG9jYXRpb246IFN0cmluZyFcbiAgICBjaXR5SWQ6IFN0cmluZyFcbiAgICBjaXR5TmFtZTogU3RyaW5nIVxuICAgIGNvdW50cnlJZDogU3RyaW5nIVxuICAgIGNvdW50cnlOYW1lOiBTdHJpbmchXG4gIH1cbiAgXG4gIGlucHV0IFVzZXJSZWdpc3RlcklucHV0IHtcbiAgICBlbWFpbDogRW1haWxBZGRyZXNzIVxuICAgIHBhc3N3b3JkOiBTdHJpbmchXG4gICAgZmlyc3ROYW1lOiBTdHJpbmchXG4gICAgbGFzdE5hbWU6IFN0cmluZyFcbiAgICBwaG9uZU51bWJlcjogUGhvbmVOdW1iZXJcbiAgfVxuXG4gIGlucHV0IFVzZXJVcGRhdGVJbnB1dCB7XG4gICAgZW1haWw6IEVtYWlsQWRkcmVzcyFcbiAgICBwYXNzd29yZDogU3RyaW5nXG4gICAgZmlyc3ROYW1lOiBTdHJpbmdcbiAgICBsYXN0TmFtZTogU3RyaW5nXG4gICAgcGhvbmVOdW1iZXI6IFBob25lTnVtYmVyXG4gIH1cblxuICBpbnB1dCBUcmlwQ3JlYXRlSW5wdXQge1xuICAgIGNyZWF0b3I6IFN0cmluZyFcbiAgICBib29rZWQ6IEJvb2xlYW4hXG4gICAgc3RhcnRMb2NhdGlvbjogU3RyaW5nIVxuICAgIGVuZExvY2F0aW9uOiBTdHJpbmchXG4gICAgc3RhcnREYXRlOiBEYXRlVGltZSFcbiAgICBkZXN0aW5hdGlvbnM6IFtTdHJpbmchXSFcbiAgICBmbGlnaHRzOiBbRmxpZ2h0SW5wdXQhXSFcbiAgICBjdXJyZW5jeTogQ3VycmVuY3khXG4gICAgcHJpY2U6IFBvc2l0aXZlSW50IVxuICB9XG5cbiAgaW5wdXQgVHJpcFVwZGF0ZUlucHV0IHtcbiAgICBfaWQ6IElEIVxuICAgIGNyZWF0b3I6IFN0cmluZyFcbiAgICBib29rZWQ6IEJvb2xlYW5cbiAgICBzdGFydExvY2F0aW9uOiBTdHJpbmdcbiAgICBlbmRMb2NhdGlvbjogU3RyaW5nXG4gICAgc3RhcnREYXRlOiBEYXRlVGltZVxuICAgIGRlc3RpbmF0aW9uczogW1N0cmluZyFdXG4gICAgZmxpZ2h0czogW0ZsaWdodElucHV0IV1cbiAgICBjdXJyZW5jeTogQ3VycmVuY3lcbiAgICBwcmljZTogUG9zaXRpdmVJbnRcbiAgfVxuXG4gIGlucHV0IEZsaWdodElucHV0IHtcbiAgICBvcmlnaW46IFN0cmluZyFcbiAgICBkZXN0aW5hdGlvbjogU3RyaW5nIVxuICAgIGRlcGFydHVyZURhdGU6IERhdGVUaW1lIVxuICAgIGFycml2YWxEYXRlOiBEYXRlVGltZSFcbiAgICBhaXJsaW5lOiBTdHJpbmchXG4gICAgY3VycmVuY3k6IEN1cnJlbmN5IVxuICAgIHByaWNlOiBQb3NpdGl2ZUludCFcbiAgfVxuYCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImFwb2xsby1zZXJ2ZXJcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYXByb2JhXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImFzc2VydFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJidWZmZXJcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY2hpbGRfcHJvY2Vzc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjaG93bnJcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY3J5cHRvXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImRlYnVnXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImV2ZW50c1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJmc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJncmFwaHFsXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImdyYXBocWwtc2NhbGFyc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJodHRwXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImh0dHBzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImljb252LWxpdGVcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiaW5pXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImpzb253ZWJ0b2tlblwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJtaW5pbWF0Y2hcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibWluaW1pc3RcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibWtkaXJwXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm1vbmdvb3NlXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm9iamVjdC1hc3NpZ25cIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwib3NcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwib3MtdG1wZGlyXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInBhdGhcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicXVlcnlzdHJpbmdcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVhZGFibGUtc3RyZWFtXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlcXVlc3RcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmltcmFmXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInNhZmUtYnVmZmVyXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInNlbXZlclwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJzZXQtYmxvY2tpbmdcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwic2lnbmFsLWV4aXRcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwic3RyZWFtXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInN0cmluZy13aWR0aFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJzdHJpbmdfZGVjb2RlclwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJzdHJpcC1hbnNpXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInN0cmlwLWpzb24tY29tbWVudHNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidXJsXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInV0aWxcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwieWFsbGlzdFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ6bGliXCIpOyJdLCJzb3VyY2VSb290IjoiIn0=